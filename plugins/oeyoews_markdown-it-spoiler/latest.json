{"title":"$:/plugins/oeyoews/markdown-it-spoiler","description":"markdown-it-spoiler","author":"oeyoews","version":"0.1.0","core-version":">=5.3.0","type":"application/json","plugin-type":"plugin","name":"markdown-it-spoiler","meat#disabled":"yes","created":"2025-01-31","list":"readme","dependents":"","text":"{\"tiddlers\":{\"$:/plugins/oeyoews/markdown-it-spoiler/readme\":{\"title\":\"$:/plugins/oeyoews/markdown-it-spoiler/readme\",\"text\":\"## markdownit spoiler\\n\\n```html\\n!!spoiler text!!\\n```\\n\\n!!spoiler text!!\",\"type\":\"text/markdown\",\"description\":\"markdown-it-spoiler\"},\"$:/plugins/oeyoews/markdown-it-spoiler/markdown-it-spoiler.js\":{\"title\":\"$:/plugins/oeyoews/markdown-it-spoiler/markdown-it-spoiler.js\",\"text\":\"// https://github.com/traPtitech/markdown-it-spoiler\\nconst exMark = 0x21; /* ! */\\n\\nconst tokenize = (frontPriorMode) => (state, silent) => {\\n  if (silent) return false;\\n\\n  const start = state.pos;\\n  const marker = state.src.charCodeAt(start);\\n\\n  if (marker !== exMark) return false;\\n\\n  const scanned = state.scanDelims(state.pos, true);\\n  let len = scanned.length;\\n  const ch = String.fromCharCode(marker);\\n\\n  if (len < 2) return false;\\n\\n  let isOdd = false;\\n  if (len % 2) {\\n    isOdd = true;\\n    if (!frontPriorMode) {\\n      const token = state.push('text', '', 0);\\n      token.content = ch;\\n    }\\n    len--;\\n  }\\n\\n  for (let i = 0; i < len; i += 2) {\\n    const token = state.push('text', '', 0);\\n    token.content = ch + ch;\\n\\n    state.delimiters.push({\\n      marker,\\n      length: 0, // disable \\\"rule of 3\\\" length checks meant for emphasis\\n      jump: i / 2, // 1 delimiter = 2 characters\\n      token: state.tokens.length - 1,\\n      end: -1,\\n      open: scanned.can_open,\\n      close: scanned.can_close,\\n    });\\n  }\\n\\n  state.pos += scanned.length;\\n  if (isOdd && frontPriorMode) {\\n    state.pos--;\\n  }\\n\\n  return true;\\n};\\n\\nconst postProcess = (state, delimiters) => {\\n  const loneMarkers = [];\\n\\n  for (const startDelim of delimiters) {\\n    if (startDelim.marker !== exMark) continue;\\n    if (startDelim.end === -1) continue;\\n\\n    const endDelim = delimiters[startDelim.end];\\n\\n    const tokenO = state.tokens[startDelim.token];\\n    tokenO.type = 'spoiler_open';\\n    tokenO.tag = 's-t';\\n    tokenO.nesting = 1;\\n    tokenO.markup = '!!';\\n    tokenO.content = '';\\n\\n    const tokenC = state.tokens[endDelim.token];\\n    tokenC.type = 'spoiler_close';\\n    tokenC.tag = 's-t';\\n    tokenC.nesting = -1;\\n    tokenC.markup = '!!';\\n    tokenC.content = '';\\n\\n    if (\\n      state.tokens[endDelim.token - 1].type === 'text' &&\\n      state.tokens[endDelim.token - 1].content === '!'\\n    ) {\\n      loneMarkers.push(endDelim.token - 1);\\n    }\\n  }\\n\\n  // If a marker sequence has an odd number of characters, it's splitted\\n  // like this: `!!!!!` -> `!` + `!!` + `!!`, leaving one marker at the\\n  // start of the sequence.\\n  //\\n  // So, we have to move all those markers after subsequent spoiler_close tags.\\n  //\\n  while (loneMarkers.length) {\\n    const i = loneMarkers.pop();\\n    let j = i + 1;\\n\\n    while (\\n      j < state.tokens.length &&\\n      state.tokens[j].type === 'spoiler_close'\\n    ) {\\n      j++;\\n    }\\n\\n    j--;\\n\\n    if (i !== j) {\\n      const token = state.tokens[j];\\n      state.tokens[j] = state.tokens[i];\\n      state.tokens[i] = token;\\n    }\\n  }\\n};\\n\\nmodule.exports = function (md, frontPriorMode = false) {\\n  md.inline.ruler.before('emphasis', 'spoiler', tokenize(frontPriorMode));\\n  md.inline.ruler2.before('emphasis', 'spoiler', (state) => {\\n    postProcess(state, state.delimiters);\\n\\n    if (!state.tokens_meta) return;\\n    for (const meta of state.tokens_meta) {\\n      if (meta && meta.delimiters) {\\n        postProcess(state, meta.delimiters);\\n      }\\n    }\\n  });\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"markdownit\"}}}"}