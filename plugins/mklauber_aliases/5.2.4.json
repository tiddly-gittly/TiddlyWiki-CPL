{"title":"$:/plugins/mklauber/aliases","description":"Aliases - Alias Manager","author":"Matthew Lauber","version":"5.2.4","core-version":">=5.2.0","plugin-type":"plugin","list":"","source":"https://github.com/mklauber/tiddly-aliases","dependents":"","type":"application/json","text":"{\"tiddlers\":{\"$:/core/modules/widgets/link.js\":{\"title\":\"$:/core/modules/widgets/link.js\",\"text\":\"/*\\\\\\ntitle: $:/core/modules/widgets/link.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nLink widget\\n\\n\\\\*/\\n(function(){\\n\\n\\t/*jslint node: true, browser: true */\\n\\t/*global $tw: false */\\n\\t\\\"use strict\\\";\\n\\n\\tvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\n\\tvar LinkWidget = function(parseTreeNode,options) {\\n\\t\\tthis.initialise(parseTreeNode,options);\\n\\t};\\n\\n\\t/*\\n\\tInherit from the base widget class\\n\\t*/\\n\\tLinkWidget.prototype = new Widget();\\n\\n\\t/*\\n\\tRender this widget into the DOM\\n\\t*/\\n\\tLinkWidget.prototype.render = function(parent,nextSibling) {\\n\\t\\t// Save the parent dom node\\n\\t\\tthis.parentDomNode = parent;\\n\\t\\t// Compute our attributes\\n\\t\\tthis.computeAttributes();\\n\\t\\t// Execute our logic\\n\\t\\tthis.execute();\\n\\t\\t// Get the value of the tv-wikilinks configuration macro\\n\\t\\tvar wikiLinksMacro = this.getVariable(\\\"tv-wikilinks\\\"),\\n\\t\\t\\tuseWikiLinks = wikiLinksMacro ? (wikiLinksMacro.trim() !== \\\"no\\\") : true,\\n\\t\\t\\tmissingLinksEnabled = !(this.hideMissingLinks && this.isMissing && !this.isShadow);\\n\\t\\t// Render the link if required\\n\\t\\tif(useWikiLinks && missingLinksEnabled) {\\n\\t\\t\\tthis.renderLink(parent,nextSibling);\\n\\t\\t} else {\\n\\t\\t\\t// Just insert the link text\\n\\t\\t\\tvar domNode = this.document.createElement(\\\"span\\\");\\n\\t\\t\\tparent.insertBefore(domNode,nextSibling);\\n\\t\\t\\tthis.renderChildren(domNode,null);\\n\\t\\t\\tthis.domNodes.push(domNode);\\n\\t\\t}\\n\\t};\\n\\n\\t/*\\n\\tRender this widget into the DOM\\n\\t*/\\n\\tLinkWidget.prototype.renderLink = function(parent,nextSibling) {\\n\\t\\tvar self = this;\\n\\t\\t// Sanitise the specified tag\\n\\t\\tvar tag = this.linkTag;\\n\\t\\tif($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {\\n\\t\\t\\ttag = \\\"a\\\";\\n\\t\\t}\\n\\t\\t// Create our element\\n\\t\\tvar namespace = this.getVariable(\\\"namespace\\\",{defaultValue: \\\"http://www.w3.org/1999/xhtml\\\"}),\\n\\t\\t\\tdomNode = this.document.createElementNS(namespace,tag);\\n\\t\\t// Assign classes\\n\\t\\tvar classes = [];\\n\\t\\tif(this.overrideClasses === undefined) {\\n\\t\\t\\tclasses.push(\\\"tc-tiddlylink\\\");\\n\\t\\t\\tif(this.isShadow) {\\n\\t\\t\\t\\tclasses.push(\\\"tc-tiddlylink-shadow\\\");\\n\\t\\t\\t}\\n\\t\\t\\tif(this.isMissing && !this.isShadow) {\\n\\t\\t\\t\\tclasses.push(\\\"tc-tiddlylink-missing\\\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif(!this.isMissing) {\\n\\t\\t\\t\\t\\tclasses.push(\\\"tc-tiddlylink-resolves\\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(this.linkClasses) {\\n\\t\\t\\t\\tclasses.push(this.linkClasses);\\n\\t\\t\\t}\\n\\t\\t} else if(this.overrideClasses !== \\\"\\\") {\\n\\t\\t\\tclasses.push(this.overrideClasses)\\n\\t\\t}\\n\\t\\tif(classes.length > 0) {\\n\\t\\t\\tdomNode.setAttribute(\\\"class\\\",classes.join(\\\" \\\"));\\n\\t\\t}\\n\\t\\t// Set an href\\n\\t\\tvar wikilinkTransformFilter = this.getVariable(\\\"tv-filter-export-link\\\"),\\n\\t\\t\\twikiLinkText;\\n\\t\\tif(wikilinkTransformFilter) {\\n\\t\\t\\t// Use the filter to construct the href\\n\\t\\t\\twikiLinkText = this.wiki.filterTiddlers(wikilinkTransformFilter,this,function(iterator) {\\n\\t\\t\\t\\titerator(self.wiki.getTiddler(self.to),self.to)\\n\\t\\t\\t})[0];\\n\\t\\t} else {\\n\\t\\t\\t// Expand the tv-wikilink-template variable to construct the href\\n\\t\\t\\tvar wikiLinkTemplateMacro = this.getVariable(\\\"tv-wikilink-template\\\"),\\n\\t\\t\\t\\twikiLinkTemplate = wikiLinkTemplateMacro ? wikiLinkTemplateMacro.trim() : \\\"#$uri_encoded$\\\";\\n\\t\\t\\twikiLinkText = $tw.utils.replaceString(wikiLinkTemplate,\\\"$uri_encoded$\\\",encodeURIComponent(this.to));\\n\\t\\t\\twikiLinkText = $tw.utils.replaceString(wikiLinkText,\\\"$uri_doubleencoded$\\\",encodeURIComponent(encodeURIComponent(this.to)));\\n\\t\\t}\\n\\t\\t// Override with the value of tv-get-export-link if defined\\n\\t\\twikiLinkText = this.getVariable(\\\"tv-get-export-link\\\",{params: [{name: \\\"to\\\",value: this.to}],defaultValue: wikiLinkText});\\n\\t\\tif(tag === \\\"a\\\") {\\n\\t\\t\\tvar namespaceHref = (namespace === \\\"http://www.w3.org/2000/svg\\\") ? \\\"http://www.w3.org/1999/xlink\\\" : undefined;\\n\\t\\t\\tdomNode.setAttributeNS(namespaceHref,\\\"href\\\",wikiLinkText);\\n\\t\\t}\\n\\t\\t// Set the tabindex\\n\\t\\tif(this.tabIndex) {\\n\\t\\t\\tdomNode.setAttribute(\\\"tabindex\\\",this.tabIndex);\\n\\t\\t}\\n\\t\\t// Set the tooltip\\n\\t\\t// HACK: Performance issues with re-parsing the tooltip prevent us defaulting the tooltip to \\\"<$transclude field='tooltip'><$transclude field='title'/></$transclude>\\\"\\n\\t\\tvar tooltipWikiText = this.tooltip || this.getVariable(\\\"tv-wikilink-tooltip\\\");\\n\\t\\tif(tooltipWikiText) {\\n\\t\\t\\tvar tooltipText = this.wiki.renderText(\\\"text/plain\\\",\\\"text/vnd.tiddlywiki\\\",tooltipWikiText,{\\n\\t\\t\\t\\t\\tparseAsInline: true,\\n\\t\\t\\t\\t\\tvariables: {\\n\\t\\t\\t\\t\\t\\tcurrentTiddler: this.to\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tparentWidget: this\\n\\t\\t\\t\\t});\\n\\t\\t\\tdomNode.setAttribute(\\\"title\\\",tooltipText);\\n\\t\\t}\\n\\t\\tif(this[\\\"aria-label\\\"]) {\\n\\t\\t\\tdomNode.setAttribute(\\\"aria-label\\\",this[\\\"aria-label\\\"]);\\n\\t\\t}\\n\\t\\t// Add a click event handler\\n\\t\\t$tw.utils.addEventListeners(domNode,[\\n\\t\\t\\t{name: \\\"click\\\", handlerObject: this, handlerMethod: \\\"handleClickEvent\\\"},\\n\\t\\t]);\\n\\t\\t// Make the link draggable if required\\n\\t\\tif(this.draggable === \\\"yes\\\") {\\n\\t\\t\\t$tw.utils.makeDraggable({\\n\\t\\t\\t\\tdomNode: domNode,\\n\\t\\t\\t\\tdragTiddlerFn: function() {return self.to;},\\n\\t\\t\\t\\twidget: this\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\t// Insert the link into the DOM and render any children\\n\\t\\tparent.insertBefore(domNode,nextSibling);\\n\\t\\tthis.renderChildren(domNode,null);\\n\\t\\tthis.domNodes.push(domNode);\\n\\t};\\n\\n\\tLinkWidget.prototype.handleClickEvent = function(event) {\\n\\t\\t// Send the click on its way as a navigate event\\n\\t\\tvar bounds = this.domNodes[0].getBoundingClientRect();\\n\\t\\tthis.dispatchEvent({\\n\\t\\t\\ttype: \\\"tm-navigate\\\",\\n\\t\\t\\tnavigateTo: this.to,\\n\\t\\t\\tnavigateFromTitle: this.getVariable(\\\"storyTiddler\\\"),\\n\\t\\t\\tnavigateFromNode: this,\\n\\t\\t\\tnavigateFromClientRect: { top: bounds.top, left: bounds.left, width: bounds.width, right: bounds.right, bottom: bounds.bottom, height: bounds.height\\n\\t\\t\\t},\\n\\t\\t\\tnavigateFromClientTop: bounds.top,\\n\\t\\t\\tnavigateFromClientLeft: bounds.left,\\n\\t\\t\\tnavigateFromClientWidth: bounds.width,\\n\\t\\t\\tnavigateFromClientRight: bounds.right,\\n\\t\\t\\tnavigateFromClientBottom: bounds.bottom,\\n\\t\\t\\tnavigateFromClientHeight: bounds.height,\\n\\t\\t\\tnavigateSuppressNavigation: event.metaKey || event.ctrlKey || (event.button === 1),\\n\\t\\t\\tmetaKey: event.metaKey,\\n\\t\\t\\tctrlKey: event.ctrlKey,\\n\\t\\t\\taltKey: event.altKey,\\n\\t\\t\\tshiftKey: event.shiftKey,\\n\\t\\t\\tfollowAliases: this.followAliases,\\n\\t\\t\\tevent: event\\n\\t\\t});\\n\\t\\tif(this.domNodes[0].hasAttribute(\\\"href\\\")) {\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t}\\n\\t\\tevent.stopPropagation();\\n\\t\\treturn false;\\n\\t};\\n\\n\\t/*\\n\\tCompute the internal state of the widget\\n\\t*/\\n\\tLinkWidget.prototype.execute = function() {\\n\\t\\t// Pick up our attributes\\n\\t\\tthis.to = this.getAttribute(\\\"to\\\",this.getVariable(\\\"currentTiddler\\\"));\\n\\t\\tthis.tooltip = this.getAttribute(\\\"tooltip\\\");\\n\\t\\tthis[\\\"aria-label\\\"] = this.getAttribute(\\\"aria-label\\\");\\n\\t\\tthis.linkClasses = this.getAttribute(\\\"class\\\");\\n\\t\\tthis.overrideClasses = this.getAttribute(\\\"overrideClass\\\");\\n\\t\\tthis.tabIndex = this.getAttribute(\\\"tabindex\\\");\\n\\t\\tthis.draggable = this.getAttribute(\\\"draggable\\\",\\\"yes\\\");\\n\\t\\tthis.linkTag = this.getAttribute(\\\"tag\\\",\\\"a\\\");\\n\\t\\tthis.followAliases = this.getAttribute(\\\"followAliases\\\", \\\"true\\\");\\n\\t\\t// Determine the link characteristics\\n\\t\\tthis.isMissing = !this.wiki.tiddlerExists(this.to) && !(this.wiki.filterTiddlers(\\\"[title[\\\"+this.to+\\\"]listed[aliases]]\\\").length === 1);\\n\\t\\tthis.isShadow = this.wiki.isShadowTiddler(this.to);\\n\\t\\tthis.hideMissingLinks = (this.getVariable(\\\"tv-show-missing-links\\\") || \\\"yes\\\") === \\\"no\\\";\\n\\t\\t// Make the child widgets\\n\\t\\tvar templateTree;\\n\\t\\tif(this.parseTreeNode.children && this.parseTreeNode.children.length > 0) {\\n\\t\\t\\ttemplateTree = this.parseTreeNode.children;\\n\\t\\t} else {\\n\\t\\t\\t// Default template is a link to the title\\n\\t\\t\\ttemplateTree = [{type: \\\"text\\\", text: this.to}];\\n\\t\\t}\\n\\t\\tthis.makeChildWidgets(templateTree);\\n\\t};\\n\\n\\t/*\\n\\tSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n\\t*/\\n\\tLinkWidget.prototype.refresh = function(changedTiddlers) {\\n\\t\\tvar changedAttributes = this.computeAttributes();\\n\\t\\tif(changedAttributes.to || changedTiddlers[this.to] || changedAttributes[\\\"aria-label\\\"] || changedAttributes.tooltip) {\\n\\t\\t\\tthis.refreshSelf();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn this.refreshChildren(changedTiddlers);\\n\\t};\\n\\n\\texports.link = LinkWidget;\\n\\n\\t})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/core/modules/widgets/navigator.js\":{\"title\":\"$:/core/modules/widgets/navigator.js\",\"text\":\"/*\\\\\\ntitle: $:/core/modules/widgets/navigator.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nNavigator widget\\n\\n\\\\*/\\n(function(){\\n\\n\\t/*jslint node: true, browser: true */\\n\\t/*global $tw: false */\\n\\t\\\"use strict\\\";\\n\\n\\tvar IMPORT_TITLE = \\\"$:/Import\\\";\\n\\n\\tvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\n\\tvar NavigatorWidget = function(parseTreeNode,options) {\\n\\t\\tthis.initialise(parseTreeNode,options);\\n\\t};\\n\\n\\t/*\\n\\tInherit from the base widget class\\n\\t*/\\n\\tNavigatorWidget.prototype = new Widget();\\n\\n\\t/*\\n\\tRender this widget into the DOM\\n\\t*/\\n\\tNavigatorWidget.prototype.render = function(parent,nextSibling) {\\n\\t\\tthis.addEventListeners([\\n\\t\\t\\t{type: \\\"tm-navigate\\\", handler: \\\"handleNavigateEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-edit-tiddler\\\", handler: \\\"handleEditTiddlerEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-delete-tiddler\\\", handler: \\\"handleDeleteTiddlerEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-save-tiddler\\\", handler: \\\"handleSaveTiddlerEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-cancel-tiddler\\\", handler: \\\"handleCancelTiddlerEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-close-tiddler\\\", handler: \\\"handleCloseTiddlerEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-close-all-tiddlers\\\", handler: \\\"handleCloseAllTiddlersEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-close-other-tiddlers\\\", handler: \\\"handleCloseOtherTiddlersEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-new-tiddler\\\", handler: \\\"handleNewTiddlerEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-import-tiddlers\\\", handler: \\\"handleImportTiddlersEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-perform-import\\\", handler: \\\"handlePerformImportEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-fold-tiddler\\\", handler: \\\"handleFoldTiddlerEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-fold-other-tiddlers\\\", handler: \\\"handleFoldOtherTiddlersEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-fold-all-tiddlers\\\", handler: \\\"handleFoldAllTiddlersEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-unfold-all-tiddlers\\\", handler: \\\"handleUnfoldAllTiddlersEvent\\\"},\\n\\t\\t\\t{type: \\\"tm-rename-tiddler\\\", handler: \\\"handleRenameTiddlerEvent\\\"}\\n\\t\\t]);\\n\\t\\tthis.parentDomNode = parent;\\n\\t\\tthis.computeAttributes();\\n\\t\\tthis.execute();\\n\\t\\tthis.renderChildren(parent,nextSibling);\\n\\t};\\n\\n\\t/*\\n\\tCompute the internal state of the widget\\n\\t*/\\n\\tNavigatorWidget.prototype.execute = function() {\\n\\t\\t// Get our parameters\\n\\t\\tthis.storyTitle = this.getAttribute(\\\"story\\\");\\n\\t\\tthis.historyTitle = this.getAttribute(\\\"history\\\");\\n\\t\\tthis.setVariable(\\\"tv-story-list\\\",this.storyTitle);\\n\\t\\tthis.setVariable(\\\"tv-history-list\\\",this.historyTitle);\\n\\t\\tthis.story = new $tw.Story({\\n\\t\\t\\twiki: this.wiki,\\n\\t\\t\\tstoryTitle: this.storyTitle,\\n\\t\\t\\thistoryTitle: this.historyTitle\\n\\t\\t});\\n\\t\\t// Construct the child widgets\\n\\t\\tthis.makeChildWidgets();\\n\\t};\\n\\n\\t/*\\n\\tSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n\\t*/\\n\\tNavigatorWidget.prototype.refresh = function(changedTiddlers) {\\n\\t\\tvar changedAttributes = this.computeAttributes();\\n\\t\\tif(changedAttributes.story || changedAttributes.history) {\\n\\t\\t\\tthis.refreshSelf();\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn this.refreshChildren(changedTiddlers);\\n\\t\\t}\\n\\t};\\n\\n\\tNavigatorWidget.prototype.getStoryList = function() {\\n\\t\\treturn this.storyTitle ? this.wiki.getTiddlerList(this.storyTitle) : null;\\n\\t};\\n\\n\\tNavigatorWidget.prototype.saveStoryList = function(storyList) {\\n\\t\\tif(this.storyTitle) {\\n\\t\\t\\tvar storyTiddler = this.wiki.getTiddler(this.storyTitle);\\n\\t\\t\\tthis.wiki.addTiddler(new $tw.Tiddler(\\n\\t\\t\\t\\t{title: this.storyTitle},\\n\\t\\t\\t\\tstoryTiddler,\\n\\t\\t\\t\\t{list: storyList}\\n\\t\\t\\t));\\n\\t\\t}\\n\\t};\\n\\n\\tNavigatorWidget.prototype.removeTitleFromStory = function(storyList,title) {\\n\\t\\tif(storyList) {\\n\\t\\t\\tvar p = storyList.indexOf(title);\\n\\t\\t\\twhile(p !== -1) {\\n\\t\\t\\t\\tstoryList.splice(p,1);\\n\\t\\t\\t\\tp = storyList.indexOf(title);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tNavigatorWidget.prototype.replaceFirstTitleInStory = function(storyList,oldTitle,newTitle) {\\n\\t\\tif(storyList) {\\n\\t\\t\\tvar pos = storyList.indexOf(oldTitle);\\n\\t\\t\\tif(pos !== -1) {\\n\\t\\t\\t\\tstoryList[pos] = newTitle;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tpos = storyList.indexOf(oldTitle,pos + 1);\\n\\t\\t\\t\\t\\tif(pos !== -1) {\\n\\t\\t\\t\\t\\t\\tstoryList.splice(pos,1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while(pos !== -1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstoryList.splice(0,0,newTitle);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tNavigatorWidget.prototype.addToStory = function(title,fromTitle) {\\n\\t\\tif(this.storyTitle) {\\n\\t\\t\\tthis.story.addToStory(title,fromTitle,{\\n\\t\\t\\t\\topenLinkFromInsideRiver: this.getAttribute(\\\"openLinkFromInsideRiver\\\",\\\"top\\\"),\\n\\t\\t\\t\\topenLinkFromOutsideRiver: this.getAttribute(\\\"openLinkFromOutsideRiver\\\",\\\"top\\\")\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n\\t/*\\n\\tAdd a new record to the top of the history stack\\n\\ttitle: a title string or an array of title strings\\n\\tfromPageRect: page coordinates of the origin of the navigation\\n\\t*/\\n\\tNavigatorWidget.prototype.addToHistory = function(title,fromPageRect) {\\n\\t\\tthis.story.addToHistory(title,fromPageRect,this.historyTitle);\\n\\t};\\n\\n\\t/*\\n\\tHandle a tm-navigate event\\n\\t*/\\n\\tNavigatorWidget.prototype.handleNavigateEvent = function(event) {\\n\\t\\tevent = $tw.hooks.invokeHook(\\\"th-navigating\\\",event);\\n\\t\\tif(event.navigateTo) {\\n\\t\\t\\tif (!this.wiki.tiddlerExists(event.navigateTo) && event.followAliases == \\\"true\\\") {\\n\\t\\t\\t\\tvar aliases = this.wiki.filterTiddlers(\\\"[title[\\\"+event.navigateTo+\\\"]listed[aliases]]\\\")\\n\\t\\t\\t\\tif (aliases.length === 1) {\\n\\t\\t\\t\\t\\tevent.navigateTo = aliases[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tthis.addToStory(event.navigateTo,event.navigateFromTitle);\\n\\t\\t\\tif(!event.navigateSuppressNavigation) {\\n\\t\\t\\t\\tthis.addToHistory(event.navigateTo,event.navigateFromClientRect);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\n\\t// Close a specified tiddler\\n\\tNavigatorWidget.prototype.handleCloseTiddlerEvent = function(event) {\\n\\t\\tevent = $tw.hooks.invokeHook(\\\"th-closing-tiddler\\\",event);\\n\\t\\tvar title = event.param || event.tiddlerTitle,\\n\\t\\t\\tstoryList = this.getStoryList();\\n\\t\\t// Look for tiddlers with this title to close\\n\\t\\tthis.removeTitleFromStory(storyList,title);\\n\\t\\tthis.saveStoryList(storyList);\\n\\t\\treturn false;\\n\\t};\\n\\n\\t// Close all tiddlers\\n\\tNavigatorWidget.prototype.handleCloseAllTiddlersEvent = function(event) {\\n\\t\\tthis.saveStoryList([]);\\n\\t\\treturn false;\\n\\t};\\n\\n\\t// Close other tiddlers\\n\\tNavigatorWidget.prototype.handleCloseOtherTiddlersEvent = function(event) {\\n\\t\\tvar title = event.param || event.tiddlerTitle;\\n\\t\\tthis.saveStoryList([title]);\\n\\t\\treturn false;\\n\\t};\\n\\n\\t// Place a tiddler in edit mode\\n\\tNavigatorWidget.prototype.handleEditTiddlerEvent = function(event) {\\n\\t\\tvar editTiddler = $tw.hooks.invokeHook(\\\"th-editing-tiddler\\\",event),\\n\\t\\t\\twin = event.event && event.event.view ? event.event.view : window;\\n\\t\\tif(!editTiddler) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvar self = this;\\n\\t\\tfunction isUnmodifiedShadow(title) {\\n\\t\\t\\treturn self.wiki.isShadowTiddler(title) && !self.wiki.tiddlerExists(title);\\n\\t\\t}\\n\\t\\tfunction confirmEditShadow(title) {\\n\\t\\t\\treturn win.confirm($tw.language.getString(\\n\\t\\t\\t\\t\\\"ConfirmEditShadowTiddler\\\",\\n\\t\\t\\t\\t{variables:\\n\\t\\t\\t\\t\\t{title: title}\\n\\t\\t\\t\\t}\\n\\t\\t\\t));\\n\\t\\t}\\n\\t\\tvar title = event.param || event.tiddlerTitle;\\n\\t\\tif(isUnmodifiedShadow(title) && !confirmEditShadow(title)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t// Replace the specified tiddler with a draft in edit mode\\n\\t\\tvar draftTiddler = this.makeDraftTiddler(title);\\n\\t\\t// Update the story and history if required\\n\\t\\tif(!event.paramObject || event.paramObject.suppressNavigation !== \\\"yes\\\") {\\n\\t\\t\\tvar draftTitle = draftTiddler.fields.title,\\n\\t\\t\\t\\tstoryList = this.getStoryList();\\n\\t\\t\\tthis.removeTitleFromStory(storyList,draftTitle);\\n\\t\\t\\tthis.replaceFirstTitleInStory(storyList,title,draftTitle);\\n\\t\\t\\tthis.addToHistory(draftTitle,event.navigateFromClientRect);\\n\\t\\t\\tthis.saveStoryList(storyList);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n\\n\\t// Delete a tiddler\\n\\tNavigatorWidget.prototype.handleDeleteTiddlerEvent = function(event) {\\n\\t\\t// Get the tiddler we're deleting\\n\\t\\tvar title = event.param || event.tiddlerTitle,\\n\\t\\t\\ttiddler = this.wiki.getTiddler(title),\\n\\t\\t\\tstoryList = this.getStoryList(),\\n\\t\\t\\toriginalTitle = tiddler ? tiddler.fields[\\\"draft.of\\\"] : \\\"\\\",\\n\\t\\t\\toriginalTiddler = originalTitle ? this.wiki.getTiddler(originalTitle) : undefined,\\n\\t\\t\\tconfirmationTitle,\\n\\t\\t\\t\\twin = event.event && event.event.view ? event.event.view : window;\\n\\t\\tif(!tiddler) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t// Check if the tiddler we're deleting is in draft mode\\n\\t\\tif(originalTitle) {\\n\\t\\t\\t// If so, we'll prompt for confirmation referencing the original tiddler\\n\\t\\t\\tconfirmationTitle = originalTitle;\\n\\t\\t} else {\\n\\t\\t\\t// If not a draft, then prompt for confirmation referencing the specified tiddler\\n\\t\\t\\tconfirmationTitle = title;\\n\\t\\t}\\n\\t\\t// Seek confirmation\\n\\t\\tif((this.wiki.getTiddler(originalTitle) || (tiddler.fields.text || \\\"\\\") !== \\\"\\\") && !win.confirm($tw.language.getString(\\n\\t\\t\\t\\t\\t\\\"ConfirmDeleteTiddler\\\",\\n\\t\\t\\t\\t\\t{variables:\\n\\t\\t\\t\\t\\t\\t{title: confirmationTitle}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t))) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t// Delete the original tiddler\\n\\t\\tif(originalTitle) {\\n\\t\\t\\tif(originalTiddler) {\\n\\t\\t\\t\\t$tw.hooks.invokeHook(\\\"th-deleting-tiddler\\\",originalTiddler);\\n\\t\\t\\t}\\n\\t\\t\\tthis.wiki.deleteTiddler(originalTitle);\\n\\t\\t\\tthis.removeTitleFromStory(storyList,originalTitle);\\n\\t\\t}\\n\\t\\t// Invoke the hook function and delete this tiddler\\n\\t\\t$tw.hooks.invokeHook(\\\"th-deleting-tiddler\\\",tiddler);\\n\\t\\tthis.wiki.deleteTiddler(title);\\n\\t\\t// Remove the closed tiddler from the story\\n\\t\\tthis.removeTitleFromStory(storyList,title);\\n\\t\\tthis.saveStoryList(storyList);\\n\\t\\t// Trigger an autosave\\n\\t\\t$tw.rootWidget.dispatchEvent({type: \\\"tm-auto-save-wiki\\\"});\\n\\t\\treturn false;\\n\\t};\\n\\n\\t/*\\n\\tCreate/reuse the draft tiddler for a given title\\n\\t*/\\n\\tNavigatorWidget.prototype.makeDraftTiddler = function(targetTitle) {\\n\\t\\t// See if there is already a draft tiddler for this tiddler\\n\\t\\tvar draftTitle = this.wiki.findDraft(targetTitle);\\n\\t\\tif(draftTitle) {\\n\\t\\t\\treturn this.wiki.getTiddler(draftTitle);\\n\\t\\t}\\n\\t\\t// Get the current value of the tiddler we're editing\\n\\t\\tvar tiddler = this.wiki.getTiddler(targetTitle);\\n\\t\\t// Save the initial value of the draft tiddler\\n\\t\\tdraftTitle = this.generateDraftTitle(targetTitle);\\n\\t\\tvar draftTiddler = new $tw.Tiddler({\\n\\t\\t\\t\\t\\ttext: \\\"\\\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\ttiddler,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttitle: draftTitle,\\n\\t\\t\\t\\t\\t\\\"draft.title\\\": targetTitle,\\n\\t\\t\\t\\t\\t\\\"draft.of\\\": targetTitle\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tthis.wiki.getModificationFields()\\n\\t\\t\\t);\\n\\t\\tthis.wiki.addTiddler(draftTiddler);\\n\\t\\treturn draftTiddler;\\n\\t};\\n\\n\\t/*\\n\\tGenerate a title for the draft of a given tiddler\\n\\t*/\\n\\tNavigatorWidget.prototype.generateDraftTitle = function(title) {\\n\\t\\treturn this.wiki.generateDraftTitle(title);\\n\\t};\\n\\n\\t// Take a tiddler out of edit mode, saving the changes\\n\\tNavigatorWidget.prototype.handleSaveTiddlerEvent = function(event) {\\n\\t\\tvar title = event.param || event.tiddlerTitle,\\n\\t\\t\\ttiddler = this.wiki.getTiddler(title),\\n\\t\\t\\tstoryList = this.getStoryList(),\\n\\t\\t\\t\\twin = event.event && event.event.view ? event.event.view : window;\\n\\t\\t// Replace the original tiddler with the draft\\n\\t\\tif(tiddler) {\\n\\t\\t\\tvar draftTitle = (tiddler.fields[\\\"draft.title\\\"] || \\\"\\\").trim(),\\n\\t\\t\\t\\tdraftOf = (tiddler.fields[\\\"draft.of\\\"] || \\\"\\\").trim();\\n\\t\\t\\tif(draftTitle) {\\n\\t\\t\\t\\tvar isRename = draftOf !== draftTitle,\\n\\t\\t\\t\\t\\tisConfirmed = true;\\n\\t\\t\\t\\tif(isRename && this.wiki.tiddlerExists(draftTitle)) {\\n\\t\\t\\t\\t\\tisConfirmed = win.confirm($tw.language.getString(\\n\\t\\t\\t\\t\\t\\t\\\"ConfirmOverwriteTiddler\\\",\\n\\t\\t\\t\\t\\t\\t{variables:\\n\\t\\t\\t\\t\\t\\t\\t{title: draftTitle}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isConfirmed) {\\n\\t\\t\\t\\t\\t// Create the new tiddler and pass it through the th-saving-tiddler hook\\n\\t\\t\\t\\t\\tvar newTiddler = new $tw.Tiddler(this.wiki.getCreationFields(),tiddler,{\\n\\t\\t\\t\\t\\t\\ttitle: draftTitle,\\n\\t\\t\\t\\t\\t\\t\\\"draft.title\\\": undefined,\\n\\t\\t\\t\\t\\t\\t\\\"draft.of\\\": undefined\\n\\t\\t\\t\\t\\t},this.wiki.getModificationFields());\\n\\t\\t\\t\\t\\tnewTiddler = $tw.hooks.invokeHook(\\\"th-saving-tiddler\\\",newTiddler,tiddler);\\n\\t\\t\\t\\t\\tthis.wiki.addTiddler(newTiddler);\\n\\t\\t\\t\\t\\t// If enabled, relink references to renamed tiddler\\n\\t\\t\\t\\t\\tvar shouldRelink = this.getAttribute(\\\"relinkOnRename\\\",\\\"no\\\").toLowerCase().trim() === \\\"yes\\\";\\n\\t\\t\\t\\t\\tif(isRename && shouldRelink && this.wiki.tiddlerExists(draftOf)) {\\n\\t\\t\\t\\t\\t\\tthis.wiki.relinkTiddler(draftOf,draftTitle);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Remove the draft tiddler\\n\\t\\t\\t\\t\\tthis.wiki.deleteTiddler(title);\\n\\t\\t\\t\\t\\t// Remove the original tiddler if we're renaming it\\n\\t\\t\\t\\t\\tif(isRename) {\\n\\t\\t\\t\\t\\t\\tthis.wiki.deleteTiddler(draftOf);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// #2381 always remove new title & old\\n\\t\\t\\t\\t\\tthis.removeTitleFromStory(storyList,draftTitle);\\n\\t\\t\\t\\t\\tthis.removeTitleFromStory(storyList,draftOf);\\n\\t\\t\\t\\t\\tif(!event.paramObject || event.paramObject.suppressNavigation !== \\\"yes\\\") {\\n\\t\\t\\t\\t\\t\\t// Replace the draft in the story with the original\\n\\t\\t\\t\\t\\t\\tthis.replaceFirstTitleInStory(storyList,title,draftTitle);\\n\\t\\t\\t\\t\\t\\tthis.addToHistory(draftTitle,event.navigateFromClientRect);\\n\\t\\t\\t\\t\\t\\tif(draftTitle !== this.storyTitle) {\\n\\t\\t\\t\\t\\t\\t\\tthis.saveStoryList(storyList);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Trigger an autosave\\n\\t\\t\\t\\t\\t$tw.rootWidget.dispatchEvent({type: \\\"tm-auto-save-wiki\\\"});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\n\\t// Take a tiddler out of edit mode without saving the changes\\n\\tNavigatorWidget.prototype.handleCancelTiddlerEvent = function(event) {\\n\\t\\tevent = $tw.hooks.invokeHook(\\\"th-cancelling-tiddler\\\", event);\\n\\t\\tvar win = event.event && event.event.view ? event.event.view : window;\\n\\t\\t// Flip the specified tiddler from draft back to the original\\n\\t\\tvar draftTitle = event.param || event.tiddlerTitle,\\n\\t\\t\\tdraftTiddler = this.wiki.getTiddler(draftTitle),\\n\\t\\t\\toriginalTitle = draftTiddler && draftTiddler.fields[\\\"draft.of\\\"];\\n\\t\\tif(draftTiddler && originalTitle) {\\n\\t\\t\\t// Ask for confirmation if the tiddler text has changed\\n\\t\\t\\tvar isConfirmed = true,\\n\\t\\t\\t\\toriginalTiddler = this.wiki.getTiddler(originalTitle),\\n\\t\\t\\t\\tstoryList = this.getStoryList();\\n\\t\\t\\tif(this.wiki.isDraftModified(draftTitle)) {\\n\\t\\t\\t\\tisConfirmed = win.confirm($tw.language.getString(\\n\\t\\t\\t\\t\\t\\\"ConfirmCancelTiddler\\\",\\n\\t\\t\\t\\t\\t{variables:\\n\\t\\t\\t\\t\\t\\t{title: draftTitle}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t));\\n\\t\\t\\t}\\n\\t\\t\\t// Remove the draft tiddler\\n\\t\\t\\tif(isConfirmed) {\\n\\t\\t\\t\\tthis.wiki.deleteTiddler(draftTitle);\\n\\t\\t\\t\\tif(!event.paramObject || event.paramObject.suppressNavigation !== \\\"yes\\\") {\\n\\t\\t\\t\\t\\tif(originalTiddler) {\\n\\t\\t\\t\\t\\t\\tthis.replaceFirstTitleInStory(storyList,draftTitle,originalTitle);\\n\\t\\t\\t\\t\\t\\tthis.addToHistory(originalTitle,event.navigateFromClientRect);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tthis.removeTitleFromStory(storyList,draftTitle);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.saveStoryList(storyList);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\n\\t// Create a new draft tiddler\\n\\t// event.param can either be the title of a template tiddler, or a hashmap of fields.\\n\\t//\\n\\t// The title of the newly created tiddler follows these rules:\\n\\t// * If a hashmap was used and a title field was specified, use that title\\n\\t// * If a hashmap was used without a title field, use a default title, if necessary making it unique with a numeric suffix\\n\\t// * If a template tiddler was used, use the title of the template, if necessary making it unique with a numeric suffix\\n\\t//\\n\\t// If a draft of the target tiddler already exists then it is reused\\n\\tNavigatorWidget.prototype.handleNewTiddlerEvent = function(event) {\\n\\t\\tevent = $tw.hooks.invokeHook(\\\"th-new-tiddler\\\", event);\\n\\t\\t// Get the story details\\n\\t\\tvar storyList = this.getStoryList(),\\n\\t\\t\\ttemplateTiddler, additionalFields, title, draftTitle, existingTiddler;\\n\\t\\t// Get the template tiddler (if any)\\n\\t\\tif(typeof event.param === \\\"string\\\") {\\n\\t\\t\\t// Get the template tiddler\\n\\t\\t\\ttemplateTiddler = this.wiki.getTiddler(event.param);\\n\\t\\t\\t// Generate a new title\\n\\t\\t\\ttitle = this.wiki.generateNewTitle(event.param || $tw.language.getString(\\\"DefaultNewTiddlerTitle\\\"));\\n\\t\\t}\\n\\t\\t// Get the specified additional fields\\n\\t\\tif(typeof event.paramObject === \\\"object\\\") {\\n\\t\\t\\tadditionalFields = event.paramObject;\\n\\t\\t}\\n\\t\\tif(typeof event.param === \\\"object\\\") { // Backwards compatibility with 5.1.3\\n\\t\\t\\tadditionalFields = event.param;\\n\\t\\t}\\n\\t\\tif(additionalFields && additionalFields.title) {\\n\\t\\t\\ttitle = additionalFields.title;\\n\\t\\t}\\n\\t\\t// Make a copy of the additional fields excluding any blank ones\\n\\t\\tvar filteredAdditionalFields = $tw.utils.extend({},additionalFields);\\n\\t\\tObject.keys(filteredAdditionalFields).forEach(function(fieldName) {\\n\\t\\t\\tif(filteredAdditionalFields[fieldName] === \\\"\\\") {\\n\\t\\t\\t\\tdelete filteredAdditionalFields[fieldName];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t// Generate a title if we don't have one\\n\\t\\ttitle = title || this.wiki.generateNewTitle($tw.language.getString(\\\"DefaultNewTiddlerTitle\\\"));\\n\\t\\t// Find any existing draft for this tiddler\\n\\t\\tdraftTitle = this.wiki.findDraft(title);\\n\\t\\t// Pull in any existing tiddler\\n\\t\\tif(draftTitle) {\\n\\t\\t\\texistingTiddler = this.wiki.getTiddler(draftTitle);\\n\\t\\t} else {\\n\\t\\t\\tdraftTitle = this.generateDraftTitle(title);\\n\\t\\t\\texistingTiddler = this.wiki.getTiddler(title);\\n\\t\\t}\\n\\t\\t// Merge the tags\\n\\t\\tvar mergedTags = [];\\n\\t\\tif(existingTiddler && existingTiddler.fields.tags) {\\n\\t\\t\\t$tw.utils.pushTop(mergedTags,existingTiddler.fields.tags);\\n\\t\\t}\\n\\t\\tif(additionalFields && additionalFields.tags) {\\n\\t\\t\\t// Merge tags\\n\\t\\t\\tmergedTags = $tw.utils.pushTop(mergedTags,$tw.utils.parseStringArray(additionalFields.tags));\\n\\t\\t}\\n\\t\\tif(templateTiddler && templateTiddler.fields.tags) {\\n\\t\\t\\t// Merge tags\\n\\t\\t\\tmergedTags = $tw.utils.pushTop(mergedTags,templateTiddler.fields.tags);\\n\\t\\t}\\n\\t\\t// Save the draft tiddler\\n\\t\\tvar draftTiddler = new $tw.Tiddler({\\n\\t\\t\\t\\ttext: \\\"\\\",\\n\\t\\t\\t\\t\\\"draft.title\\\": title\\n\\t\\t\\t},\\n\\t\\t\\ttemplateTiddler,\\n\\t\\t\\tadditionalFields,\\n\\t\\t\\tthis.wiki.getCreationFields(),\\n\\t\\t\\texistingTiddler,\\n\\t\\t\\tfilteredAdditionalFields,\\n\\t\\t\\t{\\n\\t\\t\\t\\ttitle: draftTitle,\\n\\t\\t\\t\\t\\\"draft.of\\\": title,\\n\\t\\t\\t\\ttags: mergedTags\\n\\t\\t\\t},this.wiki.getModificationFields());\\n\\t\\tthis.wiki.addTiddler(draftTiddler);\\n\\t\\t// Update the story to insert the new draft at the top and remove any existing tiddler\\n\\t\\tif(storyList && storyList.indexOf(draftTitle) === -1) {\\n\\t\\t\\tvar slot = storyList.indexOf(event.navigateFromTitle);\\n\\t\\t\\tif(slot === -1) {\\n\\t\\t\\t\\tslot = this.getAttribute(\\\"openLinkFromOutsideRiver\\\",\\\"top\\\") === \\\"bottom\\\" ? storyList.length - 1 : slot;\\n\\t\\t\\t}\\n\\t\\t\\tstoryList.splice(slot + 1,0,draftTitle);\\n\\t\\t}\\n\\t\\tif(storyList && storyList.indexOf(title) !== -1) {\\n\\t\\t\\tstoryList.splice(storyList.indexOf(title),1);\\n\\t\\t}\\n\\t\\tthis.saveStoryList(storyList);\\n\\t\\t// Add a new record to the top of the history stack\\n\\t\\tthis.addToHistory(draftTitle);\\n\\t\\treturn false;\\n\\t};\\n\\n\\t// Import JSON tiddlers into a pending import tiddler\\n\\tNavigatorWidget.prototype.handleImportTiddlersEvent = function(event) {\\n\\t\\t// Get the tiddlers\\n\\t\\tvar tiddlers = [];\\n\\t\\ttry {\\n\\t\\t\\ttiddlers = JSON.parse(event.param);\\n\\t\\t} catch(e) {\\n\\t\\t}\\n\\t\\t// Get the current $:/Import tiddler\\n\\t\\tvar importTitle = event.importTitle ? event.importTitle : IMPORT_TITLE,\\n\\t\\t\\timportTiddler = this.wiki.getTiddler(importTitle),\\n\\t\\t\\timportData = this.wiki.getTiddlerData(importTitle,{}),\\n\\t\\t\\tnewFields = new Object({\\n\\t\\t\\t\\ttitle: importTitle,\\n\\t\\t\\t\\ttype: \\\"application/json\\\",\\n\\t\\t\\t\\t\\\"plugin-type\\\": \\\"import\\\",\\n\\t\\t\\t\\t\\\"status\\\": \\\"pending\\\"\\n\\t\\t\\t}),\\n\\t\\t\\tincomingTiddlers = [];\\n\\t\\t// Process each tiddler\\n\\t\\timportData.tiddlers = importData.tiddlers || {};\\n\\t\\t$tw.utils.each(tiddlers,function(tiddlerFields) {\\n\\t\\t\\ttiddlerFields.title = $tw.utils.trim(tiddlerFields.title);\\n\\t\\t\\tvar title = tiddlerFields.title;\\n\\t\\t\\tif(title) {\\n\\t\\t\\t\\tincomingTiddlers.push(title);\\n\\t\\t\\t\\timportData.tiddlers[title] = tiddlerFields;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t// Give the active upgrader modules a chance to process the incoming tiddlers\\n\\t\\tvar messages = this.wiki.invokeUpgraders(incomingTiddlers,importData.tiddlers);\\n\\t\\t// Deselect any disabled, but _not_ suppressed tiddlers\\n\\t\\tvar systemMessage = $tw.language.getString(\\\"Import/Upgrader/Tiddler/Unselected\\\");\\n\\t\\t$tw.utils.each(messages,function(message,title) {\\n\\t\\t\\tnewFields[\\\"message-\\\" + title] = message;\\n\\t\\t\\tif (message.indexOf(systemMessage) !== -1) {\\n\\t\\t\\t\\tnewFields[\\\"selection-\\\" + title] = \\\"unchecked\\\";\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t// Deselect suppressed tiddlers ... they have been removed and can't be selected anymore\\n\\t\\t$tw.utils.each(importData.tiddlers,function(tiddler,title) {\\n\\t\\t\\tif($tw.utils.count(tiddler) === 0) {\\n\\t\\t\\t\\tnewFields[\\\"selection-\\\" + title] = \\\"unchecked\\\";\\n\\t\\t\\t\\tnewFields[\\\"suppressed-\\\" + title] = \\\"yes\\\";\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t// Save the $:/Import tiddler\\n\\t\\tnewFields.text = JSON.stringify(importData,null,$tw.config.preferences.jsonSpaces);\\n\\t\\tthis.wiki.addTiddler(new $tw.Tiddler(importTiddler,newFields));\\n\\t\\t// Update the story and history details\\n\\t\\tvar autoOpenOnImport = event.autoOpenOnImport ? event.autoOpenOnImport : this.getVariable(\\\"tv-auto-open-on-import\\\");\\n\\t\\tif(autoOpenOnImport !== \\\"no\\\") {\\n\\t\\t\\tvar storyList = this.getStoryList(),\\n\\t\\t\\t\\thistory = [];\\n\\t\\t\\t// Add it to the story\\n\\t\\t\\tif(storyList && storyList.indexOf(importTitle) === -1) {\\n\\t\\t\\t\\tstoryList.unshift(importTitle);\\n\\t\\t\\t}\\n\\t\\t\\t// And to history\\n\\t\\t\\thistory.push(importTitle);\\n\\t\\t\\t// Save the updated story and history\\n\\t\\t\\tthis.saveStoryList(storyList);\\n\\t\\t\\tthis.addToHistory(history);\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\n\\t//\\n\\tNavigatorWidget.prototype.handlePerformImportEvent = function(event) {\\n\\t\\tvar self = this,\\n\\t\\t\\timportTiddler = this.wiki.getTiddler(event.param),\\n\\t\\t\\timportData,\\n\\t\\t\\timportReport = [];\\n\\t\\timportReport.push($tw.language.getString(\\\"Import/Imported/Hint\\\") + \\\"\\\\n\\\");\\n\\t\\t// If you need to modify the import tiddler payload then consider th-importing-tiddler instead\\n\\t\\timportTiddler = $tw.hooks.invokeHook(\\\"th-before-importing\\\",importTiddler);\\n\\t\\timportData = this.wiki.getTiddlerDataCached(event.param,{tiddlers: {}}),\\n\\t\\t$tw.utils.each(importData.tiddlers,function(tiddlerFields) {\\n\\t\\t\\tvar title = tiddlerFields.title;\\n\\t\\t\\tif(title && importTiddler && importTiddler.fields[\\\"selection-\\\" + title] !== \\\"unchecked\\\") {\\n\\t\\t\\t\\tif($tw.utils.hop(importTiddler.fields,[\\\"rename-\\\" + title])) {\\n\\t\\t\\t\\t\\tvar tiddler = new $tw.Tiddler(tiddlerFields,{title : importTiddler.fields[\\\"rename-\\\" + title]});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar tiddler = new $tw.Tiddler(tiddlerFields);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// th-importing-tiddler doesn't allow user interaction by default\\n\\t\\t\\t\\t// If you want to use the default UI then use: $:/core/modules/upgraders/ instead\\n\\t\\t\\t\\ttiddler = $tw.hooks.invokeHook(\\\"th-importing-tiddler\\\",tiddler);\\n\\t\\t\\t\\t// Add the tiddlers to the store\\n\\t\\t\\t\\tself.wiki.addTiddler(tiddler);\\n\\t\\t\\t\\timportReport.push(\\\"# [[\\\" + tiddler.fields.title + \\\"]]\\\");\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t// Replace the $:/Import tiddler with an import report\\n\\t\\tthis.wiki.addTiddler(new $tw.Tiddler({\\n\\t\\t\\ttitle: event.param,\\n\\t\\t\\ttext: importReport.join(\\\"\\\\n\\\"),\\n\\t\\t\\t\\\"status\\\": \\\"complete\\\"\\n\\t\\t}));\\n\\t\\t// Navigate to the $:/Import tiddler\\n\\t\\tthis.addToHistory([event.param]);\\n\\t\\t// Trigger an autosave\\n\\t\\t$tw.rootWidget.dispatchEvent({type: \\\"tm-auto-save-wiki\\\"});\\n\\t};\\n\\n\\tNavigatorWidget.prototype.handleFoldTiddlerEvent = function(event) {\\n\\t\\tvar paramObject = event.paramObject || {};\\n\\t\\tif(paramObject.foldedState) {\\n\\t\\t\\tvar foldedState = this.wiki.getTiddlerText(paramObject.foldedState,\\\"show\\\") === \\\"show\\\" ? \\\"hide\\\" : \\\"show\\\";\\n\\t\\t\\tthis.wiki.setText(paramObject.foldedState,\\\"text\\\",null,foldedState);\\n\\t\\t}\\n\\t};\\n\\n\\tNavigatorWidget.prototype.handleFoldOtherTiddlersEvent = function(event) {\\n\\t\\tvar self = this,\\n\\t\\t\\tparamObject = event.paramObject || {},\\n\\t\\t\\tprefix = paramObject.foldedStatePrefix;\\n\\t\\t$tw.utils.each(this.getStoryList(),function(title) {\\n\\t\\t\\tself.wiki.setText(prefix + title,\\\"text\\\",null,event.param === title ? \\\"show\\\" : \\\"hide\\\");\\n\\t\\t});\\n\\t};\\n\\n\\tNavigatorWidget.prototype.handleFoldAllTiddlersEvent = function(event) {\\n\\t\\tvar self = this,\\n\\t\\t\\tparamObject = event.paramObject || {},\\n\\t\\t\\tprefix = paramObject.foldedStatePrefix || \\\"$:/state/folded/\\\";\\n\\t\\t$tw.utils.each(this.getStoryList(),function(title) {\\n\\t\\t\\tself.wiki.setText(prefix + title,\\\"text\\\",null,\\\"hide\\\");\\n\\t\\t});\\n\\t};\\n\\n\\tNavigatorWidget.prototype.handleUnfoldAllTiddlersEvent = function(event) {\\n\\t\\tvar self = this,\\n\\t\\t\\tparamObject = event.paramObject || {},\\n\\t\\t\\tprefix = paramObject.foldedStatePrefix;\\n\\t\\t$tw.utils.each(this.getStoryList(),function(title) {\\n\\t\\t\\tself.wiki.setText(prefix + title,\\\"text\\\",null,\\\"show\\\");\\n\\t\\t});\\n\\t};\\n\\n\\tNavigatorWidget.prototype.handleRenameTiddlerEvent = function(event) {\\n\\t\\tvar options = {},\\n\\t\\t\\tparamObject = event.paramObject || {},\\n\\t\\t\\tfrom = paramObject.from || event.tiddlerTitle,\\n\\t\\t\\tto = paramObject.to;\\n\\t\\toptions.dontRenameInTags = (paramObject.renameInTags === \\\"false\\\" || paramObject.renameInTags === \\\"no\\\") ? true : false;\\n\\t\\toptions.dontRenameInLists = (paramObject.renameInLists === \\\"false\\\" || paramObject.renameInLists === \\\"no\\\") ? true : false;\\n\\t\\tthis.wiki.renameTiddler(from,to,options);\\n\\t};\\n\\n\\texports.navigator = NavigatorWidget;\\n\\n\\t})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/mklauber/aliases/footer\":{\"title\":\"$:/plugins/mklauber/aliases/footer\",\"tags\":\"$:/tags/ViewTemplate\",\"text\":\"<$list filter=\\\"[all[shadows+tiddlers]contains:aliases{!!title}first[]]\\\" variable=\\\"\\\">\\nYou may have meant one of the following pages\\n<$list filter=\\\"[all[shadows+tiddlers]contains:aliases{!!title}]\\\">\\n<li><$link>{{!!title}}</$link></li>\\n</$list>\\n</$list>\\n\"}}}","name":"aliases"}