{"name":"Graph","title":"$:/plugins/flibbles/graph","description":"Lightweight and programmable graphing for Tiddlywiki","author":"Flibbles","version":"1.3.0","stability":"STABILITY_2_STABLE","core-version":">=5.3.7","source":"https://github.com/flibbles/tw5-graph","demo":"http://flibbles.github.io/tw5-graph/","list":"readme settings","dependents":"","plugin-type":"plugin","type":"application/json","text":"{\"tiddlers\":{\"$:/config/DefaultColourMappings/graph-banner-background\":{\"title\":\"$:/config/DefaultColourMappings/graph-banner-background\",\"text\":\"<<colour sidebar-tab-background>>\"},\"$:/config/DefaultColourMappings/graph-banner-foreground\":{\"title\":\"$:/config/DefaultColourMappings/graph-banner-foreground\",\"text\":\"<<colour sidebar-tab-foreground>>\"},\"$:/config/DefaultColourMappings/graph-background\":{\"title\":\"$:/config/DefaultColourMappings/graph-background\",\"text\":\"<<colour background>>\"},\"$:/config/DefaultColourMappings/graph-border\":{\"title\":\"$:/config/DefaultColourMappings/graph-border\",\"text\":\"<<colour tiddler-border>>\"},\"$:/config/DefaultColourMappings/graph-node-color\":{\"title\":\"$:/config/DefaultColourMappings/graph-node-color\",\"text\":\"<<colour primary>>\"},\"$:/config/DefaultColourMappings/graph-font-color\":{\"title\":\"$:/config/DefaultColourMappings/graph-font-color\",\"text\":\"<<colour foreground>>\"},\"$:/plugins/flibbles/graph/ViewTemplateBodyFilter/graph\":{\"title\":\"$:/plugins/flibbles/graph/ViewTemplateBodyFilter/graph\",\"list-before\":\"$:/config/ViewTemplateBodyFilters/code-body\",\"tags\":\"$:/tags/ViewTemplateBodyFilter\",\"text\":\"[{!!title}] [get[draft.of]] +[prefix[$:/graph/]then[$:/plugins/flibbles/graph/ui/ViewTemplate/graph]]\\n\"},\"$:/plugins/flibbles/graph/ViewTemplateBodyFilter/properties\":{\"title\":\"$:/plugins/flibbles/graph/ViewTemplateBodyFilter/properties\",\"list-before\":\"$:/config/ViewTemplateBodyFilters/code-body\",\"tags\":\"$:/tags/ViewTemplateBodyFilter\",\"text\":\"[removeprefix[$:/config/flibbles/graph/]search:title[/]then[$:/plugins/flibbles/graph/ui/ViewTemplate/graph-object]]\\n\"},\"$:/config/flibbles/graph/edges/fields/list\":{\"title\":\"$:/config/flibbles/graph/edges/fields/list\",\"description\":\"The tiddler lists another resource in its list field.\",\"type\":\"application/json\",\"text\":\"{\\n    \\\"label\\\": \\\"lists\\\"\\n}\"},\"$:/config/flibbles/graph/edges/fields/tags\":{\"title\":\"$:/config/flibbles/graph/edges/fields/tags\",\"description\":\"The tiddler is tagged by another resource.\",\"type\":\"application/json\",\"text\":\"{\\n    \\\"label\\\": \\\"tagged with\\\"\\n}\"},\"$:/config/flibbles/graph/edges/functions/links\":{\"title\":\"$:/config/flibbles/graph/edges/functions/links\",\"description\":\"The tiddler contains a links of another resource.\",\"filter\":\"[links[]]\",\"type\":\"application/json\",\"text\":\"{\\n    \\\"label\\\": \\\"links to\\\"\\n}\\n\"},\"$:/config/flibbles/graph/edges/functions/transcludes\":{\"title\":\"$:/config/flibbles/graph/edges/functions/transcludes\",\"description\":\"The tiddler contains a transclusion of another resource.\",\"filter\":\"[transcludes[]]\",\"type\":\"application/json\",\"text\":\"{\\n    \\\"label\\\": \\\"transcludes\\\"\\n}\\n\"},\"$:/plugins/flibbles/graph/fieldtypes/filter.js\":{\"title\":\"$:/plugins/flibbles/graph/fieldtypes/filter.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/fieldtypes/filter.js\\ntype: application/javascript\\nmodule-type: fieldtype\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"filter\\\";\\n\\nexports.get = function(tiddler, field, options) {\\n\\t// We optimize by storing a cache of compiled filters for this tiddler\\n\\t// We will need them a lot, especially if our graphs are doing neighbor\\n\\t// evaluation, which will call on these filters with every single change.\\n\\tvar fieldCache = options.wiki.getCacheForTiddler(tiddler.fields.title, \\\"filter-fields\\\", function() {\\n\\t\\treturn Object.create(null);\\n\\t});\\n\\tvar method = fieldCache[field];\\n\\tif (method === undefined) {\\n\\t\\t// We haven't cached this filter function yet\\n\\t\\tvar filterStr = tiddler.getFieldString(field);\\n\\t\\tfieldCache[field] = method = getFilterFunction(filterStr, options.wiki);\\n\\t}\\n\\treturn method.call(options.wiki, null, options.widget);\\n};\\n\\nexports.add = function(tiddler, field, value, options) {\\n\\tvar filterString = tiddler && tiddler.getFieldString(field);\\n\\tvar changed = false;\\n\\t// We don't want to add the title if it's already a filter result.\\n\\twhile (options.wiki.filterTiddlers(filterString, options.widget).indexOf(value) < 0) {\\n\\t\\tchanged = true;\\n\\t\\tvar filterTree = options.wiki.parseFilter(filterString);\\n\\t\\tvar found = false;\\n\\t\\t// Search backwards for any explicit removal of the target Ref\\n\\t\\t// Otherwise, we might get `... -value value`\\n\\t\\tfor (let i = filterTree.length-1; i>= 0; i--) {\\n\\t\\tvar run = filterTree[i];\\n\\t\\tvar title = runIsSingleTitle(run);\\n\\t\\tif (title !== null) {\\n\\t\\t\\tif (run.prefix === \\\"-\\\" && title === value) {\\n\\t\\t\\t\\t// We found an explicit removal. Remove the removal.\\n\\t\\t\\t\\tfilterTree.splice(i, 1);\\n\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} else if (run.prefix) {\\n\\t\\t\\t// This filter has gotten complicated.\\n\\t\\t\\t// Forget searching for explicit removals.\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\t}\\n\\t\\tif (!found) {\\n\\t\\t// We didn't find an explicit removal (expected),\\n\\t\\t// so we add the title to the list.\\n\\t\\tfilterTree.push({\\n\\t\\t\\tprefix: \\\"\\\",\\n\\t\\t\\toperators: [{operator: \\\"title\\\", operands: [{text: value}]}]});\\n\\t\\t}\\n\\t\\tfilterString = reassembleFilter(filterTree);\\n\\t\\t// Now we go back and try again to make sure it actually took.\\n\\t}\\n\\tif (changed) {\\n\\t\\treturn filterString;\\n\\t}\\n};\\n\\nexports.remove = function(tiddler, field, value, options) {\\n\\tvar filterString = tiddler && tiddler.getFieldString(field);\\n\\tvar changed = false;\\n\\t// We don't want to remove a title that's not already there\\n\\twhile (filterString && options.wiki.filterTiddlers(filterString, options.widget).indexOf(value) >= 0) {\\n\\t\\tchanged = true;\\n\\t\\tvar filterTree = options.wiki.parseFilter(filterString);\\n\\t\\tvar found = false;\\n\\t\\tfor (let i = filterTree.length-1; i >= 0; i--) {\\n\\t\\t\\tlet run = filterTree[i];\\n\\t\\t\\tlet title = runIsSingleTitle(run);\\n\\t\\t\\tif (title !== null) {\\n\\t\\t\\t\\tif (!run.prefix && title === value) {\\n\\t\\t\\t\\t\\t// This is the title we're looking for. Remove it.\\n\\t\\t\\t\\t\\tfilterTree.splice(i, 1);\\n\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (run.prefix) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!found) {\\n\\t\\t\\t// We couldn't find it. So it must be a complicated filter.\\n\\t\\t\\t// We'll put in a manual removal.\\n\\t\\t\\tfilterTree.push({\\n\\t\\t\\t\\tprefix: \\\"-\\\",\\n\\t\\t\\t\\toperators: [{operator: \\\"title\\\", operands: [{text: value}]}]});\\n\\t\\t}\\n\\t\\tfilterString = reassembleFilter(filterTree, this.actionClean);\\n\\t\\t// Now we do it again to make sure it was actually removed\\n\\t}\\n\\tif (changed) {\\n\\t\\treturn filterString;\\n\\t}\\n};\\n\\n// This returns a compiled filter given a string. It optimizes where it can.\\nfunction getFilterFunction(filterStr, wiki) {\\n\\tvar method;\\n\\tif (filterStr) {\\n\\t\\tmethod = wiki.compileFilter(filterStr);\\n\\t\\t// A further optimization here.\\n\\t\\t// If the filter is very simple, as in nothing by titles,\\n\\t\\t// then we can just call it now and cache the output,\\n\\t\\t// because it will never change.\\n\\t\\tif (filterStr.indexOf(\\\"[\\\") < 0) {\\n\\t\\t\\tvar results = method.call(wiki);\\n\\t\\t\\tmethod = function() { return results; };\\n\\t\\t}\\n\\t} else {\\n\\t\\tmethod = function() { return []; };\\n\\t}\\n\\treturn method;\\n};\\n\\n// If this is a single title, return the title, otherwise null\\nfunction runIsSingleTitle(run) {\\n\\tif (run.operators.length === 1 && !run.namedPrefix) {\\n\\t\\tvar op = run.operators[0];\\n\\t\\tif (op.operator === \\\"title\\\"\\n\\t\\t&& op.operands.length === 1\\n\\t\\t&& !op.suffix\\n\\t\\t&& !op.prefix) {\\n\\t\\t\\tvar operand = op.operands[0];\\n\\t\\t\\tif (!operand.variable && !operand.indirect) {\\n\\t\\t\\t\\treturn operand.text;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn null;\\n};\\n\\nfunction reassembleFilter(parseTree, clean) {\\n\\t// This will hold all of the filter parts\\n\\tconst fragments = [];\\n\\t// Rebuild the filter.\\n\\tfor (var i = 0; i < parseTree.length; i++) {\\n\\t\\tvar run = parseTree[i];\\n\\t\\tif (fragments.length > 0) {\\n\\t\\t\\tfragments.push(\\\" \\\");\\n\\t\\t}\\n\\t\\tfragments.push(run.prefix);\\n\\t\\tlet title = runIsSingleTitle(run);\\n\\t\\tif (title) {\\n\\t\\t\\tfragments.push(bestQuoteFor(title));\\n\\t\\t} else if (run.operators.length > 0) {\\n\\t\\t\\tfragments.push(\\\"[\\\");\\n\\t\\t\\tfor (let j = 0; j < run.operators.length; j++) {\\n\\t\\t\\t\\tlet op = run.operators[j];\\n\\t\\t\\t\\tlet firstOperand = true;\\n\\t\\t\\t\\tif (op.prefix) {\\n\\t\\t\\t\\t\\tfragments.push(op.prefix);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (op.operator !== \\\"title\\\" || op.suffix) {\\n\\t\\t\\t\\t\\tfragments.push(op.operator);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (op.suffix) {\\n\\t\\t\\t\\t\\tfragments.push(':', op.suffix);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (op.regexp) {\\n\\t\\t\\t\\t\\tfragments.push(\\\"/\\\", op.regexp.source, \\\"/\\\");\\n\\t\\t\\t\\t\\tif (op.regexp.flags) {\\n\\t\\t\\t\\t\\t\\tfragments.push(\\\"(\\\", op.regexp.flags, \\\")\\\");\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfor (let k = 0; k < op.operands.length; k++) {\\n\\t\\t\\t\\t\\t\\tlet operand = op.operands[k];\\n\\t\\t\\t\\t\\t\\tif (!firstOperand) {\\n\\t\\t\\t\\t\\t\\t\\tfragments.push(',');\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tfirstOperand = false;\\n\\t\\t\\t\\t\\t\\tif (operand.variable) {\\n\\t\\t\\t\\t\\t\\t\\tfragments.push('<', operand.text, '>');\\n\\t\\t\\t\\t\\t\\t} else if (operand.indirect) {\\n\\t\\t\\t\\t\\t\\t\\tfragments.push('{', operand.text, '}');\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tfragments.push('[', operand.text, ']');\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfragments.push(']');\\n\\t\\t}\\n\\t}\\n\\t// Return compiled filter string, if there is one\\n\\tif (clean && fragments.length == 0) {\\n\\t\\treturn undefined;\\n\\t}\\n\\treturn fragments.join(\\\"\\\");\\n};\\n\\nfunction bestQuoteFor(title) {\\n\\tif (/^[^\\\\s\\\\[\\\\]\\\\-+~=:'\\\"][^\\\\s\\\\[\\\\]]*$/.test(title)) {\\n\\t\\treturn title;\\n\\t}\\n\\tif (title.indexOf(\\\"]\\\") < 0) {\\n\\t\\treturn \\\"[[\\\" + title + \\\"]]\\\";\\n\\t}\\n\\tif (title.indexOf(\\\"'\\\") < 0) {\\n\\t\\treturn \\\"'\\\" + title + \\\"'\\\";\\n\\t}\\n\\treturn '\\\"' + title + '\\\"';\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"fieldtype\"},\"$:/plugins/flibbles/graph/fieldtypes/list.js\":{\"title\":\"$:/plugins/flibbles/graph/fieldtypes/list.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/fieldtypes/list.js\\ntype: application/javascript\\nmodule-type: fieldtype\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"list\\\";\\n\\nexports.add = function(tiddler, field, value, options) {\\n\\tvar array = (tiddler && tiddler.getFieldList(field)) || [];\\n\\tif (array.indexOf(value) < 0) {\\n\\t\\tarray.push(value);\\n\\t\\treturn $tw.utils.stringifyList(array);\\n\\t}\\n};\\n\\nexports.remove = function(tiddler, field, value, options) {\\n\\tvar array = (tiddler && tiddler.getFieldList(field)) || [];\\n\\tvar index = array.indexOf(value);\\n\\tif (index >= 0) {\\n\\t\\tarray.splice(index, 1);\\n\\t\\treturn $tw.utils.stringifyList(array);\\n\\t}\\n};\\n\\nexports.get = function(tiddler, field, options) {\\n\\treturn tiddler.getFieldList(field);\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"fieldtype\"},\"$:/plugins/flibbles/graph/fieldtypes/title.js\":{\"title\":\"$:/plugins/flibbles/graph/fieldtypes/title.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/fieldtypes/title.js\\ntype: application/javascript\\nmodule-type: fieldtype\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"title\\\";\\n\\nexports.add = function(tiddler, field, value, options) {\\n\\tif (!tiddler || tiddler.fields[field] !== value) {\\n\\t\\treturn value;\\n\\t}\\n};\\n\\nexports.remove = function(tiddler, field, value, options) {\\n\\tif (tiddler && tiddler.fields[field] === value) {\\n\\t\\treturn \\\"\\\";\\n\\t}\\n};\\n\\nexports.get = function(tiddler, field) {\\n\\tvar value = tiddler.getFieldString(field);\\n\\treturn value? [value]: [];\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"fieldtype\"},\"$:/plugins/flibbles/graph/filterrunprefixes/cache.js\":{\"title\":\"$:/plugins/flibbles/graph/filterrunprefixes/cache.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/filterrunprefixes/cache.js\\ntype: application/javascript\\nmodule-type: filterrunprefix\\n\\nAllows the results of a filter run to be cached for later filter executions.\\nThe runs MUST be generator functions. Local-run input is ignored, but run is\\nexecuted each time\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\n// The counter is an incrementing  value we use to uniquely identify\\n// instances of opFunction. opFunction, in turn, is cached by TW's limited\\n// cache of compiled filters.\\nvar counter = 0;\\n\\nexports.cache = function(operationSubFunction, options) {\\n\\tvar opFunction = function(results, _/*ignored source*/, widget) {\\n\\t\\t// Use the input from previous runs as currentTiddlers.\\n\\t\\t// If there was not input, then we'll introduce an empty string as\\n\\t\\t// currentTiddler.\\n\\t\\tvar inputTitles = results.toArray();\\n\\t\\tif (inputTitles.length == 0) {\\n\\t\\t\\tinputTitles.push(\\\"\\\");\\n\\t\\t}\\n\\t\\tresults.clear();\\n\\t\\tvar root = options.wiki.getGlobalCache(\\\"filterPrefix-\\\" + opFunction.cacheKey, function() { return Object.create(null); });\\n\\t\\tfor (var i = 0; i < inputTitles.length; i++) {\\n\\t\\t\\tvar current = inputTitles[i];\\n\\t\\t\\t// Roots start as {}, or a Node that is not yet Branch or Leaf\\n\\t\\t\\troot[current] = root[current] || {};\\n\\t\\t\\tvar output = execute(current, root[current], operationSubFunction, widget);\\n\\t\\t\\tresults.push.apply(results, output);\\n\\t\\t}\\n\\t};\\n\\topFunction.cacheKey = counter++;\\n\\treturn opFunction;\\n};\\n\\n/*\\nNode = { } // A node begins as undefined until we make it a branch or node.\\nBranch = {\\n\\tvariable: \\\"Variable name\\\",\\n\\toptions: (options that came with getVariable call)\\n\\tchildren: { \\\"variable value\\\": <Node>, ...},\\n}\\nLeaf = {\\n\\tvalue: [\\\"Outputs\\\", ...]\\n}\\n*/\\n\\nfunction execute(currentTiddler, root, operationSubFunction, widget) {\\n\\t// First, try to retrieve from cache if it's available\\n\\tvar node = root;\\n\\tvar variables = {currentTiddler: currentTiddler};\\n\\tvar mockWidget = widget.makeFakeWidgetWithVariables(variables);\\n\\tdo {\\n\\t\\tif (node.value !== undefined) {\\n\\t\\t\\t// We have a value to return\\n\\t\\t\\treturn node.value;\\n\\t\\t}\\n\\t\\tif (node.variable === undefined) {\\n\\t\\t\\t// No value, and no variable either. Must be a fresh cache.\\n\\t\\t\\t// This should only happen with the root node. It's the only one\\n\\t\\t\\t// that isn't necessarily a Branch or Leaf when execute starts.\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar info = mockWidget.getVariableInfo(node.variable, node.options);\\n\\t\\tnode = node.children[info.text];\\n\\t} while (node !== undefined);\\n\\t// It wasn't cached. We must now start back at the root and begin recording\\n\\tnode = root;\\n\\tvar trackWidget = widget.makeFakeWidgetWithVariables(variables);\\n\\tvar visited = Object.create(null);\\n\\ttrackWidget.oldVariable = trackWidget.getVariable;\\n\\ttrackWidget.getVariable = function(name, options) {\\n\\t\\tvar value = this.oldVariable(name, options);\\n\\t\\textendTree(name, value, options);\\n\\t\\treturn value;\\n\\t};\\n\\ttrackWidget.oldVariableInfo = trackWidget.getVariableInfo;\\n\\ttrackWidget.getVariableInfo = function(name, options) {\\n\\t\\tvar info = this.oldVariableInfo(name, options);\\n\\t\\textendTree(name, info.text, options);\\n\\t\\treturn info;\\n\\t};\\n\\tfunction extendTree(name, value, options) {\\n\\t\\t// We don't need to extend the tree for currentTiddler.\\n\\t\\t// It's already accounted for.\\n\\t\\t// Also, if we've already encountered this variable, no need to\\n\\t\\t// extend the tree again.\\n\\t\\tif (name !== \\\"currentTiddler\\\" && !visited[name]) {\\n\\t\\t\\tvisited[name] = true;\\n\\t\\t\\t// Logically, we're pointing at a node that does not have a value.\\n\\t\\t\\tif (node.variable === undefined) {\\n\\t\\t\\t\\t// It's an undefined node. Make it a branch.\\n\\t\\t\\t\\tnode.variable = name;\\n\\t\\t\\t\\tnode.options = options;\\n\\t\\t\\t\\tnode.children = Object.create(null);\\n\\t\\t\\t} else if (node.variable !== name) {\\n\\t\\t\\t\\t// Unexpected. Variables should always be called in\\n\\t\\t\\t\\t// the same order that they were before.\\n\\t\\t\\t\\tthrow \\\"Non-deterministic filter\\\";\\n\\t\\t\\t}\\n\\t\\t\\tvar child = node.children[value];\\n\\t\\t\\tif (child === undefined) {\\n\\t\\t\\t\\tchild = node.children[value] = {};\\n\\t\\t\\t}\\n\\t\\t\\tnode = child;\\n\\t\\t}\\n\\t}\\n\\tvar output = operationSubFunction(function() {/*No source*/}, trackWidget);\\n\\t// Change the current node (which is undefined) into a leaf.\\n\\tnode.value = output;\\n\\treturn output;\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"filterrunprefix\"},\"$:/plugins/flibbles/graph/filters/gettyped.js\":{\"title\":\"$:/plugins/flibbles/graph/filters/gettyped.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/filters/gettyped.js\\ntype: application/javascript\\nmodule-type: filteroperator\\n\\nFilter operator which replcaes tiddler titles with the values of the field of the specified operand, but does so in a way that's responsive to the type of field, depending on how it's configured by Relink.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar typeOperators = $tw.modules.getModulesByTypeAsHashmap(\\\"fieldtype\\\");\\nvar relinkPrefix = \\\"$:/config/flibbles/relink/fields/\\\" ;\\n\\nexports.gettyped = function(source, operator, options) {\\n\\tvar results = [];\\n\\tvar field = operator.operand;\\n\\tvar typeName = options.wiki.getTiddlerText(relinkPrefix + field, \\\"list\\\");\\n\\tvar type = typeOperators[typeName] || typeOperators.list;\\n\\tsource(function(tiddler, title) {\\n\\t\\tif (tiddler) {\\n\\t\\t\\tresults.push.apply(results, type.get(tiddler, field, options));\\n\\t\\t}\\n\\t});\\n\\treturn results;\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"filteroperator\"},\"$:/plugins/flibbles/graph/graphengine.js\":{\"title\":\"$:/plugins/flibbles/graph/graphengine.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/graphengine.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nMacro returns the graph engine of choice within the current context.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar utils = require(\\\"./utils.js\\\");\\nvar config = \\\"$:/config/flibbles/graph/engine\\\";\\n\\nexports.name = \\\"graphengine\\\";\\nexports.params = [];\\n\\nexports.run = function() {\\n\\treturn exports.get(this.wiki);\\n};\\n\\nexports.get = function(wiki) {\\n\\treturn wiki.getCacheForTiddler(config, \\\"graphengine\\\", function() {\\n\\t\\tvar specified = wiki.getTiddlerText(config);\\n\\t\\tif (specified) {\\n\\t\\t\\treturn specified;\\n\\t\\t} else {\\n\\t\\t\\tvar engineMap = utils.getEngineMap();\\n\\t\\t\\tfor (var entry in engineMap) {\\n\\t\\t\\t\\treturn entry;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn \\\"\\\";\\n\\t});\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/flibbles/graph/icon\":{\"title\":\"$:/plugins/flibbles/graph/icon\",\"text\":\"\\\\parameters (size:\\\"22pt\\\")\\n\\\\procedure pi() 3.141592653589793\\n\\\\function pair() [all[]sin[]] [all[]cos[]] +[multiply[-50]join[ ]]\\n\\\\procedure nodes() [range[0],[4]divide[6]multiply[2]multiply<pi>] :map[function[pair]] \\\"0 0\\\"\\n\\\\whitespace trim\\n\\n<$wikify name=edge-color text=\\\"<<colour muted-foreground>>\\\" >\\n<svg class=\\\"graph-icon\\\" width=<<size>> height=<<size>> version=\\\"1.1\\\" viewBox=\\\"-64 -64 128 128\\\">\\n<path class=\\\"graph-icon-splash\\\" stroke-width=15 d=`M 0 0 S ${[subfilter<nodes>join[ ]]}$` style=`fill:$(edge-color)$;` />\\n<$list variable=pos filter=\\\"[subfilter<nodes>putlast[]butfirst[3]]\\\">\\n<circle class=\\\"graph-icon-node\\\" r=14\\n\\tcx={{{ [<pos>split[ ]first[]] }}}\\n\\tcy={{{ [<pos>split[ ]last[]] }}}\\n\\tfill=<<node-color>> />\\n\"},\"$:/plugins/flibbles/graph/images/drag\":{\"title\":\"$:/plugins/flibbles/graph/images/drag\",\"tags\":\"$:/tags/Image\",\"text\":\"\\\\whitespace trim\\n\\\\parameters (size:\\\"22pt\\\")\\n<svg width=<<size>> height=<<size>> class=\\\"tc-draggable-button tc-image-button\\\" viewBox=\\\"0 0 30 30\\\">\\n<circle r=3 cx=10 cy=5 />\\n<circle r=3 cx=10 cy=15 />\\n<circle r=3 cx=10 cy=25 />\\n<circle r=3 cx=20 cy=5 />\\n<circle r=3 cx=20 cy=15 />\\n<circle r=3 cx=20 cy=25 />\\n</svg>\\n\"},\"$:/plugins/flibbles/graph/macros/action.addedge\":{\"text\":\"\\\\widget $action.addedge()\\n\\\\whitespace trim\\n<$parameters\\n\\t$$fromTiddler={{{ [<fromTiddler>!match[]else<currentTiddler>] }}}\\n\\t$$toTiddler={{{ [<toTiddler>!match[]else<currentTiddler>] }}} >\\n\\n<$action-modal $tiddler=\\\"$:/plugins/flibbles/graph/ui/Modals/SelectField\\\">\\n\\n  <$action-addtyped $tiddler=<<$fromTiddler>> $field=<<selection>> $value=<<$toTiddler>> />\\n\\n</$action-modal>\\n<$action-sendmessage $message=tm-focus-selector $param=\\\"input.graph-select\\\" />\\n\\n\\\\end\\n\\n\\\\relink $action.addedge $fromTiddler:title $oTiddler:title\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/action.addedge\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/macros/edges.typed\":{\"text\":\"\\\\widget $edges.typed($editable:no)\\n\\\\whitespace trim\\n<$parameters\\n\\t$$functions={{{ [<functionsFilter>!is[blank]] ~\\\"[all[]]\\\" }}}\\n\\t$$fields={{{ [<fieldsFilter>!is[blank]] ~\\\"[all[]]\\\" }}}\\n\\t$$tiddler=<<currentTiddler>> >\\n\\n<!-- First create edges for field types -->\\n\\n<$list variable=fieldName filter=\\\"+[subfilter{$:/plugins/flibbles/graph/subfilters##edgetypes.fields}subfilter<$fields>]\\\">\\n\\n<$let\\n\\tdataTiddler=`$:/config/flibbles/graph/edges/fields/$(fieldName)$` >\\n\\n<$properties $for=edges\\n\\t$tiddler=<<dataTiddler>>\\n\\tdelete={{{ [<$editable>!match[no]then[<$action-removetyped $tiddler=<<fromTiddler>> $field=<<fieldName>> $value=<<toTiddler>> />]] }}} >\\n\\n\\n<$list variable=toTiddler counter=index filter=\\\"[<$tiddler>] :map:flat[gettyped<fieldName>] +[!is[blank]]\\\">\\n\\n<$vars id=`$:/edge/fields/$($tiddler)$\\n$(fieldName)$-$(index)$`>\\n\\n<$slot $name=ts-raw>\\n\\n<$edge $from=<<$tiddler>> $id=<<id>> />\\n\\n</$slot></$vars></$list></$properties></$let></$list>\\n\\n<!-- Now create edges for function types -->\\n\\n<$list variable=functionName filter=\\\"[subfilter{$:/plugins/flibbles/graph/subfilters##edgetypes.functions}subfilter<$functions>]\\\">\\n\\n<$let\\n\\tdataTiddler=`$:/config/flibbles/graph/edges/functions/$(functionName)$`\\n\\tfunction={{{ [<dataTiddler>get[filter]] }}} >\\n\\n<$properties $for=edges\\n\\t$tiddler=<<dataTiddler>> >\\n\\n<$list variable=toTiddler counter=index filter=\\\"[<$tiddler>] :map:flat[subfilter<function>] +[!is[blank]]\\\">\\n\\n<$vars id=`$:/edge/functions/$($tiddler)$\\n$(functionName)$-$(index)$`>\\n\\n<$slot $name=ts-raw>\\n\\n<$edge $from=<<$tiddler>> $id=<<id>> />\\n\\n</$slot></$vars></$list></$properties></$let></$list>\\n\\\\end\\n\\n\\\\relink $edges.typed $functions:filter $fields:filter $tiddler:title\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/edges.typed\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/macros/graph.view\":{\"text\":\"\\\\widget $graph.view($tiddler:\\\"$:/graph/Default\\\", $mode)\\n\\\\whitespace trim\\n<$parameters $params=viewParams $parseMode=$defaultMode $$template={{{ [<$tiddler>get[template]] ~[[$:/tags/flibbles/graph/Template]tagging[]first[]] }}}>\\n\\n<$vars currentTiddler=<<$tiddler>> >\\n\\n<$genesis\\n\\t$type=\\\"$transclude\\\"\\n\\t$$tiddler=<<$template>>\\n\\t$$fillignore=yes\\n\\t$$mode={{{ [<$mode>!is[blank]else<$defaultMode>] }}}\\n\\t$names=\\\"[<viewParams>jsonindexes[]!prefix[$]]\\\"\\n\\t$values=\\\"[<viewParams>jsonindexes[]!prefix[$]] :map[<viewParams>jsonget{!!title}]\\\" />\\n\\n</$vars></$parameters>\\n\\\\end\\n\\n\\\\relink $graph.view $tiddler\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/graph.view\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/macros/node.default\":{\"text\":\"\\\\widget $node.default()\\n<$wikify name=label\\n\\tmode=inline\\n\\ttext={{{ [{!!title}get[caption]else[<$text text={{!!title}} />]] }}} >\\n\\n  <$node $pos=<<pos>> label=<<label>> color={{!!color}} image={{!!icon}} />\\n\\n</$wikify>\\n\\\\end\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/node.default\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/macros/nodes.neighbors\":{\"text\":\"\\\\widget $nodes.neighbors($filter, $fields:'[all[]]', $functions:'[all[]]', $interedges, $whitelist:'[!is[system]]')\\n\\n<!-- None of these \\\\procedures are \\\\functions because that mucks with caching. -->\\n\\\\procedure filter.cached() [{!!title}] :cache[all[tiddlers]subfilter<$filter>]\\n\\n<!-- Holy nuts this is getting complicated, but we need to :map:flat twice\\n     in order to switch ..currentTiddler and currentTiddler, as the fields\\n     and functions will expect it. -->\\n\\\\procedure edges.fields.flipped() [<..currentTiddler>] :map:flat[<currentTiddler>gettyped<..currentTiddler>]\\n\\\\procedure edges.functions.flipped() [<..currentTiddler>] :map:flat[<currentTiddler>subfilter<..currentTiddler>]\\n\\n\\\\procedure edges.fields() :cache[subfilter{$:/plugins/flibbles/graph/subfilters##edgetypes.fields}subfilter<$fields>] :map:flat[<..currentTiddler>subfilter<edges.fields.flipped>]\\n\\\\procedure edges.functions() :cache[subfilter{$:/plugins/flibbles/graph/subfilters##edgetypes.functions}subfilter<$functions>addprefix[$:/config/flibbles/graph/edges/functions/]get[filter]] :map:flat[<..currentTiddler>subfilter<edges.functions.flipped>]\\n\\n\\\\procedure neighbors.for() [subfilter<edges.fields>] [subfilter<edges.functions>] +[!is[blank]unique[]]\\n\\\\procedure neighbors.cached() [all[]] :cache[subfilter<neighbors.for>]\\n\\n\\\\procedure incoming.raw() [all[tiddlers]subfilter<$whitelist>!search:title:regexp,casesensitive<regexp>] :filter[subfilter<neighbors.cached>search:title:regexp,casesensitive<regexp>]\\n\\\\procedure incoming.cached() :cache[subfilter<incoming.raw>]\\n\\\\whitespace trim\\n\\n<$vars\\n\\tregexp={{{ [subfilter<filter.cached>escaperegexp[]join[|]addprefix[^(?:]addsuffix[)$]] }}}\\n\\tfunctionsFilter=<<$functions>>\\n\\tfieldsFilter=<<$fields>> >\\n\\n<!-- incoming neighbors -->\\n\\n<$list filter=<<incoming.cached>> >\\n\\n<$slot $name=ts-raw>\\n\\n<$node.default />\\n\\n</$slot>\\n\\n<$edges.typed>\\n\\n<%if [<$interedges>match[yes]] ~[<toTiddler>search:title:regexp,casesensitive<regexp>] %>\\n\\n<$edge $id=<<id>> />\\n\\n<%endif%></$edges.typed></$list>\\n\\n<!-- outgoing neighbors -->\\n\\n<$list filter=\\\"[subfilter<filter.cached>subfilter<neighbors.cached>subfilter<$whitelist>!search:title:regexp,casesensitive<regexp>] -[subfilter<incoming.cached>]\\\">\\n\\n<$slot $name=ts-raw>\\n\\n<$node.default />\\n\\n</$slot>\\n\\n<%if [<$interedges>match[yes]] %>\\n\\n<$edges.typed />\\n\\n<%endif%></$list>\\n\\\\end\\n\\n\\\\relink $nodes.neighbors $filter:filter $fields:filter $functions:filter $whitelist:filter\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/nodes.neighbors\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/macros/nodes.writable\":{\"text\":\"\\\\widget $nodes.writable($field, $variable:currentTiddler)\\n\\n\\\\procedure actionAddnode()\\n\\\\whitespace trim\\n<$action-modal $tiddler=\\\"$:/plugins/flibbles/graph/ui/Modals/SelectTiddler\\\">\\n  <% if [<selection>!is[tiddler]] %>\\n    <$action-createtiddler $basetitle=<<selection>> />\\n  <% endif %>\\n  <% if [<$field>!match[]] %>\\n    <$action-addtyped $tiddler=<<$tiddler>> $field=<<$field>> $value=<<selection>> />\\n  <% endif %>\\n  <$transclude $variable=recordPosition title=<<selection>> />\\n</$action-modal>\\n<$action-sendmessage $message=tm-focus-selector $param=\\\"input.graph-select\\\" />\\n\\\\end actionAddnode\\n\\n\\\\whitespace trim\\n<$parameters $$tiddler={{!!title}}>\\n\\n<$properties $for=graph\\n\\tdoubleclick=<<actionAddnode>>\\n\\taddNode=<<actionAddnode>>\\n\\taddEdge=\\\"\\\"\\\"<$action.addedge/>\\\"\\\"\\\"\\n/>\\n\\n<$properties delete=\\\"<$action-removetyped $tiddler=<<$tiddler>> $field=<<$field>> $value=<<nodeTiddler>> />\\\">\\n\\n<$list variable=<<$variable>> filter=\\\"[<$tiddler>gettyped<$field>!is[draft]]\\\">\\n\\n<$slot $name=ts-raw>\\n\\n<$node.default />\\n\\n\\\\end\\n\\n\\\\relink $nodes.writable $field:fieldname $tiddler:title\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/nodes.writable\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/macros/properties.persistent\":{\"text\":\"\\\\widget $properties.persistent($dataTiddler)\\n\\\\whitespace trim\\n\\n\\\\function pos() [<$dataTiddler>getindex{!!title}]\\n\\n\\\\procedure recordPosition(title)\\n\\\\whitespace trim\\n<$action-setfield\\n  $tiddler=<<$dataTiddler>>\\n  $index=<<title>>\\n  $value=`$(x)$,$(y)$`/>\\n<%if [<$dataTiddler>!prefix[$:/graph/]] %>\\n  <$fieldmangler tiddler=<<$dataTiddler>> >\\n    <$action-sendmessage $message=tm-add-tag $param=\\\"$:/tags/flibbles/graph/TiddlerData\\\" />\\n  </$fieldmangler>\\n<%endif%>\\n\\\\end recordPosition\\n\\n<$properties\\n  free=\\\"<$transclude $variable=recordPosition title=<<nodeTiddler>> />\\\"\\n  delete=\\\"<$action-setfield $tiddler=<<$dataTiddler>> $index=<<nodeTiddler>>/>\\\">\\n\\n<$slot $name=ts-raw />\\n\\n\\\\end\\n\\n\\\\relink $properties.persistent $dataTiddler:title\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/properties.persistent\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/macros/properties.popup\":{\"text\":\"\\\\widget $properties.popup($enabled:yes $ms:600, $width, $height:50%)\\n\\\\whitespace trim\\n\\n<$parameters $state=<<qualify \\\"$:/state/graph/tooltip\\\">> >\\n\\n<$let state=<<$state>>\\n\\tdelayState=`$(state)$-delay`\\n\\tblurringState=`$(state)$-interrupt`\\n\\tdraggingState=`$(state)$-dragging`\\n\\t$msLinger=0>\\n\\n<$properties $for={{{ [<$enabled>match[yes]then[nodes]] }}}\\n  hover=\\\"\\\"\\\"\\\\whitespace trim\\n    <%if [<draggingState>] [<state>] +[is[tiddler]count[]match[0]] %>\\n      <$action-delay $state=<<delayState>> $ms=<<$ms>> >\\n        <$action-with $offset=\\\"mouse\\\" $canvas=canvas>\\n          <$vars\\n              lr={{{ [<mouse-x>multiply[2]compare:number:gt<canvas-width>then[right]else[left]] }}}\\n              tb={{{ [<mouse-y>multiply[2]compare:number:gt<canvas-height>then[bottom]else[top]] }}} >\\n            <$action-popup $state=<<$state>> $coords=\\\"(0,0,0,0)\\\"/>\\n            <$action-setfield $tiddler=<<$state>>\\n              x={{{ [<lr>match[left]then<mouse-x>] ~[<canvas-width>subtract<mouse-x>] }}}\\n              y={{{ [<tb>match[top]then<mouse-y>] ~[<canvas-height>subtract<mouse-y>] }}}\\n              lr=<<lr>>\\n              tb=<<tb>>\\n              target=<<targetTiddler>> />\\n          </$vars>\\n        </$action-pointer>\\n      </$action-delay>\\n    <%endif%>\\n    <$action-deletetiddler $tiddler=<<blurringState>> />\\\"\\\"\\\"\\n  blur=\\\"\\\"\\\"\\\\whitespace trim\\n    <$action-delay $state=<<blurringState>> $ms=<<$msLinger>> >\\n      <$action-deletetiddler $tiddler=<<delayState>> />\\n      <$action-popup $state=<<state>> />\\\"\\\"\\\"\\n  drag=\\\"\\\"\\\"\\\\whitespace trim\\n    <$action-deletetiddler $tiddler=<<delayState>> />\\n    <$action-popup $state=<<state>> />\\n    <$action-setfield $tiddler=<<draggingState>> text=dragging />\\\"\\\"\\\"\\n  free='<$action-deletetiddler $tiddler=<<draggingState>> />' >\\n\\n<$slot $name=\\\"ts-raw\\\" />\\n\\n</$properties>\\n\\n<$vars\\n  x={{{ [<$state>get[x]] }}}\\n  y={{{ [<$state>get[y]] }}}\\n  lr={{{ [<$state>get[lr]] }}}\\n  tb={{{ [<$state>get[tb]] }}}\\n  width={{{ [<$width>!is[blank]addprefix[max-width:]addsuffix[;]] }}} >\\n\\n<!-- We aren't using the popup type because we need to be more dynamic about placing the popup in different directions. The text must be a coord because of $action-popup, but we don't use it. -->\\n\\n<%if [<$enabled>match[yes]] %>\\n\\n<$reveal\\n  type=match\\n  text=\\\"(0,0,0,0)\\\"\\n  state=<<$state>>\\n  positionAllowNegative=yes\\n  class=\\\"graph-popup tc-popup tc-popup-keep\\\"\\n  style=`$(width)$max-height:$($height)$;$(lr)$:$(x)$px;$(tb)$:$(y)$px;`>\\n\\n<$vars currentTooltip={{{ [<$state>get[target]] }}}>\\n\\n<$slot $name=tooltip>\\n\\n<$transclude $tiddler=<<currentTooltip>> />\\n\\n\\\\end\\n\\n\\\\relink $properties.popup $state:title\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/properties.popup\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/macros/properties.river\":{\"text\":\"\\\\widget $properties.river()\\n\\\\parameters ($state: \\\"$:/state/flibbles/graph/river\\\")\\n\\\\whitespace trim\\n\\n<%if [<graph-sidebar>!match[yes]] %>\\n\\n<$qualify name=state title=<<$state>> >\\n\\n<$properties $for=graph\\n\\tblur=\\\"<$action-deletetiddler $tiddler=<<state>> />\\\"\\n\\tfocus=\\\"<$action-setfield $tiddler=<<state>> text=focused />\\\"\\n\\tzoom={{{ [<state>get[text]match[focused]then[yes]else[no]] }}} />\\n\\n<$slot $name=\\\"ts-raw\\\" />\\n\\n<$properties $for=graph navigation={{{ [<state>get[text]match[focused]then[]else[no]] }}} />\\n\\n</$qualify><%else%>\\n\\n<$properties $for=graph zoom=yes />\\n\\n<$slot $name=\\\"ts-raw\\\" />\\n\\n<%endif%>\\n\\\\end\\n\\n\\\\relink $properties.river $state:title\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/properties.river\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/macros/properties.settings\":{\"text\":\"\\\\widget $properties.settings()\\n\\\\whitespace trim\\n\\n<$properties.popup\\n  $enabled={{!!popup}}\\n  $width={{{ [{!!title}get[popup.width]else[300px]] }}}\\n  $height={{{ [{!!title}get[popup.height]else[200px]] }}} >\\n\\n<$properties.river>\\n\\n<$properties $tiddler={{!!title}} $field=\\\"graph.edges\\\" $for=edges >\\n\\n<$properties $tiddler={{!!title}} $field=\\\"graph.nodes\\\" $for=nodes >\\n\\n<$properties.stack>\\n\\n<$let\\n  fieldsFilter={{{ [{!!edges.fields}!is[blank]] ~\\\"[all[]]\\\" }}}\\n  functionsFilter={{{ [{!!edges.functions}!is[blank]] ~\\\"[all[]]\\\" }}}>\\n\\n<$slot $name=\\\"ts-raw\\\" $depth=4 />\\n\\n<%if [{!!neighbors.incoming}] =[{!!neighbors.outgoing}] +[match[1]count[]match[2]] %>\\n\\n<$wikify name=muted text=\\\"<<colour muted-foreground>>\\\">\\n\\n<$properties color=<<muted>> >\\n \\n<$nodes.neighbors\\n  $filter={{!!filter}}\\n  $functions=<<functionsFilter>>\\n  $fields=<<fieldsFilter>>\\n  $interedges={{!!neighbors.interedges}}\\n  $whitelist={{{ [{!!title}get[neighbors.whitelist]] ~\\\"[!is[system]]\\\" }}} />\\n\\n</$properties></$wikify><%endif%></$let></$properties.stack></$properties></$properties>\\n<$properties $tiddler={{!!title}} $field=\\\"graph.graph\\\" $for=graph />\\n\\n</$properties.river></$properties.popup>\\n\\\\end\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/properties.settings\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/macros/properties.stack\":{\"text\":\"\\\\widget $properties.stack()\\n\\\\procedure $properties.stack.recurse(zth)\\n\\\\procedure node.stack() [list[$:/config/flibbles/graph/nodes/stack]] =[all[shadows+tiddlers]prefix[$:/config/flibbles/graph/nodes/stack/]sort[]] +[unique[]is[tiddler]]\\n\\\\whitespace trim\\n<%if :cache[subfilter<node.stack>] +[zth<zth>] %>\\n  <$properties $filter={{{ [<condition>get[filter]] }}} $tiddler=<<condition>> >\\n    <$transclude $variable=$properties.stack.recurse $fillignore=yes zth={{{ [<zth>add[1]] }}} />\\n  </$properties>\\n<%else%>\\n  <$slot $name=ts-raw />\\n<%endif%>\\n\\\\end $properties.stack.recurse\\n\\\\whitespace trim\\n\\n<$transclude $variable=$properties.stack.recurse zth=0 $fillignore=yes />\\n\\n\\\\end\\n\",\"title\":\"$:/plugins/flibbles/graph/macros/properties.stack\",\"tags\":\"$:/tags/Global\",\"code-body\":\"yes\"},\"$:/plugins/flibbles/graph/presettypes/edges/fields\":{\"title\":\"$:/plugins/flibbles/graph/presettypes/edges/fields\",\"text\":\"\\\\procedure typeSelector()\\n\\\\whitespace trim\\n<$select tiddler=`$:/config/flibbles/relink/fields/$(fieldName)$` default=list>\\n  <$list filter=\\\"[[$:/plugins/flibbles/relink]is[tiddler]then[relinkfieldtype]else[fieldtype]modules[]moduleproperty[name]]\\\">\\n    <option>\\n      <$text text={{!!title}} />\\n    </option>\\n  </$list>\\n</$select>\\n\\\\end\\n\\n\\\"Fields\\\" presets define the edge properties for edges corresponding to tiddler fields. These types of edges can be easily added to a node using the <<.link EdgesAllWidget>> widget, or the more inclusive `$edges.typed` widget, which encompasses all other types of preset edge types.\\n\\n<$vars fieldName={{{ [<currentTiddler>removeprefix[$:/config/flibbles/graph/edges/fields/]] }}}>\\n\\nField type: <<typeSelector>>\\n\"},\"$:/plugins/flibbles/graph/presettypes/edges/functions\":{\"title\":\"$:/plugins/flibbles/graph/presettypes/edges/functions\",\"text\":\"\\\"Function\\\" edges define properties for edges generated from input nodes //individually// into a filter, and then creating an edge from that node to each of the filter's output.\\n\\nFilter: <$edit-text field=filter />\\n\"},\"$:/plugins/flibbles/graph/presettypes/nodes/stack\":{\"title\":\"$:/plugins/flibbles/graph/presettypes/nodes/stack\",\"orderable\":\"yes\",\"text\":\"\\\"stack\\\" nodes define the node properties that can be applied as a stack to contained nodes, such as nodes contained within `$properties.stack`. For each node, the stack of node properties are applied one after another, each depending on if that node matches any given stack property's filter.\\n\\nFilter: <$edit-text field=filter />\\n\"},\"$:/plugins/flibbles/graph/propertytypes/actions.js\":{\"text\":\"/*\\\\\\n\\nDefines behavior to be taken in the event that particular action is called.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"actions\\\";\\n\\nexports.type = \\\"wikitext\\\";\\n\\nexports.toProperty = function(info, value) {\\n\\treturn value? true: null;\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/propertytypes/actions.js\",\"type\":\"application/javascript\",\"module-type\":\"graphpropertytype\"},\"$:/plugins/flibbles/graph/propertytypes/boolean.js\":{\"text\":\"/*\\\\\\n\\nDefines behavior for boolean types in graph engine properties.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"boolean\\\";\\n\\nexports.toProperty = function(info, value) {\\n\\tswitch (value.toLowerCase()) {\\n\\t\\tcase \\\"yes\\\":\\n\\t\\tcase \\\"true\\\":\\n\\t\\tcase \\\"1\\\":\\n\\t\\tcase \\\"y\\\":\\n\\t\\tcase \\\"t\\\":\\n\\t\\t\\treturn true;\\n\\t\\tdefault:\\n\\t\\t\\treturn false;\\n\\t}\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/propertytypes/boolean.js\",\"type\":\"application/javascript\",\"module-type\":\"graphpropertytype\"},\"$:/plugins/flibbles/graph/propertytypes/enum.js\":{\"text\":\"/*\\\\\\n\\nDefines behavior for enum types in graph engine properties.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"enum\\\";\\n\\nexports.toProperty = function(info, value) {\\n\\tif (info.values.indexOf(value) >= 0) {\\n\\t\\treturn value;\\n\\t}\\n\\treturn null;\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/propertytypes/enum.js\",\"type\":\"application/javascript\",\"module-type\":\"graphpropertytype\"},\"$:/plugins/flibbles/graph/propertytypes/image.js\":{\"text\":\"/*\\\\\\n\\nDefines images types, and manages fetching a url from titles.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"image\\\";\\n\\nexports.type = \\\"title\\\";\\n\\nexports.toProperty = function(info, value, options) {\\n\\tvar tiddler = options.widget.wiki.getTiddler(value);\\n\\tif (!tiddler) {\\n\\t\\t// It does not appear to be a real tiddler,\\n\\t\\t// so let's treat it like a real URL.\\n\\t\\treturn value;\\n\\t}\\n\\tvar cache = options.widget.wiki.getGlobalCache(\\\"graph-image\\\", function() {\\n\\t\\treturn Object.create(null);\\n\\t});\\n\\tif (!cache[value]) {\\n\\t\\tvar output = getTiddlerUri(value, options.widget);\\n\\t\\tif (output.uri === undefined && output.widget) {\\n\\t\\t\\tvar container = $tw.fakeDocument.createElement(\\\"div\\\");\\n\\t\\t\\toutput.widget.render(container, null);\\n\\t\\t\\tvar svg = findSVGElement(container);\\n\\t\\t\\tif (!svg) {\\n\\t\\t\\t\\t// Not an image as far as we can tell. Ignore the input.\\n\\t\\t\\t\\toutput.uri = null;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinjectNamespace(svg);\\n\\t\\t\\t\\t// wikitext images may benefit from colors. svg images should too, but let's\\n\\t\\t\\t\\t// not worry about that right now.\\n\\t\\t\\t\\toutput.widget.color = options.widget.getColor(\\\"nodeColor\\\");\\n\\t\\t\\t\\tinjectStyle(svg, output.widget);\\n\\t\\t\\t\\toutput.uri = \\\"data:image/svg+xml,\\\" + encodeURIComponent(container.innerHTML);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcache[value] = output;\\n\\t}\\n\\treturn cache[value].uri;\\n};\\n\\nexports.refresh = function(info, value, changedTiddlers, widget) {\\n\\tif (changedTiddlers[value]) {\\n\\t\\treturn true;\\n\\t}\\n\\tvar graphWidget = getGraphWidget(widget);\\n\\tvar tiddler = graphWidget.wiki.getTiddler(value);\\n\\tif (tiddler) {\\n\\t\\tvar output = getTiddlerUri(value, graphWidget);\\n\\t\\tif (output.widget && output.widget.refresh(changedTiddlers)) {\\n\\t\\t\\toutput.uri = undefined;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\t// Now we need to check whether the color for this image has changed\\n\\tif (output && output.widget) {\\n\\t\\tvar newColor = graphWidget.getColor(\\\"nodeColor\\\");\\n\\t\\tif (newColor !== output.widget.color) {\\n\\t\\t\\toutput.color = newColor;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n};\\n\\nfunction getGraphWidget(widget) {\\n\\twhile (widget && !widget.getColor) {\\n\\t\\twidget = widget.parentWidget;\\n\\t}\\n\\treturn widget;\\n};\\n\\nfunction getTiddlerUri(title, widget) {\\n\\tvar wiki = widget.wiki;\\n\\tvar tiddler = wiki.getTiddler(title);\\n\\tvar output = {};\\n\\tif(wiki.isImageTiddler(title)) {\\n\\t\\t// Check if it is an image tiddler\\n\\t\\tvar type = tiddler.fields.type,\\n\\t\\t\\ttext = tiddler.fields.text,\\n\\t\\t\\t_canonical_uri = tiddler.fields._canonical_uri,\\n\\t\\t\\ttypeInfo = $tw.config.contentTypeInfo[type] || {},\\n\\t\\t\\tdeserializerType = typeInfo.deserializerType || type;\\n\\t\\tif(text) {\\n\\t\\t\\t// Render the appropriate element for the image type by looking up the encoding in the content type info\\n\\t\\t\\tvar encoding = typeInfo.encoding || \\\"utf8\\\";\\n\\t\\t\\tif (encoding === \\\"base64\\\") {\\n\\t\\t\\t\\t// .pdf .png .jpg etc.\\n\\t\\t\\t\\toutput.uri = \\\"data:\\\" + deserializerType + \\\";base64,\\\" + text;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// .svg .tid .xml etc.\\n\\t\\t\\t\\toutput.uri = \\\"data:\\\" + deserializerType + \\\";\\\" + encoding + \\\",\\\" + encodeURIComponent(text);\\n\\t\\t\\t}\\n\\t\\t} else if(_canonical_uri) {\\n\\t\\t\\toutput.uri = _canonical_uri;\\n\\t\\t} else {\\n\\t\\t\\t// This must be a lazily loaded tiddler. We don't suppor those yet.\\n\\t\\t\\toutput.uri = null;\\n\\t\\t}\\n\\t} else {\\n\\t\\t// We assume it is wikitext trying to make an svg\\n\\t\\toutput.widget = wiki.getCacheForTiddler(title, \\\"graph-image\\\", function() {\\n\\t\\t\\tvar parser = wiki.parseTiddler(title, {parseAsInline: true});\\n\\t\\t\\treturn wiki.makeWidget(parser, {parentWidget: widget});\\n\\t\\t});\\n\\t}\\n\\treturn output;\\n};\\n\\nfunction findSVGElement(element) {\\n\\tif (element.tag === \\\"svg\\\") {\\n\\t\\treturn element;\\n\\t}\\n\\tif (element.children) {\\n\\t\\tfor (var i = 0; i < element.children.length; i++) {\\n\\t\\t\\tvar found = findSVGElement(element.children[i]);\\n\\t\\t\\tif (found) {\\n\\t\\t\\t\\treturn found;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn null;\\n};\\n\\nfunction injectNamespace(svg) {\\n\\t// wikitext svg does not need namespacing, but data URIs do\\n\\tsvg.setAttribute(\\\"xmlns\\\", \\\"http://www.w3.org/2000/svg\\\");\\n};\\n\\nfunction injectStyle(svg, widget) {\\n\\tif (widget.color) {\\n\\t\\tvar style = $tw.fakeDocument.createElement(\\\"style\\\");\\n\\t\\tstyle.textContent = \\\":root{fill:\\\" + widget.color + \\\";}\\\";\\n\\t\\tsvg.insertBefore(style, svg.children[0]);\\n\\t}\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/propertytypes/image.js\",\"type\":\"application/javascript\",\"module-type\":\"graphpropertytype\"},\"$:/plugins/flibbles/graph/propertytypes/number.js\":{\"text\":\"/*\\\\\\n\\nDefines behavior for number types in graph engine properties.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"number\\\";\\n\\nexports.toProperty = function(info, value) {\\n\\tvalue = parseFloat(value);\\n\\tif (isNaN(value)) {\\n\\t\\t// Ignore it. It's a bad number.\\n\\t\\treturn null;\\n\\t}\\n\\tif (info.min !== undefined && value < info.min) {\\n\\t\\tvalue = info.min;\\n\\t}\\n\\tif (info.max !== undefined && value > info.max) {\\n\\t\\tvalue = info.max;\\n\\t}\\n\\treturn value;\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/propertytypes/number.js\",\"type\":\"application/javascript\",\"module-type\":\"graphpropertytype\"},\"$:/plugins/flibbles/graph/propertytypes/string.js\":{\"text\":\"/*\\\\\\n\\nDefines behavior for string types in graph engine properties.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"string\\\";\\n\\nexports.toProperty = function(info, value) {\\n\\treturn value || null;\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/propertytypes/string.js\",\"type\":\"application/javascript\",\"module-type\":\"graphpropertytype\"},\"$:/plugins/flibbles/graph/readme\":{\"title\":\"$:/plugins/flibbles/graph/readme\",\"text\":\"//tw5-graph// is a plugin which provides a toolkit of widgets to interact with graph visualization software. This plugin does not include any visualization libraries itself. It must be coupled with a library plugin that acts as an engine.\\n\\n[ext[Project page is available on github.|https://github.com/flibbles/tw5-graph]]\\n\"},\"$:/plugins/flibbles/graph/relink/attributes.js\":{\"title\":\"$:/plugins/flibbles/graph/relink/attributes.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/relink/attributes.js\\ntype: application/javascript\\nmodule-type: relinkhtmlattributes\\n\\nRelinks attributes of $properties and other graph object widgets.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"graph\\\";\\n\\nvar utils = require(\\\"./utils.js\\\");\\nvar graphObjects = Object.create(null);\\n\\n$tw.modules.forEachModuleOfType(\\\"widget-subclass\\\", function(subclass, module) {\\n\\tvar type = module.prototype.graphObjectType;\\n\\tif (module.baseClass === \\\"graphobject\\\") {\\n\\t\\tgraphObjects[\\\"$\\\" + module.name] = function() { return type; };\\n\\t}\\n});\\n\\ngraphObjects[\\\"$graph\\\"] = function() { return \\\"graph\\\"; };\\n\\n// Current behavior is if $for is specified, but it's empty or wrong, then\\n// this widget gets ignored for relinking, just as it gets ignored by graphs.\\ngraphObjects[\\\"$properties\\\"] = function(element) {\\n\\tvar forAttr = element.attributes[\\\"$for\\\"];\\n\\treturn forAttr !== undefined? forAttr.value: \\\"nodes\\\";\\n};\\n\\nexports.getHandler = function(element, attribute, options) {\\n\\tvar forFunc = graphObjects[element.tag];\\n\\tif (forFunc) {\\n\\t\\treturn processAttribute(forFunc(element), attribute, options);\\n\\t}\\n};\\n\\nfunction processAttribute(forObject, attribute, options) {\\n\\tvar name = attribute.name;\\n\\tif (name[0] !== \\\"$\\\") {\\n\\t\\tvar engine = utils.getEngine(options.wiki);\\n\\t\\tif (engine) {\\n\\t\\t\\tvar properties = engine.prototype.properties[forObject];\\n\\t\\t\\tif (properties) {\\n\\t\\t\\t\\tvar propertyInfo = properties[attribute.name];\\n\\t\\t\\t\\treturn utils.getRelinker(propertyInfo);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"relinkhtmlattributes\"},\"$:/config/flibbles/relink/attributes/$action-addtyped/$field\":{\"title\":\"$:/config/flibbles/relink/attributes/$action-addtyped/$field\",\"text\":\"fieldname\"},\"$:/config/flibbles/relink/attributes/$action-addtyped/$tiddler\":{\"title\":\"$:/config/flibbles/relink/attributes/$action-addtyped/$tiddler\",\"text\":\"title\"},\"$:/config/flibbles/relink/attributes/$action-delay/$state\":{\"title\":\"$:/config/flibbles/relink/attributes/$action-delay/$state\",\"text\":\"title\"},\"$:/config/flibbles/relink/attributes/$action-modal/$tiddler\":{\"title\":\"$:/config/flibbles/relink/attributes/$action-modal/$tiddler\",\"text\":\"title\"},\"$:/config/flibbles/relink/attributes/$action-removetyped/$field\":{\"title\":\"$:/config/flibbles/relink/attributes/$action-removetyped/$field\",\"text\":\"fieldname\"},\"$:/config/flibbles/relink/attributes/$action-removetyped/$tiddler\":{\"title\":\"$:/config/flibbles/relink/attributes/$action-removetyped/$tiddler\",\"text\":\"title\"},\"$:/config/flibbles/relink/attributes/$boundingbox/length\":{\"title\":\"$:/config/flibbles/relink/attributes/$boundingbox/length\",\"text\":\"filter\"},\"$:/config/flibbles/relink/attributes/$boundingbox/width\":{\"title\":\"$:/config/flibbles/relink/attributes/$boundingbox/width\",\"text\":\"filter\"},\"$:/config/flibbles/relink/attributes/$edge/$from\":{\"title\":\"$:/config/flibbles/relink/attributes/$edge/$from\",\"text\":\"title\"},\"$:/config/flibbles/relink/attributes/$edge/$to\":{\"title\":\"$:/config/flibbles/relink/attributes/$edge/$to\",\"text\":\"title\"},\"$:/config/flibbles/relink/attributes/$fieldtranscriber/state\":{\"title\":\"$:/config/flibbles/relink/attributes/$fieldtranscriber/state\",\"text\":\"title\"},\"$:/config/flibbles/relink/attributes/$fieldtranscriber/field\":{\"title\":\"$:/config/flibbles/relink/attributes/$fieldtranscriber/field\",\"text\":\"fieldname\"},\"$:/config/flibbles/relink/attributes/$fieldtranscriber/tiddler\":{\"title\":\"$:/config/flibbles/relink/attributes/$fieldtranscriber/tiddler\",\"text\":\"title\"},\"$:/config/flibbles/relink/attributes/$node/$tiddler\":{\"title\":\"$:/config/flibbles/relink/attributes/$node/$tiddler\",\"text\":\"title\"},\"$:/config/flibbles/relink/attributes/$properties/$tiddler\":{\"title\":\"$:/config/flibbles/relink/attributes/$properties/$tiddler\",\"text\":\"title\"},\"$:/config/flibbles/relink/attributes/$properties/$field\":{\"title\":\"$:/config/flibbles/relink/attributes/$properties/$field\",\"text\":\"fieldname\"},\"$:/config/flibbles/relink/attributes/$properties/$filter\":{\"title\":\"$:/config/flibbles/relink/attributes/$properties/$filter\",\"text\":\"filter\"},\"$:/plugins/flibbles/graph/relink/configprefix.js\":{\"title\":\"$:/plugins/flibbles/graph/relink/configprefix.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/relink/configprefix.js\\ntype: application/javascript\\nmodule-type: relinkprefix\\n\\nTakes care of relinking property data tiddlers\\nin the $:/config/flibbles/graph namespace.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.prefix = \\\"$:/config/flibbles/graph/\\\";\\n\\nvar utils = require(\\\"./utils.js\\\");\\nvar jsonType = \\\"application/json\\\";\\n\\n\\nexports.report = function(tiddler, callback, options) {\\n\\tforEachProperty(options.wiki, tiddler, function(key, data, relinker) {\\n\\t\\trelinker.report(data[key], function(title, blurb, info) {\\n\\t\\t\\tvar suffix = blurb? (\\\": \\\" + blurb): \\\"\\\";\\n\\t\\t\\tcallback(title, key + suffix, info);\\n\\t\\t}, options);\\n\\t});\\n};\\n\\nexports.relink = function(tiddler, fromTitle, toTitle, changes, options) {\\n\\tvar changed, tiddlerData;\\n\\tvar type = tiddler.fields.type;\\n\\tvar impossible = false;\\n\\tforEachProperty(options.wiki, tiddler, function(key, data, relinker) {\\n\\t\\tvar lineEntry = relinker.relink(data[key], fromTitle, toTitle, options);\\n\\t\\tif (lineEntry) {\\n\\t\\t\\tchanged = true;\\n\\t\\t\\tif (lineEntry.output) {\\n\\t\\t\\t\\tdata[key] = lineEntry.output;\\n\\t\\t\\t\\ttiddlerData = data;\\n\\t\\t\\t\\tif (!isLegalDictionaryValue(lineEntry.output)) {\\n\\t\\t\\t\\t\\ttype = jsonType;\\n\\t\\t\\t\\t\\tchanges.type = {output: jsonType};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\timpossible = lineEntry.impossible || impossible;\\n\\t\\t}\\n\\t});\\n\\tif (changed) {\\n\\t\\tchanges.text = {};\\n\\t\\tif (tiddlerData) {\\n\\t\\t\\tvar text;\\n\\t\\t\\tif (type === jsonType) {\\n\\t\\t\\t\\ttext = JSON.stringify(tiddlerData, null, $tw.config.preferences.jsonSpaces);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttext = $tw.utils.makeTiddlerDictionary(tiddlerData);\\n\\t\\t\\t}\\n\\t\\t\\tchanges.text.output = text;\\n\\t\\t}\\n\\t\\tif (impossible) {\\n\\t\\t\\tchanges.text.impossible = true;\\n\\t\\t}\\n\\t}\\n};\\n\\nfunction forEachProperty(wiki, tiddler, callback) {\\n\\tvar title = tiddler.fields.title;\\n\\tvar slashPos = title.indexOf(\\\"/\\\", exports.prefix.length);\\n\\tif (slashPos >= 0) {\\n\\t\\tvar objectType = title.substring(exports.prefix.length, slashPos);\\n\\t\\tvar data = wiki.getTiddlerData(title);\\n\\t\\tutils.forEachPropertyIn(data, objectType, wiki, callback);\\n\\t}\\n};\\n\\nfunction isLegalDictionaryValue(text) {\\n\\treturn text.indexOf(\\\"\\\\n\\\") < 0;\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"relinkprefix\"},\"$:/plugins/flibbles/graph/relink/fieldedgeprefix.js\":{\"title\":\"$:/plugins/flibbles/graph/relink/fieldedgeprefix.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/relink/fieldedgeprefix.js\\ntype: application/javascript\\nmodule-type: relinkprefix\\n\\nTakes care of relinking all edge property files in the \\\"field\\\" category.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\n// We only use this module if relink-fieldnames is installed and active\\n// Otherewise we don't engage in renaming field edges.\\nif ($tw.wiki.getShadowSource(\\\"$:/plugins/flibbles/relink-fieldnames/utils.js\\\")) {\\n\\nexports.prefix = \\\"$:/config/flibbles/graph/edges/fields/\\\";\\n\\nvar utils = require(\\\"$:/plugins/flibbles/relink-fieldnames/utils.js\\\");\\n\\nexports.report = function(tiddler, callback, options) {\\n\\tvar field = tiddler.fields.title.substr(exports.prefix.length);\\n\\tif (!utils.isReserved(field, options)) {\\n\\t\\tcallback(field, \\\"#graph field edgetype: \\\" + field);\\n\\t}\\n};\\n\\nexports.relink = function(tiddler, fromTitle, toTitle, changes, options) {\\n\\tvar field = tiddler.fields.title.substr(exports.prefix.length);\\n\\tif (field === fromTitle && !utils.isReserved(field, options)) {\\n\\t\\tif (utils.isReserved(toTitle, options)\\n\\t\\t|| options.wiki.tiddlerExists(exports.prefix + toTitle)) {\\n\\t\\t\\tchanges.title = {impossible: true};\\n\\t\\t} else {\\n\\t\\t\\tchanges.title = {output: exports.prefix + toTitle};\\n\\t\\t}\\n\\t}\\n};\\n\\n}\\n\",\"type\":\"application/javascript\",\"module-type\":\"relinkprefix\"},\"$:/config/flibbles/relink/fields/filter\":{\"title\":\"$:/config/flibbles/relink/fields/filter\",\"text\":\"filter\"},\"$:/config/flibbles/relink/fields/template\":{\"title\":\"$:/config/flibbles/relink/fields/template\",\"text\":\"title\"},\"$:/config/flibbles/relink/fields/edges.fields\":{\"title\":\"$:/config/flibbles/relink/fields/edges.fields\",\"text\":\"filter\"},\"$:/config/flibbles/relink/fields/edges.functions\":{\"title\":\"$:/config/flibbles/relink/fields/edges.functions\",\"text\":\"filter\"},\"$:/plugins/flibbles/graph/relink/graphprefix.js\":{\"title\":\"$:/plugins/flibbles/graph/relink/graphprefix.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/relink/graphprefix.js\\ntype: application/javascript\\nmodule-type: relinkprefix\\n\\nTakes care of relinking everything graphTiddler related.\\nSuch as the tiddlers in the $:/graph/ namespace.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.prefix = \\\"$:/graph/\\\";\\n\\nvar utils = require(\\\"./utils.js\\\");\\nvar tag = \\\"$:/tags/flibbles/graph/TiddlerData\\\";\\n\\nexports.report = function(tiddler, callback, options) {\\n\\tif (!tiddler.hasTag(tag)) {\\n\\t\\treturn utils.reportTiddlerData(tiddler, callback, options);\\n\\t}\\n};\\n\\nexports.relink = function(tiddler, fromTitle, toTitle, changes, options) {\\n\\tif (!tiddler.hasTag(tag)) {\\n\\t\\treturn utils.relinkTiddlerData(tiddler, fromTitle, toTitle, changes, options);\\n\\t}\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"relinkprefix\"},\"$:/config/flibbles/relink/operators/gettyped\":{\"title\":\"$:/config/flibbles/relink/operators/gettyped\",\"text\":\"fieldname\"},\"$:/plugins/flibbles/graph/relink/propertyfields.js\":{\"title\":\"$:/plugins/flibbles/graph/relink/propertyfields.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/relink/propertyfields.js\\ntype: application/javascript\\nmodule-type: relinkoperator\\n\\nTakes care of relinking graph.* properties across all tiddlers.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"graph fields\\\";\\n\\nvar utils = require(\\\"./utils.js\\\");\\nvar fieldPrefix = \\\"graph.\\\";\\nvar tag = \\\"$:/tags/flibbles/graph/TiddlerData\\\";\\n\\nexports.report = function(tiddler, callback, options) {\\n\\tif (tiddler.hasTag(tag)) {\\n\\t\\tutils.reportTiddlerData(tiddler, callback, options);\\n\\t}\\n\\tfor (var field in tiddler.fields) {\\n\\t\\tif ($tw.utils.startsWith(field, fieldPrefix)) {\\n\\t\\t\\tvar type = field.substr(fieldPrefix.length);\\n\\t\\t\\tvar data;\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = JSON.parse(tiddler.fields[field]);\\n\\t\\t\\t} catch {}\\n\\t\\t\\tutils.forEachPropertyIn(data, type, options.wiki, function(key, data, relinker) {\\n\\t\\t\\t\\trelinker.report(data[key], function(title, blurb, info) {\\n\\t\\t\\t\\t\\tvar prefix = \\\"#\\\" + type + \\\" - \\\" + key;\\n\\t\\t\\t\\t\\tif (blurb) {\\n\\t\\t\\t\\t\\t\\tprefix += \\\": \\\" + blurb;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcallback(title, prefix, info);\\n\\t\\t\\t\\t}, options);\\n\\t\\t\\t});\\n\\t\\t}\\n\\t}\\n};\\n\\nexports.relink = function(tiddler, fromTitle, toTitle, changes, options) {\\n\\tif (tiddler.hasTag(tag)) {\\n\\t\\tutils.relinkTiddlerData(tiddler, fromTitle, toTitle, changes, options);\\n\\t}\\n\\tvar changedField = {};\\n\\tvar impossibleFields = {};\\n\\tfor (var field in tiddler.fields) {\\n\\t\\tif ($tw.utils.startsWith(field, fieldPrefix)) {\\n\\t\\t\\tvar fieldData = undefined,\\n\\t\\t\\t\\tchanged = false,\\n\\t\\t\\t\\timpossible = false;\\n\\t\\t\\tvar type = field.substr(fieldPrefix.length);\\n\\t\\t\\tvar data;\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = JSON.parse(tiddler.fields[field]);\\n\\t\\t\\t} catch {}\\n\\t\\t\\tutils.forEachPropertyIn(data, type, options.wiki, function(key, data, relinker) {\\n\\t\\t\\t\\tvar lineEntry = relinker.relink(data[key], fromTitle, toTitle, options);\\n\\t\\t\\t\\tif (lineEntry) {\\n\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t\\tif (lineEntry.output) {\\n\\t\\t\\t\\t\\t\\tdata[key] = lineEntry.output;\\n\\t\\t\\t\\t\\t\\tfieldData = data;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\timpossible = lineEntry.impossible || impossible;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\tif (changed) {\\n\\t\\t\\t\\tchanges[field] = {};\\n\\t\\t\\t\\tif (fieldData) {\\n\\t\\t\\t\\t\\tvar text = JSON.stringify(fieldData);\\n\\t\\t\\t\\t\\tchanges[field].output = text;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (impossible) {\\n\\t\\t\\t\\t\\tchanges[field].impossible = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"relinkoperator\"},\"$:/plugins/flibbles/graph/relink/utils.js\":{\"title\":\"$:/plugins/flibbles/graph/relink/utils.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/relink/utils.js\\ntype: application/javascript\\nmodule-type: library\\n\\nThese utilities only ever get loaded if Relink is installed.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar baseUtils = require(\\\"../utils.js\\\");\\nvar relinkUtils = require(\\\"$:/plugins/flibbles/relink/js/utils.js\\\");\\nvar PropertyTypes = $tw.modules.getModulesByTypeAsHashmap(\\\"graphpropertytype\\\");\\n\\nexports.forEachPropertyIn = function(data, objectType, wiki, callback) {\\n\\tif (data) {\\n\\t\\tvar engine = exports.getEngine(wiki);\\n\\t\\tif (engine) {\\n\\t\\t\\tvar properties = engine.prototype.properties[objectType];\\n\\t\\t\\tif (properties) {\\n\\t\\t\\t\\tfor (var key in data) {\\n\\t\\t\\t\\t\\tvar propertyInfo = properties[key];\\n\\t\\t\\t\\t\\tvar relinker = exports.getRelinker(propertyInfo);\\n\\t\\t\\t\\t\\tif (relinker) {\\n\\t\\t\\t\\t\\t\\tcallback(key, data, relinker);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nexports.getRelinker = function(propertyInfo) {\\n\\tvar relinker;\\n\\tif (propertyInfo) {\\n\\t\\tvar propertyClass = PropertyTypes[propertyInfo.type];\\n\\t\\tif (propertyClass && propertyClass.type) {\\n\\t\\t\\trelinker = relinkUtils.getType(propertyClass.type);\\n\\t\\t}\\n\\t}\\n\\treturn relinker;\\n};\\n\\nexports.getEngine = function(wiki) {\\n\\tvar value = $tw.macros.graphengine.get(wiki);\\n\\treturn baseUtils.getEngine(value);\\n};\\n\\nexports.reportTiddlerData = function(tiddler, callback, options) {\\n\\tvar data = options.wiki.getTiddlerDataCached(tiddler.fields.title, {});\\n\\tfor (var title in data) {\\n\\t\\tcallback(title, data[title], {soft: true});\\n\\t}\\n};\\n\\nexports.relinkTiddlerData = function(tiddler, fromTitle, toTitle, changes, options) {\\n\\tvar data = options.wiki.getTiddlerDataCached(tiddler.fields.title, {});\\n\\tif (data[fromTitle] !== undefined) {\\n\\t\\tvar newData = {};\\n\\t\\tfor (var title in data) {\\n\\t\\t\\tif (title === fromTitle) {\\n\\t\\t\\t\\tnewData[toTitle] = data[title];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnewData[title] = data[title];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar newText;\\n\\t\\tvar type = tiddler.fields.type;\\n\\t\\tif (type === \\\"application/x-tiddler-dictionary\\\") {\\n\\t\\t\\tif (isLegalDictionaryKey(toTitle)) {\\n\\t\\t\\t\\tnewText = $tw.utils.makeTiddlerDictionary(newData);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttype = \\\"application/json\\\";\\n\\t\\t\\t\\tchanges.type = {output: type};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (type === \\\"application/json\\\") {\\n\\t\\t\\tnewText = JSON.stringify(newData, null, $tw.config.preferences.jsonSpaces);\\n\\t\\t}\\n\\t\\tchanges.text = {output: newText};\\n\\t}\\n};\\n\\nfunction isLegalDictionaryKey(title) {\\n\\t// We make a microdictionary with the value and make sure we get back\\n\\t// a dictionary with the key pointing to an arbitrary x\\n\\tvar fields = $tw.utils.parseFields(title + \\\":x\\\");\\n\\tvar found = false;\\n\\tfor (var key in fields) {\\n\\t\\tif (found\\n\\t\\t|| key !== title\\n\\t\\t|| fields[key] !== \\\"x\\\") {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfound = true;\\n\\t}\\n\\treturn found;\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/flibbles/graph/settings\":{\"title\":\"$:/plugins/flibbles/graph/settings\",\"tags\":\"[[$:/tags/ControlPanel/SettingsTab]]\",\"caption\":\"Graph\",\"text\":\"\\\\procedure filterTab() [!has[filter]] ~[subfilter{!!filter}]\\n\\\\procedure settingsTabs() [[$:/tags/flibbles/graph/SettingsTab]tagging[]filter<filterTab>]\\n\\nSettings page for TW5-Graph. See the [ext[project website|https://flibbles.github.io/tw5-graph]] for complete documentation.\\n\\n<$transclude $variable=tabs\\n\\ttabsList=<<settingsTabs>>\\n\\tdefault={{{ [subfilter<settingsTabs>] }}}\\n\\texplicitState=\\\"$:/state/flibbles/graph/settings\\\" />\\n\"},\"$:/plugins/flibbles/graph/startup/messages.js\":{\"title\":\"$:/plugins/flibbles/graph/startup/messages.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/startup/messages.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nIntroduces some handling of custom messages that TW5-Graph needs.\\n\\nDO NOT USE \\\"tm-download-raw\\\"! It's flimsy, poorly tested, and exists only\\nbecause there is no other way to download a binary file in Tiddlywiki.\\n\\nAs soon as I find a better way to do it, I'm deleting this file.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"graph-messages\\\";\\nexports.before = [\\\"startup\\\"];\\nexports.synchronous = true;\\n\\nexports.startup = function() {\\n\\tvar CoreSaver = $tw.SaverHandler;\\n\\t$tw.SaverHandler = function() {\\n\\t\\tCoreSaver.apply(this, arguments);\\n\\t\\tif ($tw.browser) {\\n\\t\\t\\tvar self = this;\\n\\t\\t\\t$tw.rootWidget.addEventListener(\\\"tm-download-raw\\\", function(event) {\\n\\t\\t\\t\\treturn download(event, self);\\n\\t\\t\\t});\\n\\t\\t}\\n\\t}\\n\\t$tw.SaverHandler.prototype = CoreSaver.prototype;\\n};\\n\\nfunction download(event, saverHandler, variables) {\\n\\tvar title = event.param;\\n\\tvar wiki = event.widget.wiki;\\n\\tvar variables = event.paramObject;\\n\\tconst element = document.createElement(\\\"a\\\");\\n\\tvar data = wiki.getTiddlerText(title);\\n\\telement.setAttribute(\\\"download\\\", variables.filename);\\n\\telement.setAttribute(\\\"href\\\", \\\"data:\\\" + variables.type + \\\";base64,\\\" + data);\\n\\tvar click = new MouseEvent(\\\"click\\\");\\n\\telement.dispatchEvent(click);\\n\\treturn true;\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"startup\"},\"$:/plugins/flibbles/graph/stylesheets/base.css\":{\"title\":\"$:/plugins/flibbles/graph/stylesheets/base.css\",\"tags\":\"$:/tags/Stylesheet\",\"text\":\"\\\\define sidebarbreakpoint()\\n<$text text={{$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint}}/>\\n\\\\end\\n\\n\\\\rules only macrocallinline\\n.graph-canvas {\\n\\tposition: relative;\\n\\tborder-style: solid;\\n\\tborder-width: 1px;\\n\\tborder-color: <<colour graph-border>>;\\n\\tbackground-color: <<colour graph-background>>;\\n\\twidth: 100%;\\n}\\n\\n.boundingbox {\\n\\tdisplay: flex;\\n\\tflex-direction: column;\\n}\\n\\n.boundingbox > .graph-canvas {\\n\\twidth: 100%;\\n\\theight: 0%;\\n\\tflex-grow: 1;\\n}\\n\\n/*** Basic graph overlay options ***/\\n\\n.graph-overlay {\\n\\tposition: absolute;\\n\\tbottom: 0px;\\n\\tleft: 0px;\\n\\tmargin: 0px;\\n\\tbackground: transparent;\\n\\tborder-width: 0px;\\n}\\n\\n/*** Error-state graphs ***/\\n\\n.graph-canvas.graph-error {\\n\\talign-content: center;\\n\\ttext-align: center;\\n\\tfont-weight: bold;\\n\\tcolor: <<colour alert-highlight>>;\\n}\\n\\n.graph-canvas.graph-error span {\\n\\tdisplay: inline-block;\\n\\tmax-width: 80%;\\n\\tbackground: <<colour alert-background>>;\\n\\tpadding: 1em;\\n\\tborder: medium solid <<colour alert-border>>;\\n\\tborder-radius: 1em;\\n\\n}\\n\\n/*** SideBar ***/\\n\\n.tc-sidebar-scrollable .graph-sidebar-disabled {\\n\\tdisplay: none;\\n}\\n\\n.tc-sidebar-scrollable .graph-sidebar-enabled {\\n\\tposition: absolute;\\n}\\n\\n.graph-sidebar-banner {\\n\\tbackground: <<colour graph-banner-background>>;\\n\\tcolor: <<colour graph-banner-foreground>>;\\n\\tpadding: 4px;\\n}\\n\\n.graph-sidebar-banner select, .graph-sidebar-banner button {\\n\\theight: 28px;\\n\\tmin-width: 28px;\\n\\tmargin-left: 3px;\\n}\\n\\n@media (max-width: <<sidebarbreakpoint>>) {\\n\\t.tc-sidebar-scrollable .graph-sidebar-enabled {\\n\\t\\tdisplay: none;\\n\\t}\\n\\n\\t.tc-sidebar-scrollable .graph-sidebar-disabled {\\n\\t\\tdisplay: flex;\\n\\t}\\n\\n\\t.tc-sidebar-scrollable .graph-sidebar-disabled button {\\n\\t\\tmargin: auto;\\n\\t}\\n\\n\\t.tc-sidebar-scrollable .graph-sidebar-disabled button svg {\\n\\t\\twidth: 2em;\\n\\t\\theight: 2em;\\n\\t}\\n}\\n\\n/*** Sidebar Center button ***/\\n\\n.graph-center-button-dropdown {\\n\\tpadding-left: 6px;\\n\\tpadding-right: 6px;\\n}\\n\\n.graph-center-button-dropdown input {\\n\\twidth: 100%;\\n}\\n\\n/*** Engine toggle buttons ***/\\n\\n.graph-engine-button-list {\\n\\tdisplay: flex;\\n\\tjustify-content: center;\\n}\\n\\n.graph-engine-button {\\n\\tmargin: 1em;\\n\\twidth: 7em;\\n\\theight: 8em;\\n\\tborder-radius: 1em;\\n\\tvertical-align: top;\\n\\tfont-weight: bold;\\n\\ttext-align: center;\\n\\tbackground-color: <<colour background>>;\\n\\tborder-color: <<colour table-footer-background>>;\\n}\\n\\n.graph-engine-button .graph-icon {\\n\\theight: 6em;\\n\\talign-content: center;\\n}\\n\\n.graph-engine-button.active {\\n\\tbackground-color: <<colour table-header-background>>;\\n}\\n\\n.graph-engine-button:hover {\\n\\tbackground-color: <<colour table-header-background>>;\\n}\\n\\n/*** grouped-tabs ***/\\n\\n.group-tab-header {\\n\\tfont-weight: bold;\\n\\tmargin-right: 0.0em;\\n\\tmargin-top: 1em;\\n\\tborder: 1px solid <<color tab-border>>;\\n\\tpadding: 3px 5px 0px 5px;\\n\\tborder-top-left-radius: 1em;\\n}\\n\\n.tc-tab-buttons.tc-vertical button.group-tab-button {\\n\\tdisplay: flex;\\n\\tpadding-left: 0px;\\n}\\n\\nbutton.group-tab-button > svg {\\n\\tmargin-top: auto;\\n\\tmargin-bottom: auto;\\n}\\n\\nbutton.group-tab-button > span {\\n\\tmargin-left: 5px;\\n\\tflex-grow: 1;\\n}\\n\\n.tc-tab-buttons.tc-vertical button.group-tab-new {\\n\\tborder-bottom-left-radius: 1em;\\n\\tborder-bottom-right-radius: 1em;\\n\\tborder-right: 1px solid <<color tab-border>>;\\n}\\n\\nbutton.group-tab-new svg {\\n\\tdisplay: block;\\n\\tmargin-left: auto;\\n\\tmargin-right: auto;\\n}\\n\\n/*** Settings: Graphs ***/\\n\\n.graph-tiddlers-edgelist {\\n\\tcolor: <<colour muted-foreground>>;\\n}\\n\\n.graph-tiddlers-edgelist .active {\\n\\tcolor: <<colour foreground>>;\\n}\\n\\n/*** GraphTiddler Edit-template ***/\\n\\n.graph-tiddler-edit-template {\\n\\tborder-top: 1px solid <<colour blockquote-bar>>;\\n}\\n\\n.graph-tiddler-edit-template table,\\n.graph-tiddler-edit-template table textarea,\\n.graph-tiddler-edit-template table input {\\n\\twidth: 100%;\\n}\\n\\n/*** Graph Property Table ***/\\n\\ntable.graph-property {\\n\\twidth: 100%;\\n\\tpadding: 3px;\\n}\\n\\ntable .graph-property-input {\\n\\tmin-width: 8em;\\n\\tborder-right-width: 0px;\\n}\\n\\ntable .graph-property-remove {\\n\\twidth: 2em;\\n\\tborder-left-width: 0px;\\n}\\n\\n/*** Graph Property Table Types ***/\\n\\ntable.graph-property input {\\n\\twidth: 100%;\\n}\\n\\ntable.graph-property td {\\n\\tpadding: 4px;\\n}\\n\\n.graph-property-input-color input[type='color'] {\\n\\theight: 24px;\\n\\twidth: 100%;\\n}\\n\\ntable.graph-property .graph-property-input-number {\\n\\tdisplay: flex;\\n}\\n\\ntable.graph-property .graph-property-input-number input {\\n\\tflex-grow: 1;\\n}\\n\\ntable.graph-property .graph-property-input-number span {\\n\\tmargin-left: 5px;\\n\\tmin-width: 2em;\\n\\tvertical-align: top;\\n\\tfont-weight: lighter;\\n}\\n\\n/*** Graph icon ***/\\n\\n.graph-icon-node {\\n\\tfill: <<colour graph-node-color>> !important;\\n}\\n\\na.tc-tiddlylink.tc-plugin-info:hover .graph-icon-splash {\\n\\tfill: <<colour background>> !important;\\n}\\n\\na.tc-tiddlylink.tc-plugin-info:hover .graph-icon-node {\\n\\tfill: <<colour muted-foreground>> !important;\\n}\\n\"},\"$:/plugins/flibbles/graph/stylesheets/fullscreen/core.css\":{\"title\":\"$:/plugins/flibbles/graph/stylesheets/fullscreen/core.css\",\"text\":\"/* CSS tweaks for core elements when fullscreen is active.\\n   Make your own tiddler with $:/tags/flibbles/graph/FullscreenStylesheet\\n   to add your own tweaks. */\\n \\n.tc-topbar, .tc-story-river, .tc-sidebar-scrollable .graph-sidebar-disabled {\\n\\tdisplay: none !important;\\n}\\n\\n.tc-dropzone > p {\\n\\tmargin: 0px;\\n}\\n\",\"tags\":\"$:/tags/flibbles/graph/FullscreenStylesheet\",\"type\":\"text/css\"},\"$:/plugins/flibbles/graph/stylesheets/fullscreen.css\":{\"title\":\"$:/plugins/flibbles/graph/stylesheets/fullscreen.css\",\"tags\":\"$:/tags/Stylesheet\",\"text\":\"<!--\\n\\tIf you need to tweak css for whenever fullscreen mode is active,\\n\\tcreate a tiddler with the $:/tags/flibbles/graph/FullscreenStylesheet\\n\\ttag rather than trying to test against the fullscreen state tiddler.\\n-->\\n\\n.graph-sidebar-enabled.graph-fullscreen {\\n\\tdisplay: flex !important;\\n\\tposition: fixed !important;\\n\\theight: 100% !important;\\n\\twidth: 100% !important;\\n\\ttop: 0 !important;\\n\\tleft: 0 !important;\\n\\t// This puts us one below the modal at 900, which should still overlap fullscreen.\\n\\tz-index: 899 !important;\\n}\\n\\n<%if [[$:/state/flibbles/graph/fullscreen]is[tiddler]] %>\\n\\n<$list filter=\\\"[all[shadows+tiddlers]tag[$:/tags/flibbles/graph/FullscreenStylesheet]!is[draft]]\\\">\\n<$transclude mode=\\\"block\\\"/>\\n</$list><%endif%>\\n\"},\"$:/plugins/flibbles/graph/stylesheets/popup.css\":{\"title\":\"$:/plugins/flibbles/graph/stylesheets/popup.css\",\"tags\":\"$:/tags/Stylesheet\",\"text\":\".graph-popup {\\n\\tposition: absolute;\\n\\tz-index: 1000;\\n\\tborder: 1px solid <<colour dropdown-border>>;\\n\\tcolor: <<colour foreground>>;\\n\\tfill: <<colour foreground>>;\\n\\tbackground-color: <<colour dropdown-background>>;\\n\\tpadding: 7px 0 7px 0;\\n\\tmargin: 4px 0 0 0;\\n\\ttext-shadow: none;\\n\\tline-height: 1.4;\\n\\toverflow: scroll;\\n\\toverscroll-behavior: contain;\\n}\\n\\n.graph-popup .tc-drop-down {\\n\\tmargin-left: 14px;\\n}\\n\\n.graph-popup button svg, .graph-popup a svg  {\\n\\tfill: <<colour foreground>>;\\n}\\n\\n.graph-popup button:disabled svg {\\n\\tfill: <<colour muted-foreground>>;\\n}\\n\\n.graph-popup button.tc-btn-invisible:hover svg {\\n\\tfill: <<colour background>>;\\n}\\n\\n.graph-popup .tc-drop-down-info {\\n\\tpadding-left: 14px;\\n}\\n\\n.graph-popup p {\\n\\tpadding: 0 14px 0 14px;\\n}\\n\\n.graph-popup a.tc-tiddlylink {\\n\\tcolor: <<colour tiddler-link-foreground>>;\\n}\\n\\n.graph-popup svg {\\n\\twidth: 1em;\\n\\theight: 1em;\\n}\\n\\n.graph-popup img {\\n\\twidth: 1em;\\n}\\n\\n.graph-popup .tc-tab-set .tc-tab-buttons button {\\n\\tdisplay: inline-block;\\n\\twidth: auto;\\n\\tmargin-bottom: 0px;\\n\\tborder-bottom-left-radius: 0;\\n\\tborder-bottom-right-radius: 0;\\n}\\n\\n.graph-popup .tc-prompt {\\n\\tpadding: 0 14px;\\n}\\n\\n.graph-popup .tc-chooser {\\n\\tborder: none;\\n}\\n\\n.graph-popup .tc-chooser .tc-swatches-horiz {\\n\\tfont-size: 0.4em;\\n\\tpadding-left: 1.2em;\\n}\\n\\n.graph-popup .tc-file-input-wrapper {\\n\\twidth: 100%;\\n}\\n\\n.graph-popup .tc-file-input-wrapper button {\\n\\tcolor: <<colour foreground>>;\\n}\\n\\n.graph-popup a:hover, .graph-popup button:hover, .graph-popup .tc-file-input-wrapper:hover button {\\n\\tcolor: <<colour tiddler-link-background>>;\\n\\tbackground-color: <<colour tiddler-link-foreground>>;\\n\\ttext-decoration: none;\\n}\\n\\n.graph-popup .tc-tab-buttons button {\\n\\tbackground-color: <<colour dropdown-tab-background>>;\\n}\\n\\n.graph-popup .tc-tab-buttons button.tc-tab-selected {\\n\\tbackground-color: <<colour dropdown-tab-background-selected>>;\\n\\tborder-bottom: 1px solid <<colour dropdown-tab-background-selected>>;\\n}\\n\\n.graph-popup .tc-drop-down-bullet {\\n\\tdisplay: inline-block;\\n\\twidth: 0.5em;\\n}\\n\\n.graph-popup .tc-tab-contents a {\\n\\tpadding: 0 0.5em 0 0.5em;\\n}\\n\"},\"$:/plugins/flibbles/graph/subfilters\":{\"title\":\"$:/plugins/flibbles/graph/subfilters\",\"type\":\"application/x-tiddler-dictionary\",\"text\":\"# This tiddler contains a series of commonly used filters used by TW5-Graph. Putting them together in one dataTiddler like this helps optimize the :cache mechanism so this information only needs to be sought once. And it reduces repetition.\\n\\n# Do not override this tiddler\\n\\nedgetypes: :cache[all[shadows+tiddlers]removeprefix[$:/config/flibbles/graph/edges/]]\\nedgetypes.fields: :cache[subfilter{$:/plugins/flibbles/graph/subfilters##edgetypes}removeprefix[fields/]]\\nedgetypes.functions: :cache[subfilter{$:/plugins/flibbles/graph/subfilters##edgetypes}removeprefix[functions/]]\\n\"},\"$:/tags/flibbles/graph/GraphToolbar\":{\"title\":\"$:/tags/flibbles/graph/GraphToolbar\",\"list\":\"[[$:/plugins/flibbles/graph/ui/Buttons/settings]] [[$:/plugins/flibbles/graph/ui/Buttons/fullscreen]]\"},\"$:/tags/flibbles/graph/SettingsTab\":{\"title\":\"$:/tags/flibbles/graph/SettingsTab\",\"list\":\"[[$:/plugins/flibbles/graph/ui/Settings/Engine]] [[$:/plugins/flibbles/graph/ui/Settings/Graphs]]\"},\"$:/tags/flibbles/graph/Template\":{\"title\":\"$:/tags/flibbles/graph/Template\",\"list\":\"[[$:/plugins/flibbles/graph/templates/standard-graph]]\"},\"$:/tags/flibbles/graph/EditTemplate\":{\"title\":\"$:/tags/flibbles/graph/EditTemplate\",\"list\":\"[[$:/plugins/flibbles/graph/ui/EditTemplate/Nodes]] [[$:/plugins/flibbles/graph/ui/EditTemplate/Edges]]\"},\"$:/plugins/flibbles/graph/templates/live-graph\":{\"title\":\"$:/plugins/flibbles/graph/templates/live-graph\",\"caption\":\"Live graph\",\"tags\":\"$:/tags/flibbles/graph/Template\",\"text\":\"\\\\whitespace trim\\n\\n<!-- By having this unused \\\"focusTiddler\\\" value update when the nodes change,\\n     we can enforce a refresh of the live-graph, rather than having it try\\n     to update, which might result in a worse presentation for some engines. -->\\n\\n<$set name=\\\"focusTiddler\\\" filter=\\\"[subfilter{!!filter}]\\\">\\n\\n<$graph>\\n\\n<$properties $for=nodes actions=\\\"<$action-navigate $to=<<nodeTiddler>> />\\\" >\\n\\n<$properties.settings>\\n\\n<$properties physics=no>\\n\\n<$slot $name=ts-raw $depth=5 />\\n\\n<$list filter={{!!filter}} >\\n\\n<$node.default />\\n\\n<$edges.typed />\\n\\n</$list>\\n</$properties>\\n</$properties.settings>\\n</$properties>\\n</$graph>\\n</$set>\\n\"},\"$:/plugins/flibbles/graph/templates/standard-graph\":{\"title\":\"$:/plugins/flibbles/graph/templates/standard-graph\",\"caption\":\"Standard editable graph\",\"tags\":\"$:/tags/flibbles/graph/Template\",\"text\":\"\\\\whitespace trim\\n\\n<$graph>\\n\\n<%if [{!!filter}is[blank]] %>\\n\\n<$node $tiddler=\\\"$:/plugins/flibbles/graph/settings\\\"\\n  label=\\\"Click on me to configure this graph\\\"\\n  image=\\\"$:/core/images/options-button\\\"\\n  actions=\\\"\\\"\\\"<$action-setfield $tiddler=\\\"$:/state/flibbles/graph/settings\\\" text=\\\"$:/plugins/flibbles/graph/ui/Settings/Graphs\\\" /><$action-setfield $tiddler=\\\"$:/state/flibbles/graph/settings/graphs\\\" text=<<currentTiddler>> />\\\"\\\"\\\" />\\n\\n<%endif%>\\n\\n<$properties physics=yes actions=\\\"<$action-navigate $to=<<nodeTiddler>> />\\\">\\n\\n<$properties $filter=\\\"[all[]] :filter[<..currentTiddler>getindex{!!title}]\\\" physics=no>\\n\\n<$properties.persistent $dataTiddler=<<currentTiddler>> >\\n\\n<$properties.settings>\\n\\n<$slot $name=ts-raw $depth=6 />\\n\\n<$nodes.writable $field=filter>\\n\\n<$node.default/>\\n\\n<$edges.typed $editable=yes />\\n\\n</$nodes.writable>\\n</$properties.settings>\\n</$properties.persistent>\\n</$properties>\\n</$properties>\\n</$graph>\\n\"},\"$:/plugins/flibbles/graph/ui/Buttons/center\":{\"description\":\"Center on a graph node\",\"caption\":\"{{$:/core/images/advanced-search-button}} center node\",\"first-search-filter\":\"[subfilter{!!filter}search:title{$:/temp/graph/select}sort[title]limit[10]]\",\"text\":\"\\\\whitespace trim\\n\\n<%if [[graphengine]modules[]] :filter[moduleproperty[name]match<graphengine>] +[moduleproperty[messages]jsonextract[graph-center-node]] %>\\n  <$vars state=<<qualify \\\"$:/state/flibbles/graph/popup/center\\\">> >\\n    <$button\\n        popup=<<state>>\\n        tooltip=\\\"Center on a graph node\\\"\\n        class=graph-center-button>\\n      <%if [<tv-config-toolbar-icons>match[yes]] %>\\n        {{$:/core/images/advanced-search-button}}\\n      <%endif%>\\n      <%if [<tv-config-toolbar-text>match[yes]] %>\\n        <span class=\\\"tc-btn-text\\\">\\n          <$text text=\\\"center node\\\" />\\n        </span>\\n      <%endif%>\\n    </$button>\\n    <$reveal state=<<state>> type=\\\"popup\\\" position=\\\"below\\\" animate=\\\"yes\\\">\\n      <div class=\\\"tc-drop-down graph-center-button-dropdown\\\">\\n        <$let tv-config-toolbar-icons=\\\"yes\\\" tv-config-toolbar-text=\\\"yes\\\" tv-config-toolbar-class=\\\"tc-btn-invisible\\\">\\n          <$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/selector\\\" configTiddler=\\\"$:/plugins/flibbles/graph/ui/Buttons/center\\\">\\n            <$fill $name=action>\\n              <$action-sendmessage $message=graph-center-node tiddler=<<selectedTiddler>> scale=\\\"1.5\\\" />\\n              <$action-deletetiddler $tiddler=<<state>> />\\n            </$fill>\\n            <$fill $name=cancel>\\n              <$action-deletetiddler $tiddler=<<state>> />\\n            </$fill>\\n          </$transclude>\\n        </$let>\\n      </div>\\n    </$reveal>\\n  </$vars>\\n<%endif%>\\n\",\"title\":\"$:/plugins/flibbles/graph/ui/Buttons/center\",\"tags\":\"$:/tags/flibbles/graph/GraphToolbar\"},\"$:/plugins/flibbles/graph/ui/Buttons/export\":{\"description\":\"Export graph\",\"caption\":\"{{$:/core/images/export-button}} export graph\",\"text\":\"\\\\whitespace trim\\n\\n<%if [[graphengine]modules[]] :filter[moduleproperty[name]match<graphengine>] +[moduleproperty[messages]jsonindexes[]prefix[graph-export-]] %>\\n  <$vars state=<<qualify \\\"$:/state/flibbles/graph/popup/export\\\">>\\n    imageStore=\\\"$:/temp/flibbles/graph/export\\\">\\n    <$button\\n        popup=<<state>>\\n        tooltip=\\\"Export graph as image\\\"\\n        class=graph-export-button>\\n      <%if [<tv-config-toolbar-icons>match[yes]] %>\\n        {{$:/core/images/export-button}}\\n      <%endif%>\\n      <%if [<tv-config-toolbar-text>match[yes]] %>\\n        <span class=\\\"tc-btn-text\\\">\\n          <$text text=\\\"export graph\\\" />\\n        </span>\\n      <%endif%>\\n    </$button>\\n    <$reveal state=<<state>> type=\\\"popup\\\" position=\\\"below\\\" animate=\\\"yes\\\">\\n      <div class=\\\"tc-drop-down graph-export-button-dropdown\\\">\\n        <$list variable=type filter=\\\"[[graphengine]modules[]] :filter[moduleproperty[name]match<graphengine>] +[moduleproperty[messages]jsonindexes[]removeprefix[graph-export-]]\\\">\\n          <$button class=`tc-btn-invisible graph-export-type-$(type)$`>\\n            <$action-sendmessage $message=`graph-export-$(type)$`\\n              targetTiddler=<<imageStore>> />\\n            <!-- We wrap our downloading inside action-createtiddler, because\\n                 create-tiddler delays refreshing its contents until its\\n                 invoked, which we need, since that `<%if` block depends on\\n                 content made by prior actions. -->\\n            <$action-createtiddler $basetitle=<<state>> $overwrite=yes>\\n              <%if [<imageStore>is[image]!type[image/svg+xml]] %>\\n                <!-- Don't use tm-download-raw yourself.\\n                     It's a hack. A workaround. A solution for chumps.\\n                     I'm scrapping it as soon as TW supports image downloads -->\\n                <$action-sendmessage $message=\\\"tm-download-raw\\\"\\n                  $param=<<imageStore>>\\n                  filename={{{[{!!title}removeprefix[$:/graph/]] ~[{!!title}]}}}\\n                  type={{{ [<imageStore>get[type]addsuffix[;base64]] }}} />\\n              <%else%>\\n                <$action-sendmessage $message=\\\"tm-download-file\\\"\\n                  $param=\\\"$:/core/templates/plain-text-tiddler\\\"\\n                  currentTiddler=<<imageStore>>\\n                  filename={{{[{!!title}removeprefix[$:/graph/]] ~[{!!title}]}}}\\n                  type={{{ [<imageStore>get[type]] }}} />\\n              <%endif%>\\n            </$action-createtiddler>\\n            <$action-deletetiddler $tiddler=<<imageStore>> />\\n            <$action-deletetiddler $tiddler=<<state>> />\\n            <$transclude $field=\\\"description\\\" $tiddler=`$:/language/Docs/Types/image/$(type)$`>\\n              <$fill $name=\\\"ts-missing\\\">\\n                <$transclude $field=\\\"description\\\" $tiddler={{{ [[$:/tags/Exporter]tagging[]] :filter[{!!title}get[extension]removeprefix[.]match<type>] }}} >\\n                  <$fill $name=\\\"ts-missing\\\">\\n                    <$text text=<<type>> />\\n                  </$fill>\\n                </$transclude>\\n              </$fill>\\n            </$transclude>\\n          </$button>\\n        </$list>\\n      </div>\\n    </$reveal>\\n  </$vars>\\n<%endif%>\\n\",\"title\":\"$:/plugins/flibbles/graph/ui/Buttons/export\",\"tags\":\"$:/tags/flibbles/graph/GraphToolbar\"},\"$:/plugins/flibbles/graph/ui/Buttons/fullscreen\":{\"description\":\"Toggle graph fullscreen mode\",\"caption\":\"{{$:/core/images/full-screen-button}} fullscreen\",\"text\":\"\\\\procedure fs-actions()\\n\\\\whitespace trim\\n<% if [<fs-state>is[tiddler]] %>\\n  <$action-deletetiddler $tiddler=<<fs-state>> />\\n<% else %>\\n  <$action-setfield $tiddler=<<fs-state>> text=graph-fullscreen />\\n<% endif %>\\n\\\\end\\n\\\\procedure fs-refocus()\\n\\\\whitespace trim\\n<!--Refocus on the fullscreen button so that hitting escape will still disable fullscreen mode -->\\n<$action-delay>\\n  <!--The delay is necessary, because you can't focus on an element that's currently hidden, and the graph may be hidden when this is called. -->\\n  <$action-sendmessage $message=\\\"tm-focus-selector\\\" $param=\\\".graph-fullscreen-button\\\"/>\\n\\\\end\\n\\n\\\\parameters (class:graph-fullscreen-button)\\n\\\\whitespace trim\\n\\n<$button\\n    tooltip=\\\"Toggle graph fullscreen mode\\\"\\n    class={{{ [<class>] +[join[ ]] }}}\\n    actions=\\\"<<fs-actions>><<fs-refocus>>\\\" >\\n  <%if [<tv-config-toolbar-icons>match[yes]] %>\\n    {{$:/core/images/full-screen-button}}\\n  <%endif%>\\n  <%if [<tv-config-toolbar-text>match[yes]] %>\\n    <span class=\\\"tc-btn-text\\\">\\n      <$text text=\\\"fullscreen\\\" />\\n    </span>\\n  <%endif%>\\n</$button>\\n\",\"title\":\"$:/plugins/flibbles/graph/ui/Buttons/fullscreen\",\"tags\":\"$:/tags/flibbles/graph/GraphToolbar\"},\"$:/plugins/flibbles/graph/ui/Buttons/settings\":{\"description\":\"Open graph settings\",\"caption\":\"{{$:/core/images/options-button}} settings\",\"text\":\"\\\\whitespace trim\\n<$button\\n    tooltip=\\\"Open graph settings\\\"\\n    class=\\\"graph-settings-button\\\"\\n    to=\\\"$:/plugins/flibbles/graph/settings\\\"\\n    actions=\\\"\\\"\\\"\\\\whitespace trim\\n    <<fs-kill>>\\n    <$action-setfield\\n      $tiddler=\\\"$:/state/flibbles/graph/settings\\\"\\n      text=\\\"$:/plugins/flibbles/graph/ui/Settings/Graphs\\\" />\\n    <$action-setfield\\n      $tiddler=\\\"$:/state/flibbles/graph/settings/graphs\\\"\\n      text={{{ [[$:/config/flibbles/graph/sidebar]get[text]else[$:/graph/Default]] }}} />\\\"\\\"\\\">\\n  <%if [<tv-config-toolbar-icons>match[yes]] %>\\n    {{$:/core/images/options-button}}\\n  <%endif%>\\n  <%if [<tv-config-toolbar-text>match[yes]] %>\\n    <span class=\\\"tc-btn-text\\\">\\n      <$text text=\\\"settings\\\" />\\n    </span>\\n  <%endif%>\\n</$button>\\n\",\"title\":\"$:/plugins/flibbles/graph/ui/Buttons/settings\",\"tags\":\"$:/tags/flibbles/graph/GraphToolbar\"},\"$:/plugins/flibbles/graph/ui/EditTemplate/Edges\":{\"caption\":\"Edge Types\",\"text\":\"\\\\procedure edgelist(category, default, customAllowed)\\n\\\\whitespace trim\\n<$vars fieldName=`edges.$(category)$` subfilterName=`edgetypes.$(category)$`>\\n  <$edit-text field=<<fieldName>> placeholder=<<default>> />\\n  <br>\\n  <span class=\\\"graph-tiddlers-edgelist\\\">\\n    <$vars masterFilter=\\\"[[$:/plugins/flibbles/graph/subfilters]getindex<subfilterName>] :map:flat[subfilter{!!title}sort[]]\\\"\\n           customFilter={{{ [{!!title}get<fieldName>!is[blank]else<default>]}}}>\\n      <$list filter=\\\"[<customAllowed>match[yes]] :map:flat[subfilter<masterFilter>subfilter<customFilter>] [subfilter<masterFilter>]\\\" join=\\\", \\\">\\n        <span class={{{ [subfilter<masterFilter>subfilter<customFilter>match{!!title}] :then[[active]] ~inactive }}}>\\n          <$text text={{!!title}} />\\n\\\\end\\n\\n\\\\whitespace trim\\n\\nDecide which of the preconfigured edge types will connect your nodes\\n\\n|tc-max-width tc-edit-max-width tc-table-no-border |k\\n|Fields |<<edgelist fields \\\"[all[]]\\\" yes>> |\\n|Functions |<<edgelist functions \\\"[all[]]\\\" no>> |\\n\",\"title\":\"$:/plugins/flibbles/graph/ui/EditTemplate/Edges\",\"tags\":\"$:/tags/flibbles/graph/EditTemplate\"},\"$:/plugins/flibbles/graph/ui/EditTemplate/Neighbors\":{\"caption\":\"Neighbors\",\"text\":\"\\\\whitespace trim\\n\\nYou can enable popups when hovering over a node.\\n\\n<!-- This uses 1 and 0 as values instead of yes and no, because someday, I\\n     may allow for deeper depth of neighbors. Those would use 2+ -->\\n\\n<!-- It sets two fields, `neighbors.incoming` and `neighbors.outgoing` for\\n     the same reason. Some day, we may configure those separately, and if so,\\n     this will be better for backward compatibility. -->\\n\\n<$checkbox field=\\\"neighbors.incoming\\\"\\n\\tchecked=1\\n\\tunchecked=0\\n\\tdefault=0\\n\\tcheckactions=\\\"\\\"\\\"<$action-setfield $field=\\\"neighbors.outgoing\\\" $value=1 />\\\"\\\"\\\"\\n\\tuncheckactions=\\\"\\\"\\\"<$action-setfield $field=\\\"neighbors.outgoing\\\" />\\\"\\\"\\\"\\n>\\n&#32;Enable neighbors\\n</$checkbox>\\n\\n<$reveal type=\\\"match\\\"\\n\\ttext=\\\"1\\\"\\n\\tstateTitle={{!!title}}\\n\\tstateField=\\\"neighbors.incoming\\\"\\n\\tretain=\\\"yes\\\"\\n\\tanimate=\\\"yes\\\">\\n\\n|tc-table-no-border |k\\n|Allowed neighbors |<$edit-text field=\\\"neighbors.whitelist\\\" placeholder=\\\"[!is[system]]\\\" /> |\\n|Edges between neighbors |<$checkbox field=\\\"neighbors.interedges\\\" checked=yes unchecked=no default=no /> |\\n\\n</$reveal>\\n\",\"title\":\"$:/plugins/flibbles/graph/ui/EditTemplate/Neighbors\",\"tags\":\"$:/tags/flibbles/graph/EditTemplate\"},\"$:/plugins/flibbles/graph/ui/EditTemplate/Nodes\":{\"caption\":\"Nodes filter\",\"text\":\"\\\\whitespace trim\\n\\nConfigure a filter describing what nodes this graph shows\\n\\n<$fieldtranscriber type=\\\"application/x-tiddler-filter\\\" field=filter>\\n\\n|tc-table-no-border |k\\n|Nodes |<$edit-text tiddler=<<state>> /> |\\n\\n</$fieldtranscriber>\\n\",\"title\":\"$:/plugins/flibbles/graph/ui/EditTemplate/Nodes\",\"tags\":\"$:/tags/flibbles/graph/EditTemplate\"},\"$:/plugins/flibbles/graph/ui/EditTemplate/Popups\":{\"caption\":\"Popups\",\"text\":\"\\\\whitespace trim\\n\\nYou can enable popups when hovering over a node.\\n\\n<$checkbox field=\\\"popup\\\"\\n\\tchecked=yes\\n\\tunchecked=no\\n\\tdefault=no>\\n&#32;Enable node popups\\n</$checkbox>\\n\\n<$reveal type=\\\"match\\\"\\n\\ttext=\\\"yes\\\"\\n\\tstateTitle={{!!title}}\\n\\tstateField=\\\"popup\\\"\\n\\tretain=\\\"yes\\\"\\n\\tanimate=\\\"yes\\\">\\n\\n|tc-table-no-border |k\\n|Popup maximum width |<$edit-text field=\\\"popup.width\\\" placeholder=\\\"300px\\\"/> |\\n|Popup maximum height |<$edit-text field=\\\"popup.height\\\" placeholder=\\\"200px\\\" /> |\\n\\n</$reveal>\\n\",\"title\":\"$:/plugins/flibbles/graph/ui/EditTemplate/Popups\",\"tags\":\"$:/tags/flibbles/graph/EditTemplate\"},\"$:/plugins/flibbles/graph/ui/EditTemplate/Properties\":{\"caption\":\"Graph Engine Defaults\",\"list-after\":\"\",\"text\":\"\\\\whitespace trim\\n\\n<$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/grouped-tabs\\\"\\n\\ttabsList=\\\"graph nodes edges\\\"\\n\\tdefault=graph\\n\\tclass=\\\"\\\"\\n\\tstate= \\\"$:/state/flibbles/graph/editTemplate/properties\\\">\\n\\n<$fill $name=body>\\n\\n<$fieldtranscriber\\n\\ttype=\\\"application/json\\\"\\n\\tfield=`graph.$(currentTab)$`>\\n\\n<$vars currentTiddler=<<state>>>\\n\\n<$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/ViewTemplate/properties\\\"\\n\\ttype=<<currentTab>> />\\n\",\"title\":\"$:/plugins/flibbles/graph/ui/EditTemplate/Properties\",\"tags\":\"$:/tags/flibbles/graph/EditTemplate\"},\"$:/plugins/flibbles/graph/ui/Modals/NewPropertySet\":{\"title\":\"$:/plugins/flibbles/graph/ui/Modals/NewPropertySet\",\"subtitle\":\"New Property Set\",\"footer\":\"{{$:/plugins/flibbles/graph/ui/Modals/Select!!footer}}\",\"mask-closable\":\"yes\",\"text\":\"<p class=\\\"tc-edit-field-add\\\">\\n\\n<em class=\\\"tc-edit tc-small-gap-right\\\">\\n\\n<$text text=\\\"Type in the name for a new set.\\\"/>\\n\\n</em></p>\\n\\n<$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/Modals/Select\\\">\\n\\n<$fill $name=list-item>\\n\\n<div class=\\\"tc-menu-list-item\\\">\\n\\n<$link overrideClass=\\\"tc-tiddlylink\\\" />\\n\"},\"$:/plugins/flibbles/graph/ui/Modals/NewGraph\":{\"title\":\"$:/plugins/flibbles/graph/ui/Modals/NewGraph\",\"subtitle\":\"New Graph\",\"footer\":\"{{$:/plugins/flibbles/graph/ui/Modals/Select!!footer}}\",\"mask-closable\":\"yes\",\"text\":\"<p class=\\\"tc-edit-field-add\\\">\\n\\n<em class=\\\"tc-edit tc-small-gap-right\\\">\\n\\n<$text text=\\\"Type in the name for a new graph.\\\"/>\\n\\n</em></p>\\n\\n<$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/Modals/Select\\\">\\n\\n<$fill $name=list-item>\\n\\n<div class=\\\"tc-menu-list-item\\\">\\n\\n<$link overrideClass=\\\"tc-tiddlylink\\\" />\\n\"},\"$:/plugins/flibbles/graph/ui/Modals/Select\":{\"title\":\"$:/plugins/flibbles/graph/ui/Modals/Select\",\"footer\":\"<$importvariables filter=\\\"[all[current]]\\\"><$button actions=<<select-accept-actions>> >Okay</$button> <$button actions=<<select-close-actions>>>Close</$button>\",\"text\":\"\\\\procedure select-accept-actions()\\n\\\\whitespace trim\\n<$action-sendmessage $message=\\\"tm-modal-finish\\\" $param={{$:/temp/graph/select/tiddler}} />\\n<$action-sendmessage $message=\\\"tm-close-tiddler\\\" />\\n<$action-deletetiddler $filter=\\\"[[$:/temp/graph/select]] [[$:/temp/graph/select/tiddler]] [[$:/temp/graph/select/selected-item]] [[$:/temp/graph/select/refresh]]\\\" />\\n\\\\end\\n\\n\\\\procedure select-click-actions()\\n<$action-setfield $tiddler=\\\"$:/temp/graph/select/tiddler\\\" text=<<navigateTo>> />\\n<<select-accept-actions>>\\n\\\\end\\n\\n\\\\procedure select-close-actions()\\n\\\\whitespace trim\\n<$action-sendmessage $message=\\\"tm-close-tiddler\\\" />\\n<$action-deletetiddler $filter=\\\"[[$:/temp/graph/select]] [[$:/temp/graph/select/tiddler]] [[$:/temp/graph/select/selected-item]] [[$:/temp/graph/select/refresh]]\\\" />\\n\\\\end\\n\\n\\\\procedure select-cancel-actions()\\n\\\\whitespace trim\\n<% if [{$:/temp/graph/select}match[]] %>\\n\\t<<select-close-actions>>\\n<% elseif [{$:/temp/graph/select}!match{$:/temp/graph/select/tiddler}] %>\\n\\t<$action-setfield $tiddler=\\\"$:/temp/graph/select/tiddler\\\" text={{$:/temp/graph/select}}/>\\n\\t<$action-deletetiddler $filter=\\\"$:/temp/graph/select/selected-item\\\" />\\n\\t<$action-setfield $tiddler=\\\"$:/temp/graph/select/refresh\\\" text=\\\"yes\\\"/>\\n<% else %>\\n\\t<$action-deletetiddler $filter=\\\"[[$:/temp/graph/select]] [[$:/temp/graph/select/tiddler]] [[$:/temp/graph/select/selected-item]] [[$:/temp/graph/select/refresh]]\\\" />\\n<% endif %>\\n\\\\end\\n\\n\\\\whitespace trim\\n\\n<div class=\\\"tc-edit-field-add-name-wrapper\\\">\\n\\n<$transclude\\n\\t$variable=\\\"keyboard-driven-input\\\"\\n\\tstoreTitle=\\\"$:/temp/graph/select\\\"\\n\\ttiddler=\\\"$:/temp/graph/select/tiddler\\\"\\n\\trefreshTitle=\\\"$:/temp/graph/select/refresh\\\"\\n\\tselectionStateTitle=\\\"$:/temp/graph/select/selected-item\\\"\\n\\tconfigTiddlerFilter=\\\"[all[current]]\\\"\\n\\ttag=\\\"input\\\"\\n\\tplaceholder=\\\"Type something\\\"\\n\\tclass=\\\"tc-edit-texteditor graph-select\\\"\\n\\tfocus=yes\\n\\tinputCancelActions=<<select-cancel-actions>>\\n\\tinputAcceptActions=<<select-accept-actions>>\\n\\t$mode=inline\\n/>\\n\\n<p>\\n\\n<$linkcatcher actions=<<select-click-actions>> >\\n\\n<$list filter={{!!first-search-filter}} >\\n\\n<$list-empty>\\n\\n<$text text=\\\"New result\\\" />\\n\\n</$list-empty>\\n<$list-template>\\n\\n<span class={{{[{$:/temp/graph/select/tiddler}match<currentTiddler>then[tc-list-item-selected]] }}}>\\n\\n<$slot $name=list-item>\\n\\n<$transclude tiddler=\\\"$:/core/ui/ListItemTemplate\\\" mode=inline/>\\n\"},\"$:/plugins/flibbles/graph/ui/Modals/SelectField\":{\"title\":\"$:/plugins/flibbles/graph/ui/Modals/SelectField\",\"subtitle\":\"Select field\",\"first-search-filter\":\"[subfilter{$:/plugins/flibbles/graph/subfilters##edgetypes.fields}search:title{$:/temp/graph/select}sort[title]limit[10]]\",\"footer\":\"{{$:/plugins/flibbles/graph/ui/Modals/Select!!footer}}\",\"mask-closable\":\"yes\",\"text\":\"<p class=\\\"tc-edit-field-add\\\">\\n\\n<em class=\\\"tc-edit tc-small-gap-right\\\">\\n\\n<$text text=\\\"Select an existing field, or type in the name for a new one.\\\"/>\\n\\n</em></p>\\n\\n<$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/Modals/Select\\\">\\n\\n<$fill $name=list-item>\\n\\n<div class=\\\"tc-menu-list-item\\\">\\n\\n<$link overrideClass=\\\"tc-tiddlylink\\\" />\\n\"},\"$:/plugins/flibbles/graph/ui/Modals/SelectTiddler\":{\"title\":\"$:/plugins/flibbles/graph/ui/Modals/SelectTiddler\",\"subtitle\":\"Select tiddler\",\"first-search-filter\":\"[!is[system]!is[draft]search:title{$:/temp/graph/select}sort[title]limit[10]]\",\"footer\":\"{{$:/plugins/flibbles/graph/ui/Modals/Select!!footer}}\",\"mask-closable\":\"yes\",\"text\":\"<p class=\\\"tc-edit-field-add\\\">\\n\\n<em class=\\\"tc-edit tc-small-gap-right\\\">\\n\\n<$text text=\\\"Select an existing tiddler, or type in the name for a new one.\\\"/>\\n\\n</em></p>\\n\\n<$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/Modals/Select\\\" />\\n\"},\"$:/plugins/flibbles/graph/ui/PropertyTypes/boolean\":{\"title\":\"$:/plugins/flibbles/graph/ui/PropertyTypes/boolean\",\"text\":\"\\\\whitespace trim\\n\\n<$checkbox index=<<property>>\\n\\tchecked=yes\\n\\tunchecked=no\\n\\tdefault={{{ [<jsonEntry>jsonget[default]match[true]then[yes]else[no]] }}}\\n/>\\n&#32;\\n<$text text={{{ [<jsonEntry>jsonget[label]] }}} />\\n\"},\"$:/plugins/flibbles/graph/ui/PropertyTypes/color\":{\"title\":\"$:/plugins/flibbles/graph/ui/PropertyTypes/color\",\"text\":\"\\\\whitespace trim\\n\\n<$edit-text class=\\\"tc-edit-texteditor tc-edit-fieldeditor\\\" tag=input index=<<property>> type=color />\\n\"},\"$:/plugins/flibbles/graph/ui/PropertyTypes/enum\":{\"title\":\"$:/plugins/flibbles/graph/ui/PropertyTypes/enum\",\"text\":\"\\\\whitespace trim\\n\\n<$select index=<<property>> default={{{ [<jsonEntry>jsonget[default]] }}} >\\n  <$list variable=enum filter=\\\"[<jsonEntry>jsonget[values]]\\\">\\n    <option value=<<enum>> >\\n      <$text text=<<enum>> />\\n    </option>\\n  </$list>\\n</$select>\\n\"},\"$:/plugins/flibbles/graph/ui/PropertyTypes/number\":{\"title\":\"$:/plugins/flibbles/graph/ui/PropertyTypes/number\",\"text\":\"\\\\whitespace trim\\n\\n<$let\\n\\tincrement={{{ [<jsonEntry>jsonget[increment]else[1]] }}}\\n\\tdefault={{{ [<jsonEntry>jsonget[default]else[0]] }}}\\n\\tmin={{{ [<jsonEntry>jsonget[min]] ~[<increment>multiply[-25]add<default>] }}}\\n\\tmax={{{ [<jsonEntry>jsonget[max]] ~[<increment>multiply[50]add<min>] }}}\\n>\\n<$range index=<<property>>\\n\\tmin=<<min>>\\n\\tmax=<<max>>\\n\\tincrement=<<increment>>\\n\\tdefault=<<default>>\\n/>\\n<span><$text text={{{ [{!!title}getindex<property>else<default>] }}} />\\n\"},\"$:/plugins/flibbles/graph/ui/Settings/Engine\":{\"title\":\"$:/plugins/flibbles/graph/ui/Settings/Engine\",\"filter\":\"[[graphengine]modules[]count[]compare:number:gt[1]]\",\"tags\":\"$:/tags/flibbles/graph/SettingsTab\",\"caption\":\"Engine\",\"text\":\"\\\\parameters (prompt: \\\"Select a default engine for your TiddlyWiki to use.\\\")\\n\\n<$transclude $variable=prompt />\\n\\n<div class=graph-engine-button-list>\\n\\n<$list filter=\\\"[[graphengine]modules[]]\\\">\\n\\n<$let name={{{ [all[current]moduleproperty[name]] }}} >\\n\\n<$button class=graph-engine-button selectedClass=active set=\\\"$:/config/flibbles/graph/engine\\\" setTo=<<name>> >\\n\\n<div class=graph-icon>\\n\\n<$transclude $tiddler={{{ [all[current]shadowsource[]addsuffix[/icon]is[shadow]] }}} />\\n\\n</div>\\n<$text text=<<name>> />\\n\"},\"$:/plugins/flibbles/graph/ui/Settings/Graphs/EditTemplate\":{\"title\":\"$:/plugins/flibbles/graph/ui/Settings/Graphs/EditTemplate\",\"text\":\"\\\\procedure templateSelector()\\n\\\\whitespace trim\\n<$select field=template default={{{ [[$:/tags/flibbles/graph/Template]tagging[]] }}} >\\n  <$list filter=\\\"[[$:/tags/flibbles/graph/Template]tagging[]]\\\">\\n    <option value={{!!title}}>\\n      <$view field=caption>\\n        <$view field=title />\\n      </$view>\\n    </option>\\n  </$list>\\n</$select>\\n\\\\end\\n\\n! <$link><$transclude field=caption><$text text={{{ [{!!title}removeprefix[$:/graph/]] }}} /></$transclude></$link>\\n\\nTemplate: <<templateSelector>>\\n\\n<$list variable=\\\"segment\\\" filter=\\\"[[$:/tags/flibbles/graph/EditTemplate]tagging[]]\\\">\\n\\n<div class=\\\"graph-tiddler-edit-template\\\">\\n\\n!! <$transclude $tiddler=<<segment>> $field=\\\"caption\\\"/>\\n\\n<$transclude $tiddler=<<segment>> />\\n\\n</div></$list>\\n\"},\"$:/plugins/flibbles/graph/ui/Settings/Graphs\":{\"title\":\"$:/plugins/flibbles/graph/ui/Settings/Graphs\",\"tags\":\"$:/tags/flibbles/graph/SettingsTab\",\"caption\":\"Graphs\",\"text\":\"\\\\whitespace trim\\n\\\\procedure graphList() :cache[all[shadows+tiddlers]insertafter{$:/config/flibbles/graph/sidebar}prefix[$:/graph/]else[$:/graph/Default]sort[]]\\n\\n<$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/grouped-tabs\\\"\\n\\ttabsList=<<graphList>>\\n\\tdefault={{{ [subfilter<graphList>] }}}\\n\\texplicitState=\\\"$:/state/flibbles/graph/settings/graphs\\\"\\n>\\n  <$fill $name=addButton>\\n    <$button class=\\\"group-tab-new\\\">\\n      {{$:/core/images/new-button}}\\n      <$action-modal $tiddler=\\\"$:/plugins/flibbles/graph/ui/Modals/NewGraph\\\">\\n        <$vars newTitle=`$:/graph/$(selection)$`>\\n          <$action-createtiddler $basetitle=<<newTitle>> type=\\\"application/json\\\" />\\n          <$action-setfield $tiddler=<<qualifiedState>> text=<<newTitle>> />\\n        </$vars>\\n      </$action-modal>\\n      <$action-sendmessage $message=tm-focus-selector $param=\\\"input.graph-select\\\" />\\n    </$button>\\n  </$fill>\\n  <$fill $name=button>\\n    <$view tiddler=<<currentTab>> field=caption>\\n      <$text text={{{ [<currentTab>removeprefix[$:/graph/]] }}} />\\n    </$view>\\n  </$fill>\\n  <$fill $name=body>\\n    <$let currentTiddler=<<currentTab>> >\\n      <$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/Settings/Graphs/EditTemplate\\\" $mode=block />\\n    </$let>\\n\\n    <$button>\\n\\n      <$vars graphName={{{ [<currentTab>removeprefix[$:/graph/]] }}}>\\n        <$action-confirm $message=`Are you sure you wish to delete '$(graphName)$'`>\\n          <%if [{$:/config/flibbles/graph/sidebar}match<currentTab>] %>\\n            <$action-deletetiddler $tiddler=\\\"$:/config/flibbles/graph/sidebar\\\"/>\\n          <%endif%>\\n          <$action-deletetiddler $tiddler=<<currentTab>>/>\\n        </$action-confirm>\\n      </$vars>\\n\\n      Delete Graph\\n    </$button>\\n  </$fill>\\n</$transclude>\\n\"},\"$:/plugins/flibbles/graph/ui/Settings/Properties/ObjectsTypeTemplate\":{\"title\":\"$:/plugins/flibbles/graph/ui/Settings/Properties/ObjectsTypeTemplate\",\"text\":\"\\\\define groupPrefix() $:/config/flibbles/graph/$(currentType)$/$(currentGroup)$/\\n\\\\whitespace trim\\n\\n<$let\\n\\tcurrentType=<<currentTab>>\\n\\tpresetPrefix=`$:/plugins/flibbles/graph/presettypes/$(currentType)$/`\\n\\tconfigPrefix=`$:/config/flibbles/graph/$(currentTab)$/`>\\n\\n\\n<$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/grouped-tabs\\\"\\n\\tgroupsList=\\\"[all[shadows+tiddlers]removeprefix<presetPrefix>]\\\"\\n\\ttabsList=\\\"[all[shadows+tiddlers]prefix<groupPrefix>]\\\"\\n\\tdefault={{{ [all[shadows+tiddlers]prefix[$:/graph/]else[$:/graph/core/Default]] }}}\\n\\tstate=`$:/state/flibbles/graph/settings/$(currentType)$`\\n\\torderFilter=\\\"[<currentGroup>addprefix<presetPrefix>get[orderable]match[yes]then<currentGroup>addprefix<configPrefix>]\\\"\\n>\\n  <$fill $name=addButton>\\n    <$button class=\\\"group-tab-new\\\">\\n      {{$:/core/images/new-button}}\\n      <$action-modal $tiddler=\\\"$:/plugins/flibbles/graph/ui/Modals/NewPropertySet\\\">\\n        <$vars newTitle=`$(groupPrefix)$$(selection)$`>\\n          <$action-createtiddler $basetitle=<<newTitle>> type=\\\"application/json\\\" />\\n          <$action-setfield $tiddler=<<tabsState>> text=<<newTitle>> />\\n        </$vars>\\n      </$action-modal>\\n      <$action-sendmessage $message=tm-focus-selector $param=\\\"input.graph-select\\\" />\\n    </$button>\\n  </$fill>\\n  <$fill $name=button>\\n    <$text text={{{ [<currentTab>removeprefix<groupPrefix>] }}} />\\n  </$fill>\\n  <$fill $name=body>\\n\\n<$let currentTiddler=<<currentTab>>\\n      currentCategory={{{ [all[current]removeprefix<configPrefix>split[/]nth[]] }}} >\\n\\n! <$link><$text text={{{ [all[current]removeprefix<configPrefix>removeprefix<currentCategory>removeprefix[/]] }}} /></$link>\\n\\n{{||$:/core/ui/ViewTemplate/body}}\\n</$let>\\n  </$fill>\\n</$transclude>\\n\"},\"$:/plugins/flibbles/graph/ui/Settings/Properties\":{\"title\":\"$:/plugins/flibbles/graph/ui/Settings/Properties\",\"tags\":\"$:/tags/flibbles/graph/SettingsTab\",\"caption\":\"Properties\",\"text\":\"\\\\function .tabs() :cache[all[shadows+tiddlers]removeprefix[$:/plugins/flibbles/graph/presettypes/]splitbefore[/]removesuffix[/]unique[]sort[]]\\n\\n<$parameters default=<<.tabs>> >\\n\\n<$transclude $variable=tabs\\n\\ttabsList=\\\"[function[.tabs]]\\\"\\n\\tdefault=<<default>>\\n\\tstate=\\\"$:/state/graph/settings/\\\"\\n\\ttemplate=\\\"$:/plugins/flibbles/graph/ui/Settings/Properties/ObjectsTypeTemplate\\\"\\n/>\\n\"},\"$:/plugins/flibbles/graph/ui/Settings/Toolbar\":{\"title\":\"$:/plugins/flibbles/graph/ui/Settings/Toolbar\",\"tags\":\"$:/tags/flibbles/graph/SettingsTab\",\"caption\":\"Toolbar\",\"text\":\"{{$:/plugins/flibbles/graph/ui/Toolbars/GraphToolbar}}\\n\"},\"$:/plugins/flibbles/graph/ui/SideBar\":{\"title\":\"$:/plugins/flibbles/graph/ui/SideBar\",\"caption\":\"Graph\",\"tags\":\"$:/tags/SideBar\",\"text\":\"\\\\procedure fs-state() $:/state/flibbles/graph/fullscreen\\n\\\\procedure fs-kill() <%if [<fs-state>is[tiddler]] %><$action-deletetiddler $tiddler=<<fs-state>> />\\n\\n\\\\whitespace trim\\n\\n\\\\parameters (state: \\\"$:/config/flibbles/graph/sidebar\\\", defaultGraph: \\\"$:/graph/Default\\\")\\n\\n\\\\function graph() [<state>get[text]else<defaultGraph>]\\n\\n<$keyboard key=\\\"escape\\\" actions=<<fs-kill>> >\\n\\n<div class=\\\"graph-sidebar-disabled graph-error tc-page-controls\\\">\\n\\n<!-- Sidebar only works in fullscreen during mobile mode.\\n     Otherwise, it's taking up too much space. -->\\n\\n  <$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/Buttons/fullscreen\\\" class=tc-btn-invisible $mode=inline />\\n\\n</div>\\n<$boundingbox\\n  class={{{ graph-sidebar-enabled [<fs-state>get[text]] +[join[ ]] }}}\\n  width=\\\"[<windowWidth>subtract<boundingLeft>subtract[15]addsuffix[px]]\\\"\\n  height=\\\"[<windowHeight>subtract<boundingTop>subtract[15]addsuffix[px]]\\\">\\n\\n  <$vars\\n      graph-sidebar=yes\\n      relayState=<<qualify graph-toolbar->> >\\n\\n    <$messagerelay to=<<relayState>> >\\n\\n      <div class=\\\"graph-sidebar-banner\\\">\\n\\n        <$slot $name=\\\"banner\\\">\\n\\n          <$select tiddler=<<state>> default=<<defaultGraph>> >\\n\\n            <$list filter=\\\"[<state>get[text]] [prefix[$:/graph/]else<defaultGraph>]\\\"  >\\n\\n              <option value=<<currentTiddler>> >\\n\\n                <$view field=caption>\\n\\n                  <$text text={{{ [{!!title}removeprefix[$:/graph/]] }}} />\\n\\n                </$view>\\n              </option>\\n            </$list>\\n          </$select>\\n          <$vars currentTiddler=<<graph>> >\\n\\n            <$list filter=\\\"[[$:/tags/flibbles/graph/GraphToolbar]tagging[]!is[draft]] :filter[{!!title}addprefix[$:/config/flibbles/graph/GraphToolbarButtons/Visibility/]!text[hide]]\\\" variable=listItem>\\n\\n              <$transclude tiddler=<<listItem>> mode=inline />\\n\\n            </$list>\\n          </$vars>\\n        </$slot>\\n      </div>\\n    </$messagerelay>\\n    <$linkcatcher actions=\\\"<%if [<fs-state>is[tiddler]] %><$action-sendmessage $message=tm-modal $param=<<navigateTo>> /><%else%><$action-navigate $to=<<navigateTo>> />\\\">\\n\\n      <$graph.view $tiddler=<<graph>> $mode=inline >\\n\\n        <$messagerelay name=<<relayState>> />\\n\\n      </$graph.view>\\n    </$linkcatcher>\\n  </$vars>\\n</$boundingbox>\\n\"},\"$:/plugins/flibbles/graph/ui/Toolbars/GraphToolbar\":{\"title\":\"$:/plugins/flibbles/graph/ui/Toolbars/GraphToolbar\",\"caption\":\"Graph Toolbar\",\"tags\":\"$:/tags/ControlPanel/Toolbars\",\"text\":\"\\\\procedure config-base() $:/config/flibbles/graph/GraphToolbarButtons/Visibility/\\n\\nChoose which buttons are displayed on the sidebar graph's toolbar. Drag and drop to change the ordering\\n\\nButtons may not show up anyway if the assigned graph engine does not support them.\\n\\n<$set name=\\\"tv-config-toolbar-icons\\\" value=\\\"yes\\\">\\n\\n<$set name=\\\"tv-config-toolbar-text\\\" value=\\\"yes\\\">\\n\\n<$macrocall $name=\\\"list-tagged-draggable\\\" tag=\\\"$:/tags/flibbles/graph/GraphToolbar\\\" itemTemplate=\\\"$:/core/ui/ControlPanel/Toolbars/ItemTemplate\\\"/>\\n\"},\"$:/plugins/flibbles/graph/ui/ViewTemplate/graph-object\":{\"title\":\"$:/plugins/flibbles/graph/ui/ViewTemplate/graph-object\",\"text\":\"\\\\whitespace trim\\n\\n<$let\\n\\tdescriptors={{{[all[current]removeprefix[$:/config/flibbles/graph/]]}}}\\n\\ttype={{{ [<descriptors>split[/]nth[1]] }}}\\n\\tcategory={{{ [<descriptors>split[/]nth[2]] }}} >\\n\\n<$transclude $tiddler=`$:/plugins/flibbles/graph/presettypes/$(type)$/$(category)$` />\\n\\n<$transclude $tiddler=\\\"$:/plugins/flibbles/graph/ui/ViewTemplate/properties\\\"\\n\\ttype={{{ [all[current]removeprefix[$:/config/flibbles/graph/]splitbefore[/]removesuffix[/]] }}} />\\n\"},\"$:/plugins/flibbles/graph/ui/ViewTemplate/graph\":{\"title\":\"$:/plugins/flibbles/graph/ui/ViewTemplate/graph\",\"text\":\"\\\\whitespace trim\\n\\n<$transclude $tiddler={{{ [{!!template}!is[blank]] ~[[$:/tags/flibbles/graph/Template]tagging[]] }}} >\\n\\n<$transclude tiddler=\\\"$:/language/MissingTiddler/Hint\\\"/>\\n\\n</$transclude>\\n\"},\"$:/plugins/flibbles/graph/ui/ViewTemplate/properties\":{\"title\":\"$:/plugins/flibbles/graph/ui/ViewTemplate/properties\",\"text\":\"\\\\procedure row(depth:0)\\n<$reveal tag=tr type=\\\"match\\\" state=<<dropdownStateTitle>> text=open default=<<default>> >\\n  <$let jsonEntry={{{ [<json>jsonextract<property>] }}}\\n        propertyType={{{ [<jsonEntry>jsonget[type]] }}} >\\n    <td class=graph-property-label>\\n      <$list filter=\\\"[range<depth>]\\\">&nbsp;&nbsp;</$list>\\n      <$text text=<<property>> />\\n    </td>\\n    <td class=`graph-property-input graph-property-input-$(propertyType)$`>\\n      <$transclude\\n        $tiddler=`$:/plugins/flibbles/graph/ui/PropertyTypes/$(propertyType)$`\\n        $mode=inline>\\n        <$edit-text tag=input index=<<property>> />\\n      </$transclude>\\n    </td>\\n    <td class=graph-property-remove>\\n      <%if [all[current]getindex<property>] %>\\n        <$button class=tc-btn-invisible tooltip=\\\"Unset this property\\\">\\n          <$action-setfield $index=<<property>> />\\n          <$transclude $tiddler=\\\"$:/core/images/delete-button\\\" $mode=inline />\\n        </$button>\\n      <%endif%>\\n    </td>\\n  </$let>\\n</$reveal>\\n<$list variable=property filter=\\\"[<json>jsonindexes[]] :filter[<json>jsonextract<currentTiddler>jsonget[parent]match<property>]\\\">\\n  <$transclude $variable=row depth={{{ [<depth>add[1]] }}} />\\n\\\\end\\n\\n\\\\procedure arrows(state, default)\\n\\\\whitespace trim\\n<$reveal type=\\\"nomatch\\\" state=<<state>> text=open default=<<default>> >\\n  <$button class=tc-btn-invisible>\\n    <$action-setfield $tiddler=<<state>> $value=open />\\n    {{$:/core/images/right-arrow}}\\n  </$button>\\n</$reveal>\\n<$reveal type=\\\"match\\\" state=<<state>> text=open default=<<default>> >\\n  <$button class=\\\"tc-btn-invisible\\\">\\n    <$action-setfield $tiddler=<<state>> $value=close  default=<<default>> />\\n    {{$:/core/images/down-arrow}}\\n  </$button>\\n</$reveal>\\n\\\\end\\n\\n\\\\procedure section(header, filter, default)\\n\\\\whitespace trim\\n<$qualify name=dropdownStateTitle title=`$:/state/dropdown/$(header)$`>\\n  <tr>\\n    <th colspan=3 align=left>\\n      <$transclude $variable=arrows state=<<dropdownStateTitle>> default=<<default>> />\\n      &#32;\\n      <<header>>\\n    </th>\\n  </tr>\\n  <$list variable=property filter=<<filter>> >\\n    <<row>>\\n\\\\end\\n\\n\\\\parameters (type)\\n\\\\whitespace trim\\n\\n<$list variable=json filter=\\\"[[graphengine]modules[]] :filter[moduleproperty[name]match<graphengine>] +[moduleproperty[properties]jsonextract<type>]\\\" >\\n\\n<table class=graph-property>\\n\\n<$transclude $variable=section $mode=inline\\n\\theader=Style\\n\\tdefault=open\\n\\tfilter=\\\"\\\"\\\"[<json>jsonindexes[]]\\n\\t\\t:filter[<json>jsonextract<currentTiddler>jsonget[type]!match[actions]]\\n\\t\\t:filter[<json>jsonextract<currentTiddler>jsonget[parent]count[]match[0]]\\n\\t\\t:filter[<json>jsonextract<currentTiddler>jsonget[hidden]else[false]!match[true]]\\\"\\\"\\\" />\\n\\n<$transclude $variable=section $mode=inline\\n\\theader=Actions\\n\\tdefault=closed\\n\\tfilter=\\\"[<json>jsonindexes[]] :filter[<json>jsonextract<currentTiddler>jsonget[type]match[actions]]\\\" />\\n\"},\"$:/plugins/flibbles/graph/ui/grouped-tabs\":{\"title\":\"$:/plugins/flibbles/graph/ui/grouped-tabs\",\"code-body\":\"yes\",\"text\":\"\\\\procedure grouped-tabs-button()\\n\\\\whitespace trim\\n<$button\\n  class=\\\"group-tab-button\\\"\\n  set=<<tabsState>>\\n  setTo=<<currentTab>>\\n  dragTiddler=<<currentTab>>\\n  default=<<default>>\\n  selectedClass=\\\"tc-tab-selected\\\"\\n  tooltip={{!!tooltip}}\\n  role=\\\"switch\\\"\\n  data-tab-title=<<currentTab>>\\n>\\n  <%if [<orderable>match[yes]] %>\\n    {{$:/plugins/flibbles/graph/images/drag}}\\n  <%endif%>\\n  <$tiddler tiddler=<<save-currentTiddler>>>\\n    <$vars tv-wikilinks=\\\"no\\\">\\n      <span>\\n        <$slot $name=button>\\n          <$transclude tiddler=<<currentTab>> field=\\\"caption\\\">\\n            <$macrocall $name=\\\"currentTab\\\" $type=\\\"text/plain\\\" $output=\\\"text/plain\\\"/>\\n          </$transclude>\\n        </$slot>\\n      </span>\\n    </$vars>\\n  </$tiddler>\\n</$button>\\n\\\\end\\n\\n\\\\define grouped-tabs-tab()\\n\\\\whitespace trim\\n<$set name=\\\"save-currentTiddler\\\" value=<<currentTiddler>>>\\n  <$tiddler tiddler=<<currentTab>>>\\n    <$transclude $variable=grouped-tabs-button $fillignore=yes />\\n  </$tiddler>\\n</$set>\\n\\\\end\\n\\n\\\\procedure grouped-tabs-tab-body()\\n\\\\whitespace trim\\n<$list filter=<<groupsList>> variable=\\\"currentGroup\\\">\\n  <$list filter=<<tabsList>> variable=\\\"currentTab\\\">\\n    <$reveal type=\\\"match\\\" state=<<tabsState>> text=<<currentTab>> default=<<default>> retain=<<retain>> tag=\\\"div\\\">\\n      <$slot $name=body />\\n    </$reveal>\\n  </$list>\\n</$list>\\n\\\\end\\n\\n\\\\function sort.by(tiddler) [<tiddler>each:list-item[list]is[tiddler]] =[all[]] +[unique[]]\\n\\n\\\\procedure grouped-tabs-drop-actions()\\n<$action-log\\n\\tactionTiddler=<<actionTiddler>>\\n\\tcurrentTab=<<currentTiddler>>\\n/>\\n<$action-listops\\n  $tiddler=<<orderTiddler>>\\n  $field=list\\n  $filter=\\\"[subfilter<tabsList>sort.by<orderTiddler>] +[insertbefore<actionTiddler>,<currentTab>]\\\"/>\\n\\\\end\\n\\n\\\\procedure grouped-tabs-tab-list()\\n\\\\whitespace trim\\n<$list variable=currentGroup filter=<<groupsList>> >\\n  <$let orderTiddler={{{ [<currentGroup>subfilter<orderFilter>] }}}\\n        orderable={{{ [<orderTiddler>!is[blank]then[yes]else[no]] }}} >\\n    <%if [<currentGroup>!is[blank]] %>\\n      <div class=\\\"group-tab-header\\\"><$text text={{{ [<currentGroup>titlecase[]] }}} /></div>\\n    <%endif%>\\n    <$list variable=currentTab filter=\\\"[subfilter<tabsList>sort.by<orderTiddler>]\\\" >\\n      <$droppable\\n          actions=<<grouped-tabs-drop-actions>>\\n          enable=<<orderable>> >\\n        <div class=\\\"tc-droppable-placeholder\\\"/>\\n        <$transclude $variable=grouped-tabs-tab $fillignore=yes/>\\n      </$droppable>\\n    </$list>\\n    <$tiddler tiddler=\\\"\\\">\\n      <$droppable\\n          actions=<<grouped-tabs-drop-actions>>\\n          enable=<<orderable>> >\\n        <div class=\\\"tc-droppable-placeholder\\\"/>\\n        <$slot $name=addButton />\\n      </$droppable>\\n    </$tiddler>\\n  </$let>\\n</$list>\\n\\\\end\\n\\n\\\\parameters (tabsList, groupsList:\\\"[[]]\\\", state:\\\"$:/state/flibbles/graph/grouped-tab\\\", explicitState, default, class:\\\"tc-vertical\\\", retain, orderFilter)\\n\\n<$qualify title=<<state>> name=qualifiedState>\\n  <$let tabsState={{{ [<explicitState>minlength[1]] ~[<qualifiedState>] }}}>\\n    <div class={{{ [[tc-tab-set]addsuffix[ ]addsuffix<class>] }}}>\\n      <div class={{{ [[tc-tab-buttons]addsuffix[ ]addsuffix<class>] }}}>\\n        <$transclude $variable=grouped-tabs-tab-list $fillignore=yes />\\n      </div>\\n      <div class={{{ [[tc-tab-divider]addsuffix[ ]addsuffix<class>] }}}/>\\n      <div class={{{ [[tc-tab-content]addsuffix[ ]addsuffix<class>] }}}>\\n        <$transclude $variable=grouped-tabs-tab-body $fillignore=yes />\\n      </div>\\n    </div>\\n  </$let>\\n</$qualify>\\n\"},\"$:/plugins/flibbles/graph/ui/selector\":{\"title\":\"$:/plugins/flibbles/graph/ui/selector\",\"code-body\":\"yes\",\"text\":\"\\\\whitespace trim\\n\\\\procedure select-accept-actions()\\n\\\\whitespace trim\\n<$vars selectedTiddler={{$:/temp/graph/select/tiddler}}>\\n<$slot $name=action />\\n<$action-deletetiddler $filter=\\\"[[$:/temp/graph/select]] [[$:/temp/graph/select/tiddler]] [[$:/temp/graph/select/selected-item]] [[$:/temp/graph/select/refresh]]\\\" />\\n</$vars>\\n\\\\end\\n\\n\\\\procedure select-click-actions()\\n<$messagecatcher $completed=\\\"\\\"\\\"<$transclude $variable=select-accept-actions $fillignore=yes />\\\"\\\"\\\" >\\n  <$action-setfield $tiddler=\\\"$:/temp/graph/select/tiddler\\\" text=<<navigateTo>> />\\n  <$action-sendmessage $message=completed />\\n\\\\end\\n\\n\\\\procedure select-close-actions()\\n\\\\whitespace trim\\n<$slot $name=cancel />\\n<$action-deletetiddler $filter=\\\"[[$:/temp/graph/select]] [[$:/temp/graph/select/tiddler]] [[$:/temp/graph/select/selected-item]] [[$:/temp/graph/select/refresh]]\\\" />\\n\\\\end\\n\\n\\\\procedure select-cancel-actions()\\n\\\\whitespace trim\\n<% if [{$:/temp/graph/select}match[]] %>\\n\\t<$transclude $variable=select-close-actions $fillignore=yes />\\n<% elseif [{$:/temp/graph/select}!match{$:/temp/graph/select/tiddler}] %>\\n\\t<$action-setfield $tiddler=\\\"$:/temp/graph/select/tiddler\\\" text={{$:/temp/graph/select}}/>\\n\\t<$action-deletetiddler $filter=\\\"$:/temp/graph/select/selected-item\\\" />\\n\\t<$action-setfield $tiddler=\\\"$:/temp/graph/select/refresh\\\" text=\\\"yes\\\"/>\\n<% else %>\\n\\t<$action-deletetiddler $filter=\\\"[[$:/temp/graph/select]] [[$:/temp/graph/select/tiddler]] [[$:/temp/graph/select/selected-item]] [[$:/temp/graph/select/refresh]]\\\" />\\n<% endif %>\\n\\\\end\\n\\n\\\\parameters (configTiddler)\\n\\n<$transclude\\n\\t$variable=keyboard-driven-input\\n\\t$fillignore=yes\\n\\t$mode=inline\\n\\tstoreTitle=\\\"$:/temp/graph/select\\\"\\n\\ttiddler=\\\"$:/temp/graph/select/tiddler\\\"\\n\\trefreshTitle=\\\"$:/temp/graph/select/refresh\\\"\\n\\tselectionStateTitle=\\\"$:/temp/graph/select/selected-item\\\"\\n\\tconfigTiddlerFilter=\\\"[<configTiddler>]\\\"\\n\\ttag=input\\n\\tplaceholder=\\\"Type something\\\"\\n\\tclass=\\\"tc-edit-texteditor graph-select\\\"\\n\\tfocus=yes\\n\\tinputCancelActions=<<select-cancel-actions>>\\n\\tinputAcceptActions=<<select-accept-actions>>\\n/>\\n\\n<p>\\n\\n<$linkcatcher actions=<<select-click-actions>> >\\n\\n<$list filter={{{ [<configTiddler>get[first-search-filter]] }}} >\\n\\n<$list-empty>\\n\\n<$text text=\\\"New result\\\" />\\n\\n</$list-empty>\\n<$list-template>\\n\\n<span class={{{[{$:/temp/graph/select/tiddler}match<currentTiddler>then[tc-list-item-selected]] }}}>\\n\\n<$slot $name=list-item>\\n\\n<$transclude tiddler=\\\"$:/core/ui/ListItemTemplate\\\" mode=inline/>\\n\"},\"$:/plugins/flibbles/graph/utils.js\":{\"title\":\"$:/plugins/flibbles/graph/utils.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/flibbles/graph/utils.js\\ntype: application/javascript\\nmodule-type: library\\n\\nUtility methods used by the graphing widgets.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar Engines = $tw.modules.createClassesFromModules(\\\"graphengine\\\");\\nvar PropertyTypes = $tw.modules.getModulesByTypeAsHashmap(\\\"graphpropertytype\\\");\\n\\n/*\\nReturns the window for flibbles/graph to use. I do this so that the testing\\nframework can mock it out on Node.JS.\\n*/\\nexports.window = function() { return window; };\\n\\nexports.getEngineMap = function() {\\n\\treturn Engines;\\n};\\n\\nexports.getEngine = function(name) {\\n\\tvar engineMap = exports.getEngineMap();\\n\\treturn engineMap[name] || null;\\n};\\n\\n/*\\nChecks if any property in an object needs to check for refresh, and returns\\ntrue if any do need to refresh.\\n*/\\nexports.refreshProperties = function(properties, widget, type, changedTiddlers) {\\n\\tvar engineName = widget.getVariable(\\\"graphengine\\\");\\n\\tvar engine = Engines[engineName];\\n\\tif (engine) {\\n\\t\\tvar propInfos = engine.prototype.properties[type];\\n\\t\\tif (propInfos) {\\n\\t\\t\\tfor (var name in properties) {\\n\\t\\t\\t\\tvar info = propInfos[name];\\n\\t\\t\\t\\tvar type = PropertyTypes[info && info.type];\\n\\t\\t\\t\\tif (type && type.refresh) {\\n\\t\\t\\t\\t\\tif (type.refresh(info, properties[name], changedTiddlers, widget)) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n};\\n\\n// Aren't we all eventually garbage?\\nvar eventualGarbage = [];\\nvar upkeepId;\\n\\n/*\\nRegister an object for destruction. It's ready to pass on once its\\nisGarbage method returns true;\\n*/\\nexports.registerForDestruction = function(object) {\\n\\tif (!upkeepId) {\\n\\t\\tupkeepId = setInterval(exports.upkeep, 5000);\\n\\t}\\n\\teventualGarbage.push(object);\\n};\\n\\nexports.upkeep = function() {\\n\\tvar i = eventualGarbage.length;\\n\\twhile (i > 0) {\\n\\t\\ti--;\\n\\t\\tvar object = eventualGarbage[i];\\n\\t\\tif (object.isGarbage()) {\\n\\t\\t\\teventualGarbage.splice(i, 1);\\n\\t\\t\\tobject.destroy();\\n\\t\\t}\\n\\t}\\n\\t// No managed objects. Let's shut down for now.\\n\\tif (eventualGarbage.length == 0) {\\n\\t\\tclearInterval(upkeepId);\\n\\t\\tupkeepId = null;\\n\\t}\\n};\\n\\nexports.getParentProperties = function(widget, type) {\\n\\t// For now, we hard-stop at the graph. We don't take properties outside\\n\\t// We may some day, but for now, support for that would be frought with\\n\\t// complications\\n\\twhile (widget.parentWidget && widget.graphObjectType !== \\\"graph\\\") {\\n\\t\\twidget = widget.parentWidget;\\n\\t\\tif (widget.graphPropertiesWidget && widget.type === type) {\\n\\t\\t\\treturn widget;\\n\\t\\t}\\n\\t};\\n\\treturn null;\\n};\\n\\nexports.WidgetIterator = function(root) {\\n\\tthis.stack = [];\\n\\tthis.ptr = root;\\n\\twhile (this.ptr.children && this.ptr.children.length > 0) {\\n\\t\\tthis.stack.push(0);\\n\\t\\tthis.ptr = this.ptr.children[0];\\n\\t}\\n};\\n\\nexports.WidgetIterator.prototype.next = function() {\\n\\tvar rtn, ptr = this.ptr;\\n\\tif (!ptr) {\\n\\t\\trtn = {done: true};\\n\\t} else {\\n\\t\\trtn = {value: ptr, done: false};\\n\\t\\tptr = ptr.parentWidget;\\n\\t\\tvar index = this.stack.pop();\\n\\t\\tif (index !== undefined) {\\n\\t\\t\\tindex++;\\n\\t\\t\\tif (ptr && ptr.children.length > index) {\\n\\t\\t\\t\\tptr = ptr.children[index];\\n\\t\\t\\t\\tthis.stack.push(index);\\n\\t\\t\\t\\t// Now dive to the lowest child\\n\\t\\t\\t\\twhile (ptr.children && ptr.children.length > 0) {\\n\\t\\t\\t\\t\\tthis.stack.push(0);\\n\\t\\t\\t\\t\\tptr = ptr.children[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tptr = null;\\n\\t\\t}\\n\\t}\\n\\tthis.ptr = ptr;\\n\\treturn rtn;\\n};\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/flibbles/graph/widgets/action-delay.js\":{\"text\":\"/*\\\\\\n\\nAction widget that introduces a delay before executing any nested actions it contains.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nvar DelayWidget = function(parseTreeNode, options) {\\n\\tthis.initialise(parseTreeNode, options);\\n};\\n\\nDelayWidget.prototype = new Widget();\\n\\nDelayWidget.prototype.render = function(parent, nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.renderChildren(parent, nextSibling);\\n};\\n\\nDelayWidget.prototype.execute = function() {\\n\\tthis.ms = this.getAttribute(\\\"$ms\\\", 0);\\n\\tthis.state = this.getAttribute(\\\"$state\\\");\\n\\tthis.makeChildWidgets();\\n};\\n\\nDelayWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\tif ($tw.utils.count(changedAttributes) > 0) {\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t}\\n\\treturn this.refreshChildren(changedTiddlers);\\n};\\n\\nvar counter = 0;\\n\\nDelayWidget.prototype.invokeAction = function(triggeringWidget, event) {\\n\\t// The id is used to make sure the later timed invocation corresponds\\n\\t// to this method call here.\\n\\tvar id = (counter++).toString();\\n\\tif (this.state) {\\n\\t\\tthis.wiki.addTiddler({title: this.state, text: id});\\n\\t}\\n\\treturn setTimeout(execute, this.ms, this, triggeringWidget, event, id);\\n};\\n\\nDelayWidget.prototype.allowActionPropagation = function() {\\n\\treturn false;\\n};\\n\\nfunction execute(delayWidget, triggeringWidget, event, id) {\\n\\tvar state = delayWidget.state;\\n\\tif (state) {\\n\\t\\tvar text = delayWidget.wiki.getTiddlerText(state);\\n\\t\\tif (text !== id) {\\n\\t\\t\\t// The state tiddler was touched by another action.\\n\\t\\t\\t// So we should not act. We're stale.\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t}\\n\\tdelayWidget.refreshChildren();\\n\\tdelayWidget.invokeActions(triggeringWidget, event);\\n\\tif (state) {\\n\\t\\tdelayWidget.wiki.deleteTiddler(state);\\n\\t}\\n};\\n\\nexports[\\\"action-delay\\\"] = DelayWidget;\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/action-delay.js\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/flibbles/graph/widgets/action-modal.js\":{\"text\":\"/*\\\\\\n\\nAction widget that creates a modal to select an existing tiddler, or specify a new one. After dialog is confirmed, it will execute any nested actions it contains.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\nvar utils = require(\\\"../utils.js\\\");\\n\\n/**\\n * This points to whatever action invoked the current modal. It assumes that\\n * only one modal is possible at a time. Probably a safe assumption.\\n */\\nvar primedWidget;\\n\\nvar ModalWidget = function(parseTreeNode, options) {\\n\\tthis.initialise(parseTreeNode, options);\\n};\\n\\nModalWidget.prototype = new Widget();\\n\\nModalWidget.prototype.render = function(parent, nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.renderChildren(parent, nextSibling);\\n};\\n\\nModalWidget.prototype.execute = function() {\\n\\tthis.modalTiddler = this.getAttribute(\\\"$tiddler\\\");\\n\\tthis.modal = $tw.modal;\\n\\tif (!this.modal || this.modal.wiki !== this.wiki) {\\n\\t\\t// Ah, we have a modal working with a subwiki (or a Node.JS system\\n\\t\\t// which has no modal). We'll create an overlay of the modal\\n\\t\\t// that works with our subwiki instead.\\n\\t\\tthis.modal = Object.create($tw.modal || null);\\n\\t\\tthis.modal.wiki = this.wiki;\\n\\t}\\n\\tthis.makeChildWidgets();\\n};\\n\\nModalWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\tif ($tw.utils.count(changedAttributes) > 0) {\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t}\\n\\treturn this.refreshChildren(changedTiddlers);\\n};\\n\\nModalWidget.prototype.invokeAction = function(triggeringWidget, event) {\\n\\tif (!$tw.rootWidget.eventListeners['tm-modal-finish']) {\\n\\t\\t$tw.rootWidget.addEventListener(\\\"tm-modal-finish\\\", function(finishEvent) {\\n\\t\\t\\tif (primedWidget) {\\n\\t\\t\\t\\tvar value = finishEvent.param;\\n\\t\\t\\t\\tprimedWidget.setVariable(\\\"selection\\\", value);\\n\\t\\t\\t\\tprimedWidget.refreshChildren();\\n\\t\\t\\t\\tprimedWidget.invokeActions(primedWidget, event);\\n\\t\\t\\t\\tprimedWidget = undefined;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\tprimedWidget = this;\\n\\tvar variables = Object.create(null);\\n\\tfor (var key in this.attributes) {\\n\\t\\tif (key.charAt(0) !== \\\"$\\\") {\\n\\t\\t\\tvariables[key] = this.attributes[key];\\n\\t\\t}\\n\\t}\\n\\tif (this.modalTiddler) {\\n\\t\\tvar self = this;\\n\\t\\t// We need to delay the assignment of click handlers for a few\\n\\t\\t// milliseconds. See Issue #43. If we don't, a click event might\\n\\t\\t// follow right after the \\\"make modal\\\" which closes the modal\\n\\t\\t// immediately.\\n\\t\\tdelayEventListenerAssignment(function() {\\n\\t\\t\\tself.modal.display(self.modalTiddler, {\\n\\t\\t\\t\\tvariables: variables,\\n\\t\\t\\t\\tevent: event});\\n\\t\\t});\\n\\t}\\n\\n};\\n\\nModalWidget.prototype.allowActionPropagation = function() {\\n\\treturn false;\\n};\\n\\nfunction delayEventListenerAssignment(method) {\\n\\tvar assignments = [];\\n\\t// We use this requested window instead of just accessing directly\\n\\t// so that the test framework can mock it up.\\n\\tvar window = utils.window();\\n\\tvar oldListener = window.EventTarget.prototype.addEventListener;\\n\\twindow.EventTarget.prototype.addEventListener = function(type) {\\n\\t\\tvar args = Array.prototype.slice.call(arguments);\\n\\t\\tif (type === \\\"click\\\") {\\n\\t\\t\\t// This is the click which might accidentally apply to the\\n\\t\\t\\t// backdrop if we're on mobile. Delay it.\\n\\t\\t\\tassignments.push({self: this, args: args});\\n\\t\\t} else {\\n\\t\\t\\t// Just call through. We don't care about this handler.\\n\\t\\t\\toldListener.apply(this, args);\\n\\t\\t}\\n\\t};\\n\\ttry {\\n\\t\\tmethod();\\n\\t} finally {\\n\\t\\twindow.EventTarget.prototype.addEventListener = oldListener;\\n\\t}\\n\\tsetTimeout(function() {\\n\\t\\tfor (var i = 0; i < assignments.length; i++) {\\n\\t\\t\\tvar set = assignments[i];\\n\\t\\t\\tset.self.addEventListener.apply(set.self, set.args);\\n\\t\\t}\\n\\t}, 10);\\n};\\n\\nexports[\\\"action-modal\\\"] = ModalWidget;\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/action-modal.js\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/flibbles/graph/widgets/action-typed.js\":{\"text\":\"/*\\\\\\n\\nCreates two action widgets for adding and removing from typed fields.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\nvar typeOperators = $tw.modules.getModulesByTypeAsHashmap(\\\"fieldtype\\\");\\nvar relinkPrefix = \\\"$:/config/flibbles/relink/fields/\\\" ;\\n\\nvar TypedWidget = new Widget();\\n\\nTypedWidget.render = function(parent, nextSibling) {\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n};\\n\\nTypedWidget.execute = function() {\\n\\tthis.actionTiddler = this.getAttribute(\\\"$tiddler\\\") || (!this.hasParseTreeNodeAttribute(\\\"$tiddler\\\") && this.getVariable(\\\"currentTiddler\\\"));\\n\\tthis.actionField = this.getAttribute(\\\"$field\\\");\\n\\tthis.actionValue = this.getAttribute(\\\"$value\\\");\\n\\tthis.actionTimestamp = this.getAttribute(\\\"$timestamp\\\",\\\"yes\\\") === \\\"yes\\\";\\n\\tthis.actionClean = this.getAttribute(\\\"$clean\\\",\\\"yes\\\") === \\\"yes\\\";\\n};\\n\\nTypedWidget.invokeAction = function(triggeringWidget, event) {\\n\\tvar tiddler = this.wiki.getTiddler(this.actionTiddler),\\n\\t\\thasChanged = false,\\n\\t\\toptions = {wiki: this.wiki, widget: this};\\n\\tif (this.actionTiddler && this.actionField) {\\n\\t\\toptions.suppressTimestamp = !this.actionTimestamp;\\n\\t\\tvar typeName = this.wiki.getTiddlerText(relinkPrefix + this.actionField, \\\"list\\\");\\n\\t\\tvar type = typeOperators[typeName];\\n\\t\\tif (type) {\\n\\t\\t\\tvar newValue = type[this.actionMethod](tiddler, this.actionField, this.actionValue, options);\\n\\t\\t\\tif (newValue !== undefined) {\\n\\t\\t\\t\\tif (newValue === \\\"\\\" && this.actionClean) {\\n\\t\\t\\t\\t\\tnewValue = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toptions.wiki.setText(this.actionTiddler, this.actionField, null, newValue, options);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n$tw.utils.each([\\\"add\\\", \\\"remove\\\"], function(method) {\\n\\tvar MethodWidget = function(parseTreeNode, options) {\\n\\t\\tthis.initialise(parseTreeNode, options);\\n\\t};\\n\\n\\tMethodWidget.prototype = Object.create(TypedWidget);\\n\\tMethodWidget.prototype.actionMethod = method;\\n\\texports[\\\"action-\\\" + method + \\\"typed\\\"] = MethodWidget;\\n});\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/action-typed.js\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/flibbles/graph/widgets/action-with.js\":{\"text\":\"/*\\\\\\n\\nAction widget that executes actions within it while exposing variables representing the mouse's current location.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nvar WithWidget = function(parseTreeNode, options) {\\n\\tthis.initialise(parseTreeNode, options);\\n};\\n\\nWithWidget.prototype = new Widget();\\n\\nWithWidget.prototype.render = function(parent, nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.renderChildren(parent, nextSibling);\\n};\\n\\nWithWidget.prototype.execute = function() {\\n\\tthis.withOffset = this.getAttribute(\\\"$offset\\\");\\n\\tthis.withCanvas = this.getAttribute(\\\"$canvas\\\");\\n\\tthis.makeChildWidgets();\\n};\\n\\nWithWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\tfor (var attribute in changedAttributes) {\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t}\\n\\treturn this.refreshChildren(changedTiddlers);\\n};\\n\\nWithWidget.prototype.invokeAction = function(triggeringWidget, event) {\\n\\tvar graph = getGraphWidget(this);\\n\\tif (graph) {\\n\\t\\tif (this.withOffset) {\\n\\t\\t\\tvar mouse = graph.mouse,\\n\\t\\t\\t\\tx = mouse.x.toString(),\\n\\t\\t\\t\\ty = mouse.y.toString();\\n\\t\\t\\tthis.setVariable(this.withOffset + \\\"-x\\\", x);\\n\\t\\t\\tthis.setVariable(this.withOffset + \\\"-y\\\", y);\\n\\t\\t}\\n\\t\\tif (this.withCanvas) {\\n\\t\\t\\tvar element = graph.graphElement;\\n\\t\\t\\tthis.setVariable(this.withCanvas + \\\"-width\\\", element.offsetWidth);\\n\\t\\t\\tthis.setVariable(this.withCanvas + \\\"-height\\\", element.offsetHeight);\\n\\t\\t}\\n\\t}\\n\\tthis.refreshChildren();\\n\\treturn true;\\n};\\n\\nfunction getGraphWidget(self) {\\n\\tvar widget = self.parentWidget;\\n\\twhile (widget) {\\n\\t\\tif (widget.graphObjectType === \\\"graph\\\") {\\n\\t\\t\\treturn widget;\\n\\t\\t}\\n\\t\\twidget = widget.parentWidget;\\n\\t}\\n\\treturn null;\\n};\\n\\nexports[\\\"action-with\\\"] = WithWidget;\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/action-with.js\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/flibbles/graph/widgets/boundingbox.js\":{\"text\":\"/*\\\\\\n\\nWidget for creating a DOM element which has strictly controlled dimensions,\\nintended for a contained graph.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\nvar utils = require(\\\"../utils.js\\\");\\n\\nvar BoxWidget = function(parseTreeNode, options) {\\n\\tthis.initialise(parseTreeNode, options);\\n\\tutils.registerForDestruction(this);\\n\\tthis.resizeInstance = this.resize.bind(this);\\n\\tthis.window = utils.window();\\n\\tthis.window.addEventListener(\\\"resize\\\", this.resizeInstance);\\n};\\n\\n/**\\n * Inherit from the base widget class\\n */\\nBoxWidget.prototype = new Widget();\\n\\n/**\\n * Render this widget into the DOM\\n */\\nBoxWidget.prototype.render = function(parent, nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.domNode = this.document.createElement(\\\"div\\\");\\n\\tthis.domNode.className = this.boxClass;\\n\\tparent.insertBefore(this.domNode, nextSibling);\\n\\t// Make sure this comes AFTER inserting domNode into the tree,\\n\\t// otherwise getBoundingClientRect() will be all zeros.\\n\\tthis.resize();\\n\\tthis.renderChildren(this.domNode, null);\\n\\tthis.domNodes.push(this.domNode);\\n};\\n\\n/**\\n * Compute the internal state of the widget\\n */\\nBoxWidget.prototype.execute = function() {\\n\\tthis.executeClass();\\n\\tthis.executeDimensions();\\n\\tthis.makeChildWidgets();\\n};\\n\\nBoxWidget.prototype.executeDimensions = function() {\\n\\tvar self = this;\\n\\tthis.widthFilter = this.wiki.compileFilter(this.getAttribute(\\\"width\\\", \\\"\\\"));\\n\\tthis.heightFilter = this.wiki.compileFilter(this.getAttribute(\\\"height\\\", \\\"\\\"));\\n\\tthis.dimensionWidget = this.wiki.makeWidget({tree: [{type: \\\"widget\\\", children: []}]}, {parentWidget: this});\\n\\tthis.dimensionWidget.execute();\\n\\t// We set up the widget so it only gets values for these variables\\n\\t// if needed. This keeps down unncessary calls to window and document,\\n\\t// and makes the $graph widget usable on Node, if that ever comes up.\\n\\tvar variables = {\\n\\t\\t// It may be better to use document.body.clientWidth,\\n\\t\\t// which doesn't consider the scrollbar.\\n\\t\\twindowWidth: function() { return self.window.innerWidth.toString(); },\\n\\t\\twindowHeight: function() { return self.window.innerHeight.toString(); },\\n\\t\\tboundingLeft: function() { return self.domNode.getBoundingClientRect().left.toString(); },\\n\\t\\tboundingTop: function() { return self.domNode.getBoundingClientRect().top.toString(); },\\n\\t};\\n\\tfor (var name in variables) {\\n\\t\\tthis.dimensionWidget.setVariable(name);\\n\\t\\tObject.defineProperty(this.dimensionWidget.variables[name], \\\"value\\\", { get: variables[name] });\\n\\t}\\n};\\n\\n/**\\n * Selectively refreshes the widget if needed.\\n * Returns true if the widget or any of its children needed re-rendering\\n */\\nBoxWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\tvar changed = false;\\n\\tif (changedAttributes[\\\"class\\\"]) {\\n\\t\\tthis.executeClass();\\n\\t\\tthis.domNode.className = this.boxClass;\\n\\t\\tchanged = true;\\n\\t}\\n\\tif ($tw.utils.count(changedAttributes) > 0) {\\n\\t\\tthis.executeDimensions();\\n\\t\\tchanged = true;\\n\\t}\\n\\t// We always try to resize.\\n\\t// The $dimension filters might spit out something different.\\n\\tthis.resize();\\n\\treturn this.refreshChildren(changedTiddlers) || changed;\\n};\\n\\nBoxWidget.prototype.executeClass = function() {\\n\\tvar nodeClass = \\\"boundingbox\\\";\\n\\tvar extraClasses = this.getAttribute(\\\"class\\\", \\\"\\\");\\n\\tif (extraClasses) {\\n\\t\\tnodeClass += \\\" \\\" + extraClasses;\\n\\t}\\n\\tthis.boxClass = nodeClass;\\n};\\n\\nBoxWidget.prototype.resize = function(event) {\\n\\tvar widget = this.dimensionWidget.children[0];\\n\\tvar newWidth = this.widthFilter(null, widget)[0] || \\\"\\\";\\n\\tvar newHeight = this.heightFilter(null, widget)[0] || \\\"\\\";\\n\\tvar style = this.domNode.style;\\n\\tif (newWidth !== style.width) {\\n\\t\\tstyle.width = newWidth;\\n\\t}\\n\\tif (newHeight !== style.height) {\\n\\t\\tstyle.height = newHeight;\\n\\t}\\n};\\n\\nBoxWidget.prototype.destroy = function() {\\n\\tthis.window.removeEventListener(\\\"resize\\\", this.resizeInstance);\\n};\\n\\nBoxWidget.prototype.isGarbage = function() {\\n\\tvar body = this.document.body;\\n\\treturn !body || !body.contains(this.domNode);\\n};\\n\\nexports.boundingbox = BoxWidget;\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/boundingbox.js\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/flibbles/graph/widgets/fieldTranscriber.js\":{\"text\":\"/*\\\\\\n\\nWidget for transcribing the text of one data tiddler\\ninto the field of another. and vice-versa.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\nvar Scribers = $tw.modules.getModulesByTypeAsHashmap(\\\"fieldtranscribertype\\\");\\n\\nvar ScriberWidget = function(parseTreeNode, options) {\\n\\tthis.initialise(parseTreeNode, options);\\n};\\n\\nScriberWidget.prototype = new Widget();\\n\\nScriberWidget.prototype.render = function(parent, nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.renderChildren(parent, nextSibling);\\n};\\n\\nScriberWidget.prototype.execute = function() {\\n\\tthis.scribeField = this.getAttribute(\\\"field\\\");\\n\\tthis.scribeTiddler = this.getAttribute(\\\"tiddler\\\") || (!this.hasParseTreeNodeAttribute(\\\"tiddler\\\") && this.getVariable(\\\"currentTiddler\\\"));\\n\\tthis.scribeType = this.getAttribute(\\\"type\\\");\\n\\tthis.scribeState = this.getAttribute(\\\"state\\\");\\n\\tif (!this.scribeState) {\\n\\t\\tthis.scribeState = \\\"$:/temp/flibbles/graph/fieldtranscriber/\\\" + encodeURIComponent(this.scribeField) + \\\"/\\\" + this.scribeTiddler;\\n\\t}\\n\\tif (!Scribers[this.scribeType]) {\\n\\t\\tthis.scribeType = \\\"text/plain\\\";\\n\\t}\\n\\tthis.setVariable(\\\"state\\\", this.scribeState);\\n\\tthis.transcriber = Scribers[this.scribeType];\\n\\tthis.prepState();\\n\\tthis.makeChildWidgets();\\n};\\n\\nScriberWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\tif ($tw.utils.count(changedAttributes) > 0) {\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t}\\n\\tif (changedTiddlers[this.scribeState] && this.scribeField) {\\n\\t\\t// Our tracked state has changed. Time to transcribe.\\n\\t\\tvar state = this.wiki.getTiddler(this.scribeState);\\n\\t\\tif (state) {\\n\\t\\t\\tvar stateText = state.getFieldString(\\\"text\\\");\\n\\t\\t\\tif (this.stateText !== stateText) {\\n\\t\\t\\t\\tvar fieldText = this.transcriber.toField(stateText);\\n\\t\\t\\t\\tif (fieldText !== this.fieldText) {\\n\\t\\t\\t\\t\\tthis.wiki.setText(this.scribeTiddler, this.scribeField, null, fieldText);\\n\\t\\t\\t\\t\\tthis.fieldText = fieldText;\\n\\t\\t\\t\\t\\tthis.stateText = stateText;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tthis.wiki.setText(this.scribeTiddler, this.scribeField, null, undefined);\\n\\t\\t\\tthis.fieldText = undefined;\\n\\t\\t\\tthis.stateText = undefined;\\n\\t\\t}\\n\\t}\\n\\tif (changedTiddlers[this.scribeTiddler]) {\\n\\t\\tthis.prepState();\\n\\t}\\n\\treturn this.refreshChildren(changedTiddlers);\\n};\\n\\nScriberWidget.prototype.prepState = function() {\\n\\tif (this.scribeState && this.scribeField) {\\n\\t\\tvar tiddler = this.wiki.getTiddler(this.scribeTiddler);\\n\\t\\tif (tiddler) {\\n\\t\\t\\tvar fieldText = tiddler.fields[this.scribeField];\\n\\t\\t\\tif (this.fieldText !== fieldText) {\\n\\t\\t\\t\\tthis.fieldText = fieldText;\\n\\t\\t\\t\\tif (fieldText === undefined) {\\n\\t\\t\\t\\t\\tthis.wiki.deleteTiddler(this.scribeState);\\n\\t\\t\\t\\t\\tthis.stateText = undefined;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthis.stateText = this.transcriber.fromField(fieldText);\\n\\t\\t\\t\\t\\tthis.wiki.addTiddler({\\n\\t\\t\\t\\t\\t\\ttitle: this.scribeState,\\n\\t\\t\\t\\t\\t\\ttext: this.stateText,\\n\\t\\t\\t\\t\\t\\ttype: this.scribeType\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nexports.fieldtranscriber = ScriberWidget;\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/fieldTranscriber.js\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/flibbles/graph/widgets/graphobject.js\":{\"text\":\"/*\\\\\\n\\nBase-class widget that provides standard functionality for all \\\"graph objects\\\",\\nsuch as nodes or edges.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\nvar utils = require(\\\"../utils.js\\\");\\n\\nvar ObjectWidget = function(parseTreeNode, options) {};\\n\\nObjectWidget.prototype = new Widget();\\n\\nObjectWidget.prototype.render = function(parent, nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.parentPropertiesWidget = utils.getParentProperties(this, this.graphObjectType);\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.computeParents();\\n\\tthis.renderChildren(parent, nextSibling);\\n\\tthis.properties = this.refreshProperties();\\n\\t// We're new, so we're changed. Announce ourselves when asked.\\n\\tthis.changed = true;\\n};\\n\\nObjectWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\t// Did our parents experience a change?\\n\\tvar possibleChanges = this.computeParents();\\n\\t// Did our own properties change?\\n\\tfor (var attribute in changedAttributes) {\\n\\t\\tpossibleChanges = true;\\n\\t}\\n\\t// No properties have overtly changed, but maybe they changed covertly...\\n\\tif (!possibleChanges && utils.refreshProperties(this.properties, this, this.graphObjectType, changedTiddlers)) {\\n\\t\\tpossibleChanges = true;\\n\\t\\t// We short-circuit this because we have a property that said it's for\\n\\t\\t// sure different.\\n\\t\\tthis.changed = true;\\n\\t}\\n\\tif (possibleChanges) {\\n\\t\\tthis.execute();\\n\\t\\tthis.properties = this.refreshProperties();\\n\\t\\tthis.changed = true;\\n\\t}\\n\\treturn this.refreshChildren(changedTiddlers) || this.changed;\\n};\\n\\nObjectWidget.prototype.allowActionPropagation = function() {\\n\\treturn false;\\n};\\n\\nObjectWidget.prototype.refreshProperties = function() {\\n\\tvar newProperties = Object.create(null);\\n\\tthis.setCustomProperties(newProperties);\\n\\tfor (var key in this.attributes) {\\n\\t\\tif (key.charAt(0) !== \\\"$\\\") {\\n\\t\\t\\tvar value = this.attributes[key];\\n\\t\\t\\tif (value) {\\n\\t\\t\\t\\tnewProperties[key] = this.attributes[key];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor (var i = 0; i < this.applicableParents.length; i++) {\\n\\t\\tvar widget = this.applicableParents[i];\\n\\t\\tfor (var property in widget.properties) {\\n\\t\\t\\tif (!Object.hasOwnProperty.call(newProperties, property)) {\\n\\t\\t\\t\\tnewProperties[property] = widget.properties[property];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn newProperties;\\n};\\n\\nObjectWidget.prototype.catchGraphEvent = function(graphEvent, triggeringWidget, variables) {\\n\\tvar actions = this.attributes[graphEvent.type];\\n\\tif (actions) {\\n\\t\\ttriggeringWidget.invokeActionString(actions, triggeringWidget, graphEvent.event, variables);\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n};\\n\\nObjectWidget.prototype.computeParents = function() {\\n\\tvar index = 0;\\n\\tvar changed = false;\\n\\tvar list = this.applicableParents = this.applicableParents || [];\\n\\tthis.traversePropertyWidgets(function(widget) {\\n\\t\\tif (list[index] !== widget) {\\n\\t\\t\\tlist[index] = widget;\\n\\t\\t\\tchanged = true;\\n\\t\\t} else if (widget.propertiesChanged) {\\n\\t\\t\\tchanged = true;\\n\\t\\t}\\n\\t\\tindex++;\\n\\t});\\n\\tif (index !== list.length) {\\n\\t\\tlist.length = index;\\n\\t\\tchanged = true;\\n\\t}\\n\\treturn changed;\\n};\\n\\n/**\\n * Explore for any $properties which might apply to this. Can be overridden.\\n */\\nObjectWidget.prototype.traversePropertyWidgets = function(method) {\\n\\tvar widget = this.parentPropertiesWidget;\\n\\twhile (widget !== null) {\\n\\t\\tif (widget.filterFunc([this.id], widget).length > 0) {\\n\\t\\t\\tmethod(widget);\\n\\t\\t}\\n\\t\\twidget = widget.parentPropertiesWidget;\\n\\t}\\n};\\n\\nexports.graphobject = ObjectWidget;\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/graphobject.js\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/flibbles/graph/widgets/messagerelay.js\":{\"text\":\"/*\\\\\\n\\nWidget for relaying emitted messages to other parts of the widget.\\nThis allows buttons for a graph to exist outside of that graph.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\nvar utils = require(\\\"../utils.js\\\");\\n\\n// Relayed is used to avoid infinite loops. Once an event is relayed,\\n// it puts itself in this object under the relay name, so it can't be\\n// relayed again through that name\\nvar relayed = Object.create(null);\\n\\nvar RelayWidget = function(parseTreeNode, options) {\\n\\tthis.initialise(parseTreeNode, options);\\n\\tutils.registerForDestruction(this);\\n};\\n\\nRelayWidget.prototype = new Widget();\\n\\nRelayWidget.prototype.render = function(parent, nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.renderChildren(parent, nextSibling);\\n};\\n\\nRelayWidget.prototype.execute = function() {\\n\\tthis.relayName = this.getAttribute(\\\"name\\\");\\n\\tthis.relayTo = this.getAttribute(\\\"to\\\");\\n\\tif (this.relayName) {\\n\\t\\tvar register = this.wiki.relayRegister = this.wiki.relayRegister || Object.create(null);\\n\\t\\tregister[this.relayName] = register[this.relayName] || [];\\n\\t\\tregister[this.relayName].push(this);\\n\\t}\\n\\tthis.makeChildWidgets();\\n};\\n\\nRelayWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\tvar changed = false;\\n\\tif (changedAttributes.name) {\\n\\t\\tthis.destroy();\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t}\\n\\tif (changedAttributes.to) {\\n\\t\\tthis.relayTo = this.getAttribute(\\\"to\\\");\\n\\t\\tchanged = true;\\n\\t}\\n\\treturn this.refreshChildren(changedTiddlers) || changed;\\n};\\n\\nRelayWidget.prototype.dispatchEvent = function(event) {\\n\\tvar register = this.wiki.relayRegister;\\n\\tif (this.relayTo\\n\\t&& register\\n\\t&& register[this.relayTo]\\n\\t&& relayed[this.relayTo] !== event) {\\n\\t\\trelayed[this.relayTo] = event;\\n\\t\\tvar targets = register[this.relayTo];\\n\\t\\tfor (var i = 0; i < targets.length; i++) {\\n\\t\\t\\tvar target = targets[i];\\n\\t\\t\\tif (!target.isGarbage()) {\\n\\t\\t\\t\\ttargets[i].dispatchEvent(event);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\treturn Widget.prototype.dispatchEvent.call(this, event);\\n\\t}\\n};\\n\\nRelayWidget.prototype.isGarbage = function() {\\n\\tvar root = rootWidget(this);\\n\\treturn root !== $tw.rootWidget;\\n};\\n\\nRelayWidget.prototype.destroy = function() {\\n\\tif (this.relayName) {\\n\\t\\tvar register = this.wiki.relayRegister[this.relayName];\\n\\t\\tfor (var i = 0; i < register.length; i++) {\\n\\t\\t\\tif (register[i] === this) {\\n\\t\\t\\t\\t// Remove this from the register\\n\\t\\t\\t\\tregister.splice(i, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.relayName = undefined;\\n\\t}\\n};\\n\\nfunction rootWidget(relay) {\\n\\tvar parent = relay.parentWidget;\\n\\twhile (parent) {\\n\\t\\tvar i = 0;\\n\\t\\tfor (; i < parent.children.length; i++) {\\n\\t\\t\\tif (parent.children[i] === relay) {\\n\\t\\t\\t\\t// Confirmed that the parent still owns this child\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (i == parent.children.length) {\\n\\t\\t\\t// Ownership was not confirmed\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\trelay = parent;\\n\\t\\tparent = relay.parentWidget;\\n\\t}\\n\\treturn relay;\\n};\\n\\nexports.messagerelay = RelayWidget;\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/messagerelay.js\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/flibbles/graph/widgets/properties.js\":{\"text\":\"/*\\\\\\n\\nWidget for setting properties on graph objects.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\nvar utils = require(\\\"../utils.js\\\");\\nvar Engines = $tw.modules.getModulesByTypeAsHashmap(\\\"graphengine\\\");\\nvar PropertyTypes = $tw.modules.getModulesByTypeAsHashmap(\\\"graphpropertytype\\\");\\n\\nvar Properties = function(parseTreeNode, options) {\\n\\tthis.initialise(parseTreeNode, options);\\n};\\n\\nProperties.prototype = new Widget();\\n\\nProperties.prototype.graphPropertiesWidget = true;\\n\\nProperties.prototype.render = function(parent, nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.renderChildren(parent, nextSibling);\\n};\\n\\nProperties.prototype.execute = function() {\\n\\tthis.type = this.getAttribute(\\\"$for\\\", \\\"nodes\\\");\\n\\tthis.parentPropertiesWidget = utils.getParentProperties(this, this.type);\\n\\tthis.filter = this.getAttribute(\\\"$filter\\\");\\n\\tthis.properties = this.getProperties();\\n\\tthis.filterFunc = this.filter? this.wiki.compileFilter(this.filter): function(source) { return source; };\\n\\tthis.makeChildWidgets();\\n};\\n\\nProperties.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\tthis.propertiesChanged = false;\\n\\tif (changedAttributes[\\\"$for\\\"]) {\\n\\t\\t// If the $for changed, we need to refocus to the different object type.\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t}\\n\\tif (propertiesChanged(changedAttributes)\\n\\t|| utils.refreshProperties(this.properties, this, this.type, changedTiddlers)\\n\\t|| changedAttributes[\\\"$tiddler\\\"]\\n\\t|| changedAttributes[\\\"$field\\\"]\\n\\t|| (this.dataTiddler\\n\\t\\t&& changedTiddlers[this.dataTiddler]\\n\\t\\t&& this.rawData !== getTiddlerString(this.wiki, this.dataTiddler, this.field))) {\\n\\t\\t// Our styling attributes have changed, so everything this $style\\n\\t\\t// affects needs to refresh.\\n\\t\\tthis.properties = this.getProperties();\\n\\t\\tthis.propertiesChanged = true;\\n\\t}\\n\\t// If we have a filterFunc, we need to worry about whether this style\\n\\t// applies to a different subset of its children objects or not.\\n\\tif (changedAttributes[\\\"$filter\\\"]) {\\n\\t\\tthis.filter = this.getAttribute(\\\"$filter\\\");\\n\\t\\tthis.filterFunc = this.filter? this.wiki.compileFilter(this.filter): function(source) { return source; };\\n\\t}\\n\\treturn this.refreshChildren(changedTiddlers) || this.propertiesChanged;\\n};\\n\\nProperties.prototype.getProperties = function() {\\n\\tthis.field = this.getAttribute(\\\"$field\\\");\\n\\tthis.dataTiddler = this.getAttribute(\\\"$tiddler\\\");\\n\\tif (!this.dataTiddler && this.field) {\\n\\t\\tthis.dataTiddler = this.getVariable(\\\"currentTiddler\\\");\\n\\t}\\n\\tvar styleObject = Object.create(null);\\n\\tif (this.dataTiddler) {\\n\\t\\tvar data;\\n\\t\\t// We recall the actual raw data string so\\n\\t\\t// we can see whether it changes later on.\\n\\t\\tthis.rawData = getTiddlerString(this.wiki, this.dataTiddler, this.field);\\n\\t\\tif (!this.field || this.field === \\\"text\\\") {\\n\\t\\t\\tdata = this.wiki.getTiddlerData(this.dataTiddler);\\n\\t\\t} else {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = this.rawData? JSON.parse(this.rawData): {};\\n\\t\\t\\t} catch {\\n\\t\\t\\t\\tdata = {};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (var entry in data) {\\n\\t\\t\\tvar datum = data[entry];\\n\\t\\t\\t// We only accept non-empty values\\n\\t\\t\\tif (datum && typeof datum === \\\"string\\\") {\\n\\t\\t\\t\\tstyleObject[entry] = datum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor (var name in this.attributes) {\\n\\t\\tif (name.charAt(0) !== '$' && this.attributes[name]) {\\n\\t\\t\\tstyleObject[name] = this.attributes[name];\\n\\t\\t}\\n\\t}\\n\\treturn styleObject;\\n};\\n\\nfunction getTiddlerString(wiki, title, field) {\\n\\tvar tiddler = wiki.getTiddler(title);\\n\\treturn tiddler && tiddler.getFieldString(field || \\\"text\\\");\\n};\\n\\nProperties.prototype.catchGraphEvent = function(graphEvent, target, variables) {\\n\\tif (graphEvent.objectType === this.type\\n\\t&& this.filterFunc([target.id], this).length > 0) {\\n\\t\\tvar actions = this.properties[graphEvent.type];\\n\\t\\tif (actions) {\\n\\t\\t\\tvariables.targetTiddler = graphEvent.id;\\n\\t\\t\\tthis.invokeActionString(actions, this, graphEvent.event, variables);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n};\\n\\nfunction propertiesChanged(changedAttributes) {\\n\\tfor (var name in changedAttributes) {\\n\\t\\tif (name.charAt(0) !== \\\"$\\\") {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n};\\n\\nexports.properties = Properties;\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/properties.js\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/flibbles/graph/widgets/subclass/edge.js\":{\"text\":\"/*\\\\\\n\\nWidget for creating edges within graphs.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar nextId = 1;\\n\\nexports.baseClass = \\\"graphobject\\\";\\nexports.name = \\\"edge\\\";\\n\\nexports.constructor = function(parseTreeNode, options) {\\n\\tthis.initialise(parseTreeNode, options);\\n};\\n\\nvar EdgeWidget = exports.prototype = {};\\n\\nEdgeWidget.graphObjectType = \\\"edges\\\";\\n\\nEdgeWidget.execute = function() {\\n\\tthis.id = this.getAttribute(\\\"$id\\\");\\n\\tif (!this.id) {\\n\\t\\t// We do this instead of using getAttribute's default arg\\n\\t\\t// so we don't increment unecessarily, and maybe reuse\\n\\t\\t// the same auto-id if this edge refreshes Self. This'll give better\\n\\t\\t// results when updating the graph. It's a CHANGED edge, not a new one.\\n\\t\\tthis.counter = this.counter || nextId++;\\n\\t\\tthis.id = \\\"$:/edge/\\\" + this.counter;\\n\\t}\\n\\tthis.fromTiddler = this.getAttribute(\\\"$from\\\", this.getVariable(\\\"currentTiddler\\\"));\\n\\tthis.toTiddler = this.getAttribute(\\\"$to\\\", this.getVariable(\\\"toTiddler\\\"));\\n\\tthis.makeChildWidgets();\\n};\\n\\nEdgeWidget.addActionContext = function(variables) {\\n\\tvariables.id = this.id;\\n\\tvariables.fromTiddler = this.fromTiddler;\\n\\tvariables.toTiddler = this.toTiddler;\\n};\\n\\nEdgeWidget.setCustomProperties = function(properties) {\\n\\tif (this.fromTiddler) {\\n\\t\\tproperties.from = this.fromTiddler;\\n\\t}\\n\\tif (this.toTiddler) {\\n\\t\\tproperties.to = this.toTiddler;\\n\\t}\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/subclass/edge.js\",\"type\":\"application/javascript\",\"module-type\":\"widget-subclass\"},\"$:/plugins/flibbles/graph/widgets/subclass/graph.js\":{\"text\":\"/*\\\\\\n\\nWidget for creating graphs.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar utils = require(\\\"../../utils.js\\\");\\n\\nvar PropertyTypes = $tw.modules.getModulesByTypeAsHashmap(\\\"graphpropertytype\\\");\\n\\nvar graphColors = {\\n\\tnodeColor: \\\"graph-node-color\\\",\\n\\tfontColor: \\\"graph-font-color\\\",\\n\\t// We pass along the background too, even though it's probably covered\\n\\t// by CSS. Some engines might need this for other coloring effects.\\n\\tgraphColor: \\\"graph-background\\\"\\n};\\n\\nexports.baseClass = \\\"graphobject\\\";\\nexports.name = \\\"graph\\\";\\n\\nexports.constructor = function(parseTreeNode, options) {\\n\\tthis.initialise(parseTreeNode, options);\\n\\tutils.registerForDestruction(this);\\n\\tthis.window = utils.window();\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nvar GraphWidget = exports.prototype = {};\\n\\nGraphWidget.graphObjectType = \\\"graph\\\";\\n\\n/*\\nRender this widget into the DOM\\n*/\\nGraphWidget.render = function(parent, nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.graphElement = this.document.createElement(\\\"div\\\");\\n\\tvar className = \\\"graph-canvas\\\";\\n\\tif (!this.graphEngine) {\\n\\t\\tclassName += \\\" graph-error\\\";\\n\\t} else {\\n\\t\\tclassName += \\\" graph-engine-\\\" + this.graphEngineName.toLowerCase();\\n\\t}\\n\\tthis.graphElement.className = className;\\n\\tthis.graphElement.addEventListener(\\\"mousemove\\\", this);\\n\\tthis.domNodes.push(this.graphElement);\\n\\tparent.insertBefore(this.graphElement, nextSibling);\\n\\tthis.renderChildren(this.graphElement, null);\\n\\n\\tthis.computeParents();\\n\\t// Render and recenter the view\\n\\tif(this.graphEngine) {\\n\\t\\tthis.graphEngine.onevent = GraphWidget.handleGraphEvent.bind(this);\\n\\t\\tvar objects = this.findGraphObjects() || {};\\n\\t\\tthis.properties = this.refreshProperties() || {};\\n\\t\\tobjects.graph = this.typecastProperties(this.properties, \\\"graph\\\");\\n\\t\\ttry {\\n\\t\\t\\tthis.graphEngine.init(this.graphElement, objects, {wiki: this.wiki});\\n\\t\\t} catch(e) {\\n\\t\\t\\t// Technically, we should drop this engine without destroying it.\\n\\t\\t\\t// It didn't successfully init, so it's not initialized.\\n\\t\\t\\t// This means it's up to the engines to be \\\"Strong Exception Safe\\\".\\n\\t\\t\\tthis.graphEngine = undefined;\\n\\t\\t\\t// Something went wrong. Rebuild this widget as an error displayer\\n\\t\\t\\tconsole.error(e);\\n\\t\\t\\tthis.errorState = e.message || e.toString();\\n\\t\\t\\tthis.refreshSelf();\\n\\t\\t}\\n\\t}\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nGraphWidget.execute = function() {\\n\\tthis.colorWidgets = {};\\n\\tthis.graphEngineName = this.getEngineName();\\n\\tthis.setVariable(\\\"graphengine\\\", this.graphEngineName);\\n\\tthis.executeColors();\\n\\tthis.mouse = {x: \\\"0\\\", y: \\\"0\\\"};\\n\\tvar Engine = utils.getEngine(this.graphEngineName);\\n\\tif (!Engine || this.errorState) {\\n\\t\\tvar message;\\n\\t\\tif (this.errorState) {\\n\\t\\t\\tmessage = this.errorState;\\n\\t\\t\\tthis.errorState = null;\\n\\t\\t} else if (!this.graphEngineName) {\\n\\t\\t\\tmessage = \\\"No graphing libraries installed.\\\";\\n\\t\\t} else if (this.getAttribute(\\\"$engine\\\")) {\\n\\t\\t\\tmessage = \\\"'\\\" + this.graphEngineName + \\\"' graphing library not found.\\\";\\n\\t\\t} else {\\n\\t\\t\\tmessage = \\\"Graph plugin configured to use missing '\\\" + this.graphEngineName + \\\"' engine. Fix this in plugin settings.\\\";\\n\\t\\t}\\n\\t\\tthis.makeChildWidgets([{type: \\\"element\\\", tag: \\\"span\\\", children: [{type: \\\"text\\\", text: message}]}]);\\n\\t\\tthis.graphEngine = undefined;\\n\\t} else {\\n\\t\\tthis.knownObjects = {};\\n\\t\\tthis.makeChildWidgets();\\n\\t\\tthis.graphEngine = new Engine(this.wiki);\\n\\t}\\n};\\n\\nGraphWidget.executeColors = function() {\\n\\tfor (var color in graphColors) {\\n\\t\\tthis.colorWidgets[color] = this.wiki.makeWidget({\\n\\t\\t\\ttree: [{\\n\\t\\t\\t\\ttype: \\\"transclude\\\",\\n\\t\\t\\t\\tattributes: {\\n\\t\\t\\t\\t\\t\\\"$variable\\\": {type: \\\"string\\\", value: \\\"colour\\\"},\\n\\t\\t\\t\\t\\t0: {type: \\\"string\\\", value: graphColors[color]}}\\n\\t\\t\\t}]}, {parentWidget: this});\\n\\t}\\n};\\n\\n/*\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n*/\\nGraphWidget.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes(),\\n\\t\\tnewName = this.getEngineName();\\n\\tif(changedAttributes[\\\"$engine\\\"] || (this.graphEngineName !== newName)) {\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t}\\n\\tvar changed = false;\\n\\tvar objects;\\n\\tfor (var attribute in changedAttributes) {\\n\\t\\tif (attribute.charAt(0) !== \\\"$\\\") {\\n\\t\\t\\tchanged = true;\\n\\t\\t}\\n\\t}\\n\\tif (this.refreshChildren(changedTiddlers)) {\\n\\t\\t// Children have changed. Look for changed nodes and edges.\\n\\t\\tobjects = this.findGraphObjects();\\n\\t\\tchanged = true;\\n\\t}\\n\\tchanged = this.computeParents() || changed;\\n\\tif (changed || this.refreshColors(changedTiddlers)) {\\n\\t\\tvar newGraphProperties = this.graphEngine? this.refreshProperties(): Object.create(null);\\n\\t\\tif (JSON.stringify(newGraphProperties) !== JSON.stringify(this.properties)) {\\n\\t\\t\\tobjects = objects || {};\\n\\t\\t\\tthis.properties = newGraphProperties;\\n\\t\\t\\tobjects.graph = this.typecastProperties(this.properties, \\\"graph\\\");\\n\\t\\t\\tchanged = true;\\n\\t\\t}\\n\\t}\\n\\tif (changed) {\\n\\t\\tif (!this.graphEngine) {\\n\\t\\t\\t// We were in an error state. Maybe we won't be after refreshing.\\n\\t\\t\\tthis.refreshSelf();\\n\\t\\t} else if (objects) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tthis.graphEngine.update(objects);\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t// Something went wrong. Rebuild this widget as an error displayer\\n\\t\\t\\t\\tconsole.error(e);\\n\\t\\t\\t\\tthis.errorState = e.message || e.toString();\\n\\t\\t\\t\\tthis.refreshSelf();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn changed;\\n};\\n\\nGraphWidget.refreshSelf = function() {\\n\\tvar nextSibling = this.findNextSiblingDomNode();\\n\\tthis.removeChildDomNodes();\\n\\tif (this.graphEngine) {\\n\\t\\tthis.graphEngine.destroy();\\n\\t}\\n\\tthis.render(this.parentDomNode, nextSibling);\\n};\\n\\nGraphWidget.refreshColors = function(changedTiddlers) {\\n\\tvar changed = false;\\n\\tfor (var color in graphColors) {\\n\\t\\tif (!this.colorWidgets[color].refresh(changedTiddlers)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tchanged = true;\\n\\t}\\n\\treturn changed;\\n};\\n\\nGraphWidget.destroy = function() {\\n\\tif (this.graphEngine) {\\n\\t\\tthis.graphEngine.destroy();\\n\\t}\\n};\\n\\nGraphWidget.isGarbage = function() {\\n\\tvar body = this.document.body;\\n\\treturn !body || !body.contains(this.graphElement);\\n};\\n\\nGraphWidget.getEngineName = function() {\\n\\treturn this.getAttribute(\\\"$engine\\\") || this.getVariable(\\\"graphengine\\\");\\n};\\n\\nGraphWidget.getColor = function(color) {\\n\\tvar widget = this.colorWidgets[color];\\n\\tvar container = $tw.fakeDocument.createElement(\\\"div\\\");\\n\\twidget.render(container, null);\\n\\treturn container.textContent;\\n};\\n\\nGraphWidget.setCustomProperties = function(properties) {\\n\\tfor (var name in graphColors) {\\n\\t\\tvar color = this.getColor(name);\\n\\t\\tif (color) {\\n\\t\\t\\tproperties[name] = color;\\n\\t\\t}\\n\\t}\\n};\\n\\n/**\\n * This overrides a graphobject method so we're looking inward instead of\\n * upward for properties that apply to this widget.\\n */\\nGraphWidget.traversePropertyWidgets = function(method) {\\n\\tvar iterator = new utils.WidgetIterator(this);\\n\\tvar ptr = null;\\n\\tvar results;\\n\\twhile (!(results = iterator.next()).done) {\\n\\t\\tvar widget = results.value;\\n\\t\\tif (widget.type === \\\"graph\\\") {\\n\\t\\t\\t// We make a quick in place linked list\\n\\t\\t\\tresults.next = ptr;\\n\\t\\t\\tptr = results;\\n\\t\\t}\\n\\t}\\n\\t// Now we run through that list. This way, we apply the found properties\\n\\t// in reverse, since the first found should be executed last as having\\n\\t// lowest priority.\\n\\twhile (ptr !== null) {\\n\\t\\tmethod(ptr.value);\\n\\t\\tptr = ptr.next;\\n\\t}\\n};\\n\\nGraphWidget.typecastProperties = function(properties, type) {\\n\\tvar engineDefinitions = this.graphEngine.properties;\\n\\tvar catalog = (engineDefinitions && engineDefinitions[type]) || {};\\n\\treturn this.typecastSet(properties, catalog);\\n};\\n\\nGraphWidget.typecastSet = function(properties, catalog) {//type, key, value) {\\n\\tvar output = Object.create(null);\\n\\tfor (var key in properties) {\\n\\t\\tvar info = catalog[key];\\n\\t\\tif (info && PropertyTypes[info.type]) {\\n\\t\\t\\tvar value = PropertyTypes[info.type].toProperty(info, properties[key], {widget: this});\\n\\t\\t\\tif (value !== null) {\\n\\t\\t\\t\\toutput[key] = value;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\toutput[key] = properties[key];\\n\\t\\t}\\n\\t}\\n\\treturn output;\\n};\\n\\nGraphWidget.findGraphObjects = function() {\\n\\tvar self = this;\\n\\tvar newObjects = {};\\n\\tvar iterator = new utils.WidgetIterator(this),\\n\\t\\tresults;\\n\\twhile (!(results = iterator.next()).done) {\\n\\t\\tvar widget = results.value;\\n\\t\\tvar type = widget.graphObjectType;\\n\\t\\tif (type && type !== \\\"graph\\\") {\\n\\t\\t\\tnewObjects[type] = newObjects[type] || Object.create(null);\\n\\t\\t\\tnewObjects[type][widget.id] = widget;\\n\\t\\t}\\n\\t}\\n\\t// Special handling for edge trimming\\n\\twithholdObjects(newObjects);\\n\\tvar prevObjects = this.knownObjects;\\n\\tthis.knownObjects = newObjects;\\n\\treturn this.getDifferences(prevObjects, newObjects);\\n};\\n\\nfunction withholdObjects(objects) {\\n\\t// Blank nodes get filtered\\n\\tif (objects.nodes) {\\n\\t\\tfor (var id in objects.nodes) {\\n\\t\\t\\tif (!id) {\\n\\t\\t\\t\\tobjects.nodes[id] = undefined;\\n\\t\\t\\t\\t// This can only happen once\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// Special handling for edge trimming\\n\\tif (objects.edges) {\\n\\t\\tfor (var id in objects.edges) {\\n\\t\\t\\tvar edge = objects.edges[id];\\n\\t\\t\\t// This could probably be done above when deleting nulls\\n\\t\\t\\tif (!objects.nodes\\n\\t\\t\\t|| !objects.nodes[edge.fromTiddler]\\n\\t\\t\\t|| !objects.nodes[edge.toTiddler]) {\\n\\t\\t\\t\\t// It must be trimmed\\n\\t\\t\\t\\tobjects.edges[id] = undefined;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nGraphWidget.getDifferences = function(prevObjects, newObjects) {\\n\\tvar objects = null\\n\\tfor (var type in prevObjects) {\\n\\t\\tvar was = prevObjects[type];\\n\\t\\tvar is = newObjects[type];\\n\\t\\tfor (var id in was) {\\n\\t\\t\\tif (was[id]) {\\n\\t\\t\\t\\tif (!is || !is[id]) {\\n\\t\\t\\t\\t\\t// It Was, and no longer Is. Flag for deletion\\n\\t\\t\\t\\t\\tobjects = objects || {};\\n\\t\\t\\t\\t\\tobjects[type] = objects[type] || Object.create(null);\\n\\t\\t\\t\\t\\tobjects[type][id] = null;\\n\\t\\t\\t\\t} else if (is[id].changed || is[id] !== was[id]) {\\n\\t\\t\\t\\t\\t// It changed, or is another instance of the same ID.\\n\\t\\t\\t\\t\\t// Updated it.\\n\\t\\t\\t\\t\\tobjects = objects || {};\\n\\t\\t\\t\\t\\tobjects[type] = objects[type] || Object.create(null);\\n\\t\\t\\t\\t\\tobjects[type][id] = this.typecastProperties(is[id].properties, type);\\n\\t\\t\\t\\t\\tis[id].changed = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor (var type in newObjects) {\\n\\t\\tvar was = prevObjects? prevObjects[type]: undefined;\\n\\t\\tvar is = newObjects[type];\\n\\t\\tfor (var id in is) {\\n\\t\\t\\tif (is[id] && (!was || !was[id])) {\\n\\t\\t\\t\\t// It has been added. Add it.\\n\\t\\t\\t\\tobjects = objects || {};\\n\\t\\t\\t\\tobjects[type] = objects[type] || Object.create(null);\\n\\t\\t\\t\\tobjects[type][id] = this.typecastProperties(is[id].properties, type);\\n\\t\\t\\t\\tis[id].changed = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn objects;\\n};\\n\\n/**\\n * This handles messages bubbling up from internal graph widgets\\n */\\nGraphWidget.dispatchEvent = function(event) {\\n\\tvar messageDef = this.graphEngine.messages && this.graphEngine.messages[event.type];\\n\\tif (messageDef) {\\n\\t\\tvar params = this.typecastSet(event.paramObject, messageDef);\\n\\t\\tif (this.graphEngine.handleMessage(event, params) === false) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\tif (this.parentWidget) {\\n\\t\\treturn this.parentWidget.dispatchEvent(event);\\n\\t}\\n};\\n\\nGraphWidget.handleGraphEvent = function(graphEvent, variables) {\\n\\tif (graphEvent.objectType === \\\"graph\\\") {\\n\\t\\tvar iterator = new utils.WidgetIterator(this);\\n\\t\\tvar results;\\n\\t\\twhile (!(results = iterator.next()).done) {\\n\\t\\t\\tvar widget = results.value;\\n\\t\\t\\tif (widget.type === \\\"graph\\\") {\\n\\t\\t\\t\\tvar actions = widget.properties[graphEvent.type];\\n\\t\\t\\t\\tif (actions) {\\n\\t\\t\\t\\t\\twidget.invokeActionString(actions, widget, graphEvent.event, variables);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.catchGraphEvent(graphEvent, this, variables);\\n\\t} else {\\n\\t\\tvar category = this.knownObjects[graphEvent.objectType];\\n\\t\\tvar object = category && category[graphEvent.id];\\n\\t\\tif (object) {\\n\\t\\t\\tvariables = variables || {};\\n\\t\\t\\t// We let the graph object assign some state, such as the id of the\\n\\t\\t\\t// targeted node, or the nodes of the targeted edge.\\n\\t\\t\\tobject.addActionContext(variables);\\n\\t\\t\\t// Make sure it's an objects we actually know about\\n\\t\\t\\tvar target = object;\\n\\t\\t\\twhile (object && object !== this) {\\n\\t\\t\\t\\tif (object.catchGraphEvent) {\\n\\t\\t\\t\\t\\t// Start at the object. Go up, finding $style to handle this\\n\\t\\t\\t\\t\\tobject.catchGraphEvent(graphEvent, target, variables);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tobject = object.parentWidget;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nGraphWidget.handleEvent = function(event) {\\n\\t// Must be a mousemove, because that's the only one we signed up for.\\n\\tthis.mouse.x = event.offsetX;\\n\\tthis.mouse.y = event.offsetY;\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/subclass/graph.js\",\"type\":\"application/javascript\",\"module-type\":\"widget-subclass\"},\"$:/plugins/flibbles/graph/widgets/subclass/node.js\":{\"text\":\"/*\\\\\\n\\nWidget for creating nodes within graphs.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nvar axes = ['x', 'y', 'z', 'w'];\\n\\nexports.baseClass = \\\"graphobject\\\";\\nexports.name = \\\"node\\\";\\n\\nexports.constructor = function(parseTreeNode, options) {\\n\\tthis.initialise(parseTreeNode, options);\\n};\\n\\nvar NodeWidget = exports.prototype = {};\\n\\nNodeWidget.graphObjectType = \\\"nodes\\\";\\n\\nNodeWidget.execute = function() {\\n\\tthis.id = this.getAttribute(\\\"$tiddler\\\", this.getVariable(\\\"currentTiddler\\\"));\\n\\tthis.pos = this.getAttribute(\\\"$pos\\\");\\n\\tthis.makeChildWidgets();\\n};\\n\\nNodeWidget.addActionContext = function(variables) {\\n\\tvariables.nodeTiddler = this.id;\\n};\\n\\nNodeWidget.setCustomProperties = function(properties) {\\n\\tif (this.pos) {\\n\\t\\tvar points = this.pos.split(\\\",\\\");\\n\\t\\tvar count = Math.min(points.length, axes.length);\\n\\t\\tfor (var i = 0; i < count; i++) {\\n\\t\\t\\tif (points[i]) {\\n\\t\\t\\t\\tproperties[axes[i]] = points[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/subclass/node.js\",\"type\":\"application/javascript\",\"module-type\":\"widget-subclass\"},\"$:/plugins/flibbles/graph/widgets/fieldtranscriber/filter.js\":{\"text\":\"/*\\\\\\n\\nType for transcribing application/x-tiddler-filter between text and field.\\n\\nChanges \\\\n into \\\"  \\\" between runs to mitigate the need for multilines.\\nHowever, it's impossible to guarantee a single line filter if newlines are\\nused in operands.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"application/x-tiddler-filter\\\";\\n\\nexports.toField = function(text) {\\n\\treturn filterWhitespaceWalk(text, function(start, end) {\\n\\t\\tvar substr = text.substring(start, end);\\n\\t\\tvar change = substr.replaceAll(\\\"\\\\n\\\", \\\"  \\\");\\n\\t\\treturn substr !== change ? change: null;\\n\\t}).trim();\\n};\\n\\nexports.fromField = function(text) {\\n\\treturn filterWhitespaceWalk(text, function(start, end) {\\n\\t\\tvar substr = text.substring(start, end);\\n\\t\\tvar change = substr.replaceAll(\\\"  \\\", \\\"\\\\n\\\");\\n\\t\\treturn substr !== change ? change: null;\\n\\t});\\n};\\n\\nvar brackets = { \\\"{\\\": \\\"}\\\", \\\"[\\\": \\\"]\\\", \\\"<\\\": \\\">\\\" };\\n\\nfunction filterWhitespaceWalk(filterString, method) {\\n\\tvar p = 0, replaceHead = 0, replacements = [], match, nextBracketPos;\\n\\tvar whitespaceRegExp = /(\\\\s+)/mg;\\n\\tvar operandRegExp = /((?:\\\\+|\\\\-|~|=|\\\\:(\\\\w+)(?:\\\\:([\\\\w\\\\:, ]*))?)?)(?:(\\\\[)|(?:\\\"([^\\\"]*)\\\")|(?:'([^']*)')|([^\\\\s\\\\[\\\\]]+))/mg;\\n\\twhile (p < filterString.length) {\\n\\t\\twhitespaceRegExp.lastIndex = p;\\n\\t\\tmatch = whitespaceRegExp.exec(filterString);\\n\\t\\tif (match && match.index === p) {\\n\\t\\t\\tvar end = p + match[0].length;\\n\\t\\t\\tvar replacement = method(p, end);\\n\\t\\t\\tif (replacement !== null) {\\n\\t\\t\\t\\treplacements.push(filterString.substring(replaceHead, p));\\n\\t\\t\\t\\treplacements.push(replacement);\\n\\t\\t\\t\\treplaceHead = end;\\n\\t\\t\\t}\\n\\t\\t\\tp = end;\\n\\t\\t}\\n\\t\\tif (p < filterString.length) {\\n\\t\\t\\toperandRegExp.lastIndex = p;\\n\\t\\t\\tmatch = operandRegExp.exec(filterString);\\n\\t\\t\\tif (!match || match.index !== p) {\\n\\t\\t\\t\\t// Broken filter\\n\\t\\t\\t\\treturn filterString;\\n\\t\\t\\t}\\n\\t\\t\\tif (match[1]) {\\n\\t\\t\\t\\t// Skip the named prefix\\n\\t\\t\\t\\tp += match[1].length;\\n\\t\\t\\t}\\n\\t\\t\\tif (match[4]) {\\n\\t\\t\\t\\t// It's a filter operation. Skip by [...]\\n\\t\\t\\t\\tif (filterString.charAt(p++) !== \\\"[\\\") {\\n\\t\\t\\t\\t\\treturn filterString;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tif(filterString.charAt(p) === \\\"!\\\") {\\n\\t\\t\\t\\t\\t\\tfilterString.charAt(p++);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Get the operator name\\n\\t\\t\\t\\t\\tnextBracketPos = filterString.substring(p).search(/[\\\\[\\\\{<\\\\/]/);\\n\\t\\t\\t\\t\\tif(nextBracketPos === -1) {\\n\\t\\t\\t\\t\\t\\treturn filterString;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnextBracketPos += p;\\n\\t\\t\\t\\t\\tvar bracket = filterString.charAt(nextBracketPos);\\n\\t\\t\\t\\t\\tnextBracketPos = filterString.indexOf(brackets[bracket], p);\\n\\t\\t\\t\\t\\tif (nextBracketPos === -1) {\\n\\t\\t\\t\\t\\t\\treturn filterString;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tp = nextBracketPos + 1;\\n\\t\\t\\t\\t} while (filterString.charAt(p++) !== \\\"]\\\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tp = match.index + match[0].length;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (replacements.length > 0) {\\n\\t\\treplacements.push(filterString.substr(replaceHead));\\n\\t\\treturn replacements.join(\\\"\\\");\\n\\t}\\n\\treturn filterString;\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/fieldtranscriber/filter.js\",\"type\":\"application/javascript\",\"module-type\":\"fieldtranscribertype\"},\"$:/plugins/flibbles/graph/widgets/fieldtranscriber/json.js\":{\"text\":\"/*\\\\\\n\\nType for transcribing application/json between text and field.\\n\\nFocuses on keeping dataTiddler style pretty printing for text, but puts all\\njson on one line for fields.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"application/json\\\";\\n\\nexports.toField = function(text) {\\n\\tif (!text) {\\n\\t\\treturn \\\"\\\";\\n\\t}\\n\\ttry {\\n\\t\\treturn JSON.stringify(JSON.parse(text));\\n\\t} catch {\\n\\t\\treturn \\\"{}\\\";\\n\\t}\\n};\\n\\nexports.fromField = function(text) {\\n\\tif (!text) {\\n\\t\\treturn \\\"\\\";\\n\\t}\\n\\ttry {\\n\\t\\treturn JSON.stringify(JSON.parse(text), null, $tw.config.preferences.jsonSpaces);\\n\\t} catch {\\n\\t\\treturn \\\"{}\\\";\\n\\t}\\n};\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/fieldtranscriber/json.js\",\"type\":\"application/javascript\",\"module-type\":\"fieldtranscribertype\"},\"$:/plugins/flibbles/graph/widgets/fieldtranscriber/plain.js\":{\"text\":\"/*\\\\\\n\\nType for transcribing text/plain between text and field.\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nexports.name = \\\"text/plain\\\";\\n\\nexports.fromField = exports.toField = function(text) { return text; };\\n\",\"title\":\"$:/plugins/flibbles/graph/widgets/fieldtranscriber/plain.js\",\"type\":\"application/javascript\",\"module-type\":\"fieldtranscribertype\"}}}","icon":"https://github.com/flibbles/tw5-graph/raw/refs/heads/master/tiddlers/Images/favicon.png"}