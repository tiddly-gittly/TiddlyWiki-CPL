{"type":"application/json","text":"{\n    \"tiddlers\": {\n        \"$:/core/modules/widgets/button-dragover-extend.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/button-dragover-extend.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nExtend the link widget to allow click when there is a drag over (option)\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar ButtonWidget = require(\\\"$:/core/modules/widgets/button.js\\\")[\\\"button\\\"];\\nButtonWidget.prototype.bjDragExtend ={};\\nButtonWidget.prototype.bjDragExtend.render = ButtonWidget.prototype.render;\\n\\nButtonWidget.prototype.render = function (parent,nextSibling) {\\n\\tButtonWidget.prototype.bjDragExtend.render.call(this,parent,nextSibling);\\n\\tif (this.dragoverclick===\\\"yes\\\") { \\n\\t\\t$tw.utils.addEventListeners(this.domNodes[0],[\\n\\t\\t\\t{name: \\\"dragover\\\", handlerObject: this, handlerMethod: \\\"handleDragOverEvent\\\"}\\n\\t\\t]);\\n\\t}\\n}\\n\\n/*\\nadd option\\n*/\\nButtonWidget.prototype.bjDragExtend.execute = ButtonWidget.prototype.execute;\\nButtonWidget.prototype.execute = function() {\\n\\tButtonWidget.prototype.bjDragExtend.execute.call(this);\\n\\tthis.dragoverclick=this.getAttribute(\\\"dragoverclick\\\",\\\"no\\\");\\n};\\n/*\\nhandle dragover\\n*/\\nButtonWidget.prototype.handleDragOverEvent  = function(event) {\\n\\t// Tell the browser that we're still interested in the drop\\n\\tevent.preventDefault();\\n\\t// Send the drag as click  as a navigate event\\n\\tvar bounds = this.domNodes[0].getBoundingClientRect();\\n\\tthis.dispatchEvent({\\n\\t\\ttype: \\\"tm-navigate\\\",\\n\\t\\tnavigateTo: this.to,\\n\\t\\tnavigateFromTitle: this.getVariable(\\\"storyTiddler\\\"),\\n\\t\\tnavigateFromNode: this,\\n\\t\\tnavigateFromClientRect: { top: bounds.top, left: bounds.left, width: bounds.width, right: bounds.right, bottom: bounds.bottom, height: bounds.height\\n\\t\\t},\\n\\t\\tnavigateSuppressNavigation: event.metaKey || event.ctrlKey\\n\\t});\\n\\tevent.preventDefault();\\n\\tevent.stopPropagation();\\n\\treturn false;\\n};\\n})();\\n\",\n            \"title\": \"$:/core/modules/widgets/button-dragover-extend.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/dropzone-extend.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/dropzone-extend.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nExtend the dropzone widget to allow other widget to handle drop events \\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n\\nvar DropZoneWidget = require(\\\"$:/core/modules/widgets/dropzone.js\\\")[\\\"dropzone\\\"];\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n/*\\nThe edit-text widget calls this method just after inserting its dom nodes\\n*/\\n/*\\noverload the base widget class initialise\\n*/\\nDropZoneWidget.prototype.bjDropzoneExtend ={};\\nDropZoneWidget.prototype.bjDropzoneExtend.initialise = DropZoneWidget.prototype.initialise;\\n\\nDropZoneWidget.prototype.initialise = function (parseTreeNode,options) {\\n\\tDropZoneWidget.prototype.bjDropzoneExtend.initialise.call(this,parseTreeNode,options);\\n\\tthis.addEventListeners([\\n\\t\\t{type: \\\"tm-dropHandled\\\", handler: \\\"handleDropHandled\\\"}]);\\n};\\n/*\\nhandle drophandled message\\n*/\\nDropZoneWidget.prototype.handleDropHandled = function(event) {\\n\\t// Reset the enter count\\n\\tthis.dragEnterCount = 0;\\n\\t// Remove highlighting\\n\\t$tw.utils.removeClass(this.domNodes[0],\\\"tc-dragover\\\");\\n\\treturn false;\\n};\\n\\n})();\\n\",\n            \"title\": \"$:/core/modules/widgets/dropzone-extend.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/bj/drag-and-drop/license\": {\n            \"title\": \"$:/plugins/bj/drag-and-drop/license\",\n            \"text\": \"The MIT License (MIT)\\n\\nCopyright (c) 2014 Jeffrey Wikinson aka buggyj\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy of\\nthis software and associated documentation files (the \\\"Software\\\"), to deal in\\nthe Software without restriction, including without limitation the rights to\\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\\nthe Software, and to permit persons to whom the Software is furnished to do so,\\nsubject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\"\n        },\n        \"$:/core/modules/widgets/link-dragover-extend.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/link-dragover-extend.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nExtend the link widget to allow click when there is a drag over (option)\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar LinkWidget = require(\\\"$:/core/modules/widgets/link.js\\\")[\\\"link\\\"];\\nLinkWidget.prototype.bjDragExtend ={};\\nLinkWidget.prototype.bjDragExtend.renderLink = LinkWidget.prototype.renderLink;\\n\\nLinkWidget.prototype.renderLink = function (parent,nextSibling) {\\n\\tLinkWidget.prototype.bjDragExtend.renderLink.call(this,parent,nextSibling);\\n\\tif (this.dragoverclick===\\\"yes\\\") { \\n\\t\\t$tw.utils.addEventListeners(this.domNodes[0],[\\n\\t\\t\\t{name: \\\"dragover\\\", handlerObject: this, handlerMethod: \\\"handleDragOverEvent\\\"}\\n\\t\\t]);\\n\\t}\\n}\\n\\n/*\\nadd option\\n*/\\nLinkWidget.prototype.bjDragExtend.execute = LinkWidget.prototype.execute;\\nLinkWidget.prototype.execute = function() {\\n\\tLinkWidget.prototype.bjDragExtend.execute.call(this);\\n\\tthis.dragoverclick=this.getAttribute(\\\"dragoverclic\\\",\\\"no\\\");\\n};\\n/*\\nhandle dragover\\n*/\\nLinkWidget.prototype.handleDragOverEvent  = function(event) {\\n\\t// Tell the browser that we're still interested in the drop\\n\\tevent.preventDefault();\\n\\t// Send the drag as click  as a navigate event\\n\\tvar bounds = this.domNodes[0].getBoundingClientRect();\\n\\tthis.dispatchEvent({\\n\\t\\ttype: \\\"tm-navigate\\\",\\n\\t\\tnavigateTo: this.to,\\n\\t\\tnavigateFromTitle: this.getVariable(\\\"storyTiddler\\\"),\\n\\t\\tnavigateFromNode: this,\\n\\t\\tnavigateFromClientRect: { top: bounds.top, left: bounds.left, width: bounds.width, right: bounds.right, bottom: bounds.bottom, height: bounds.height\\n\\t\\t},\\n\\t\\tnavigateSuppressNavigation: event.metaKey || event.ctrlKey\\n\\t});\\n\\tevent.preventDefault();\\n\\tevent.stopPropagation();\\n\\treturn false;\\n};\\n})();\\n\",\n            \"title\": \"$:/core/modules/widgets/link-dragover-extend.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/ondrop.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/ondrop.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nList and list item widgets\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\n/*\\nThe list widget creates list element sub-widgets that reach back into the list widget for their configuration\\n*/\\n\\nvar OnDrop = function(parseTreeNode,options) {\\n\\t// Main initialisation inherited from widget.js\\n\\tthis.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nOnDrop.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nOnDrop.prototype.render = function(parent,nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\t\\t// Add event handlers\\n\\t// Create element\\n\\tvar domNode = this.document.createElement(\\\"div\\\");\\n\\tdomNode.className = \\\"tc-dropzone\\\";\\n\\t$tw.utils.addEventListeners(domNode,[\\n\\t\\t{name: \\\"drop\\\", handlerObject: this, handlerMethod: \\\"handleDropEvent\\\"}\\n\\t\\t]);\\n\\t// Insert element\\n\\tparent.insertBefore(domNode,nextSibling);\\n\\tthis.renderChildren(domNode,null);\\n\\tthis.domNodes.push(domNode);\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nOnDrop.prototype.execute = function() {\\n\\tthis.listtag = this.getAttribute(\\\"targeTtag\\\",this.getVariable(\\\"currentTiddler\\\"));\\n    this.onAddMessage = this.getAttribute(\\\"onAddMessage\\\");\\n    this.action = this.getAttribute(\\\"tagAction\\\"); \\n\\t// Make child widgets\\n\\tthis.makeChildWidgets();\\n};\\n\\n/*\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n*/\\nOnDrop.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\t// Completely refresh if any of our attributes have changed\\n\\tif(changedAttributes.tagAction || changedAttributes.onAddMessage) {\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t} else {\\n\\treturn this.refreshChildren(changedTiddlers);\\n\\t}\\n};\\nOnDrop.prototype.addTag = function (tidname) {\\n\\t\\tvar tiddler = this.wiki.getTiddler(tidname);\\n\\t\\tvar modification = this.wiki.getModificationFields();\\n\\t\\tmodification.tags = (tiddler.fields.tags || []).slice(0);\\n\\t\\t$tw.utils.pushTop(modification.tags,this.listtag);\\n\\t\\tthis.wiki.addTiddler(new $tw.Tiddler(tiddler,modification));\\n\\t\\t\\t\\n}\\n\\nOnDrop.prototype.removeTag = function (tidname) {\\n\\t\\tvar tiddler = this.wiki.getTiddler(tidname);\\n\\t\\tvar p = tiddler.fields.tags.indexOf(this.listtag);\\n\\t\\tif(p !== -1) {\\n\\t\\t\\tvar modification = this.wiki.getModificationFields();\\n\\t\\t\\tmodification.tags = (tiddler.fields.tags || []).slice(0);\\n\\t\\t\\tmodification.tags.splice(p,1);\\n\\t\\t\\tif(modification.tags.length === 0) {\\n\\t\\t\\t\\tmodification.tags = undefined;\\n\\t\\t\\t}\\n\\t\\tthis.wiki.addTiddler(new $tw.Tiddler(tiddler,modification));\\n\\t\\t}\\t\\n}\\n\\nOnDrop.prototype.handleDropEvent  = function(event) {\\n\\tvar self = this,\\n\\t\\tdataTransfer = event.dataTransfer, returned={};\\n\\t\\treturned = self.nameandOnListTag(dataTransfer);\\n\\t\\n\\tif (!!returned.name) { //only handle tiddler drops\\n\\t\\t if (!returned.onList) { //this means tiddler does not have the tag\\n\\t\\t\\tif (self.action === 'addtag') self.addTag(returned.name);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (self.action === 'removetag') self.removeTag(returned.name);\\n\\t\\t}\\n\\t\\t //cancel normal action\\n\\t\\t self.cancelAction(event);\\n\\n\\t\\t self.dispatchEvent({type: \\\"tm-dropHandled\\\", param: null});\\n\\t if (self.onAddMessage) self.dispatchEvent({type: self.onAddMessage, param: returned.name});\\n\\t }\\n\\t //else let the event fall thru\\n};\\nOnDrop.prototype.importDataTypes = [\\n\\t{type: \\\"text/vnd.tiddler\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\treturn JSON.parse(data);\\n\\t}},\\n\\t{type: \\\"URL\\\", IECompatible: true, convertToFields: function(data) {\\n\\t\\t// Check for tiddler data URI\\n\\t\\tvar match = decodeURI(data).match(/^data\\\\:text\\\\/vnd\\\\.tiddler,(.*)/i);\\n\\t\\tif(match) {\\n\\t\\t\\treturn JSON.parse(match[1]);\\n\\t\\t} else {\\n\\t\\t\\treturn { // As URL string\\n\\t\\t\\t\\ttext: data\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}},\\n\\t{type: \\\"text/x-moz-url\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\t// Check for tiddler data URI\\n\\t\\tvar match = decodeURI(data).match(/^data\\\\:text\\\\/vnd\\\\.tiddler,(.*)/i);\\n\\t\\tif(match) {\\n\\t\\t\\treturn JSON.parse(match[1]);\\n\\t\\t} else {\\n\\t\\t\\treturn { // As URL string\\n\\t\\t\\t\\ttext: data\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}},\\n\\t{type: \\\"text/plain\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\treturn {\\n\\t\\t\\ttext: data\\n\\t\\t};\\n\\t}},\\n\\t{type: \\\"Text\\\", IECompatible: true, convertToFields: function(data) {\\n\\t\\treturn {\\n\\t\\t\\ttext: data\\n\\t\\t};\\n\\t}},\\n\\t{type: \\\"text/uri-list\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\treturn {\\n\\t\\t\\ttext: data\\n\\t\\t};\\n\\t}}\\n];\\nOnDrop.prototype.cancelAction =function(event) {\\n\\t// Try each provided data type in turn\\n\\t\\t{\\n\\tvar dataTransfer = event.dataTransfer;\\n\\tevent.preventDefault();\\n\\t// Stop the drop ripple up to any parent handlers\\n\\tevent.stopPropagation();\\n};\\n};\\n\\nOnDrop.prototype.nameandOnListTag = function(dataTransfer) {\\n\\t// Try each provided data type in turn\\n\\tfor(var t=0; t<this.importDataTypes.length; t++) {\\n\\t\\tif(!$tw.browser.isIE || this.importDataTypes[t].IECompatible) {\\n\\t\\t\\t// Get the data\\n\\t\\t\\tvar dataType = this.importDataTypes[t];\\n\\t\\t\\tvar data = dataTransfer.getData(dataType.type);\\n\\t\\t\\t// Import the tiddlers in the data);\\n\\t\\t\\tif(data !== \\\"\\\" && data !== null) {\\n\\t\\t\\t\\tvar tiddlerFields = dataType.convertToFields(data);\\n\\t\\t\\t\\tif(!tiddlerFields.title) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (tiddlerFields.tags && $tw.utils.parseStringArray(tiddlerFields.tags).indexOf(this.listtag) !== -1) {\\n\\t\\t\\t\\t\\treturn {name:tiddlerFields.title, onList:true};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {//we have to add the tag to the tiddler\\n\\t\\t\\t\\t\\tif (!!this.wiki.getTiddler(tiddlerFields.title)){//tid is in this tw\\n\\t\\t\\t\\t\\t\\treturn {name:tiddlerFields.title, onList:false};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t//return false; \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\treturn  {name:null, onList:false};\\n};\\nexports.ondrop = OnDrop;\\n})();\\n\\n\",\n            \"title\": \"$:/core/modules/widgets/ondrop.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/bj/drag-and-drop/readme\": {\n            \"title\": \"$:/plugins/bj/drag-and-drop/readme\",\n            \"text\": \"!!!Drag and Drop Widgets\\n\\nPlugin contains the following widgets\\n\\n# taglist - re-orderable list of tiddlers with the same tag. Api parameters:\\n#* targettag - name of the lists tag\\n#* template - The title of a template tiddler for transcluding each tiddler in the list. When no template is specified, the body of the widget serves as the item template. With no body, a simple link to the tiddler is returned.\\n#* variable - The name for a variable in which the title of each listed tiddler is stored. Defaults to currentTiddler\\n#* nodrop - drops are ignored\\n#* htmltag - enclosing html element for list items\\n# ondrop - and or remove tags in response to a drop event. Api parameters:\\n#* targeTtag name of tag to act with. \\n#* tagAction can be set to addtag or removetag\\n\\nThis plugin also adds ondragover click events to the link and button widgets. \\n\"\n        },\n        \"$:/core/modules/widgets/taglist.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/taglist.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nList and list item widgets\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\n/*\\nThe list widget creates list element sub-widgets that reach back into the list widget for their configuration\\n*/\\n\\nvar TagListWidget = function(parseTreeNode,options) {\\n\\t// Initialise the storyviews if they've not been done already\\n\\tif(!this.storyViews) {\\n\\t\\tTagListWidget.prototype.storyViews = {};\\n\\t\\t$tw.modules.applyMethods(\\\"storyview\\\",this.storyViews);\\n\\t}\\n\\t// Main initialisation inherited from widget.js\\n\\tthis.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nTagListWidget.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nTagListWidget.prototype.render = function(parent,nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.renderChildren(parent,nextSibling);\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nTagListWidget.prototype.execute = function() {\\n\\t// Get our attributes\\n\\tthis.template = this.getAttribute(\\\"template\\\");\\n\\tthis.editTemplate = this.getAttribute(\\\"editTemplate\\\");\\n\\tthis.variableName = this.getAttribute(\\\"variable\\\",\\\"currentTiddler\\\");\\n\\tthis.nodrop = this.getAttribute(\\\"nodrop\\\");\\n\\tthis.htmltag = this.getAttribute(\\\"htmltag\\\");\\n\\tthis.static = this.getAttribute(\\\"static\\\"); \\n\\tthis.listtag=this.getAttribute(\\\"targeTtag\\\",this.getVariable(\\\"currentTiddler\\\"));\\n\\tthis.listtag=this.getAttribute(\\\"targettag\\\",this.listtag);\\n\\t// Compose the list elements\\n\\tthis.list = this.getTiddlerList();\\n\\tvar members = [],\\n\\t\\tself = this;\\n\\t// Check for an empty list\\n\\tif(this.list.length === 0) {\\n\\t\\tmembers = this.getEmptyMessage();\\n\\t} else {\\n\\t\\t$tw.utils.each(this.list,function(title,index) {\\n\\t\\t\\tmembers.push(self.makeItemTemplate(title));\\n\\t\\t});\\n\\t}\\n\\t// Construct the child widgets\\n\\tthis.makeChildWidgets(members);\\n};\\n\\nTagListWidget.prototype.getTiddlerList = function() {\\n\\tvar defaultFilter = \\\"[tag[\\\"+this.listtag+\\\"]]\\\";\\n\\treturn this.wiki.filterTiddlers(this.getAttribute(\\\"filter\\\",defaultFilter),this);//BJ FIXME should not allow user defined filters\\n};\\nTagListWidget.prototype.setTiddlerList = function(what,where) {\\n\\tvar self = this;\\n\\tif (this.nodrop || this.static) return;\\n\\tvar update = function(value) {\\n\\t\\tvar tiddler = self.wiki.getTiddler(self.listtag)||{title:self.listtag},\\n\\t\\t\\tupdateFields = {};\\n\\t\\t\\n\\t\\tupdateFields[\\\"list\\\"] = value;\\n\\t\\tself.wiki.addTiddler(new $tw.Tiddler(self.wiki.getCreationFields(),tiddler,updateFields,\\n\\t\\tself.wiki.getModificationFields()));\\n\\t};\\n\\tvar newlist=[],\\n\\t\\tj=0;\\n\\t\\n\\tfor (var i=0;i<this.list.length;i++) {\\n\\t\\tif (this.list[i]===what) continue;\\n\\t\\tif (this.list[i]===where) {\\n\\t\\t\\tnewlist[j]=what;\\n\\t\\t\\tj++; \\n\\t\\t}\\n\\t\\tnewlist[j]=this.list[i];\\n\\t\\tj++; \\n\\t}\\n\\tupdate(newlist);\\n};\\n\\nTagListWidget.prototype.getEmptyMessage = function() {\\n\\tvar emptyMessage = this.getAttribute(\\\"emptyMessage\\\",\\\"\\\"),\\n\\t\\tparser = this.wiki.parseText(\\\"text/vnd.tiddlywiki\\\",emptyMessage,{parseAsInline: true});\\n\\tif(parser) {\\n\\t\\treturn parser.tree;\\n\\t} else {\\n\\t\\treturn [];\\n\\t}\\n};\\n\\n/*\\nCompose the template for a list item\\n*/\\nTagListWidget.prototype.makeItemTemplate = function(title) {\\n\\t// Check if the tiddler is a draft\\n\\tvar tiddler = this.wiki.getTiddler(title),\\n\\t\\tisDraft = tiddler && tiddler.hasField(\\\"draft.of\\\"),\\n\\t\\ttemplate = this.template,\\n\\t\\ttemplateTree;\\n\\tif(isDraft && this.editTemplate) {\\n\\t\\ttemplate = this.editTemplate;\\n\\t}\\n\\t// Compose the transclusion of the template\\n\\tif(template) {\\n\\t\\ttemplateTree = [{type: \\\"transclude\\\", attributes: {tiddler: {type: \\\"string\\\", value: template}}}];\\n\\t} else {\\n\\t\\tif(this.parseTreeNode.children && this.parseTreeNode.children.length > 0) {\\n\\t\\t\\ttemplateTree = this.parseTreeNode.children;\\n\\t\\t} else {\\n\\t\\t\\t// Default template is a link to the title\\n\\t\\t\\ttemplateTree = [{type: \\\"element\\\", tag: this.parseTreeNode.isBlock ? \\\"div\\\" : \\\"span\\\", children: [{type: \\\"link\\\", attributes: {to: {type: \\\"string\\\", value: title}}, children: [\\n\\t\\t\\t\\t\\t{type: \\\"text\\\", text: title}\\n\\t\\t\\t]}]}];\\n\\t\\t}\\n\\t}\\n\\t// Return the list item\\n\\tif (this.nodrop) return {type: \\\"taglistitem\\\", itemTitle: title, variableName: this.variableName, children: templateTree, listtag:null};\\n\\treturn {type: \\\"taglistitem\\\", itemTitle: title, variableName: this.variableName, children: templateTree, listtag:this.listtag, htmltag:this.htmltag};\\n};\\n\\n/*\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n*/\\nTagListWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\t// Completely refresh if any of our attributes have changed\\n\\tif(changedAttributes.filter || changedAttributes.template || changedAttributes.editTemplate || changedAttributes.emptyMessage || changedAttributes.storyview || changedAttributes.targeTtag) {\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t} else {\\n\\t\\t// Handle any changes to the list\\n\\t\\tvar hasChanged = this.handleListChanges(changedTiddlers);\\n\\t\\treturn hasChanged;\\n\\t}\\n};\\n\\n\\n/*\\nProcess any changes to the list\\n*/\\nTagListWidget.prototype.handleListChanges = function(changedTiddlers) {\\n\\t// Get the new list\\n\\tvar prevList = this.list;\\n\\tthis.list = this.getTiddlerList();//alert(this.list);\\n\\tvar redolist = false;\\n\\n\\t// Check for an empty list\\n\\tif(this.list.length === 0) {\\n\\t\\t// Check if it was empty before\\n\\t\\tif(prevList.length === 0) {\\n\\t\\t\\t// If so, just refresh the empty message\\n\\t\\t\\treturn this.refreshChildren(changedTiddlers);\\n\\t\\t} else {\\n\\t\\t\\t// Replace the previous content with the empty message\\n\\t\\t\\tfor(var t=this.children.length-1; t>=0; t--) {\\n\\t\\t\\t\\tthis.removeListItem(t);\\n\\t\\t\\t}\\n\\t\\t\\tvar nextSibling = this.findNextSiblingDomNode();\\n\\t\\t\\tthis.makeChildWidgets(this.getEmptyMessage());\\n\\t\\t\\tthis.renderChildren(this.parentDomNode,nextSibling);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t} else {\\n\\t\\t// If the list was empty then we need to remove the empty message\\n\\t\\tif(prevList.length === 0) \\n\\t\\t{\\n\\t\\t\\tthis.removeChildDomNodes();\\n\\t\\t\\tthis.children = [];\\n\\t\\t}\\n\\t\\tif (prevList.length!==this.list.length) {\\n\\t\\t\\tredolist = true;\\n\\t\\t} else {\\n\\t\\t\\tvar t;\\n\\t\\t\\tfor(t=0; t<this.list.length; t++) {\\n\\t\\t\\t\\tif (prevList[t]!==this.list[t]) {//compare tid titles\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t}\\n\\t\\t\\tif ( t!==this.list.length ){\\n\\t\\t\\t\\tredolist = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar hasRefreshed = false;\\n\\t\\tif (redolist === true) {\\n\\t\\t\\tvar hasRefreshed = true;\\n\\t\\t\\tfor(var t=this.children.length-1; t>=0; t--) {\\n\\t\\t\\t\\tthis.removeListItem(t);\\n\\t\\t\\t}\\n\\t\\t\\tfor(var t=0; t<this.list.length; t++) {\\n\\t\\t\\t\\t\\tthis.insertListItem(t,this.list[t]);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\treturn this.refreshChildren(changedTiddlers);\\n\\t\\t}\\n\\t\\treturn hasRefreshed;\\n\\t}\\n};\\n\\n/*\\nFind the list item with a given title, starting from a specified position\\n*/\\nTagListWidget.prototype.findListItem = function(startIndex,title) {\\n\\twhile(startIndex < this.children.length) {\\n\\t\\tif(this.children[startIndex].parseTreeNode.itemTitle === title) {\\n\\t\\t\\treturn startIndex;\\n\\t\\t}\\n\\t\\tstartIndex++;\\n\\t}\\n\\treturn undefined;\\n};\\n\\n/*\\nInsert a new list item at the specified index\\n*/\\nTagListWidget.prototype.insertListItem = function(index,title) {\\n\\t// Create, insert and render the new child widgets\\n\\tvar widget = this.makeChildWidget(this.makeItemTemplate(title));\\n\\twidget.parentDomNode = this.parentDomNode; // Hack to enable findNextSiblingDomNode() to work\\n\\tthis.children.splice(index,0,widget);\\n\\tvar nextSibling = widget.findNextSiblingDomNode();\\n\\twidget.render(this.parentDomNode,nextSibling);\\n\\t// Animate the insertion if required\\n\\tif(this.storyview && this.storyview.insert) {\\n\\t\\tthis.storyview.insert(widget);\\n\\t}\\n\\treturn true;\\n};\\n\\n/*\\nRemove the specified list item\\n*/\\nTagListWidget.prototype.removeListItem = function(index) {\\n\\tvar widget = this.children[index];\\n\\t// Animate the removal if required\\n\\tif(this.storyview && this.storyview.remove) {\\n\\t\\tthis.storyview.remove(widget);\\n\\t} else {\\n\\t\\twidget.removeChildDomNodes();\\n\\t}\\n\\t// Remove the child widget\\n\\tthis.children.splice(index,1);\\n};\\n\\nexports.taglist = TagListWidget;\\n\\nvar TagListItemWidget = function(parseTreeNode,options) {\\n\\tthis.initialise(parseTreeNode,options);\\n\\tthis.nodrop = this.parseTreeNode.listtag;\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nTagListItemWidget.prototype = new Widget();\\nTagListItemWidget.prototype.addTag = function (tidname) {\\n\\t\\tvar tiddler = this.wiki.getTiddler(tidname);\\n\\t\\tvar modification = this.wiki.getModificationFields();\\n\\t\\tmodification.tags = (tiddler.fields.tags || []).slice(0);\\n\\t\\t$tw.utils.pushTop(modification.tags,this.parseTreeNode.listtag);\\n\\t\\tthis.wiki.addTiddler(new $tw.Tiddler(tiddler,modification));\\n\\t\\t\\t\\n}\\nTagListItemWidget.prototype.handleDropEvent  = function(event) {\\n\\tvar self = this,\\n\\t\\tdataTransfer = event.dataTransfer,\\n\\t\\treturned = this.nameandOnListTag(dataTransfer);\\n\\tif (!this.nodrop) {\\n\\t\\tthis.cancelAction(event);\\n\\t\\tself.dispatchEvent({type: \\\"tm-dropHandled\\\", param: null});\\n\\t\\treturn;\\n\\t}\\n\\tif (!!returned.name) { //only handle tiddler drops\\n\\t\\t if (!returned.onList) { //this means tiddler does not have the tag\\n\\t\\t\\t this.addTag(returned.name);\\n\\t\\t }\\n\\t\\t this.parentWidget.setTiddlerList(returned.name, this.parseTreeNode.itemTitle);\\n\\n\\t\\t //cancel normal action\\n\\t\\t this.cancelAction(event);\\n\\t\\t self.dispatchEvent({type: \\\"tm-dropHandled\\\", param: null});\\n\\n\\t }\\n\\t //else let the event fall thru\\n};\\nTagListItemWidget.prototype.importDataTypes = [\\n\\t{type: \\\"text/vnd.tiddler\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\treturn JSON.parse(data);\\n\\t}},\\n\\t{type: \\\"URL\\\", IECompatible: true, convertToFields: function(data) {\\n\\t\\t// Check for tiddler data URI\\n\\t\\tvar match = decodeURIComponent(data).match(/^data\\\\:text\\\\/vnd\\\\.tiddler,(.*)/i);\\n\\t\\tif(match) {\\n\\t\\t\\treturn JSON.parse(match[1]);\\n\\t\\t} else {\\n\\t\\t\\treturn { // As URL string\\n\\t\\t\\t\\ttext: data\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}},\\n\\t{type: \\\"text/x-moz-url\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\t// Check for tiddler data URI\\n\\t\\tvar match = decodeURIComponent(data).match(/^data\\\\:text\\\\/vnd\\\\.tiddler,(.*)/i);\\n\\t\\tif(match) {\\n\\t\\t\\treturn JSON.parse(match[1]);\\n\\t\\t} else {\\n\\t\\t\\treturn { // As URL string\\n\\t\\t\\t\\ttext: data\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}},\\n\\t{type: \\\"text/plain\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\treturn {\\n\\t\\t\\ttext: data\\n\\t\\t};\\n\\t}},\\n\\t{type: \\\"Text\\\", IECompatible: true, convertToFields: function(data) {\\n\\t\\treturn {\\n\\t\\t\\ttext: data\\n\\t\\t};\\n\\t}},\\n\\t{type: \\\"text/uri-list\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\treturn {\\n\\t\\t\\ttext: data\\n\\t\\t};\\n\\t}}\\n];\\nTagListItemWidget.prototype.cancelAction =function(event) {\\n\\t// Try each provided data type in turn\\n\\t\\t{\\n\\tvar self = this,\\n\\t\\tdataTransfer = event.dataTransfer;\\n\\tevent.preventDefault();\\n\\t// Stop the drop ripple up to any parent handlers\\n\\tevent.stopPropagation();\\n};\\n};\\n\\n\\nTagListItemWidget.prototype.nameandOnListTag = function(dataTransfer) {\\n\\t// Try each provided data type in turn\\n\\tvar self = this;\\n\\tfor(var t=0; t<this.importDataTypes.length; t++) {\\n\\t\\tif(!$tw.browser.isIE || this.importDataTypes[t].IECompatible) {\\n\\t\\t\\t// Get the data\\n\\t\\t\\tvar dataType = this.importDataTypes[t];\\n\\t\\t\\tvar data = dataTransfer.getData(dataType.type);\\n\\t\\t\\t// Import the tiddlers in the data\\n\\t\\t\\tif(data !== \\\"\\\" && data !== null) {\\n\\t\\t\\t\\tvar tiddlerFields = dataType.convertToFields(data);\\n\\t\\t\\t\\tif(!tiddlerFields.title) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (tiddlerFields.tags && $tw.utils.parseStringArray(tiddlerFields.tags).indexOf(self.parseTreeNode.listtag) !== -1) {\\n\\t\\t\\t\\t\\treturn {name:tiddlerFields.title, onList:true};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {//we have to add the tag to the tiddler\\n\\t\\t\\t\\t\\tif (!!self.wiki.getTiddler(tiddlerFields.title)){//tid is in this tw\\n\\t\\t\\t\\t\\t\\treturn {name:tiddlerFields.title, onList:false};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t//return false; \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}else alert(\\\"not found\\\");\\n\\t};\\n\\treturn  {name:null, onList:false};\\n};\\n/*\\nRender this widget into the DOM\\n*/\\nTagListItemWidget.prototype.render = function(parent,nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\t\\n\\tvar tag = \\\"div\\\";\\n\\tif(this.parseTreeNode.htmltag && $tw.config.htmlUnsafeElements.indexOf(this.revealTag) === -1) {\\n\\t\\ttag = this.parseTreeNode.htmltag;\\n\\t}\\nvar domNode = this.document.createElement(tag);\\n\\t// Add event handlers\\n\\t$tw.utils.addEventListeners(domNode,[\\n\\t\\t{name: \\\"dragover\\\", handlerObject: this, handlerMethod: \\\"handleDragOverEvent\\\"},\\t\\t\\n\\t\\t{name: \\\"drop\\\", handlerObject: this, handlerMethod: \\\"handleDropEvent\\\"}\\n\\t\\t]);\\n\\t// Insert element\\n\\tparent.insertBefore(domNode,nextSibling);\\n\\tthis.renderChildren(domNode,null);\\n\\tthis.domNodes.push(domNode);\\n};\\n\\n\\nTagListItemWidget.prototype.handleDragOverEvent  = function(event) {\\n//alert(\\\"OVER\\\")\\n\\t// Tell the browser that we're still interested in the drop\\n\\tevent.preventDefault();\\n\\tevent.dataTransfer.dropEffect = \\\"copy\\\";\\n};\\n/*\\nCompute the internal state of the widget\\n*/\\nTagListItemWidget.prototype.execute = function() {\\n\\t// Set the current list item title\\n\\tthis.setVariable(this.parseTreeNode.variableName,this.parseTreeNode.itemTitle);\\n\\t// Construct the child widgets\\n\\tthis.makeChildWidgets();\\n};\\n\\n/*\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n*/\\nTagListItemWidget.prototype.refresh = function(changedTiddlers) {\\n\\treturn this.refreshChildren(changedTiddlers);\\n};\\n\\nexports.taglistitem = TagListItemWidget;\\n\\n})();\\n\",\n            \"title\": \"$:/core/modules/widgets/taglist.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        }\n    }\n}","author":"Jeffrey Wilkinson aka buggyj","bag":"default","core-version":">=5.1.11","dependents":"","description":"drag and drop widgets","list":"readme license","plugin-type":"plugin","revision":"0","source":"https://github.com/buggyj/TW5-tools","title":"$:/plugins/bj/drag-and-drop","version":"1.11.0","name":"drag-and-drop"}