{"type":"application/json","text":"{\n    \"tiddlers\": {\n        \"$:/plugins/rboue/Three.js/Lib/SimplexNoise.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/SimplexNoise.js\",\n            \"module-type\": \"library\",\n            \"text\": \"// Ported from Stefan Gustavson's java implementation\\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\\n// Read Stefan's excellent paper for details on how this code works.\\n//\\n// Sean McCullough banksean@gmail.com\\n//\\n// Added 4D noise\\n// Joshua Koo zz85nus@gmail.com \\n\\n/**\\n * You can pass in a random number generator object if you like.\\n * It is assumed to have a random() method.\\n */\\nvar SimplexNoise = function(r) {\\n\\tif (r == undefined) r = Math;\\n  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], \\n                                 [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], \\n                                 [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; \\n\\n  this.grad4 = [[0,1,1,1], [0,1,1,-1], [0,1,-1,1], [0,1,-1,-1],\\n\\t     [0,-1,1,1], [0,-1,1,-1], [0,-1,-1,1], [0,-1,-1,-1],\\n\\t     [1,0,1,1], [1,0,1,-1], [1,0,-1,1], [1,0,-1,-1],\\n\\t     [-1,0,1,1], [-1,0,1,-1], [-1,0,-1,1], [-1,0,-1,-1],\\n\\t     [1,1,0,1], [1,1,0,-1], [1,-1,0,1], [1,-1,0,-1],\\n\\t     [-1,1,0,1], [-1,1,0,-1], [-1,-1,0,1], [-1,-1,0,-1],\\n\\t     [1,1,1,0], [1,1,-1,0], [1,-1,1,0], [1,-1,-1,0],\\n\\t     [-1,1,1,0], [-1,1,-1,0], [-1,-1,1,0], [-1,-1,-1,0]];\\n\\n  this.p = [];\\n  for (var i=0; i<256; i++) {\\n\\t  this.p[i] = Math.floor(r.random()*256);\\n  }\\n  // To remove the need for index wrapping, double the permutation table length \\n  this.perm = []; \\n  for(var i=0; i<512; i++) {\\n\\t\\tthis.perm[i]=this.p[i & 255];\\n\\t} \\n\\n  // A lookup table to traverse the simplex around a given point in 4D. \\n  // Details can be found where this table is used, in the 4D noise method. \\n  this.simplex = [ \\n    [0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0], \\n    [0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0], \\n    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0], \\n    [1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0], \\n    [1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0], \\n    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0], \\n    [2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0], \\n    [2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]; \\n};\\n\\nSimplexNoise.prototype.dot = function(g, x, y) { \\n\\treturn g[0]*x + g[1]*y;\\n};\\n\\nSimplexNoise.prototype.dot3 = function(g, x, y, z) {\\n  return g[0]*x + g[1]*y + g[2]*z; \\n}\\n\\nSimplexNoise.prototype.dot4 = function(g, x, y, z, w) {\\n  return g[0]*x + g[1]*y + g[2]*z + g[3]*w;\\n};\\n\\nSimplexNoise.prototype.noise = function(xin, yin) { \\n  var n0, n1, n2; // Noise contributions from the three corners \\n  // Skew the input space to determine which simplex cell we're in \\n  var F2 = 0.5*(Math.sqrt(3.0)-1.0); \\n  var s = (xin+yin)*F2; // Hairy factor for 2D \\n  var i = Math.floor(xin+s); \\n  var j = Math.floor(yin+s); \\n  var G2 = (3.0-Math.sqrt(3.0))/6.0; \\n  var t = (i+j)*G2; \\n  var X0 = i-t; // Unskew the cell origin back to (x,y) space \\n  var Y0 = j-t; \\n  var x0 = xin-X0; // The x,y distances from the cell origin \\n  var y0 = yin-Y0; \\n  // For the 2D case, the simplex shape is an equilateral triangle. \\n  // Determine which simplex we are in. \\n  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords \\n  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1) \\n  else {i1=0; j1=1;}      // upper triangle, YX order: (0,0)->(0,1)->(1,1) \\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and \\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where \\n  // c = (3-sqrt(3))/6 \\n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords \\n  var y1 = y0 - j1 + G2; \\n  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords \\n  var y2 = y0 - 1.0 + 2.0 * G2; \\n  // Work out the hashed gradient indices of the three simplex corners \\n  var ii = i & 255; \\n  var jj = j & 255; \\n  var gi0 = this.perm[ii+this.perm[jj]] % 12; \\n  var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12; \\n  var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12; \\n  // Calculate the contribution from the three corners \\n  var t0 = 0.5 - x0*x0-y0*y0; \\n  if(t0<0) n0 = 0.0; \\n  else { \\n    t0 *= t0; \\n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient \\n  } \\n  var t1 = 0.5 - x1*x1-y1*y1; \\n  if(t1<0) n1 = 0.0; \\n  else { \\n    t1 *= t1; \\n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); \\n  }\\n  var t2 = 0.5 - x2*x2-y2*y2; \\n  if(t2<0) n2 = 0.0; \\n  else { \\n    t2 *= t2; \\n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); \\n  } \\n  // Add contributions from each corner to get the final noise value. \\n  // The result is scaled to return values in the interval [-1,1]. \\n  return 70.0 * (n0 + n1 + n2); \\n};\\n\\n// 3D simplex noise \\nSimplexNoise.prototype.noise3d = function(xin, yin, zin) { \\n  var n0, n1, n2, n3; // Noise contributions from the four corners \\n  // Skew the input space to determine which simplex cell we're in \\n  var F3 = 1.0/3.0; \\n  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D \\n  var i = Math.floor(xin+s); \\n  var j = Math.floor(yin+s); \\n  var k = Math.floor(zin+s); \\n  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too \\n  var t = (i+j+k)*G3; \\n  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space \\n  var Y0 = j-t; \\n  var Z0 = k-t; \\n  var x0 = xin-X0; // The x,y,z distances from the cell origin \\n  var y0 = yin-Y0; \\n  var z0 = zin-Z0; \\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron. \\n  // Determine which simplex we are in. \\n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords \\n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords \\n  if(x0>=y0) { \\n    if(y0>=z0) \\n      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order \\n      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order \\n      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order \\n    } \\n  else { // x0<y0 \\n    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order \\n    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order \\n    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order \\n  } \\n  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z), \\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and \\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where \\n  // c = 1/6.\\n  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords \\n  var y1 = y0 - j1 + G3; \\n  var z1 = z0 - k1 + G3; \\n  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords \\n  var y2 = y0 - j2 + 2.0*G3; \\n  var z2 = z0 - k2 + 2.0*G3; \\n  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords \\n  var y3 = y0 - 1.0 + 3.0*G3; \\n  var z3 = z0 - 1.0 + 3.0*G3; \\n  // Work out the hashed gradient indices of the four simplex corners \\n  var ii = i & 255; \\n  var jj = j & 255; \\n  var kk = k & 255; \\n  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12; \\n  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12; \\n  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12; \\n  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12; \\n  // Calculate the contribution from the four corners \\n  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0; \\n  if(t0<0) n0 = 0.0; \\n  else { \\n    t0 *= t0; \\n    n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0); \\n  }\\n  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1; \\n  if(t1<0) n1 = 0.0; \\n  else { \\n    t1 *= t1; \\n    n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1); \\n  } \\n  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2; \\n  if(t2<0) n2 = 0.0; \\n  else { \\n    t2 *= t2; \\n    n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2); \\n  } \\n  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3; \\n  if(t3<0) n3 = 0.0; \\n  else { \\n    t3 *= t3; \\n    n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3); \\n  } \\n  // Add contributions from each corner to get the final noise value. \\n  // The result is scaled to stay just inside [-1,1] \\n  return 32.0*(n0 + n1 + n2 + n3); \\n};\\n\\n// 4D simplex noise\\nSimplexNoise.prototype.noise4d = function( x, y, z, w ) {\\n\\t// For faster and easier lookups\\n\\tvar grad4 = this.grad4;\\n\\tvar simplex = this.simplex;\\n\\tvar perm = this.perm;\\n\\t\\n   // The skewing and unskewing factors are hairy again for the 4D case\\n   var F4 = (Math.sqrt(5.0)-1.0)/4.0;\\n   var G4 = (5.0-Math.sqrt(5.0))/20.0;\\n   var n0, n1, n2, n3, n4; // Noise contributions from the five corners\\n   // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\\n   var s = (x + y + z + w) * F4; // Factor for 4D skewing\\n   var i = Math.floor(x + s);\\n   var j = Math.floor(y + s);\\n   var k = Math.floor(z + s);\\n   var l = Math.floor(w + s);\\n   var t = (i + j + k + l) * G4; // Factor for 4D unskewing\\n   var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\\n   var Y0 = j - t;\\n   var Z0 = k - t;\\n   var W0 = l - t;\\n   var x0 = x - X0;  // The x,y,z,w distances from the cell origin\\n   var y0 = y - Y0;\\n   var z0 = z - Z0;\\n   var w0 = w - W0;\\n\\n   // For the 4D case, the simplex is a 4D shape I won't even try to describe.\\n   // To find out which of the 24 possible simplices we're in, we need to\\n   // determine the magnitude ordering of x0, y0, z0 and w0.\\n   // The method below is a good way of finding the ordering of x,y,z,w and\\n   // then find the correct traversal order for the simplex weâ€™re in.\\n   // First, six pair-wise comparisons are performed between each possible pair\\n   // of the four coordinates, and the results are used to add up binary bits\\n   // for an integer index.\\n   var c1 = (x0 > y0) ? 32 : 0;\\n   var c2 = (x0 > z0) ? 16 : 0;\\n   var c3 = (y0 > z0) ? 8 : 0;\\n   var c4 = (x0 > w0) ? 4 : 0;\\n   var c5 = (y0 > w0) ? 2 : 0;\\n   var c6 = (z0 > w0) ? 1 : 0;\\n   var c = c1 + c2 + c3 + c4 + c5 + c6;\\n   var i1, j1, k1, l1; // The integer offsets for the second simplex corner\\n   var i2, j2, k2, l2; // The integer offsets for the third simplex corner\\n   var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\\n   // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\\n   // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\\n   // impossible. Only the 24 indices which have non-zero entries make any sense.\\n   // We use a thresholding to set the coordinates in turn from the largest magnitude.\\n   // The number 3 in the \\\"simplex\\\" array is at the position of the largest coordinate.\\n   i1 = simplex[c][0]>=3 ? 1 : 0;\\n   j1 = simplex[c][1]>=3 ? 1 : 0;\\n   k1 = simplex[c][2]>=3 ? 1 : 0;\\n   l1 = simplex[c][3]>=3 ? 1 : 0;\\n   // The number 2 in the \\\"simplex\\\" array is at the second largest coordinate.\\n   i2 = simplex[c][0]>=2 ? 1 : 0;\\n   j2 = simplex[c][1]>=2 ? 1 : 0;    k2 = simplex[c][2]>=2 ? 1 : 0;\\n   l2 = simplex[c][3]>=2 ? 1 : 0;\\n   // The number 1 in the \\\"simplex\\\" array is at the second smallest coordinate.\\n   i3 = simplex[c][0]>=1 ? 1 : 0;\\n   j3 = simplex[c][1]>=1 ? 1 : 0;\\n   k3 = simplex[c][2]>=1 ? 1 : 0;\\n   l3 = simplex[c][3]>=1 ? 1 : 0;\\n   // The fifth corner has all coordinate offsets = 1, so no need to look that up.\\n   var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\\n   var y1 = y0 - j1 + G4;\\n   var z1 = z0 - k1 + G4;\\n   var w1 = w0 - l1 + G4;\\n   var x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords\\n   var y2 = y0 - j2 + 2.0*G4;\\n   var z2 = z0 - k2 + 2.0*G4;\\n   var w2 = w0 - l2 + 2.0*G4;\\n   var x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords\\n   var y3 = y0 - j3 + 3.0*G4;\\n   var z3 = z0 - k3 + 3.0*G4;\\n   var w3 = w0 - l3 + 3.0*G4;\\n   var x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords\\n   var y4 = y0 - 1.0 + 4.0*G4;\\n   var z4 = z0 - 1.0 + 4.0*G4;\\n   var w4 = w0 - 1.0 + 4.0*G4;\\n   // Work out the hashed gradient indices of the five simplex corners\\n   var ii = i & 255;\\n   var jj = j & 255;\\n   var kk = k & 255;\\n   var ll = l & 255;\\n   var gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;\\n   var gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;\\n   var gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;\\n   var gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;\\n   var gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;\\n   // Calculate the contribution from the five corners\\n   var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\\n   if(t0<0) n0 = 0.0;\\n   else {\\n     t0 *= t0;\\n     n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);\\n   }\\n  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\\n   if(t1<0) n1 = 0.0;\\n   else {\\n     t1 *= t1;\\n     n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);\\n   }\\n  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\\n   if(t2<0) n2 = 0.0;\\n   else {\\n     t2 *= t2;\\n     n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);\\n   }   var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\\n   if(t3<0) n3 = 0.0;\\n   else {\\n     t3 *= t3;\\n     n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);\\n   }\\n  var t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\\n   if(t4<0) n4 = 0.0;\\n   else {\\n     t4 *= t4;\\n     n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);\\n   }\\n   // Sum up and scale the result to cover the range [-1,1]\\n   return 27.0 * (n0 + n1 + n2 + n3 + n4);\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Utils/UVsUtils.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Utils/UVsUtils.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/*\\n * @author gyuque / http://github.com/gyuque\\n * Cylinder Mapping for ExtrudeGeometry\\n */\\n\\nTHREE.UVsUtils = {\\n\\n};\\n\\nTHREE.UVsUtils.CylinderUVGenerator = function() {\\n    this.uRepeat = 1;\\n    this.targetGeometry = null;\\n    this.lengthCache = null;\\n};\\n\\nTHREE.UVsUtils.CylinderUVGenerator.prototype = {\\n    generateTopUV: THREE.ExtrudeGeometry.WorldUVGenerator.generateTopUV,\\n    generateBottomUV: THREE.ExtrudeGeometry.WorldUVGenerator.generateBottomUV,\\n    \\n    generateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,\\n                                  indexA, indexB, indexC, indexD, stepIndex, stepsLength,\\n                                  contourIndex1, contourIndex2 ) {\\n        // first call\\n        if (this.targetGeometry !== geometry) {\\n            this.prepare(geometry, wallContour);\\n        }\\n\\n        // generate uv\\n        var u_list = this.lengthCache;\\n        var v1 = stepIndex / stepsLength;\\n        var v2 = ( stepIndex + 1 ) / stepsLength;\\n        \\n        var u1 = u_list[contourIndex1];\\n        var u2 = u_list[contourIndex2];\\n        if (u1 < u2) {u1 += 1.0;}\\n        \\n        u1 *= this.uRepeat;\\n        u2 *= this.uRepeat;\\n        return [\\n            new THREE.Vector2( u1, v1 ),\\n            new THREE.Vector2( u2, v1 ),\\n            new THREE.Vector2( u2, v2 ),\\n            new THREE.Vector2( u1, v2 )\\n        ];\\n    },\\n    \\n    prepare: function(geometry, wallContour) {\\n        var p1, p2;\\n        var u_list = [];\\n        var lengthSum = 0;\\n        var len = wallContour.length;\\n        for (var i = 0;i < len;i++) {\\n            p1 = wallContour[ i ];\\n            p2 = wallContour[ (i+1) % len ];\\n\\n            var dx = p1.x - p2.x;\\n            var dy = p1.y - p2.y;\\n            var segmentLength = Math.sqrt(dx*dx + dy*dy);\\n            \\n            u_list.push(lengthSum);\\n            lengthSum += segmentLength;\\n        }\\n        \\n        this.normalizeArray(u_list, lengthSum);\\n        this.targetGeometry = geometry;\\n        this.lengthCache = u_list;\\n    },\\n    \\n    normalizeArray: function(ls, v) {\\n        var len = ls.length;\\n        for (var i = 0;i < len;i++) {\\n            ls[i] /= v;\\n        }\\n        \\n        return ls;\\n    }\\n};\\n\\n\\n\\n/* \\n * @author zz85 / http://github.com/zz85\\n * @author WestLangley / http://github.com/WestLangley\\n *\\n * tool for \\\"unwrapping\\\" and debugging three.js \\n * geometries UV mapping\\n *\\n * Sample usage:\\n *\\tdocument.body.appendChild(\\n *\\t\\tTHREE.UVsDebug(\\n *\\t\\t\\tnew THREE.SphereGeometry(10,10,10,10));\\n *\\n */\\n \\nTHREE.UVsDebug = function( geometry, size ) {\\n\\n    // handles wrapping of uv.x > 1 only\\n    \\n    var abc = 'abcd';\\n\\n    var uv, u, ax, ay;\\n    var i, il, j, jl;\\n    var vnum;\\n\\n    var a = new THREE.Vector2();\\n    var b = new THREE.Vector2();\\n\\n    var faces = geometry.faces;\\n    var uvs = geometry.faceVertexUvs[ 0 ];\\n\\n    var canvas = document.createElement( 'canvas' );\\n    var width = size || 1024;   // power of 2 required for wrapping\\n    var height = size || 1024;\\n    canvas.width = width;\\n    canvas.height = height;\\n\\n    var ctx = canvas.getContext( '2d' );\\n    ctx.lineWidth = 2;\\n    ctx.strokeStyle = 'rgba( 0, 0, 0, 1.0 )';\\n    ctx.textAlign = 'center';\\n\\n    // paint background white\\n\\n    ctx.fillStyle = 'rgba( 255, 255, 255, 1.0 )';\\n    ctx.fillRect( 0, 0, width, height );\\n\\n    for ( i = 0, il = uvs.length; i < il; i++ ) {\\n\\n        uv = uvs[ i ];\\n\\n        // draw lines\\n\\n        ctx.beginPath();\\n\\n        a.set( 0, 0 );\\n\\n        for ( j = 0, jl = uv.length; j < jl; j++ ) {\\n\\n            u = uv[ j ];\\n\\n            a.x += u.x;\\n            a.y += u.y;\\n\\n            if ( j == 0 ) {\\n\\n                ctx.moveTo( u.x * width, ( 1 - u.y ) * height );\\n\\n            } else {\\n\\n                ctx.lineTo( u.x * width, ( 1 - u.y ) * height );\\n\\n            }\\n\\n        }\\n\\n        ctx.closePath();\\n        ctx.stroke();\\n\\n        a.divideScalar( jl );\\n\\n        // label the face number\\n\\n        ctx.font = \\\"12pt Arial bold\\\";\\n        ctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\\n        ctx.fillText( i, a.x * width, ( 1 - a.y ) * height );\\n\\n        if ( a.x > 0.95 ) { // wrap x // 0.95 is arbitrary\\n\\n            ctx.fillText( i, ( a.x % 1 ) * width, ( 1 - a.y ) * height );\\n\\n        }\\n\\n        ctx.font = \\\"8pt Arial bold\\\";\\n        ctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\\n\\n        // label uv edge orders\\n\\n        for ( j = 0, jl = uv.length; j < jl; j++ ) {\\n\\n            u = uv[ j ];\\n            b.addVectors( a, u ).divideScalar( 2 );\\n\\n            vnum = faces[ i ][ abc[ j ] ];\\n            ctx.fillText( abc[ j ] + vnum, b.x * width, ( 1 - b.y ) * height );\\n\\n            if ( b.x > 0.95 ) {  // wrap x\\n\\n                ctx.fillText( abc[ j ] + vnum, ( b.x % 1 ) * width, ( 1 - b.y ) * height );\\n\\n            }\\n\\n        }\\n\\n    }\\n\\n    return canvas;\\n\\n}\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Utils/GeometryUtils.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Utils/GeometryUtils.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.GeometryUtils = {\\n\\n\\t// Merge two geometries or geometry and geometry from object (using object's transform)\\n\\n\\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\\n\\n\\t\\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\\n\\n\\t\\tvar matrix;\\n\\n\\t\\tif ( geometry2 instanceof THREE.Mesh ) {\\n\\n\\t\\t\\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\\n\\n\\t\\t\\tmatrix = geometry2.matrix;\\n\\t\\t\\tgeometry2 = geometry2.geometry;\\n\\n\\t\\t}\\n\\n\\t\\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\\n\\n\\t},\\n\\n\\t// Get random point in triangle (via barycentric coordinates)\\n\\t// \\t(uniform distribution)\\n\\t// \\thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\\n\\n\\trandomPointInTriangle: function () {\\n\\n\\t\\tvar vector = new THREE.Vector3();\\n\\n\\t\\treturn function ( vectorA, vectorB, vectorC ) {\\n\\n\\t\\t\\tvar point = new THREE.Vector3();\\n\\n\\t\\t\\tvar a = THREE.Math.random16();\\n\\t\\t\\tvar b = THREE.Math.random16();\\n\\n\\t\\t\\tif ( ( a + b ) > 1 ) {\\n\\n\\t\\t\\t\\ta = 1 - a;\\n\\t\\t\\t\\tb = 1 - b;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar c = 1 - a - b;\\n\\n\\t\\t\\tpoint.copy( vectorA );\\n\\t\\t\\tpoint.multiplyScalar( a );\\n\\n\\t\\t\\tvector.copy( vectorB );\\n\\t\\t\\tvector.multiplyScalar( b );\\n\\n\\t\\t\\tpoint.add( vector );\\n\\n\\t\\t\\tvector.copy( vectorC );\\n\\t\\t\\tvector.multiplyScalar( c );\\n\\n\\t\\t\\tpoint.add( vector );\\n\\n\\t\\t\\treturn point;\\n\\n\\t\\t};\\n\\n\\t}(),\\n\\n\\t// Get random point in face (triangle)\\n\\t// (uniform distribution)\\n\\n\\trandomPointInFace: function ( face, geometry, useCachedAreas ) {\\n\\n\\t\\tvar vA, vB, vC;\\n\\n\\t\\tvA = geometry.vertices[ face.a ];\\n\\t\\tvB = geometry.vertices[ face.b ];\\n\\t\\tvC = geometry.vertices[ face.c ];\\n\\n\\t\\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\\n\\n\\t},\\n\\n\\t// Get uniformly distributed random points in mesh\\n\\t// \\t- create array with cumulative sums of face areas\\n\\t//  - pick random number from 0 to total area\\n\\t//  - find corresponding place in area array by binary search\\n\\t//\\t- get random point in face\\n\\n\\trandomPointsInGeometry: function ( geometry, n ) {\\n\\n\\t\\tvar face, i,\\n\\t\\t\\tfaces = geometry.faces,\\n\\t\\t\\tvertices = geometry.vertices,\\n\\t\\t\\til = faces.length,\\n\\t\\t\\ttotalArea = 0,\\n\\t\\t\\tcumulativeAreas = [],\\n\\t\\t\\tvA, vB, vC, vD;\\n\\n\\t\\t// precompute face areas\\n\\n\\t\\tfor ( i = 0; i < il; i ++ ) {\\n\\n\\t\\t\\tface = faces[ i ];\\n\\n\\t\\t\\tvA = vertices[ face.a ];\\n\\t\\t\\tvB = vertices[ face.b ];\\n\\t\\t\\tvC = vertices[ face.c ];\\n\\n\\t\\t\\tface._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );\\n\\n\\t\\t\\ttotalArea += face._area;\\n\\n\\t\\t\\tcumulativeAreas[ i ] = totalArea;\\n\\n\\t\\t}\\n\\n\\t\\t// binary search cumulative areas array\\n\\n\\t\\tfunction binarySearchIndices( value ) {\\n\\n\\t\\t\\tfunction binarySearch( start, end ) {\\n\\n\\t\\t\\t\\t// return closest larger index\\n\\t\\t\\t\\t// if exact number is not found\\n\\n\\t\\t\\t\\tif ( end < start )\\n\\t\\t\\t\\t\\treturn start;\\n\\n\\t\\t\\t\\tvar mid = start + Math.floor( ( end - start ) / 2 );\\n\\n\\t\\t\\t\\tif ( cumulativeAreas[ mid ] > value ) {\\n\\n\\t\\t\\t\\t\\treturn binarySearch( start, mid - 1 );\\n\\n\\t\\t\\t\\t} else if ( cumulativeAreas[ mid ] < value ) {\\n\\n\\t\\t\\t\\t\\treturn binarySearch( mid + 1, end );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\treturn mid;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar result = binarySearch( 0, cumulativeAreas.length - 1 )\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t\\t// pick random face weighted by face area\\n\\n\\t\\tvar r, index,\\n\\t\\t\\tresult = [];\\n\\n\\t\\tvar stats = {};\\n\\n\\t\\tfor ( i = 0; i < n; i ++ ) {\\n\\n\\t\\t\\tr = THREE.Math.random16() * totalArea;\\n\\n\\t\\t\\tindex = binarySearchIndices( r );\\n\\n\\t\\t\\tresult[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\\n\\n\\t\\t\\tif ( ! stats[ index ] ) {\\n\\n\\t\\t\\t\\tstats[ index ] = 1;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tstats[ index ] += 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\n\\t},\\n\\n\\trandomPointsInBufferGeometry: function ( geometry, n ) {\\n\\n\\t\\tvar i,\\n\\t\\t\\tvertices = geometry.attributes.position.array,\\n\\t\\t\\ttotalArea = 0,\\n\\t\\t\\tcumulativeAreas = [],\\n\\t\\t\\tvA, vB, vC;\\n\\n\\t\\t// precompute face areas\\n\\t\\tvA = new THREE.Vector3();\\n\\t\\tvB = new THREE.Vector3();\\n\\t\\tvC = new THREE.Vector3();\\n\\n\\t\\t// geometry._areas = [];\\n\\t\\tvar il = vertices.length / 9;\\n\\n\\t\\tfor ( i = 0; i < il; i ++ ) {\\n\\n\\t\\t\\tvA.set( vertices[i * 9 + 0], vertices[i * 9 + 1], vertices[i * 9 + 2] );\\n\\t\\t\\tvB.set( vertices[i * 9 + 3], vertices[i * 9 + 4], vertices[i * 9 + 5] );\\n\\t\\t\\tvC.set( vertices[i * 9 + 6], vertices[i * 9 + 7], vertices[i * 9 + 8] );\\n\\n\\t\\t\\tarea = THREE.GeometryUtils.triangleArea( vA, vB, vC );\\n\\t\\t\\ttotalArea += area;\\n\\n\\t\\t\\tcumulativeAreas.push(totalArea);\\n\\t\\t}\\n\\n\\t\\t// binary search cumulative areas array\\n\\n\\t\\tfunction binarySearchIndices( value ) {\\n\\n\\t\\t\\tfunction binarySearch( start, end ) {\\n\\n\\t\\t\\t\\t// return closest larger index\\n\\t\\t\\t\\t// if exact number is not found\\n\\n\\t\\t\\t\\tif ( end < start )\\n\\t\\t\\t\\t\\treturn start;\\n\\n\\t\\t\\t\\tvar mid = start + Math.floor( ( end - start ) / 2 );\\n\\n\\t\\t\\t\\tif ( cumulativeAreas[ mid ] > value ) {\\n\\n\\t\\t\\t\\t\\treturn binarySearch( start, mid - 1 );\\n\\n\\t\\t\\t\\t} else if ( cumulativeAreas[ mid ] < value ) {\\n\\n\\t\\t\\t\\t\\treturn binarySearch( mid + 1, end );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\treturn mid;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar result = binarySearch( 0, cumulativeAreas.length - 1 )\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t\\t// pick random face weighted by face area\\n\\n\\t\\tvar r, index,\\n\\t\\t\\tresult = [];\\n\\n\\t\\tfor ( i = 0; i < n; i ++ ) {\\n\\n\\t\\t\\tr = THREE.Math.random16() * totalArea;\\n\\n\\t\\t\\tindex = binarySearchIndices( r );\\n\\n\\t\\t\\t// result[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\\n\\t\\t\\tvA.set( vertices[index * 9 + 0], vertices[index * 9 + 1], vertices[index * 9 + 2] );\\n\\t\\t\\tvB.set( vertices[index * 9 + 3], vertices[index * 9 + 4], vertices[index * 9 + 5] );\\n\\t\\t\\tvC.set( vertices[index * 9 + 6], vertices[index * 9 + 7], vertices[index * 9 + 8] );\\n\\t\\t\\tresult[ i ] = THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\\n\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\n\\t},\\n\\n\\t// Get triangle area (half of parallelogram)\\n\\t// http://mathworld.wolfram.com/TriangleArea.html\\n\\n\\ttriangleArea: function () {\\n\\n\\t\\tvar vector1 = new THREE.Vector3();\\n\\t\\tvar vector2 = new THREE.Vector3();\\n\\n\\t\\treturn function ( vectorA, vectorB, vectorC ) {\\n\\n\\t\\t\\tvector1.subVectors( vectorB, vectorA );\\n\\t\\t\\tvector2.subVectors( vectorC, vectorA );\\n\\t\\t\\tvector1.cross( vector2 );\\n\\n\\t\\t\\treturn 0.5 * vector1.length();\\n\\n\\t\\t};\\n\\n\\t}(),\\n\\n\\tcenter: function ( geometry ) {\\n\\n\\t\\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\\n\\t\\treturn geometry.center();\\n\\n\\t}\\n\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Effects/VREffect.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Effects/VREffect.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author dmarcos / https://github.com/dmarcos\\n *\\n * It handles stereo rendering\\n * If mozGetVRDevices and getVRDevices APIs are not available it gracefuly falls back to a\\n * regular renderer\\n *\\n * The HMD supported is the Oculus DK1 and The Web API doesn't currently allow\\n * to query for the display resolution (only the chrome API allows it).\\n * The dimensions of the screen are temporarly hardcoded (1280 x 800).\\n *\\n * For VR mode to work it has to be used with the Oculus enabled builds of Firefox or Chrome:\\n *\\n * Firefox:\\n *\\n * OSX: http://people.mozilla.com/~vladimir/vr/firefox-33.0a1.en-US.mac.dmg\\n * WIN: http://people.mozilla.com/~vladimir/vr/firefox-33.0a1.en-US.win64-x86_64.zip\\n *\\n * Chrome builds:\\n *\\n * https://drive.google.com/folderview?id=0BzudLt22BqGRbW9WTHMtOWMzNjQ&usp=sharing#list\\n *\\n */\\nTHREE.VREffect = function ( renderer, done ) {\\n\\tthis._renderer = renderer;\\n\\n\\tthis._init = function() {\\n\\t\\tvar self = this;\\n\\t\\tif ( !navigator.mozGetVRDevices && !navigator.getVRDevices ) {\\n\\t\\t\\tif ( done ) {\\n\\t\\t\\t\\tdone(\\\"Your browser is not VR Ready\\\");\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif ( navigator.getVRDevices ) {\\n\\t\\t\\tnavigator.getVRDevices().then( gotVRDevices );\\n\\t\\t} else {\\n\\t\\t\\tnavigator.mozGetVRDevices( gotVRDevices );\\n\\t\\t}\\n\\t\\tfunction gotVRDevices( devices ) {\\n\\t\\t\\tvar vrHMD;\\n\\t\\t\\tvar error;\\n\\t\\t\\tfor ( var i = 0; i < devices.length; ++i ) {\\n\\t\\t\\t\\tif ( devices[i] instanceof HMDVRDevice ) {\\n\\t\\t\\t\\t\\tvrHMD = devices[i];\\n\\t\\t\\t\\t\\tself._vrHMD = vrHMD;\\n\\t\\t\\t\\t\\tself.leftEyeTranslation = vrHMD.getEyeTranslation( \\\"left\\\" );\\n\\t\\t\\t\\t\\tself.rightEyeTranslation = vrHMD.getEyeTranslation( \\\"right\\\" );\\n\\t\\t\\t\\t\\tself.leftEyeFOV = vrHMD.getRecommendedEyeFieldOfView( \\\"left\\\" );\\n\\t\\t\\t\\t\\tself.rightEyeFOV = vrHMD.getRecommendedEyeFieldOfView( \\\"right\\\" );\\n\\t\\t\\t\\t\\tbreak; // We keep the first we encounter\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( done ) {\\n\\t\\t\\t\\tif ( !vrHMD ) {\\n\\t\\t\\t\\t error = 'HMD not available';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdone( error );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tthis._init();\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\t\\tvar renderer = this._renderer;\\n\\t\\tvar vrHMD = this._vrHMD;\\n\\t\\trenderer.enableScissorTest( false );\\n\\t\\t// VR render mode if HMD is available\\n\\t\\tif ( vrHMD ) {\\n\\t\\t\\tthis.renderStereo.apply( this, arguments );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// Regular render mode if not HMD\\n\\t\\trenderer.render.apply( this._renderer , arguments );\\n\\t};\\n\\n\\tthis.renderStereo = function( scene, camera, renderTarget, forceClear ) {\\n\\t\\tvar cameraLeft;\\n\\t\\tvar cameraRight;\\n\\t\\tvar leftEyeTranslation = this.leftEyeTranslation;\\n\\t\\tvar rightEyeTranslation = this.rightEyeTranslation;\\n\\t\\tvar renderer = this._renderer;\\n\\t\\tvar rendererWidth = renderer.domElement.width / renderer.devicePixelRatio;\\n\\t\\tvar rendererHeight = renderer.domElement.height / renderer.devicePixelRatio;\\n\\t\\tvar eyeDivisionLine = rendererWidth / 2;\\n\\t\\trenderer.enableScissorTest( true );\\n\\t\\trenderer.clear();\\n\\n\\t\\t// Grab camera matrix from user.\\n\\t\\t// This is interpreted as the head base.\\n\\t\\tif ( camera.matrixAutoUpdate ) {\\n\\t\\t\\tcamera.updateMatrix();\\n\\t\\t}\\n\\t\\tvar eyeWorldMatrix = camera.matrixWorld.clone();\\n\\n\\t\\tcameraLeft = camera.clone();\\n\\t\\tcameraRight = camera.clone();\\n\\t\\tcameraLeft.projectionMatrix = this.FovToProjection( this.leftEyeFOV );\\n\\t\\tcameraRight.projectionMatrix = this.FovToProjection( this.rightEyeFOV );\\n\\t\\tcameraLeft.position.add(new THREE.Vector3(\\n\\t\\t\\tleftEyeTranslation.x, leftEyeTranslation.y, leftEyeTranslation.z) );\\n\\t\\tcameraRight.position.add(new THREE.Vector3(\\n\\t\\t\\trightEyeTranslation.x, rightEyeTranslation.y, rightEyeTranslation.z) );\\n\\n\\t\\t// render left eye\\n\\t\\trenderer.setViewport( 0, 0, eyeDivisionLine, rendererHeight );\\n\\t\\trenderer.setScissor( 0, 0, eyeDivisionLine, rendererHeight );\\n\\t\\trenderer.render( scene, cameraLeft );\\n\\n\\t\\t// render right eye\\n\\t\\trenderer.setViewport( eyeDivisionLine, 0, eyeDivisionLine, rendererHeight );\\n\\t\\trenderer.setScissor( eyeDivisionLine, 0, eyeDivisionLine, rendererHeight );\\n\\t\\trenderer.render( scene, cameraRight );\\n\\n\\t};\\n\\n\\tthis.setFullScreen = function( enable ) {\\n\\t\\tvar renderer = this._renderer;\\n\\t\\tvar vrHMD = this._vrHMD;\\n\\t\\tvar canvasOriginalSize = this._canvasOriginalSize;\\n\\t\\tif (!vrHMD) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// If state doesn't change we do nothing\\n\\t\\tif ( enable === this._fullScreen ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tthis._fullScreen = !!enable;\\n\\n\\t\\t// VR Mode disabled\\n\\t\\tif ( !enable ) {\\n\\t\\t\\t// Restores canvas original size\\n\\t\\t\\trenderer.setSize( canvasOriginalSize.width, canvasOriginalSize.height );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// VR Mode enabled\\n\\t\\tthis._canvasOriginalSize = {\\n\\t\\t\\twidth: renderer.domElement.width,\\n\\t\\t\\theight: renderer.domElement.height\\n\\t\\t};\\n\\t\\t// Hardcoded Rift display size\\n\\t\\trenderer.setSize( 1280, 800, false );\\n\\t\\tthis.startFullscreen();\\n\\t};\\n\\n\\tthis.startFullscreen = function() {\\n\\t\\tvar self = this;\\n\\t\\tvar renderer = this._renderer;\\n\\t\\tvar vrHMD = this._vrHMD;\\n\\t\\tvar canvas = renderer.domElement;\\n\\t\\tvar fullScreenChange =\\n\\t\\t\\tcanvas.mozRequestFullScreen? 'mozfullscreenchange' : 'webkitfullscreenchange';\\n\\n\\t\\tdocument.addEventListener( fullScreenChange, onFullScreenChanged, false );\\n\\t\\tfunction onFullScreenChanged() {\\n\\t\\t\\tif ( !document.mozFullScreenElement && !document.webkitFullScreenElement ) {\\n\\t\\t\\t\\tself.setFullScreen( false );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( canvas.mozRequestFullScreen ) {\\n\\t\\t\\tcanvas.mozRequestFullScreen( { vrDisplay: vrHMD } );\\n\\t\\t} else {\\n\\t\\t\\tcanvas.webkitRequestFullscreen( { vrDisplay: vrHMD } );\\n\\t\\t}\\n\\t};\\n\\n\\tthis.FovToNDCScaleOffset = function( fov ) {\\n\\t\\tvar pxscale = 2.0 / (fov.leftTan + fov.rightTan);\\n\\t\\tvar pxoffset = (fov.leftTan - fov.rightTan) * pxscale * 0.5;\\n\\t\\tvar pyscale = 2.0 / (fov.upTan + fov.downTan);\\n\\t\\tvar pyoffset = (fov.upTan - fov.downTan) * pyscale * 0.5;\\n\\t\\treturn { scale: [pxscale, pyscale], offset: [pxoffset, pyoffset] };\\n\\t};\\n\\n\\tthis.FovPortToProjection = function( fov, rightHanded /* = true */, zNear /* = 0.01 */, zFar /* = 10000.0 */ )\\n\\t{\\n\\t\\trightHanded = rightHanded === undefined ? true : rightHanded;\\n\\t\\tzNear = zNear === undefined ? 0.01 : zNear;\\n\\t\\tzFar = zFar === undefined ? 10000.0 : zFar;\\n\\n\\t\\tvar handednessScale = rightHanded ? -1.0 : 1.0;\\n\\n\\t\\t// start with an identity matrix\\n\\t\\tvar mobj = new THREE.Matrix4();\\n\\t\\tvar m = mobj.elements;\\n\\n\\t\\t// and with scale/offset info for normalized device coords\\n\\t\\tvar scaleAndOffset = this.FovToNDCScaleOffset(fov);\\n\\n\\t\\t// X result, map clip edges to [-w,+w]\\n\\t\\tm[0*4+0] = scaleAndOffset.scale[0];\\n\\t\\tm[0*4+1] = 0.0;\\n\\t\\tm[0*4+2] = scaleAndOffset.offset[0] * handednessScale;\\n\\t\\tm[0*4+3] = 0.0;\\n\\n\\t\\t// Y result, map clip edges to [-w,+w]\\n\\t\\t// Y offset is negated because this proj matrix transforms from world coords with Y=up,\\n\\t\\t// but the NDC scaling has Y=down (thanks D3D?)\\n\\t\\tm[1*4+0] = 0.0;\\n\\t\\tm[1*4+1] = scaleAndOffset.scale[1];\\n\\t\\tm[1*4+2] = -scaleAndOffset.offset[1] * handednessScale;\\n\\t\\tm[1*4+3] = 0.0;\\n\\n\\t\\t// Z result (up to the app)\\n\\t\\tm[2*4+0] = 0.0;\\n\\t\\tm[2*4+1] = 0.0;\\n\\t\\tm[2*4+2] = zFar / (zNear - zFar) * -handednessScale;\\n\\t\\tm[2*4+3] = (zFar * zNear) / (zNear - zFar);\\n\\n\\t\\t// W result (= Z in)\\n\\t\\tm[3*4+0] = 0.0;\\n\\t\\tm[3*4+1] = 0.0;\\n\\t\\tm[3*4+2] = handednessScale;\\n\\t\\tm[3*4+3] = 0.0;\\n\\n\\t\\tmobj.transpose();\\n\\n\\t\\treturn mobj;\\n\\t};\\n\\n\\tthis.FovToProjection = function( fov, rightHanded /* = true */, zNear /* = 0.01 */, zFar /* = 10000.0 */ )\\n\\t{\\n\\t\\tvar fovPort = {\\n\\t\\t\\tupTan: Math.tan(fov.upDegrees * Math.PI / 180.0),\\n\\t\\t\\tdownTan: Math.tan(fov.downDegrees * Math.PI / 180.0),\\n\\t\\t\\tleftTan: Math.tan(fov.leftDegrees * Math.PI / 180.0),\\n\\t\\t\\trightTan: Math.tan(fov.rightDegrees * Math.PI / 180.0)\\n\\t\\t};\\n\\t\\treturn this.FovPortToProjection(fovPort, rightHanded, zNear, zFar);\\n\\t};\\n\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Effects/OculusRiftEffect.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Effects/OculusRiftEffect.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author troffmo5 / http://github.com/troffmo5\\n *\\n * Effect to render the scene in stereo 3d side by side with lens distortion.\\n * It is written to be used with the Oculus Rift (http://www.oculusvr.com/) but\\n * it works also with other HMD using the same technology\\n */\\n\\nTHREE.OculusRiftEffect = function ( renderer, options ) {\\n\\t// worldFactor indicates how many units is 1 meter\\n\\tvar worldFactor = (options && options.worldFactor) ? options.worldFactor: 1.0;\\n\\n\\t// Specific HMD parameters\\n\\tvar HMD = (options && options.HMD) ? options.HMD: {\\n\\t\\t// Parameters from the Oculus Rift DK1\\n\\t\\thResolution: 1280,\\n\\t\\tvResolution: 800,\\n\\t\\thScreenSize: 0.14976,\\n\\t\\tvScreenSize: 0.0936,\\n\\t\\tinterpupillaryDistance: 0.064,\\n\\t\\tlensSeparationDistance: 0.064,\\n\\t\\teyeToScreenDistance: 0.041,\\n\\t\\tdistortionK : [1.0, 0.22, 0.24, 0.0],\\n\\t\\tchromaAbParameter: [ 0.996, -0.004, 1.014, 0.0]\\n\\t};\\n\\n\\t// Perspective camera\\n\\tvar pCamera = new THREE.PerspectiveCamera();\\n\\tpCamera.matrixAutoUpdate = false;\\n\\tpCamera.target = new THREE.Vector3();\\n\\n\\t// Orthographic camera\\n\\tvar oCamera = new THREE.OrthographicCamera( -1, 1, 1, -1, 1, 1000 );\\n\\toCamera.position.z = 1;\\n\\n\\t// pre-render hooks\\n\\tthis.preLeftRender = function() {};\\n\\tthis.preRightRender = function() {};\\n\\n\\trenderer.autoClear = false;\\n\\tvar emptyColor = new THREE.Color(\\\"black\\\");\\n\\n\\t// Render target\\n\\tvar RTParams = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\\n\\tvar renderTarget = new THREE.WebGLRenderTarget( 640, 800, RTParams );\\n\\tvar RTMaterial = new THREE.ShaderMaterial( {\\n\\t\\tuniforms: {\\n\\t\\t\\t\\\"texid\\\": { type: \\\"t\\\", value: renderTarget },\\n\\t\\t\\t\\\"scale\\\": { type: \\\"v2\\\", value: new THREE.Vector2(1.0,1.0) },\\n\\t\\t\\t\\\"scaleIn\\\": { type: \\\"v2\\\", value: new THREE.Vector2(1.0,1.0) },\\n\\t\\t\\t\\\"lensCenter\\\": { type: \\\"v2\\\", value: new THREE.Vector2(0.0,0.0) },\\n\\t\\t\\t\\\"hmdWarpParam\\\": { type: \\\"v4\\\", value: new THREE.Vector4(1.0,0.0,0.0,0.0) },\\n\\t\\t\\t\\\"chromAbParam\\\": { type: \\\"v4\\\", value: new THREE.Vector4(1.0,0.0,0.0,0.0) }\\n\\t\\t},\\n\\t\\tvertexShader: [\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\t\\t\\t\\\"void main() {\\\",\\n\\t\\t\\t\\\" vUv = uv;\\\",\\n\\t\\t\\t\\\"\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\\"}\\\"\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tfragmentShader: [\\n\\t\\t\\t\\\"uniform vec2 scale;\\\",\\n\\t\\t\\t\\\"uniform vec2 scaleIn;\\\",\\n\\t\\t\\t\\\"uniform vec2 lensCenter;\\\",\\n\\t\\t\\t\\\"uniform vec4 hmdWarpParam;\\\",\\n\\t\\t\\t'uniform vec4 chromAbParam;',\\n\\t\\t\\t\\\"uniform sampler2D texid;\\\",\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\t\\t\\t\\\"void main()\\\",\\n\\t\\t\\t\\\"{\\\",\\n\\t\\t\\t\\\"  vec2 uv = (vUv*2.0)-1.0;\\\", // range from [0,1] to [-1,1]\\n\\t\\t\\t\\\"  vec2 theta = (uv-lensCenter)*scaleIn;\\\",\\n\\t\\t\\t\\\"  float rSq = theta.x*theta.x + theta.y*theta.y;\\\",\\n\\t\\t\\t\\\"  vec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);\\\",\\n\\t\\t\\t'  vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);',\\n\\t\\t\\t\\\"  vec2 tcBlue = (lensCenter + scale * rBlue);\\\",\\n\\t\\t\\t\\\"  tcBlue = (tcBlue+1.0)/2.0;\\\", // range from [-1,1] to [0,1]\\n\\t\\t\\t\\\"  if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue))) {\\\",\\n\\t\\t\\t\\\"    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\\",\\n\\t\\t\\t\\\"    return;}\\\",\\n\\t\\t\\t\\\"  vec2 tcGreen = lensCenter + scale * rvector;\\\",\\n\\t\\t\\t\\\"  tcGreen = (tcGreen+1.0)/2.0;\\\", // range from [-1,1] to [0,1]\\n\\t\\t\\t\\\"  vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);\\\",\\n\\t\\t\\t\\\"  vec2 tcRed = lensCenter + scale * rRed;\\\",\\n\\t\\t\\t\\\"  tcRed = (tcRed+1.0)/2.0;\\\", // range from [-1,1] to [0,1]\\n\\t\\t\\t\\\"  gl_FragColor = vec4(texture2D(texid, tcRed).r, texture2D(texid, tcGreen).g, texture2D(texid, tcBlue).b, 1);\\\",\\n\\t\\t\\t\\\"}\\\"\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\t} );\\n\\n\\tvar mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), RTMaterial );\\n\\n\\t// Final scene\\n\\tvar finalScene = new THREE.Scene();\\n\\tfinalScene.add( oCamera );\\n\\tfinalScene.add( mesh );\\n\\n    var left = {}, right = {};\\n    var distScale = 1.0;\\n\\tthis.setHMD = function(v) {\\n\\t\\tHMD = v;\\n\\t\\t// Compute aspect ratio and FOV\\n\\t\\tvar aspect = HMD.hResolution / (2*HMD.vResolution);\\n\\n\\t\\t// Fov is normally computed with:\\n\\t\\t//   THREE.Math.radToDeg( 2*Math.atan2(HMD.vScreenSize,2*HMD.eyeToScreenDistance) );\\n\\t\\t// But with lens distortion it is increased (see Oculus SDK Documentation)\\n\\t\\tvar r = -1.0 - (4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize);\\n\\t\\tdistScale = (HMD.distortionK[0] + HMD.distortionK[1] * Math.pow(r,2) + HMD.distortionK[2] * Math.pow(r,4) + HMD.distortionK[3] * Math.pow(r,6));\\n\\t\\tvar fov = THREE.Math.radToDeg(2*Math.atan2(HMD.vScreenSize*distScale, 2*HMD.eyeToScreenDistance));\\n\\n\\t\\t// Compute camera projection matrices\\n\\t\\tvar proj = (new THREE.Matrix4()).makePerspective( fov, aspect, 0.3, 10000 );\\n\\t\\tvar h = 4 * (HMD.hScreenSize/4 - HMD.interpupillaryDistance/2) / HMD.hScreenSize;\\n\\t\\tleft.proj = ((new THREE.Matrix4()).makeTranslation( h, 0.0, 0.0 )).multiply(proj);\\n\\t\\tright.proj = ((new THREE.Matrix4()).makeTranslation( -h, 0.0, 0.0 )).multiply(proj);\\n\\n\\t\\t// Compute camera transformation matrices\\n\\t\\tleft.tranform = (new THREE.Matrix4()).makeTranslation( -worldFactor * HMD.interpupillaryDistance/2, 0.0, 0.0 );\\n\\t\\tright.tranform = (new THREE.Matrix4()).makeTranslation( worldFactor * HMD.interpupillaryDistance/2, 0.0, 0.0 );\\n\\n\\t\\t// Compute Viewport\\n\\t\\tleft.viewport = [0, 0, HMD.hResolution/2, HMD.vResolution];\\n\\t\\tright.viewport = [HMD.hResolution/2, 0, HMD.hResolution/2, HMD.vResolution];\\n\\n\\t\\t// Distortion shader parameters\\n\\t\\tvar lensShift = 4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize;\\n\\t\\tleft.lensCenter = new THREE.Vector2(lensShift, 0.0);\\n\\t\\tright.lensCenter = new THREE.Vector2(-lensShift, 0.0);\\n\\n\\t\\tRTMaterial.uniforms['hmdWarpParam'].value = new THREE.Vector4(HMD.distortionK[0], HMD.distortionK[1], HMD.distortionK[2], HMD.distortionK[3]);\\n\\t\\tRTMaterial.uniforms['chromAbParam'].value = new THREE.Vector4(HMD.chromaAbParameter[0], HMD.chromaAbParameter[1], HMD.chromaAbParameter[2], HMD.chromaAbParameter[3]);\\n\\t\\tRTMaterial.uniforms['scaleIn'].value = new THREE.Vector2(1.0,1.0/aspect);\\n\\t\\tRTMaterial.uniforms['scale'].value = new THREE.Vector2(1.0/distScale, 1.0*aspect/distScale);\\n\\n\\t\\t// Create render target\\n\\t\\tif ( renderTarget ) renderTarget.dispose();\\n\\t\\trenderTarget = new THREE.WebGLRenderTarget( HMD.hResolution*distScale/2, HMD.vResolution*distScale, RTParams );\\n\\t\\tRTMaterial.uniforms[ \\\"texid\\\" ].value = renderTarget;\\n\\n\\t}\\t\\n\\tthis.getHMD = function() {return HMD};\\n\\n\\tthis.setHMD(HMD);\\t\\n\\n\\tthis.setSize = function ( width, height ) {\\n\\t\\tleft.viewport = [width/2 - HMD.hResolution/2, height/2 - HMD.vResolution/2, HMD.hResolution/2, HMD.vResolution];\\n\\t\\tright.viewport = [width/2, height/2 - HMD.vResolution/2, HMD.hResolution/2, HMD.vResolution];\\n\\n\\t\\trenderer.setSize( width, height );\\n\\t};\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\t\\tvar cc = renderer.getClearColor().clone();\\n\\n\\t\\t// Clear\\n\\t\\trenderer.setClearColor(emptyColor);\\n\\t\\trenderer.clear();\\n\\t\\trenderer.setClearColor(cc);\\n\\n\\t\\t// camera parameters\\n\\t\\tif (camera.matrixAutoUpdate) camera.updateMatrix();\\n\\n\\t\\t// Render left\\n\\t\\tthis.preLeftRender();\\n\\n\\t\\tpCamera.projectionMatrix.copy(left.proj);\\n\\n\\t\\tpCamera.matrix.copy(camera.matrix).multiply(left.tranform);\\n\\t\\tpCamera.matrixWorldNeedsUpdate = true;\\n\\n\\t\\trenderer.setViewport(left.viewport[0], left.viewport[1], left.viewport[2], left.viewport[3]);\\n\\n\\t\\tRTMaterial.uniforms['lensCenter'].value = left.lensCenter;\\n\\t\\trenderer.render( scene, pCamera, renderTarget, true );\\n\\n\\t\\trenderer.render( finalScene, oCamera );\\n\\n\\t\\t// Render right\\n\\t\\tthis.preRightRender();\\n\\n\\t\\tpCamera.projectionMatrix.copy(right.proj);\\n\\n\\t\\tpCamera.matrix.copy(camera.matrix).multiply(right.tranform);\\n\\t\\tpCamera.matrixWorldNeedsUpdate = true;\\n\\n\\t\\trenderer.setViewport(right.viewport[0], right.viewport[1], right.viewport[2], right.viewport[3]);\\n\\n\\t\\tRTMaterial.uniforms['lensCenter'].value = right.lensCenter;\\n\\n\\t\\trenderer.render( scene, pCamera, renderTarget, true );\\n\\t\\trenderer.render( finalScene, oCamera );\\n\\n\\t};\\n\\n\\tthis.dispose = function() {\\n\\t\\tif ( RTMaterial ) {\\n\\t\\t\\tRTMaterial.dispose();\\n\\t\\t}\\n\\t\\tif ( renderTarget ) {\\n\\t\\t\\trenderTarget.dispose();\\n\\t\\t}\\n\\t};\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Effects/ParallaxBarrierEffect.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Effects/ParallaxBarrierEffect.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author marklundin / http://mark-lundin.com/\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.ParallaxBarrierEffect = function ( renderer ) {\\n\\n\\tvar eyeRight = new THREE.Matrix4();\\n\\tvar eyeLeft = new THREE.Matrix4();\\n\\tvar focalLength = 125;\\n\\tvar _aspect, _near, _far, _fov;\\n\\n\\tvar _cameraL = new THREE.PerspectiveCamera();\\n\\t_cameraL.matrixAutoUpdate = false;\\n\\n\\tvar _cameraR = new THREE.PerspectiveCamera();\\n\\t_cameraR.matrixAutoUpdate = false;\\n\\n\\tvar _scene = new THREE.Scene();\\n\\n\\tvar _camera = new THREE.PerspectiveCamera( 53, 1, 1, 10000 );\\n\\t_camera.position.z = 2;\\n\\t_scene.add( _camera );\\n\\n\\tvar _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\\n\\n\\tvar _renderTargetL = new THREE.WebGLRenderTarget( 512, 512, _params );\\n\\tvar _renderTargetR = new THREE.WebGLRenderTarget( 512, 512, _params );\\n\\n\\tvar _material = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\t\\\"mapLeft\\\": { type: \\\"t\\\", value: _renderTargetL },\\n\\t\\t\\t\\\"mapRight\\\": { type: \\\"t\\\", value: _renderTargetR }\\n\\n\\t\\t},\\n\\n\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"\\tvUv = vec2( uv.x, uv.y );\\\",\\n\\t\\t\\t\\\"\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\\"uniform sampler2D mapLeft;\\\",\\n\\t\\t\\t\\\"uniform sampler2D mapRight;\\\",\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"\\tvec2 uv = vUv;\\\",\\n\\n\\t\\t\\t\\\"\\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {\\\",\\n\\n\\t\\t\\t\\\"\\t\\tgl_FragColor = texture2D( mapLeft, uv );\\\",\\n\\n\\t\\t\\t\\\"\\t} else {\\\",\\n\\n\\t\\t\\t\\\"\\t\\tgl_FragColor = texture2D( mapRight, uv );\\\",\\n\\n\\t\\t\\t\\\"\\t}\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t} );\\n\\n\\tvar mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), _material );\\n\\t_scene.add( mesh );\\n\\n\\tthis.setSize = function ( width, height ) {\\n\\n\\t\\t_renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\\n\\t\\t_renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\\n\\n\\t\\t_material.uniforms[ \\\"mapLeft\\\" ].value = _renderTargetL;\\n\\t\\t_material.uniforms[ \\\"mapRight\\\" ].value = _renderTargetR;\\n\\n\\t\\trenderer.setSize( width, height );\\n\\n\\t};\\n\\n\\t/*\\n\\t * Renderer now uses an asymmetric perspective projection\\n\\t * (http://paulbourke.net/miscellaneous/stereographics/stereorender/).\\n\\t *\\n\\t * Each camera is offset by the eye seperation and its projection matrix is\\n\\t * also skewed asymetrically back to converge on the same projection plane.\\n\\t * Added a focal length parameter to, this is where the parallax is equal to 0.\\n\\t */\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\n\\t\\tscene.updateMatrixWorld();\\n\\n\\t\\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\\n\\n\\t\\tvar hasCameraChanged = ( _aspect !== camera.aspect ) || ( _near !== camera.near ) || ( _far !== camera.far ) || ( _fov !== camera.fov );\\n\\n\\t\\tif ( hasCameraChanged ) {\\n\\n\\t\\t\\t_aspect = camera.aspect;\\n\\t\\t\\t_near = camera.near;\\n\\t\\t\\t_far = camera.far;\\n\\t\\t\\t_fov = camera.fov;\\n\\n\\t\\t\\tvar projectionMatrix = camera.projectionMatrix.clone();\\n\\t\\t\\tvar eyeSep = focalLength / 30 * 0.5;\\n\\t\\t\\tvar eyeSepOnProjection = eyeSep * _near / focalLength;\\n\\t\\t\\tvar ymax = _near * Math.tan( THREE.Math.degToRad( _fov * 0.5 ) );\\n\\t\\t\\tvar xmin, xmax;\\n\\n\\t\\t\\t// translate xOffset\\n\\n\\t\\t\\teyeRight.elements[12] = eyeSep;\\n\\t\\t\\teyeLeft.elements[12] = -eyeSep;\\n\\n\\t\\t\\t// for left eye\\n\\n\\t\\t\\txmin = -ymax * _aspect + eyeSepOnProjection;\\n\\t\\t\\txmax = ymax * _aspect + eyeSepOnProjection;\\n\\n\\t\\t\\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\\n\\t\\t\\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\\n\\n\\t\\t\\t_cameraL.projectionMatrix.copy( projectionMatrix );\\n\\n\\t\\t\\t// for right eye\\n\\n\\t\\t\\txmin = -ymax * _aspect - eyeSepOnProjection;\\n\\t\\t\\txmax = ymax * _aspect - eyeSepOnProjection;\\n\\n\\t\\t\\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\\n\\t\\t\\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\\n\\n\\t\\t\\t_cameraR.projectionMatrix.copy( projectionMatrix );\\n\\n\\t\\t}\\n\\n\\t\\t_cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\\n\\t\\t_cameraL.position.copy( camera.position );\\n\\t\\t_cameraL.near = camera.near;\\n\\t\\t_cameraL.far = camera.far;\\n\\n\\t\\trenderer.render( scene, _cameraL, _renderTargetL, true );\\n\\n\\t\\t_cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\\n\\t\\t_cameraR.position.copy( camera.position );\\n\\t\\t_cameraR.near = camera.near;\\n\\t\\t_cameraR.far = camera.far;\\n\\n\\t\\trenderer.render( scene, _cameraR, _renderTargetR, true );\\n\\n\\t\\t_scene.updateMatrixWorld();\\n\\n\\t\\trenderer.render( _scene, _camera );\\n\\n\\t};\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Effects/AnaglyphEffect.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Effects/AnaglyphEffect.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author marklundin / http://mark-lundin.com/\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.AnaglyphEffect = function ( renderer, width, height ) {\\n\\n\\tvar eyeRight = new THREE.Matrix4();\\n\\tvar eyeLeft = new THREE.Matrix4();\\n\\tvar focalLength = 125;\\n\\tvar _aspect, _near, _far, _fov;\\n\\n\\tvar _cameraL = new THREE.PerspectiveCamera();\\n\\t_cameraL.matrixAutoUpdate = false;\\n\\n\\tvar _cameraR = new THREE.PerspectiveCamera();\\n\\t_cameraR.matrixAutoUpdate = false;\\n\\n\\tvar _camera = new THREE.OrthographicCamera( -1, 1, 1, - 1, 0, 1 );\\n\\n\\tvar _scene = new THREE.Scene();\\n\\n\\tvar _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\\n\\n\\tif ( width === undefined ) width = 512;\\n\\tif ( height === undefined ) height = 512;\\n\\n\\tvar _renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\\n\\tvar _renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\\n\\n\\tvar _material = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\t\\\"mapLeft\\\": { type: \\\"t\\\", value: _renderTargetL },\\n\\t\\t\\t\\\"mapRight\\\": { type: \\\"t\\\", value: _renderTargetR }\\n\\n\\t\\t},\\n\\n\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"\\tvUv = vec2( uv.x, uv.y );\\\",\\n\\t\\t\\t\\\"\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\\"uniform sampler2D mapLeft;\\\",\\n\\t\\t\\t\\\"uniform sampler2D mapRight;\\\",\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"\\tvec4 colorL, colorR;\\\",\\n\\t\\t\\t\\\"\\tvec2 uv = vUv;\\\",\\n\\n\\t\\t\\t\\\"\\tcolorL = texture2D( mapLeft, uv );\\\",\\n\\t\\t\\t\\\"\\tcolorR = texture2D( mapRight, uv );\\\",\\n\\n\\t\\t\\t\\t// http://3dtv.at/Knowhow/AnaglyphComparison_en.aspx\\n\\n\\t\\t\\t\\\"\\tgl_FragColor = vec4( colorL.g * 0.7 + colorL.b * 0.3, colorR.g, colorR.b, colorL.a + colorR.a ) * 1.1;\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t} );\\n\\n\\tvar mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), _material );\\n\\t_scene.add( mesh );\\n\\n\\tthis.setSize = function ( width, height ) {\\n\\n\\t\\tif ( _renderTargetL ) _renderTargetL.dispose();\\n\\t\\tif ( _renderTargetR ) _renderTargetR.dispose();\\n\\t\\t_renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\\n\\t\\t_renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\\n\\n\\t\\t_material.uniforms[ \\\"mapLeft\\\" ].value = _renderTargetL;\\n\\t\\t_material.uniforms[ \\\"mapRight\\\" ].value = _renderTargetR;\\n\\n\\t\\trenderer.setSize( width, height );\\n\\n\\t};\\n\\n\\t/*\\n\\t * Renderer now uses an asymmetric perspective projection\\n\\t * (http://paulbourke.net/miscellaneous/stereographics/stereorender/).\\n\\t *\\n\\t * Each camera is offset by the eye seperation and its projection matrix is\\n\\t * also skewed asymetrically back to converge on the same projection plane.\\n\\t * Added a focal length parameter to, this is where the parallax is equal to 0.\\n\\t */\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\n\\t\\tscene.updateMatrixWorld();\\n\\n\\t\\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\\n\\n\\t\\tvar hasCameraChanged = ( _aspect !== camera.aspect ) || ( _near !== camera.near ) || ( _far !== camera.far ) || ( _fov !== camera.fov );\\n\\n\\t\\tif ( hasCameraChanged ) {\\n\\n\\t\\t\\t_aspect = camera.aspect;\\n\\t\\t\\t_near = camera.near;\\n\\t\\t\\t_far = camera.far;\\n\\t\\t\\t_fov = camera.fov;\\n\\n\\t\\t\\tvar projectionMatrix = camera.projectionMatrix.clone();\\n\\t\\t\\tvar eyeSep = focalLength / 30 * 0.5;\\n\\t\\t\\tvar eyeSepOnProjection = eyeSep * _near / focalLength;\\n\\t\\t\\tvar ymax = _near * Math.tan( THREE.Math.degToRad( _fov * 0.5 ) );\\n\\t\\t\\tvar xmin, xmax;\\n\\n\\t\\t\\t// translate xOffset\\n\\n\\t\\t\\teyeRight.elements[12] = eyeSep;\\n\\t\\t\\teyeLeft.elements[12] = -eyeSep;\\n\\n\\t\\t\\t// for left eye\\n\\n\\t\\t\\txmin = -ymax * _aspect + eyeSepOnProjection;\\n\\t\\t\\txmax = ymax * _aspect + eyeSepOnProjection;\\n\\n\\t\\t\\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\\n\\t\\t\\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\\n\\n\\t\\t\\t_cameraL.projectionMatrix.copy( projectionMatrix );\\n\\n\\t\\t\\t// for right eye\\n\\n\\t\\t\\txmin = -ymax * _aspect - eyeSepOnProjection;\\n\\t\\t\\txmax = ymax * _aspect - eyeSepOnProjection;\\n\\n\\t\\t\\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\\n\\t\\t\\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\\n\\n\\t\\t\\t_cameraR.projectionMatrix.copy( projectionMatrix );\\n\\n\\t\\t}\\n\\n\\t\\t_cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\\n\\t\\t_cameraL.position.copy( camera.position );\\n\\t\\t_cameraL.near = camera.near;\\n\\t\\t_cameraL.far = camera.far;\\n\\n\\t\\trenderer.render( scene, _cameraL, _renderTargetL, true );\\n\\n\\t\\t_cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\\n\\t\\t_cameraR.position.copy( camera.position );\\n\\t\\t_cameraR.near = camera.near;\\n\\t\\t_cameraR.far = camera.far;\\n\\n\\t\\trenderer.render( scene, _cameraR, _renderTargetR, true );\\n\\n\\t\\trenderer.render( _scene, _camera );\\n\\n\\t};\\n\\n\\tthis.dispose = function() {\\n\\t\\tif ( _renderTargetL ) _renderTargetL.dispose();\\n\\t\\tif ( _renderTargetR ) _renderTargetR.dispose();\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Effects/StereoEffect.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Effects/StereoEffect.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n * @authod mrdoob / http://mrdoob.com/\\n * @authod arodic / http://aleksandarrodic.com/\\n */\\n\\nTHREE.StereoEffect = function ( renderer ) {\\n\\n\\t// API\\n\\n\\tthis.separation = 3;\\n\\n\\t// internals\\n\\n\\tvar _width, _height;\\n\\n\\tvar _position = new THREE.Vector3();\\n\\tvar _quaternion = new THREE.Quaternion();\\n\\tvar _scale = new THREE.Vector3();\\n\\n\\tvar _cameraL = new THREE.PerspectiveCamera();\\n\\tvar _cameraR = new THREE.PerspectiveCamera();\\n\\n\\t// initialization\\n\\n\\trenderer.autoClear = false;\\n\\n\\tthis.setSize = function ( width, height ) {\\n\\n\\t\\t_width = width / 2;\\n\\t\\t_height = height;\\n\\n\\t\\trenderer.setSize( width, height );\\n\\n\\t};\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\n\\t\\tscene.updateMatrixWorld();\\n\\n\\t\\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\\n\\t\\n\\t\\tcamera.matrixWorld.decompose( _position, _quaternion, _scale );\\n\\n\\t\\t// left\\n\\n\\t\\t_cameraL.fov = camera.fov;\\n\\t\\t_cameraL.aspect = 0.5 * camera.aspect;\\n\\t\\t_cameraL.near = camera.near;\\n\\t\\t_cameraL.far = camera.far;\\n\\t\\t_cameraL.updateProjectionMatrix();\\n\\n\\t\\t_cameraL.position.copy( _position );\\n\\t\\t_cameraL.quaternion.copy( _quaternion );\\n\\t\\t_cameraL.translateX( - this.separation );\\n\\n\\t\\t// right\\n\\n\\t\\t_cameraR.near = camera.near;\\n\\t\\t_cameraR.far = camera.far;\\n\\t\\t_cameraR.projectionMatrix = _cameraL.projectionMatrix;\\n\\n\\t\\t_cameraR.position.copy( _position );\\n\\t\\t_cameraR.quaternion.copy( _quaternion );\\n\\t\\t_cameraR.translateX( this.separation );\\n\\n\\t\\t//\\n\\n\\t\\trenderer.setViewport( 0, 0, _width * 2, _height );\\n\\t\\trenderer.clear();\\n\\n\\t\\trenderer.setViewport( 0, 0, _width, _height );\\n\\t\\trenderer.render( scene, _cameraL );\\n\\n\\t\\trenderer.setViewport( _width, 0, _width, _height );\\n\\t\\trenderer.render( scene, _cameraR );\\n\\n\\t};\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Effects/AsciiEffect.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Effects/AsciiEffect.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/*\\n * @author zz85 / https://github.com/zz85\\n *\\n * Ascii generation is based on http://www.nihilogic.dk/labs/jsascii/\\n * Maybe more about this later with a blog post at http://lab4games.net/zz85/blog\\n *\\n * 16 April 2012 - @blurspline\\n */\\n\\nTHREE.AsciiEffect = function ( renderer, charSet, options ) {\\n\\n\\t// its fun to create one your own!\\n\\n\\tcharSet = ( charSet === undefined ) ? ' .:-=+*#%@' : charSet;\\n\\n\\t// ' .,:;=|iI+hHOE#`$';\\n\\t// darker bolder character set from https://github.com/saw/Canvas-ASCII-Art/\\n\\t// ' .\\\\'`^\\\",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$'.split('');\\n\\n\\tif ( !options ) options = {};\\n\\n\\t// Some ASCII settings\\n\\n\\tvar bResolution = !options['resolution'] ? 0.15 : options['resolution']; // Higher for more details\\n\\tvar iScale = !options['scale'] ? 1 : options['scale'];\\n\\tvar bColor = !options['color'] ? false : options['color']; // nice but slows down rendering!\\n\\tvar bAlpha = !options['alpha'] ? false : options['alpha']; // Transparency\\n\\tvar bBlock = !options['block'] ? false : options['block']; // blocked characters. like good O dos\\n\\tvar bInvert = !options['invert'] ? false : options['invert']; // black is white, white is black\\n\\n\\tvar strResolution = 'low';\\n\\n\\tvar width, height;\\n\\n\\tvar domElement = document.createElement('div');\\n\\tdomElement.style.cursor = 'default';\\n\\n\\tvar oAscii = document.createElement(\\\"table\\\");\\n\\tdomElement.appendChild( oAscii );\\n\\n\\tvar iWidth, iHeight;\\n\\tvar oImg;\\n\\n\\tthis.setSize = function ( w, h ) {\\n\\n\\t\\twidth = w;\\n\\t\\theight = h;\\n\\n\\t\\trenderer.setSize( w, h );\\n\\n\\t\\tinitAsciiSize();\\n\\n\\t};\\n\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\n\\t\\trenderer.render( scene, camera );\\n\\t\\tasciifyImage( renderer, oAscii );\\n\\n\\t};\\n\\n\\tthis.domElement = domElement;\\n\\n\\n\\t// Throw in ascii library from http://www.nihilogic.dk/labs/jsascii/jsascii.js\\n\\n\\t/*\\n\\t* jsAscii 0.1\\n\\t* Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/\\n\\t* MIT License [http://www.nihilogic.dk/licenses/mit-license.txt]\\n\\t*/\\n\\n\\tfunction initAsciiSize() {\\n\\n\\t\\tiWidth = Math.round( width * fResolution );\\n\\t\\tiHeight = Math.round( height * fResolution );\\n\\n\\t\\toCanvas.width = iWidth;\\n\\t\\toCanvas.height = iHeight;\\n\\t\\t// oCanvas.style.display = \\\"none\\\";\\n\\t\\t// oCanvas.style.width = iWidth;\\n\\t\\t// oCanvas.style.height = iHeight;\\n\\n\\t\\toImg = renderer.domElement;\\n\\n\\t\\tif ( oImg.style.backgroundColor ) {\\n\\n\\t\\t\\toAscii.rows[0].cells[0].style.backgroundColor = oImg.style.backgroundColor;\\n\\t\\t\\toAscii.rows[0].cells[0].style.color = oImg.style.color;\\n\\n\\t\\t}\\n\\n\\t\\toAscii.cellSpacing = 0;\\n\\t\\toAscii.cellPadding = 0;\\n\\n\\t\\tvar oStyle = oAscii.style;\\n\\t\\toStyle.display = \\\"inline\\\";\\n\\t\\toStyle.width = Math.round(iWidth/fResolution*iScale) + \\\"px\\\";\\n\\t\\toStyle.height = Math.round(iHeight/fResolution*iScale) + \\\"px\\\";\\n\\t\\toStyle.whiteSpace = \\\"pre\\\";\\n\\t\\toStyle.margin = \\\"0px\\\";\\n\\t\\toStyle.padding = \\\"0px\\\";\\n\\t\\toStyle.letterSpacing = fLetterSpacing + \\\"px\\\";\\n\\t\\toStyle.fontFamily = strFont;\\n\\t\\toStyle.fontSize = fFontSize + \\\"px\\\";\\n\\t\\toStyle.lineHeight = fLineHeight + \\\"px\\\";\\n\\t\\toStyle.textAlign = \\\"left\\\";\\n\\t\\toStyle.textDecoration = \\\"none\\\";\\n\\t}\\n\\n\\n\\tvar aDefaultCharList = (\\\" .,:;i1tfLCG08@\\\").split(\\\"\\\");\\n\\tvar aDefaultColorCharList = (\\\" CGO08@\\\").split(\\\"\\\");\\n\\tvar strFont = \\\"courier new, monospace\\\";\\n\\n\\tvar oCanvasImg = renderer.domElement;\\n\\n\\tvar oCanvas = document.createElement(\\\"canvas\\\");\\n\\tif (!oCanvas.getContext) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tvar oCtx = oCanvas.getContext(\\\"2d\\\");\\n\\tif (!oCtx.getImageData) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tvar aCharList = (bColor ? aDefaultColorCharList : aDefaultCharList);\\n\\n\\tif (charSet) aCharList = charSet;\\n\\n\\tvar fResolution = 0.5;\\n\\n\\tswitch ( strResolution ) {\\n\\n\\t\\tcase \\\"low\\\" : \\tfResolution = 0.25; break;\\n\\t\\tcase \\\"medium\\\" : fResolution = 0.5; break;\\n\\t\\tcase \\\"high\\\" : \\tfResolution = 1; break;\\n\\n\\t}\\n\\n\\tif ( bResolution ) fResolution = bResolution;\\n\\n\\t// Setup dom\\n\\n\\tvar fFontSize = (2/fResolution)*iScale;\\n\\tvar fLineHeight = (2/fResolution)*iScale;\\n\\n\\t// adjust letter-spacing for all combinations of scale and resolution to get it to fit the image width.\\n\\n\\tvar fLetterSpacing = 0;\\n\\n\\tif ( strResolution == \\\"low\\\" ) {\\n\\n\\t\\tswitch (iScale) {\\n\\t\\t\\tcase 1 : fLetterSpacing = -1; break;\\n\\t\\t\\tcase 2 :\\n\\t\\t\\tcase 3 : fLetterSpacing = -2.1; break;\\n\\t\\t\\tcase 4 : fLetterSpacing = -3.1; break;\\n\\t\\t\\tcase 5 : fLetterSpacing = -4.15; break;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tif ( strResolution == \\\"medium\\\" ) {\\n\\n\\t\\tswitch (iScale) {\\n\\t\\t\\tcase 1 : fLetterSpacing = 0; break;\\n\\t\\t\\tcase 2 : fLetterSpacing = -1; break;\\n\\t\\t\\tcase 3 : fLetterSpacing = -1.04; break;\\n\\t\\t\\tcase 4 :\\n\\t\\t\\tcase 5 : fLetterSpacing = -2.1; break;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tif ( strResolution == \\\"high\\\" ) {\\n\\n\\t\\tswitch (iScale) {\\n\\t\\t\\tcase 1 :\\n\\t\\t\\tcase 2 : fLetterSpacing = 0; break;\\n\\t\\t\\tcase 3 :\\n\\t\\t\\tcase 4 :\\n\\t\\t\\tcase 5 : fLetterSpacing = -1; break;\\n\\t\\t}\\n\\n\\t}\\n\\n\\n\\t// can't get a span or div to flow like an img element, but a table works?\\n\\n\\n\\t// convert img element to ascii\\n\\n\\tfunction asciifyImage( canvasRenderer, oAscii ) {\\n\\n\\t\\toCtx.clearRect( 0, 0, iWidth, iHeight );\\n\\t\\toCtx.drawImage( oCanvasImg, 0, 0, iWidth, iHeight );\\n\\t\\tvar oImgData = oCtx.getImageData(0, 0, iWidth, iHeight).data;\\n\\n\\t\\t// Coloring loop starts now\\n\\t\\tvar strChars = \\\"\\\";\\n\\n\\t\\t// console.time('rendering');\\n\\n\\t\\tfor (var y=0;y<iHeight;y+=2) {\\n\\t\\t\\tfor (var x=0;x<iWidth;x++) {\\n\\t\\t\\t\\tvar iOffset = (y*iWidth + x) * 4;\\n\\n\\t\\t\\t\\tvar iRed = oImgData[iOffset];\\n\\t\\t\\t\\tvar iGreen = oImgData[iOffset + 1];\\n\\t\\t\\t\\tvar iBlue = oImgData[iOffset + 2];\\n\\t\\t\\t\\tvar iAlpha = oImgData[iOffset + 3];\\n\\t\\t\\t\\tvar iCharIdx;\\n\\n\\t\\t\\t\\tvar fBrightness;\\n\\n\\t\\t\\t\\tfBrightness = (0.3*iRed + 0.59*iGreen + 0.11*iBlue) / 255;\\n\\t\\t\\t\\t// fBrightness = (0.3*iRed + 0.5*iGreen + 0.3*iBlue) / 255;\\n\\n\\t\\t\\t\\tif (iAlpha == 0) {\\n\\t\\t\\t\\t\\t// should calculate alpha instead, but quick hack :)\\n\\t\\t\\t\\t\\t//fBrightness *= (iAlpha / 255);\\n\\t\\t\\t\\t\\tfBrightness = 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tiCharIdx = Math.floor((1-fBrightness) * (aCharList.length-1));\\n\\n\\t\\t\\t\\tif (bInvert) {\\n\\t\\t\\t\\t\\tiCharIdx = aCharList.length - iCharIdx - 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// good for debugging\\n\\t\\t\\t\\t//fBrightness = Math.floor(fBrightness * 10);\\n\\t\\t\\t\\t//strThisChar = fBrightness;\\n\\n\\t\\t\\t\\tvar strThisChar = aCharList[iCharIdx];\\n\\n\\t\\t\\t\\tif (strThisChar===undefined || strThisChar == \\\" \\\")\\n\\t\\t\\t\\t\\tstrThisChar = \\\"&nbsp;\\\";\\n\\n\\t\\t\\t\\tif (bColor) {\\n\\t\\t\\t\\t\\tstrChars += \\\"<span style='\\\"\\n\\t\\t\\t\\t\\t\\t+ \\\"color:rgb(\\\"+iRed+\\\",\\\"+iGreen+\\\",\\\"+iBlue+\\\");\\\"\\n\\t\\t\\t\\t\\t\\t+ (bBlock ? \\\"background-color:rgb(\\\"+iRed+\\\",\\\"+iGreen+\\\",\\\"+iBlue+\\\");\\\" : \\\"\\\")\\n\\t\\t\\t\\t\\t\\t+ (bAlpha ? \\\"opacity:\\\" + (iAlpha/255) + \\\";\\\" : \\\"\\\")\\n\\t\\t\\t\\t\\t\\t+ \\\"'>\\\" + strThisChar + \\\"</span>\\\";\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstrChars += strThisChar;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstrChars += \\\"<br/>\\\";\\n\\t\\t}\\n\\n\\t\\toAscii.innerHTML = \\\"<tr><td>\\\" + strChars + \\\"</td></tr>\\\";\\n\\n\\t\\t// console.timeEnd('rendering');\\n\\n\\t\\t// return oAscii;\\n\\t}\\n\\n\\t// end modified asciifyImage block\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Exporters/OBJExporter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Exporters/OBJExporter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.OBJExporter = function () {};\\n\\nTHREE.OBJExporter.prototype = {\\n\\n\\tconstructor: THREE.OBJExporter,\\n\\n\\tparse: function ( geometry ) {\\n\\n\\t\\tvar output = '';\\n\\n\\t\\tfor ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar vertex = geometry.vertices[ i ];\\n\\t\\t\\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\\\n';\\n\\n\\t\\t}\\n\\n\\t\\t// uvs\\n\\n\\t\\tfor ( var i = 0, l = geometry.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar vertexUvs = geometry.faceVertexUvs[ 0 ][ i ];\\n\\n\\t\\t\\tfor ( var j = 0; j < vertexUvs.length; j ++ ) {\\n\\n\\t\\t\\t\\tvar uv = vertexUvs[ j ];\\n\\t\\t\\t\\toutput += 'vt ' + uv.x + ' ' + uv.y + '\\\\n';\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// normals\\n\\n\\t\\tfor ( var i = 0, l = geometry.faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar normals = geometry.faces[ i ].vertexNormals;\\n\\n\\t\\t\\tfor ( var j = 0; j < normals.length; j ++ ) {\\n\\n\\t\\t\\t\\tvar normal = normals[ j ];\\n\\t\\t\\t\\toutput += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\\\n';\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// faces\\n\\n\\t\\tfor ( var i = 0, j = 1, l = geometry.faces.length; i < l; i ++, j += 3 ) {\\n\\n\\t\\t\\tvar face = geometry.faces[ i ];\\n\\n\\t\\t\\toutput += 'f ';\\n\\t\\t\\toutput += ( face.a + 1 ) + '/' + ( j ) + '/' + ( j ) + ' ';\\n\\t\\t\\toutput += ( face.b + 1 ) + '/' + ( j + 1 ) + '/' + ( j + 1 ) + ' ';\\n\\t\\t\\toutput += ( face.c + 1 ) + '/' + ( j + 2 ) + '/' + ( j + 2 ) + '\\\\n';\\n\\n\\t\\t}\\n\\n\\t\\treturn output;\\n\\n\\t}\\n\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Exporters/STLExporter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Exporters/STLExporter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author kovacsv / http://kovacsv.hu/\\n * @author mrdoob / http://mrdoob.com/\\n */\\n \\nTHREE.STLExporter = function () {};\\n\\nTHREE.STLExporter.prototype = {\\n\\n\\tconstructor: THREE.STLExporter,\\n\\n\\tparse: ( function () {\\n\\n\\t\\tvar vector = new THREE.Vector3();\\n\\t\\tvar normalMatrixWorld = new THREE.Matrix3();\\n\\n\\t\\treturn function ( scene ) {\\n\\n\\t\\t\\tvar output = '';\\n\\n\\t\\t\\toutput += 'solid exported\\\\n';\\n\\n\\t\\t\\tscene.traverse( function ( object ) {\\n\\n\\t\\t\\t\\tif ( object instanceof THREE.Mesh ) {\\n\\n\\t\\t\\t\\t\\tvar geometry = object.geometry;\\n\\t\\t\\t\\t\\tvar matrixWorld = object.matrixWorld;\\n\\n\\t\\t\\t\\t\\tif ( geometry instanceof THREE.Geometry ) {\\n\\n\\t\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\t\\t\\t\\tvar faces = geometry.faces;\\n\\n\\t\\t\\t\\t\\t\\tnormalMatrixWorld.getNormalMatrix( matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tvector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();\\n\\n\\t\\t\\t\\t\\t\\t\\toutput += '\\\\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\\\n';\\n\\t\\t\\t\\t\\t\\t\\toutput += '\\\\t\\\\touter loop\\\\n';\\n\\n\\t\\t\\t\\t\\t\\t\\tvar indices = [ face.a, face.b, face.c ];\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvector.copy( vertices[ indices[ j ] ] ).applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\toutput += '\\\\t\\\\t\\\\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\\\n';\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\toutput += '\\\\t\\\\tendloop\\\\n';\\n\\t\\t\\t\\t\\t\\t\\toutput += '\\\\tendfacet\\\\n';\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\toutput += 'endsolid exported\\\\n';\\n\\n\\t\\t\\treturn output;\\n\\n\\t\\t};\\n\\n\\t}() )\\n\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Exporters/MaterialExporter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Exporters/MaterialExporter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.MaterialExporter = function () {};\\n\\nTHREE.MaterialExporter.prototype = {\\n\\n\\tconstructor: THREE.MaterialExporter,\\n\\n\\tparse: function ( material ) {\\n\\n\\t\\tvar output = {\\n\\t\\t\\tmetadata: {\\n\\t\\t\\t\\tversion: 4.2,\\n\\t\\t\\t\\ttype: 'material',\\n\\t\\t\\t\\tgenerator: 'MaterialExporter'\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\toutput.uuid = material.uuid;\\n\\n\\t\\tif ( material.name !== \\\"\\\" ) output.name = material.name;\\n\\n\\t\\tif ( material instanceof THREE.MeshBasicMaterial ) {\\n\\n\\t\\t\\toutput.type = 'MeshBasicMaterial';\\n\\t\\t\\toutput.color = material.color.getHex();\\n\\t\\t\\tif ( material.vertexColors !== THREE.NoColors ) output.vertexColors = material.vertexColors;\\n\\t\\t\\tif ( material.blending !== THREE.NormalBlending ) output.blending = material.blending;\\n\\t\\t\\tif ( material.side !== THREE.FrontSide ) output.side = material.side;\\n\\t\\t\\toutput.opacity = material.opacity;\\n\\t\\t\\toutput.transparent = material.transparent;\\n\\t\\t\\toutput.wireframe = material.wireframe;\\n\\n\\t\\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\\n\\n\\t\\t\\toutput.type = 'MeshLambertMaterial';\\n\\t\\t\\toutput.color = material.color.getHex();\\n\\t\\t\\toutput.ambient = material.ambient.getHex();\\n\\t\\t\\toutput.emissive = material.emissive.getHex();\\n\\t\\t\\tif ( material.vertexColors !== THREE.NoColors ) output.vertexColors = material.vertexColors;\\n\\t\\t\\tif ( material.blending !== THREE.NormalBlending ) output.blending = material.blending;\\n\\t\\t\\tif ( material.side !== THREE.FrontSide ) output.side = material.side;\\n\\t\\t\\toutput.opacity = material.opacity;\\n\\t\\t\\toutput.transparent = material.transparent;\\n\\t\\t\\toutput.wireframe = material.wireframe;\\n\\n\\t\\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\\n\\n\\t\\t\\toutput.type = 'MeshPhongMaterial';\\n\\t\\t\\toutput.color = material.color.getHex();\\n\\t\\t\\toutput.ambient = material.ambient.getHex();\\n\\t\\t\\toutput.emissive = material.emissive.getHex();\\n\\t\\t\\toutput.specular = material.specular.getHex();\\n\\t\\t\\toutput.shininess = material.shininess;\\n\\t\\t\\tif ( material.vertexColors !== THREE.NoColors ) output.vertexColors = material.vertexColors;\\n\\t\\t\\tif ( material.blending !== THREE.NormalBlending ) output.blending = material.blending;\\n\\t\\t\\tif ( material.side !== THREE.FrontSide ) output.side = material.side;\\n\\t\\t\\toutput.opacity = material.opacity;\\n\\t\\t\\toutput.transparent = material.transparent;\\n\\t\\t\\toutput.wireframe = material.wireframe;\\n\\n\\t\\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\\n\\n\\t\\t\\toutput.type = 'MeshNormalMaterial';\\n\\t\\t\\tif ( material.blending !== THREE.NormalBlending ) output.blending = material.blending;\\n\\t\\t\\tif ( material.side !== THREE.FrontSide ) output.side = material.side;\\n\\t\\t\\toutput.opacity = material.opacity;\\n\\t\\t\\toutput.transparent = material.transparent;\\n\\t\\t\\toutput.wireframe = material.wireframe;\\n\\n\\t\\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\\n\\n\\t\\t\\toutput.type = 'MeshDepthMaterial';\\n\\t\\t\\tif ( material.blending !== THREE.NormalBlending ) output.blending = material.blending;\\n\\t\\t\\tif ( material.side !== THREE.FrontSide ) output.side = material.side;\\n\\t\\t\\toutput.opacity = material.opacity;\\n\\t\\t\\toutput.transparent = material.transparent;\\n\\t\\t\\toutput.wireframe = material.wireframe;\\n\\n\\t\\t} else if ( material instanceof THREE.MeshFaceMaterial ) {\\n\\n\\t\\t\\toutput.type = 'MeshFaceMaterial';\\n\\t\\t\\toutput.materials = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = material.materials.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\toutput.materials.push( this.parse( material.materials[ i ] ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else if ( material instanceof THREE.ShaderMaterial ) {\\n\\n\\t\\t\\toutput.type = 'ShaderMaterial';\\n\\t\\t\\toutput.uniforms = material.uniforms;\\n\\t\\t\\toutput.vertexShader = material.vertexShader;\\n\\t\\t\\toutput.fragmentShader = material.fragmentShader;\\n\\n\\t\\t} else if ( material instanceof THREE.SpriteMaterial ) {\\n\\n\\t\\t\\toutput.type = 'SpriteMaterial';\\n\\t\\t\\toutput.color = material.color.getHex();\\n\\t\\t\\toutput.opacity = material.opacity;\\n\\t\\t\\toutput.transparent = material.transparent;\\n\\n\\t\\t}\\n\\n\\t\\treturn output;\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Exporters/BufferGeometryExporter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Exporters/BufferGeometryExporter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.BufferGeometryExporter = function () {};\\n\\nTHREE.BufferGeometryExporter.prototype = {\\n\\n\\tconstructor: THREE.BufferGeometryExporter,\\n\\n\\tparse: function ( geometry ) {\\n\\n\\t\\tvar output = {\\n\\t\\t\\tmetadata: {\\n\\t\\t\\t\\tversion: 4.0,\\n\\t\\t\\t\\ttype: 'BufferGeometry',\\n\\t\\t\\t\\tgenerator: 'BufferGeometryExporter'\\n\\t\\t\\t},\\n\\t\\t\\tattributes: {\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tvar attributes = geometry.attributes;\\n\\t\\tvar offsets = geometry.offsets;\\n\\t\\tvar boundingSphere = geometry.boundingSphere;\\n\\n\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\tvar attribute = attributes[ key ];\\n\\n\\t\\t\\tvar array = [], typeArray = attribute.array;\\n\\n\\t\\t\\tfor ( var i = 0, l = typeArray.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tarray[ i ] = typeArray[ i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\toutput.attributes[ key ] = {\\n\\t\\t\\t\\titemSize: attribute.itemSize,\\n\\t\\t\\t\\ttype: attribute.array.constructor.name,\\n\\t\\t\\t\\tarray: array\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( offsets.length > 0 ) {\\n\\n\\t\\t\\toutput.offsets = JSON.parse( JSON.stringify( offsets ) );\\n\\n\\t\\t}\\n\\n\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\toutput.boundingSphere = {\\n\\t\\t\\t\\tcenter: boundingSphere.center.toArray(),\\n\\t\\t\\t\\tradius: boundingSphere.radius\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn output;\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Exporters/ObjectExporter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Exporters/ObjectExporter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.ObjectExporter = function () {};\\n\\nTHREE.ObjectExporter.prototype = {\\n\\n\\tconstructor: THREE.ObjectExporter,\\n\\n\\tparse: function ( object ) {\\n\\n\\t\\t// console.log( object );\\n\\n\\t\\tvar output = {\\n\\t\\t\\tmetadata: {\\n\\t\\t\\t\\tversion: 4.3,\\n\\t\\t\\t\\ttype: 'Object',\\n\\t\\t\\t\\tgenerator: 'ObjectExporter'\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t//\\n\\n\\t\\tvar geometries = {};\\n\\t\\tvar geometryExporter = new THREE.GeometryExporter();\\n\\t\\tvar bufferGeometryExporter = new THREE.BufferGeometryExporter();\\n\\n\\t\\tvar parseGeometry = function ( geometry ) {\\n\\n\\t\\t\\tif ( output.geometries === undefined ) {\\n\\n\\t\\t\\t\\toutput.geometries = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometries[ geometry.uuid ] === undefined ) {\\n\\n\\t\\t\\t\\tvar data = {};\\n\\n\\t\\t\\t\\tdata.uuid = geometry.uuid;\\n\\n\\t\\t\\t\\tif ( geometry.name !== \\\"\\\" ) data.name = geometry.name;\\n\\n\\t\\t\\t\\tvar handleParameters = function ( parameters ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < parameters.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar parameter = parameters[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( geometry.parameters[ parameter ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tdata[ parameter ] = geometry.parameters[ parameter ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tif ( geometry instanceof THREE.PlaneGeometry ) {\\n\\n\\t\\t\\t\\t\\tdata.type = 'PlaneGeometry';\\n\\t\\t\\t\\t\\thandleParameters( [ 'width', 'height', 'widthSegments', 'heightSegments' ] );\\n\\n\\t\\t\\t\\t} else if ( geometry instanceof THREE.BoxGeometry ) {\\n\\n\\t\\t\\t\\t\\tdata.type = 'BoxGeometry';\\n\\t\\t\\t\\t\\thandleParameters( [ 'width', 'height', 'depth', 'widthSegments', 'heightSegments', 'depthSegments' ] );\\n\\n\\t\\t\\t\\t} else if ( geometry instanceof THREE.CircleGeometry ) {\\n\\n\\t\\t\\t\\t\\tdata.type = 'CircleGeometry';\\n\\t\\t\\t\\t\\thandleParameters( [ 'radius', 'segments' ] );\\n\\n\\t\\t\\t\\t} else if ( geometry instanceof THREE.CylinderGeometry ) {\\n\\n\\t\\t\\t\\t\\tdata.type = 'CylinderGeometry';\\n\\t\\t\\t\\t\\thandleParameters( [ 'radiusTop', 'radiusBottom', 'height', 'radialSegments', 'heightSegments', 'openEnded' ] );\\n\\n\\t\\t\\t\\t} else if ( geometry instanceof THREE.SphereGeometry ) {\\n\\n\\t\\t\\t\\t\\tdata.type = 'SphereGeometry';\\n\\t\\t\\t\\t\\thandleParameters( [ 'radius', 'widthSegments', 'heightSegments', 'phiStart', 'phiLength', 'thetaStart', 'thetaLength' ] );\\n\\n\\t\\t\\t\\t} else if ( geometry instanceof THREE.IcosahedronGeometry ) {\\n\\n\\t\\t\\t\\t\\tdata.type = 'IcosahedronGeometry';\\n\\t\\t\\t\\t\\thandleParameters( [ 'radius', 'detail' ] );\\n\\n\\t\\t\\t\\t} else if ( geometry instanceof THREE.TorusGeometry ) {\\n\\n\\t\\t\\t\\t\\tdata.type = 'TorusGeometry';\\n\\t\\t\\t\\t\\thandleParameters( [ 'radius', 'tube', 'radialSegments', 'tubularSegments', 'arc' ] );\\n\\n\\t\\t\\t\\t} else if ( geometry instanceof THREE.TorusKnotGeometry ) {\\n\\n\\t\\t\\t\\t\\tdata.type = 'TorusKnotGeometry';\\n\\t\\t\\t\\t\\thandleParameters( [ 'radius', 'tube', 'radialSegments', 'tubularSegments', 'p', 'q', 'heightScale' ] );\\n\\n\\t\\t\\t\\t} else if ( geometry instanceof THREE.BufferGeometry ) {\\n\\n\\t\\t\\t\\t\\tdata.type = 'BufferGeometry';\\n\\t\\t\\t\\t\\tdata.data = bufferGeometryExporter.parse( geometry );\\n\\n\\t\\t\\t\\t\\tdelete data.data.metadata;\\n\\n\\t\\t\\t\\t} else if ( geometry instanceof THREE.Geometry ) {\\n\\n\\t\\t\\t\\t\\tdata.type = 'Geometry';\\n\\t\\t\\t\\t\\tdata.data = geometryExporter.parse( geometry );\\n\\n\\t\\t\\t\\t\\tdelete data.data.metadata;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometries[ geometry.uuid ] = data;\\n\\n\\t\\t\\t\\toutput.geometries.push( data );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometry.uuid;\\n\\n\\t\\t};\\n\\n\\t\\t//\\n\\n\\t\\tvar materials = {};\\n\\t\\tvar materialExporter = new THREE.MaterialExporter();\\n\\n\\t\\tvar parseMaterial = function ( material ) {\\n\\n\\t\\t\\tif ( output.materials === undefined ) {\\n\\n\\t\\t\\t\\toutput.materials = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( materials[ material.uuid ] === undefined ) {\\n\\n\\t\\t\\t\\tvar data = materialExporter.parse( material );\\n\\n\\t\\t\\t\\tdelete data.metadata;\\n\\n\\t\\t\\t\\tmaterials[ material.uuid ] = data;\\n\\n\\t\\t\\t\\toutput.materials.push( data );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn material.uuid;\\n\\n\\t\\t};\\n\\n\\t\\t//\\n\\n\\t\\tvar parseObject = function ( object ) {\\n\\n\\t\\t\\tvar data = {};\\n\\n\\t\\t\\tdata.uuid = object.uuid;\\n\\n\\t\\t\\tif ( object.name !== '' ) data.name = object.name;\\n\\t\\t\\tif ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;\\n\\t\\t\\tif ( object.visible !== true ) data.visible = object.visible;\\n\\n\\t\\t\\tif ( object instanceof THREE.Scene ) {\\n\\n\\t\\t\\t\\tdata.type = 'Scene';\\n\\n\\t\\t\\t} else if ( object instanceof THREE.PerspectiveCamera ) {\\n\\n\\t\\t\\t\\tdata.type = 'PerspectiveCamera';\\n\\t\\t\\t\\tdata.fov = object.fov;\\n\\t\\t\\t\\tdata.aspect = object.aspect;\\n\\t\\t\\t\\tdata.near = object.near;\\n\\t\\t\\t\\tdata.far = object.far;\\n\\n\\t\\t\\t} else if ( object instanceof THREE.OrthographicCamera ) {\\n\\n\\t\\t\\t\\tdata.type = 'OrthographicCamera';\\n\\t\\t\\t\\tdata.left = object.left;\\n\\t\\t\\t\\tdata.right = object.right;\\n\\t\\t\\t\\tdata.top = object.top;\\n\\t\\t\\t\\tdata.bottom = object.bottom;\\n\\t\\t\\t\\tdata.near = object.near;\\n\\t\\t\\t\\tdata.far = object.far;\\n\\n\\t\\t\\t} else if ( object instanceof THREE.AmbientLight ) {\\n\\n\\t\\t\\t\\tdata.type = 'AmbientLight';\\n\\t\\t\\t\\tdata.color = object.color.getHex();\\n\\n\\t\\t\\t} else if ( object instanceof THREE.DirectionalLight ) {\\n\\n\\t\\t\\t\\tdata.type = 'DirectionalLight';\\n\\t\\t\\t\\tdata.color = object.color.getHex();\\n\\t\\t\\t\\tdata.intensity = object.intensity;\\n\\n\\t\\t\\t} else if ( object instanceof THREE.PointLight ) {\\n\\n\\t\\t\\t\\tdata.type = 'PointLight';\\n\\t\\t\\t\\tdata.color = object.color.getHex();\\n\\t\\t\\t\\tdata.intensity = object.intensity;\\n\\t\\t\\t\\tdata.distance = object.distance;\\n\\n\\t\\t\\t} else if ( object instanceof THREE.SpotLight ) {\\n\\n\\t\\t\\t\\tdata.type = 'SpotLight';\\n\\t\\t\\t\\tdata.color = object.color.getHex();\\n\\t\\t\\t\\tdata.intensity = object.intensity;\\n\\t\\t\\t\\tdata.distance = object.distance;\\n\\t\\t\\t\\tdata.angle = object.angle;\\n\\t\\t\\t\\tdata.exponent = object.exponent;\\n\\n\\t\\t\\t} else if ( object instanceof THREE.HemisphereLight ) {\\n\\n\\t\\t\\t\\tdata.type = 'HemisphereLight';\\n\\t\\t\\t\\tdata.color = object.color.getHex();\\n\\t\\t\\t\\tdata.groundColor = object.groundColor.getHex();\\n\\n\\t\\t\\t} else if ( object instanceof THREE.Mesh ) {\\n\\n\\t\\t\\t\\tdata.type = 'Mesh';\\n\\t\\t\\t\\tdata.geometry = parseGeometry( object.geometry );\\n\\t\\t\\t\\tdata.material = parseMaterial( object.material );\\n\\n\\t\\t\\t} else if ( object instanceof THREE.Sprite ) {\\n\\n\\t\\t\\t\\tdata.type = 'Sprite';\\n\\t\\t\\t\\tdata.material = parseMaterial( object.material );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdata.type = 'Object3D';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdata.matrix = object.matrix.toArray();\\n\\n\\t\\t\\tif ( object.children.length > 0 ) {\\n\\n\\t\\t\\t\\tdata.children = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < object.children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tdata.children.push( parseObject( object.children[ i ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t\\toutput.object = parseObject( object );\\n\\n\\t\\treturn output;\\n\\n\\t}\\n\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Exporters/SceneExporter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Exporters/SceneExporter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.SceneExporter = function () {};\\n\\nTHREE.SceneExporter.prototype = {\\n\\n\\tconstructor: THREE.SceneExporter,\\n\\n\\tparse: function ( scene ) {\\n\\n\\t\\tvar position = Vector3String( scene.position );\\n\\t\\tvar rotation = Vector3String( scene.rotation );\\n\\t\\tvar scale = Vector3String( scene.scale );\\n\\n\\t\\tvar nobjects = 0;\\n\\t\\tvar ngeometries = 0;\\n\\t\\tvar nmaterials = 0;\\n\\t\\tvar ntextures = 0;\\n\\n\\t\\tvar objectsArray = [];\\n\\t\\tvar geometriesArray = [];\\n\\t\\tvar materialsArray = [];\\n\\t\\tvar texturesArray = [];\\n\\t\\tvar fogsArray = [];\\n\\n\\t\\tvar geometriesMap = {};\\n\\t\\tvar materialsMap = {};\\n\\t\\tvar texturesMap = {};\\n\\n\\t\\t// extract objects, geometries, materials, textures\\n\\n\\t\\tvar checkTexture = function ( map ) {\\n\\n\\t\\t\\tif ( ! map ) return;\\n\\n\\t\\t\\tif ( ! ( map.id in texturesMap ) ) {\\n\\n\\t\\t\\t\\ttexturesMap[ map.id ] = true;\\n\\t\\t\\t\\ttexturesArray.push( TextureString( map ) );\\n\\t\\t\\t\\tntextures += 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tvar linesArray = [];\\n\\n\\t\\tfunction createObjectsList( object, pad ) {\\n\\n\\t\\t\\tfor ( var i = 0; i < object.children.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar node = object.children[ i ];\\n\\n\\t\\t\\t\\tif ( node instanceof THREE.Mesh ) {\\n\\n\\t\\t\\t\\t\\tlinesArray.push( MeshString( node, pad ) );\\n\\t\\t\\t\\t\\tnobjects += 1;\\n\\n\\t\\t\\t\\t\\tif ( ! ( node.geometry.id in geometriesMap ) ) {\\n\\n\\t\\t\\t\\t\\t\\tgeometriesMap[ node.geometry.id ] = true;\\n\\t\\t\\t\\t\\t\\tgeometriesArray.push( GeometryString( node.geometry ) );\\n\\t\\t\\t\\t\\t\\tngeometries += 1;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( ! ( node.material.id in materialsMap ) ) {\\n\\n\\t\\t\\t\\t\\t\\tmaterialsMap[ node.material.id ] = true;\\n\\t\\t\\t\\t\\t\\tmaterialsArray.push( MaterialString( node.material ) );\\n\\t\\t\\t\\t\\t\\tnmaterials += 1;\\n\\n\\t\\t\\t\\t\\t\\tcheckTexture( node.material.map );\\n\\t\\t\\t\\t\\t\\tcheckTexture( node.material.envMap );\\n\\t\\t\\t\\t\\t\\tcheckTexture( node.material.lightMap );\\n\\t\\t\\t\\t\\t\\tcheckTexture( node.material.specularMap );\\n\\t\\t\\t\\t\\t\\tcheckTexture( node.material.bumpMap );\\n\\t\\t\\t\\t\\t\\tcheckTexture( node.material.normalMap );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( node instanceof THREE.Light ) {\\n\\n\\t\\t\\t\\t\\tlinesArray.push( LightString( node, pad ) );\\n\\t\\t\\t\\t\\tnobjects += 1;\\n\\n\\t\\t\\t\\t} else if ( node instanceof THREE.Camera ) {\\n\\n\\t\\t\\t\\t\\tlinesArray.push( CameraString( node, pad ) );\\n\\t\\t\\t\\t\\tnobjects += 1;\\n\\n\\t\\t\\t\\t} else if ( node instanceof THREE.Object3D ) {\\n\\n\\t\\t\\t\\t\\tlinesArray.push( ObjectString( node, pad ) );\\n\\t\\t\\t\\t\\tnobjects += 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( node.children.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tlinesArray.push( PaddingString( pad + 1 ) + '\\\\t\\\\t\\\"children\\\" : {' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcreateObjectsList( node, pad + 2 );\\n\\n\\t\\t\\t\\tif ( node.children.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tlinesArray.push( PaddingString( pad + 1 ) + \\\"\\\\t\\\\t}\\\" );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlinesArray.push( PaddingString( pad ) + \\\"\\\\t\\\\t}\\\" + ( i < object.children.length - 1 ? \\\",\\\\n\\\" : \\\"\\\" ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tcreateObjectsList( scene, 0 );\\n\\n\\t\\tvar objects = linesArray.join( \\\"\\\\n\\\" );\\n\\n\\t\\t// extract fog\\n\\n\\t\\tif ( scene.fog ) {\\n\\n\\t\\t\\tfogsArray.push( FogString( scene.fog ) );\\n\\n\\t\\t}\\n\\n\\t\\t// generate sections\\n\\n\\t\\tvar geometries = generateMultiLineString( geometriesArray, \\\",\\\\n\\\\n\\\\t\\\" );\\n\\t\\tvar materials = generateMultiLineString( materialsArray, \\\",\\\\n\\\\n\\\\t\\\" );\\n\\t\\tvar textures = generateMultiLineString( texturesArray, \\\",\\\\n\\\\n\\\\t\\\" );\\n\\t\\tvar fogs = generateMultiLineString( fogsArray, \\\",\\\\n\\\\n\\\\t\\\" );\\n\\n\\t\\t// generate defaults\\n\\n\\t\\tvar activeCamera = null;\\n\\n\\t\\tscene.traverse( function ( node ) {\\n\\n\\t\\t\\tif ( node instanceof THREE.Camera && node.userData.active ) {\\n\\n\\t\\t\\t\\tactiveCamera = node;\\n\\n\\t\\t\\t}\\n\\n\\t\\t} );\\n\\n\\t\\tvar defcamera = LabelString( activeCamera ? getObjectName( activeCamera ) : \\\"\\\" );\\n\\t\\tvar deffog = LabelString( scene.fog ? getFogName( scene.fog ) : \\\"\\\" );\\n\\n\\t\\t// templates\\n\\n\\t\\tfunction Vector2String( v ) {\\n\\n\\t\\t\\treturn \\\"[\\\" + v.x + \\\",\\\" + v.y + \\\"]\\\";\\n\\n\\t\\t}\\n\\n\\t\\tfunction Vector3String( v ) {\\n\\n\\t\\t\\treturn \\\"[\\\" + v.x + \\\",\\\" + v.y + \\\",\\\" + v.z + \\\"]\\\";\\n\\n\\t\\t}\\n\\n\\t\\tfunction ColorString( c ) {\\n\\n\\t\\t\\treturn \\\"[\\\" + c.r.toFixed( 3 ) + \\\",\\\" + c.g.toFixed( 3 ) + \\\",\\\" + c.b.toFixed( 3 ) + \\\"]\\\";\\n\\n\\t\\t}\\n\\n\\t\\tfunction LabelString( s ) {\\n\\n\\t\\t\\treturn '\\\"' + s + '\\\"';\\n\\n\\t\\t}\\n\\n\\t\\tfunction NumConstantString( c ) {\\n\\n\\t\\t\\tvar constants = [ \\\"NearestFilter\\\", \\\"NearestMipMapNearestFilter\\\" , \\\"NearestMipMapLinearFilter\\\",\\n\\t\\t\\t\\t\\t\\t\\t  \\\"LinearFilter\\\", \\\"LinearMipMapNearestFilter\\\", \\\"LinearMipMapLinearFilter\\\" ];\\n\\n\\t\\t\\tfor ( var i = 0; i < constants.length; i ++ ) {\\n\\n\\t\\t\\t\\tif ( THREE[ constants[ i ] ] === c ) return LabelString( constants[ i ] );\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\treturn \\\"\\\";\\n\\n\\t\\t}\\n\\n\\t\\tfunction PaddingString( n ) {\\n\\n\\t\\t\\tvar output = \\\"\\\";\\n\\n\\t\\t\\tfor ( var i = 0; i < n; i ++ ) output += \\\"\\\\t\\\";\\n\\n\\t\\t\\treturn output;\\n\\n\\t\\t}\\n\\n\\n\\t\\t//\\n\\n\\t\\tfunction LightString( o, n ) {\\n\\n\\t\\t\\tif ( o instanceof THREE.AmbientLight ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t\\\\t' + LabelString( getObjectName( o ) ) + ' : {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"  : \\\"AmbientLight\\\",',\\n\\t\\t\\t\\t'\\t\\\"color\\\" : ' + o.color.getHex() + ( o.children.length ? ',' : '' )\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( o instanceof THREE.DirectionalLight ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t\\\\t' + LabelString( getObjectName( o ) ) + ' : {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"      : \\\"DirectionalLight\\\",',\\n\\t\\t\\t\\t'\\t\\\"color\\\"     : ' + o.color.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\\"intensity\\\" : ' + o.intensity + ',',\\n\\t\\t\\t\\t'\\t\\\"direction\\\" : ' + Vector3String( o.position ) + ',',\\n\\t\\t\\t\\t'\\t\\\"target\\\"    : ' + LabelString( getObjectName( o.target ) ) + ( o.children.length ? ',' : '' )\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( o instanceof THREE.PointLight ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t\\\\t' + LabelString( getObjectName( o ) ) + ' : {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"      : \\\"PointLight\\\",',\\n\\t\\t\\t\\t'\\t\\\"color\\\"     : ' + o.color.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\\"intensity\\\" : ' + o.intensity + ',',\\n\\t\\t\\t\\t'\\t\\\"position\\\"  : ' + Vector3String( o.position ) + ',',\\n\\t\\t\\t\\t'\\t\\\"distance\\\"  : ' + o.distance + ( o.children.length ? ',' : '' )\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( o instanceof THREE.SpotLight ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t\\\\t' + LabelString( getObjectName( o ) ) + ' : {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"      : \\\"SpotLight\\\",',\\n\\t\\t\\t\\t'\\t\\\"color\\\"     : ' + o.color.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\\"intensity\\\" : ' + o.intensity + ',',\\n\\t\\t\\t\\t'\\t\\\"position\\\"  : ' + Vector3String( o.position ) + ',',\\n\\t\\t\\t\\t'\\t\\\"distance\\\"  : ' + o.distance + ',',\\n\\t\\t\\t\\t'\\t\\\"angle\\\"     : ' + o.angle + ',',\\n\\t\\t\\t\\t'\\t\\\"exponent\\\"  : ' + o.exponent + ',',\\n\\t\\t\\t\\t'\\t\\\"target\\\"    : ' + LabelString( getObjectName( o.target ) ) + ( o.children.length ? ',' : '' )\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( o instanceof THREE.HemisphereLight ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t\\\\t' + LabelString( getObjectName( o ) ) + ' : {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"        : \\\"HemisphereLight\\\",',\\n\\t\\t\\t\\t'\\t\\\"skyColor\\\"    : ' + o.color.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\\"groundColor\\\" : ' + o.groundColor.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\\"intensity\\\"   : ' + o.intensity + ',',\\n\\t\\t\\t\\t'\\t\\\"position\\\"    : ' + Vector3String( o.position ) + ( o.children.length ? ',' : '' )\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar output = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn generateMultiLineString( output, '\\\\n\\\\t\\\\t', n );\\n\\n\\t\\t}\\n\\n\\t\\tfunction CameraString( o, n ) {\\n\\n\\t\\t\\tif ( o instanceof THREE.PerspectiveCamera ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t\\\\t' + LabelString( getObjectName( o ) ) + ' : {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"     : \\\"PerspectiveCamera\\\",',\\n\\t\\t\\t\\t'\\t\\\"fov\\\"      : ' + o.fov + ',',\\n\\t\\t\\t\\t'\\t\\\"aspect\\\"   : ' + o.aspect + ',',\\n\\t\\t\\t\\t'\\t\\\"near\\\"     : ' + o.near + ',',\\n\\t\\t\\t\\t'\\t\\\"far\\\"      : ' + o.far + ',',\\n\\t\\t\\t\\t'\\t\\\"position\\\" : ' + Vector3String( o.position ) + ( o.children.length ? ',' : '' )\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( o instanceof THREE.OrthographicCamera ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t\\\\t' + LabelString( getObjectName( o ) ) + ' : {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"     : \\\"OrthographicCamera\\\",',\\n\\t\\t\\t\\t'\\t\\\"left\\\"     : ' + o.left + ',',\\n\\t\\t\\t\\t'\\t\\\"right\\\"    : ' + o.right + ',',\\n\\t\\t\\t\\t'\\t\\\"top\\\"      : ' + o.top + ',',\\n\\t\\t\\t\\t'\\t\\\"bottom\\\"   : ' + o.bottom + ',',\\n\\t\\t\\t\\t'\\t\\\"near\\\"     : ' + o.near + ',',\\n\\t\\t\\t\\t'\\t\\\"far\\\"      : ' + o.far + ',',\\n\\t\\t\\t\\t'\\t\\\"position\\\" : ' + Vector3String( o.position ) + ( o.children.length ? ',' : '' )\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar output = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn generateMultiLineString( output, '\\\\n\\\\t\\\\t', n );\\n\\n\\t\\t}\\n\\n\\t\\tfunction ObjectString( o, n ) {\\n\\n\\t\\t\\tvar output = [\\n\\n\\t\\t\\t'\\\\t\\\\t' + LabelString( getObjectName( o ) ) + ' : {',\\n\\t\\t\\t'\\t\\\"position\\\" : ' + Vector3String( o.position ) + ',',\\n\\t\\t\\t'\\t\\\"rotation\\\" : ' + Vector3String( o.rotation ) + ',',\\n\\t\\t\\t'\\t\\\"scale\\\"\\t   : ' + Vector3String( o.scale ) + ',',\\n\\t\\t\\t'\\t\\\"visible\\\"  : ' + o.visible + ( o.children.length ? ',' : '' )\\n\\n\\t\\t\\t];\\n\\n\\t\\t\\treturn generateMultiLineString( output, '\\\\n\\\\t\\\\t', n );\\n\\n\\t\\t}\\n\\n\\t\\tfunction MeshString( o, n ) {\\n\\n\\t\\t\\tvar output = [\\n\\n\\t\\t\\t'\\\\t\\\\t' + LabelString( getObjectName( o ) ) + ' : {',\\n\\t\\t\\t'\\t\\\"geometry\\\" : ' + LabelString( getGeometryName( o.geometry ) ) + ',',\\n\\t\\t\\t'\\t\\\"material\\\" : ' + LabelString( getMaterialName( o.material ) ) + ',',\\n\\t\\t\\t'\\t\\\"position\\\" : ' + Vector3String( o.position ) + ',',\\n\\t\\t\\t'\\t\\\"rotation\\\" : ' + Vector3String( o.rotation ) + ',',\\n\\t\\t\\t'\\t\\\"scale\\\"\\t   : ' + Vector3String( o.scale ) + ',',\\n\\t\\t\\t'\\t\\\"visible\\\"  : ' + o.visible + ( o.children.length ? ',' : '' )\\n\\n\\t\\t\\t];\\n\\n\\t\\t\\treturn generateMultiLineString( output, '\\\\n\\\\t\\\\t', n );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction GeometryString( g ) {\\n\\n\\t\\t\\tif ( g instanceof THREE.SphereGeometry ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getGeometryName( g ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"    : \\\"sphere\\\",',\\n\\t\\t\\t\\t'\\t\\\"radius\\\"  : ' \\t\\t + g.radius + ',',\\n\\t\\t\\t\\t'\\t\\\"widthSegments\\\"  : ' + g.widthSegments + ',',\\n\\t\\t\\t\\t'\\t\\\"heightSegments\\\" : ' + g.heightSegments,\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( g instanceof THREE.BoxGeometry ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getGeometryName( g ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"    : \\\"cube\\\",',\\n\\t\\t\\t\\t'\\t\\\"width\\\"  : '  + g.width  + ',',\\n\\t\\t\\t\\t'\\t\\\"height\\\"  : ' + g.height + ',',\\n\\t\\t\\t\\t'\\t\\\"depth\\\"  : '  + g.depth  + ',',\\n\\t\\t\\t\\t'\\t\\\"widthSegments\\\"  : ' + g.widthSegments + ',',\\n\\t\\t\\t\\t'\\t\\\"heightSegments\\\" : ' + g.heightSegments + ',',\\n\\t\\t\\t\\t'\\t\\\"depthSegments\\\" : '  + g.depthSegments,\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( g instanceof THREE.PlaneGeometry ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getGeometryName( g ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"    : \\\"plane\\\",',\\n\\t\\t\\t\\t'\\t\\\"width\\\"  : '  + g.width  + ',',\\n\\t\\t\\t\\t'\\t\\\"height\\\"  : ' + g.height + ',',\\n\\t\\t\\t\\t'\\t\\\"widthSegments\\\"  : ' + g.widthSegments + ',',\\n\\t\\t\\t\\t'\\t\\\"heightSegments\\\" : ' + g.heightSegments,\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( g instanceof THREE.Geometry ) {\\n\\n\\t\\t\\t\\tif ( g.sourceType === \\\"ascii\\\" || g.sourceType === \\\"ctm\\\" || g.sourceType === \\\"stl\\\" || g.sourceType === \\\"vtk\\\" ) {\\n\\n\\t\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t\\t'\\\\t' + LabelString( getGeometryName( g ) ) + ': {',\\n\\t\\t\\t\\t\\t'\\t\\\"type\\\" : ' + LabelString( g.sourceType ) + ',',\\n\\t\\t\\t\\t\\t'\\t\\\"url\\\"  : ' + LabelString( g.sourceFile ),\\n\\t\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t\\t];\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar output = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar output = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn generateMultiLineString( output, '\\\\n\\\\t\\\\t' );\\n\\n\\t\\t}\\n\\n\\t\\tfunction MaterialString( m ) {\\n\\n\\t\\t\\tif ( m instanceof THREE.MeshBasicMaterial ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getMaterialName( m ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"    : \\\"MeshBasicMaterial\\\",',\\n\\t\\t\\t\\t'\\t\\\"parameters\\\"  : {',\\n\\t\\t\\t\\t'\\t\\t\\\"color\\\"  : ' \\t+ m.color.getHex() + ',',\\n\\n\\t\\t\\t\\tm.map ? \\t\\t'\\t\\t\\\"map\\\" : ' + LabelString( getTextureName( m.map ) ) + ',' : '',\\n\\t\\t\\t\\tm.envMap ? \\t\\t'\\t\\t\\\"envMap\\\" : ' + LabelString( getTextureName( m.envMap ) ) + ',' : '',\\n\\t\\t\\t\\tm.specularMap ? '\\t\\t\\\"specularMap\\\" : ' + LabelString( getTextureName( m.specularMap ) ) + ',' : '',\\n\\t\\t\\t\\tm.lightMap ? \\t'\\t\\t\\\"lightMap\\\" : ' + LabelString( getTextureName( m.lightMap ) ) + ',' : '',\\n\\n\\t\\t\\t\\t'\\t\\t\\\"reflectivity\\\"  : ' + m.reflectivity + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"transparent\\\" : ' + m.transparent + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"opacity\\\" : ' \\t+ m.opacity + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"wireframe\\\" : ' + m.wireframe + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"wireframeLinewidth\\\" : ' + m.wireframeLinewidth,\\n\\t\\t\\t\\t'\\t}',\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\n\\t\\t\\t} else if ( m instanceof THREE.MeshLambertMaterial ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getMaterialName( m ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"    : \\\"MeshLambertMaterial\\\",',\\n\\t\\t\\t\\t'\\t\\\"parameters\\\"  : {',\\n\\t\\t\\t\\t'\\t\\t\\\"color\\\"  : ' \\t+ m.color.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"ambient\\\"  : ' \\t+ m.ambient.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"emissive\\\"  : ' + m.emissive.getHex() + ',',\\n\\n\\t\\t\\t\\tm.map ? \\t\\t'\\t\\t\\\"map\\\" : ' + LabelString( getTextureName( m.map ) ) + ',' : '',\\n\\t\\t\\t\\tm.envMap ? \\t\\t'\\t\\t\\\"envMap\\\" : ' + LabelString( getTextureName( m.envMap ) ) + ',' : '',\\n\\t\\t\\t\\tm.specularMap ? '\\t\\t\\\"specularMap\\\" : ' + LabelString( getTextureName( m.specularMap ) ) + ',' : '',\\n\\t\\t\\t\\tm.lightMap ? \\t'\\t\\t\\\"lightMap\\\" : ' + LabelString( getTextureName( m.lightMap ) ) + ',' : '',\\n\\n\\t\\t\\t\\t'\\t\\t\\\"reflectivity\\\"  : ' + m.reflectivity + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"transparent\\\" : ' + m.transparent + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"opacity\\\" : ' \\t+ m.opacity + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"wireframe\\\" : ' + m.wireframe + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"wireframeLinewidth\\\" : ' + m.wireframeLinewidth,\\n\\t\\t\\t\\t'\\t}',\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( m instanceof THREE.MeshPhongMaterial ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getMaterialName( m ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"    : \\\"MeshPhongMaterial\\\",',\\n\\t\\t\\t\\t'\\t\\\"parameters\\\"  : {',\\n\\t\\t\\t\\t'\\t\\t\\\"color\\\"  : ' \\t+ m.color.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"ambient\\\"  : ' \\t+ m.ambient.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"emissive\\\"  : ' + m.emissive.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"specular\\\"  : ' + m.specular.getHex() + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"shininess\\\" : ' + m.shininess + ',',\\n\\n\\t\\t\\t\\tm.map ? \\t\\t'\\t\\t\\\"map\\\" : ' + LabelString( getTextureName( m.map ) ) + ',' : '',\\n\\t\\t\\t\\tm.envMap ? \\t\\t'\\t\\t\\\"envMap\\\" : ' + LabelString( getTextureName( m.envMap ) ) + ',' : '',\\n\\t\\t\\t\\tm.specularMap ? '\\t\\t\\\"specularMap\\\" : ' + LabelString( getTextureName( m.specularMap ) ) + ',' : '',\\n\\t\\t\\t\\tm.lightMap ? \\t'\\t\\t\\\"lightMap\\\" : ' + LabelString( getTextureName( m.lightMap ) ) + ',' : '',\\n\\t\\t\\t\\tm.normalMap ? \\t'\\t\\t\\\"normalMap\\\" : ' + LabelString( getTextureName( m.normalMap ) ) + ',' : '',\\n\\t\\t\\t\\tm.bumpMap ? \\t'\\t\\t\\\"bumpMap\\\" : ' + LabelString( getTextureName( m.bumpMap ) ) + ',' : '',\\n\\n\\t\\t\\t\\t'\\t\\t\\\"bumpScale\\\"  : ' + m.bumpScale + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"reflectivity\\\"  : ' + m.reflectivity + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"transparent\\\" : ' + m.transparent + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"opacity\\\" : ' \\t+ m.opacity + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"wireframe\\\" : ' + m.wireframe + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"wireframeLinewidth\\\" : ' + m.wireframeLinewidth,\\n\\t\\t\\t\\t'\\t}',\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( m instanceof THREE.MeshDepthMaterial ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getMaterialName( m ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"    : \\\"MeshDepthMaterial\\\",',\\n\\t\\t\\t\\t'\\t\\\"parameters\\\"  : {',\\n\\t\\t\\t\\t'\\t\\t\\\"transparent\\\" : ' + m.transparent + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"opacity\\\" : ' \\t+ m.opacity + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"wireframe\\\" : ' + m.wireframe + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"wireframeLinewidth\\\" : ' + m.wireframeLinewidth,\\n\\t\\t\\t\\t'\\t}',\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( m instanceof THREE.MeshNormalMaterial ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getMaterialName( m ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"    : \\\"MeshNormalMaterial\\\",',\\n\\t\\t\\t\\t'\\t\\\"parameters\\\"  : {',\\n\\t\\t\\t\\t'\\t\\t\\\"transparent\\\" : ' + m.transparent + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"opacity\\\" : ' \\t+ m.opacity + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"wireframe\\\" : ' + m.wireframe + ',',\\n\\t\\t\\t\\t'\\t\\t\\\"wireframeLinewidth\\\" : ' + m.wireframeLinewidth,\\n\\t\\t\\t\\t'\\t}',\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( m instanceof THREE.MeshFaceMaterial ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getMaterialName( m ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"    : \\\"MeshFaceMaterial\\\",',\\n\\t\\t\\t\\t'\\t\\\"parameters\\\"  : {}',\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn generateMultiLineString( output, '\\\\n\\\\t\\\\t' );\\n\\n\\t\\t}\\n\\n\\t\\tfunction TextureString( t ) {\\n\\n\\t\\t\\t// here would be also an option to use data URI\\n\\t\\t\\t// with embedded image from \\\"t.image.src\\\"\\n\\t\\t\\t// (that's a side effect of using FileReader to load images)\\n\\n\\t\\t\\tvar output = [\\n\\n\\t\\t\\t'\\\\t' + LabelString( getTextureName( t ) ) + ': {',\\n\\t\\t\\t'\\t\\\"url\\\"    : \\\"' + t.sourceFile + '\\\",',\\n\\t\\t\\t'\\t\\\"repeat\\\" : ' + Vector2String( t.repeat ) + ',',\\n\\t\\t\\t'\\t\\\"offset\\\" : ' + Vector2String( t.offset ) + ',',\\n\\t\\t\\t'\\t\\\"magFilter\\\" : ' + NumConstantString( t.magFilter ) + ',',\\n\\t\\t\\t'\\t\\\"minFilter\\\" : ' + NumConstantString( t.minFilter ) + ',',\\n\\t\\t\\t'\\t\\\"anisotropy\\\" : ' + t.anisotropy,\\n\\t\\t\\t'}'\\n\\n\\t\\t\\t];\\n\\n\\t\\t\\treturn generateMultiLineString( output, '\\\\n\\\\t\\\\t' );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction FogString( f ) {\\n\\n\\t\\t\\tif ( f instanceof THREE.Fog ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getFogName( f ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"  : \\\"linear\\\",',\\n\\t\\t\\t\\t'\\t\\\"color\\\" : ' + ColorString( f.color ) + ',',\\n\\t\\t\\t\\t'\\t\\\"near\\\"  : '  + f.near + ',',\\n\\t\\t\\t\\t'\\t\\\"far\\\"   : '    + f.far,\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else if ( f instanceof THREE.FogExp2 ) {\\n\\n\\t\\t\\t\\tvar output = [\\n\\n\\t\\t\\t\\t'\\\\t' + LabelString( getFogName( f ) ) + ': {',\\n\\t\\t\\t\\t'\\t\\\"type\\\"    : \\\"exp2\\\",',\\n\\t\\t\\t\\t'\\t\\\"color\\\"   : '  + ColorString( f.color ) + ',',\\n\\t\\t\\t\\t'\\t\\\"density\\\" : ' + f.density,\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar output = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn generateMultiLineString( output, '\\\\n\\\\t\\\\t' );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction generateMultiLineString( lines, separator, padding ) {\\n\\n\\t\\t\\tvar cleanLines = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < lines.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar line = lines[ i ];\\n\\n\\t\\t\\t\\tif ( line ) {\\n\\n\\t\\t\\t\\t\\tif ( padding ) line = PaddingString( padding ) + line;\\n\\t\\t\\t\\t\\tcleanLines.push(  line );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cleanLines.join( separator );\\n\\n\\t\\t}\\n\\n\\t\\tfunction getObjectName( o ) {\\n\\n\\t\\t\\treturn o.name ? o.name : \\\"Object_\\\" + o.id;\\n\\n\\t\\t}\\n\\n\\t\\tfunction getGeometryName( g ) {\\n\\n\\t\\t\\treturn g.name ? g.name : \\\"Geometry_\\\" + g.id;\\n\\n\\t\\t}\\n\\n\\t\\tfunction getMaterialName( m ) {\\n\\n\\t\\t\\treturn m.name ? m.name : \\\"Material_\\\" + m.id;\\n\\n\\t\\t}\\n\\n\\t\\tfunction getTextureName( t ) {\\n\\n\\t\\t\\treturn t.name ? t.name : \\\"Texture_\\\" + t.id;\\n\\n\\t\\t}\\n\\n\\t\\tfunction getFogName( f ) {\\n\\n\\t\\t\\treturn f.name ? f.name : \\\"Default fog\\\";\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar output = [\\n\\t\\t\\t'{',\\n\\t\\t\\t'\\t\\\"metadata\\\": {',\\n\\t\\t\\t'\\t\\t\\\"formatVersion\\\" : 3.2,',\\n\\t\\t\\t'\\t\\t\\\"type\\\"\\t\\t: \\\"scene\\\",',\\n\\t\\t\\t'\\t\\t\\\"generatedBy\\\"\\t: \\\"SceneExporter\\\",',\\n\\t\\t\\t'\\t\\t\\\"objects\\\"       : ' + nobjects + ',',\\n\\t\\t\\t'\\t\\t\\\"geometries\\\"    : ' + ngeometries + ',',\\n\\t\\t\\t'\\t\\t\\\"materials\\\"     : ' + nmaterials + ',',\\n\\t\\t\\t'\\t\\t\\\"textures\\\"      : ' + ntextures,\\n\\t\\t\\t'\\t},',\\n\\t\\t\\t'',\\n\\t\\t\\t'\\t\\\"urlBaseType\\\": \\\"relativeToScene\\\",',\\n\\t\\t\\t'',\\n\\n\\t\\t\\t'\\t\\\"objects\\\" :',\\n\\t\\t\\t'\\t{',\\n\\t\\t\\tobjects,\\n\\t\\t\\t'\\t},',\\n\\t\\t\\t'',\\n\\n\\t\\t\\t'\\t\\\"geometries\\\" :',\\n\\t\\t\\t'\\t{',\\n\\t\\t\\t'\\\\t' + \\tgeometries,\\n\\t\\t\\t'\\t},',\\n\\t\\t\\t'',\\n\\n\\t\\t\\t'\\t\\\"materials\\\" :',\\n\\t\\t\\t'\\t{',\\n\\t\\t\\t'\\\\t' + \\tmaterials,\\n\\t\\t\\t'\\t},',\\n\\t\\t\\t'',\\n\\n\\t\\t\\t'\\t\\\"textures\\\" :',\\n\\t\\t\\t'\\t{',\\n\\t\\t\\t'\\\\t' + \\ttextures,\\n\\t\\t\\t'\\t},',\\n\\t\\t\\t'',\\n\\n\\t\\t\\t'\\t\\\"fogs\\\" :',\\n\\t\\t\\t'\\t{',\\n\\t\\t\\t'\\\\t' + \\tfogs,\\n\\t\\t\\t'\\t},',\\n\\t\\t\\t'',\\n\\n\\t\\t\\t'\\t\\\"transform\\\" :',\\n\\t\\t\\t'\\t{',\\n\\t\\t\\t'\\t\\t\\\"position\\\"  : ' + position + ',',\\n\\t\\t\\t'\\t\\t\\\"rotation\\\"  : ' + rotation + ',',\\n\\t\\t\\t'\\t\\t\\\"scale\\\"     : ' + scale,\\n\\t\\t\\t'\\t},',\\n\\t\\t\\t'',\\n\\t\\t\\t'\\t\\\"defaults\\\" :',\\n\\t\\t\\t'\\t{',\\n\\t\\t\\t'\\t\\t\\\"camera\\\"  : ' + defcamera + ',',\\n\\t\\t\\t'\\t\\t\\\"fog\\\"  \\t  : ' + deffog,\\n\\t\\t\\t'\\t}',\\n\\t\\t\\t'}'\\n\\t\\t].join( '\\\\n' );\\n\\n\\t\\treturn JSON.parse( output );\\n\\n\\t}\\n\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Exporters/HTMLExporter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Exporters/HTMLExporter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.HTMLExporter = function () {};\\n\\nTHREE.HTMLExporter.prototype = {\\n\\n\\tconstructor: THREE.HTMLExporter,\\n\\n\\tparse: function ( scene ) {\\n\\n\\t\\treturn output;\\n\\n\\t}\\n\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Exporters/STLBinaryExporter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Exporters/STLBinaryExporter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author kovacsv / http://kovacsv.hu/\\n * @author mrdoob / http://mrdoob.com/\\n * @author mudcube / http://mudcu.be/\\n */\\n \\nTHREE.STLBinaryExporter = function () {};\\n\\nTHREE.STLBinaryExporter.prototype = {\\n\\n\\tconstructor: THREE.STLBinaryExporter,\\n\\n\\tparse: ( function () {\\n\\n\\t\\tvar vector = new THREE.Vector3();\\n\\t\\tvar normalMatrixWorld = new THREE.Matrix3();\\n\\n\\t\\treturn function ( scene ) {\\n\\n\\t\\t\\tvar triangles = 0;\\n\\t\\t\\tscene.traverse( function ( object ) {\\n\\t\\t\\t\\tif ( !(object instanceof THREE.Mesh) ) return;\\n\\t\\t\\t\\ttriangles += object.geometry.faces.length;\\n\\t\\t\\t});\\n\\n\\t\\t\\tvar offset = 80; // skip header\\n\\t\\t\\tvar bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\\n\\t\\t\\tvar arrayBuffer = new ArrayBuffer(bufferLength);\\n\\t\\t\\tvar output = new DataView(arrayBuffer);\\n\\t\\t\\toutput.setUint32(offset, triangles, true); offset += 4;\\n\\n\\t\\t\\tscene.traverse( function ( object ) {\\n\\n\\t\\t\\t\\tif ( !(object instanceof THREE.Mesh) ) return;\\n\\t\\t\\t\\tif ( !(object.geometry instanceof THREE.Geometry )) return;\\n\\n\\t\\t\\t\\tvar geometry = object.geometry;\\n\\t\\t\\t\\tvar matrixWorld = object.matrixWorld;\\n\\n\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\t\\tvar faces = geometry.faces;\\n\\n\\t\\t\\t\\tnormalMatrixWorld.getNormalMatrix( matrixWorld );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\t\\tvector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();\\n\\n\\t\\t\\t\\t\\toutput.setFloat32(offset, vector.x, true); offset += 4; // normal\\n\\t\\t\\t\\t\\toutput.setFloat32(offset, vector.y, true); offset += 4;\\n\\t\\t\\t\\t\\toutput.setFloat32(offset, vector.z, true); offset += 4;\\n\\n\\t\\t\\t\\t\\tvar indices = [ face.a, face.b, face.c ];\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvector.copy( vertices[ indices[ j ] ] ).applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\toutput.setFloat32(offset, vector.x, true); offset += 4; // vertices\\n\\t\\t\\t\\t\\t\\toutput.setFloat32(offset, vector.y, true); offset += 4;\\n\\t\\t\\t\\t\\t\\toutput.setFloat32(offset, vector.z, true); offset += 4;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\toutput.setUint16(offset, 0, true); offset += 2; // attribute byte count\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} );\\n\\t\\t\\t\\n\\t\\t\\treturn output;\\n\\n\\t\\t};\\n\\n\\t}() )\\n\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Exporters/TypedGeometryExporter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Exporters/TypedGeometryExporter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.TypedGeometryExporter = function () {};\\n\\nTHREE.TypedGeometryExporter.prototype = {\\n\\n\\tconstructor: THREE.TypedGeometryExporter,\\n\\n\\tparse: function ( geometry ) {\\n\\n\\t\\tvar output = {\\n\\t\\t\\tmetadata: {\\n\\t\\t\\t\\tversion: 4.0,\\n\\t\\t\\t\\ttype: 'TypedGeometry',\\n\\t\\t\\t\\tgenerator: 'TypedGeometryExporter'\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tvar attributes = [ 'vertices', 'normals', 'uvs' ];\\n\\n\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\tvar attribute = attributes[ key ];\\n\\t\\t\\t\\n\\t\\t\\tvar typedArray = geometry[ attribute ];\\n\\t\\t\\tvar array = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = typedArray.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tarray[ i ] = typedArray[ i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\toutput[ attribute ] = array;\\n\\n\\t\\t}\\n\\n\\t\\tvar boundingSphere = geometry.boundingSphere;\\n\\n\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\toutput.boundingSphere = {\\n\\t\\t\\t\\tcenter: boundingSphere.center.toArray(),\\n\\t\\t\\t\\tradius: boundingSphere.radius\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn output;\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Exporters/GeometryExporter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Exporters/GeometryExporter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.GeometryExporter = function () {};\\n\\nTHREE.GeometryExporter.prototype = {\\n\\n\\tconstructor: THREE.GeometryExporter,\\n\\n\\tparse: function ( geometry ) {\\n\\n\\t\\tvar output = {\\n\\t\\t\\tmetadata: {\\n\\t\\t\\t\\tversion: 4.0,\\n\\t\\t\\t\\ttype: 'geometry',\\n\\t\\t\\t\\tgenerator: 'GeometryExporter'\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tvar vertices = [];\\n\\n\\t\\tfor ( var i = 0; i < geometry.vertices.length; i ++ ) {\\n\\n\\t\\t\\tvar vertex = geometry.vertices[ i ];\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t}\\n\\n\\t\\tvar faces = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar normalsHash = {};\\n\\t\\tvar colors = [];\\n\\t\\tvar colorsHash = {};\\n\\t\\tvar uvs = [];\\n\\t\\tvar uvsHash = {};\\n\\n\\t\\tfor ( var i = 0; i < geometry.faces.length; i ++ ) {\\n\\n\\t\\t\\tvar face = geometry.faces[ i ];\\n\\n\\t\\t\\tvar hasMaterial = false; // face.materialIndex !== undefined;\\n\\t\\t\\tvar hasFaceUv = false; // deprecated\\n\\t\\t\\tvar hasFaceVertexUv = geometry.faceVertexUvs[ 0 ][ i ] !== undefined;\\n\\t\\t\\tvar hasFaceNormal = face.normal.length() > 0;\\n\\t\\t\\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\\n\\t\\t\\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\\n\\t\\t\\tvar hasFaceVertexColor = face.vertexColors.length > 0;\\n\\n\\t\\t\\tvar faceType = 0;\\n\\n\\t\\t\\tfaceType = setBit( faceType, 0, 0 );\\n\\t\\t\\tfaceType = setBit( faceType, 1, hasMaterial );\\n\\t\\t\\tfaceType = setBit( faceType, 2, hasFaceUv );\\n\\t\\t\\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\\n\\t\\t\\tfaceType = setBit( faceType, 4, hasFaceNormal );\\n\\t\\t\\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\\n\\t\\t\\tfaceType = setBit( faceType, 6, hasFaceColor );\\n\\t\\t\\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\\n\\n\\t\\t\\tfaces.push( faceType );\\n\\t\\t\\tfaces.push( face.a, face.b, face.c );\\n\\n\\n\\t\\t\\t/*\\n\\t\\t\\tif ( hasMaterial ) {\\n\\n\\t\\t\\t\\tfaces.push( face.materialIndex );\\n\\n\\t\\t\\t}\\n\\t\\t\\t*/\\n\\n\\t\\t\\tif ( hasFaceVertexUv ) {\\n\\n\\t\\t\\t\\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ][ i ];\\n\\n\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 0 ] ),\\n\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 1 ] ),\\n\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 2 ] )\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasFaceNormal ) {\\n\\n\\t\\t\\t\\tfaces.push( getNormalIndex( face.normal ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasFaceVertexNormal ) {\\n\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 0 ] ),\\n\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 1 ] ),\\n\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 2 ] )\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasFaceColor ) {\\n\\n\\t\\t\\t\\tfaces.push( getColorIndex( face.color ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasFaceVertexColor ) {\\n\\n\\t\\t\\t\\tvar vertexColors = face.vertexColors;\\n\\n\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 0 ] ),\\n\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 1 ] ),\\n\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 2 ] )\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setBit( value, position, enabled ) {\\n\\n\\t\\t\\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );\\n\\n\\t\\t}\\n\\n\\t\\tfunction getNormalIndex( normal ) {\\n\\n\\t\\t\\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\\n\\n\\t\\t\\tif ( normalsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\treturn normalsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tnormalsHash[ hash ] = normals.length / 3;\\n\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\treturn normalsHash[ hash ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction getColorIndex( color ) {\\n\\n\\t\\t\\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\\n\\n\\t\\t\\tif ( colorsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\treturn colorsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcolorsHash[ hash ] = colors.length;\\n\\t\\t\\tcolors.push( color.getHex() );\\n\\n\\t\\t\\treturn colorsHash[ hash ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction getUvIndex( uv ) {\\n\\n\\t\\t\\tvar hash = uv.x.toString() + uv.y.toString();\\n\\n\\t\\t\\tif ( uvsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\treturn uvsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tuvsHash[ hash ] = uvs.length / 2;\\n\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\treturn uvsHash[ hash ];\\n\\n\\t\\t}\\n\\n\\t\\toutput.vertices = vertices;\\n\\t\\toutput.normals = normals;\\n\\t\\tif ( colors.length > 0 ) output.colors = colors;\\n\\t\\tif ( uvs.length > 0 ) output.uvs = [ uvs ]; // temporal backward compatibility\\n\\t\\toutput.faces = faces;\\n\\n\\t\\t//\\n\\n\\t\\treturn output;\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/BloomPass.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/BloomPass.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.BloomPass = function ( strength, kernelSize, sigma, resolution ) {\\n\\n\\tstrength = ( strength !== undefined ) ? strength : 1;\\n\\tkernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;\\n\\tsigma = ( sigma !== undefined ) ? sigma : 4.0;\\n\\tresolution = ( resolution !== undefined ) ? resolution : 256;\\n\\n\\t// render targets\\n\\n\\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };\\n\\n\\tthis.renderTargetX = new THREE.WebGLRenderTarget( resolution, resolution, pars );\\n\\tthis.renderTargetY = new THREE.WebGLRenderTarget( resolution, resolution, pars );\\n\\n\\t// copy material\\n\\n\\tif ( THREE.CopyShader === undefined )\\n\\t\\tconsole.error( \\\"THREE.BloomPass relies on THREE.CopyShader\\\" );\\n\\n\\tvar copyShader = THREE.CopyShader;\\n\\n\\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\\n\\n\\tthis.copyUniforms[ \\\"opacity\\\" ].value = strength;\\n\\n\\tthis.materialCopy = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: this.copyUniforms,\\n\\t\\tvertexShader: copyShader.vertexShader,\\n\\t\\tfragmentShader: copyShader.fragmentShader,\\n\\t\\tblending: THREE.AdditiveBlending,\\n\\t\\ttransparent: true\\n\\n\\t} );\\n\\n\\t// convolution material\\n\\n\\tif ( THREE.ConvolutionShader === undefined )\\n\\t\\tconsole.error( \\\"THREE.BloomPass relies on THREE.ConvolutionShader\\\" );\\n\\n\\tvar convolutionShader = THREE.ConvolutionShader;\\n\\n\\tthis.convolutionUniforms = THREE.UniformsUtils.clone( convolutionShader.uniforms );\\n\\n\\tthis.convolutionUniforms[ \\\"uImageIncrement\\\" ].value = THREE.BloomPass.blurx;\\n\\tthis.convolutionUniforms[ \\\"cKernel\\\" ].value = THREE.ConvolutionShader.buildKernel( sigma );\\n\\n\\tthis.materialConvolution = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: this.convolutionUniforms,\\n\\t\\tvertexShader:  convolutionShader.vertexShader,\\n\\t\\tfragmentShader: convolutionShader.fragmentShader,\\n\\t\\tdefines: {\\n\\t\\t\\t\\\"KERNEL_SIZE_FLOAT\\\": kernelSize.toFixed( 1 ),\\n\\t\\t\\t\\\"KERNEL_SIZE_INT\\\": kernelSize.toFixed( 0 )\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tthis.enabled = true;\\n\\tthis.needsSwap = false;\\n\\tthis.clear = false;\\n\\n\\n\\tthis.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\\n\\tthis.scene  = new THREE.Scene();\\n\\n\\tthis.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );\\n\\tthis.scene.add( this.quad );\\n\\n};\\n\\nTHREE.BloomPass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\\n\\n\\t\\tif ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );\\n\\n\\t\\t// Render quad with blured scene into texture (convolution pass 1)\\n\\n\\t\\tthis.quad.material = this.materialConvolution;\\n\\n\\t\\tthis.convolutionUniforms[ \\\"tDiffuse\\\" ].value = readBuffer;\\n\\t\\tthis.convolutionUniforms[ \\\"uImageIncrement\\\" ].value = THREE.BloomPass.blurX;\\n\\n\\t\\trenderer.render( this.scene, this.camera, this.renderTargetX, true );\\n\\n\\n\\t\\t// Render quad with blured scene into texture (convolution pass 2)\\n\\n\\t\\tthis.convolutionUniforms[ \\\"tDiffuse\\\" ].value = this.renderTargetX;\\n\\t\\tthis.convolutionUniforms[ \\\"uImageIncrement\\\" ].value = THREE.BloomPass.blurY;\\n\\n\\t\\trenderer.render( this.scene, this.camera, this.renderTargetY, true );\\n\\n\\t\\t// Render original scene with superimposed blur to texture\\n\\n\\t\\tthis.quad.material = this.materialCopy;\\n\\n\\t\\tthis.copyUniforms[ \\\"tDiffuse\\\" ].value = this.renderTargetY;\\n\\n\\t\\tif ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );\\n\\n\\t\\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\\n\\n\\t}\\n\\n};\\n\\nTHREE.BloomPass.blurX = new THREE.Vector2( 0.001953125, 0.0 );\\nTHREE.BloomPass.blurY = new THREE.Vector2( 0.0, 0.001953125 );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/ShaderPass.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/ShaderPass.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.ShaderPass = function ( shader, textureID ) {\\n\\n\\tthis.textureID = ( textureID !== undefined ) ? textureID : \\\"tDiffuse\\\";\\n\\n\\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\\n\\n\\tthis.material = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: this.uniforms,\\n\\t\\tvertexShader: shader.vertexShader,\\n\\t\\tfragmentShader: shader.fragmentShader\\n\\n\\t} );\\n\\n\\tthis.renderToScreen = false;\\n\\n\\tthis.enabled = true;\\n\\tthis.needsSwap = true;\\n\\tthis.clear = false;\\n\\n\\n\\tthis.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\\n\\tthis.scene  = new THREE.Scene();\\n\\n\\tthis.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );\\n\\tthis.scene.add( this.quad );\\n\\n};\\n\\nTHREE.ShaderPass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\\n\\n\\t\\tif ( this.uniforms[ this.textureID ] ) {\\n\\n\\t\\t\\tthis.uniforms[ this.textureID ].value = readBuffer;\\n\\n\\t\\t}\\n\\n\\t\\tthis.quad.material = this.material;\\n\\n\\t\\tif ( this.renderToScreen ) {\\n\\n\\t\\t\\trenderer.render( this.scene, this.camera );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/SavePass.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/SavePass.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.SavePass = function ( renderTarget ) {\\n\\n\\tif ( THREE.CopyShader === undefined )\\n\\t\\tconsole.error( \\\"THREE.SavePass relies on THREE.CopyShader\\\" );\\n\\n\\tvar shader = THREE.CopyShader;\\n\\n\\tthis.textureID = \\\"tDiffuse\\\";\\n\\n\\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\\n\\n\\tthis.material = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: this.uniforms,\\n\\t\\tvertexShader: shader.vertexShader,\\n\\t\\tfragmentShader: shader.fragmentShader\\n\\n\\t} );\\n\\n\\tthis.renderTarget = renderTarget;\\n\\n\\tif ( this.renderTarget === undefined ) {\\n\\n\\t\\tthis.renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };\\n\\t\\tthis.renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, this.renderTargetParameters );\\n\\n\\t}\\n\\n\\tthis.enabled = true;\\n\\tthis.needsSwap = false;\\n\\tthis.clear = false;\\n\\n\\n\\tthis.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\\n\\tthis.scene  = new THREE.Scene();\\n\\n\\tthis.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );\\n\\tthis.scene.add( this.quad );\\n\\n};\\n\\nTHREE.SavePass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\\n\\n\\t\\tif ( this.uniforms[ this.textureID ] ) {\\n\\n\\t\\t\\tthis.uniforms[ this.textureID ].value = readBuffer;\\n\\n\\t\\t}\\n\\n\\t\\tthis.quad.material = this.material;\\n\\n\\t\\trenderer.render( this.scene, this.camera, this.renderTarget, this.clear );\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/DotScreenPass.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/DotScreenPass.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.DotScreenPass = function ( center, angle, scale ) {\\n\\n\\tif ( THREE.DotScreenShader === undefined )\\n\\t\\tconsole.error( \\\"THREE.DotScreenPass relies on THREE.DotScreenShader\\\" );\\n\\n\\tvar shader = THREE.DotScreenShader;\\n\\n\\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\\n\\n\\tif ( center !== undefined ) this.uniforms[ \\\"center\\\" ].value.copy( center );\\n\\tif ( angle !== undefined ) this.uniforms[ \\\"angle\\\"].value = angle;\\n\\tif ( scale !== undefined ) this.uniforms[ \\\"scale\\\"].value = scale;\\n\\n\\tthis.material = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: this.uniforms,\\n\\t\\tvertexShader: shader.vertexShader,\\n\\t\\tfragmentShader: shader.fragmentShader\\n\\n\\t} );\\n\\n\\tthis.enabled = true;\\n\\tthis.renderToScreen = false;\\n\\tthis.needsSwap = true;\\n\\n\\n\\tthis.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\\n\\tthis.scene  = new THREE.Scene();\\n\\n\\tthis.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );\\n\\tthis.scene.add( this.quad );\\n\\n};\\n\\nTHREE.DotScreenPass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\\n\\n\\t\\tthis.uniforms[ \\\"tDiffuse\\\" ].value = readBuffer;\\n\\t\\tthis.uniforms[ \\\"tSize\\\" ].value.set( readBuffer.width, readBuffer.height );\\n\\n\\t\\tthis.quad.material = this.material;\\n\\n\\t\\tif ( this.renderToScreen ) {\\n\\n\\t\\t\\trenderer.render( this.scene, this.camera );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\trenderer.render( this.scene, this.camera, writeBuffer, false );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/GlitchPass.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/GlitchPass.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n \\n */\\n\\nTHREE.GlitchPass = function ( dt_size ) {\\n\\n\\tif ( THREE.DigitalGlitch === undefined ) console.error( \\\"THREE.GlitchPass relies on THREE.DigitalGlitch\\\" );\\n\\t\\n\\tvar shader = THREE.DigitalGlitch;\\n\\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\\n\\n\\tif(dt_size==undefined) dt_size=64;\\n\\t\\n\\t\\n\\tthis.uniforms[ \\\"tDisp\\\"].value=this.generateHeightmap(dt_size);\\n\\t\\n\\n\\tthis.material = new THREE.ShaderMaterial({\\n\\t\\tuniforms: this.uniforms,\\n\\t\\tvertexShader: shader.vertexShader,\\n\\t\\tfragmentShader: shader.fragmentShader\\n\\t});\\n\\n\\tconsole.log(this.material);\\n\\t\\n\\tthis.enabled = true;\\n\\tthis.renderToScreen = false;\\n\\tthis.needsSwap = true;\\n\\n\\n\\tthis.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\\n\\tthis.scene  = new THREE.Scene();\\n\\n\\tthis.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );\\n\\tthis.scene.add( this.quad );\\n\\t\\n\\tthis.goWild=false;\\n\\tthis.curF=0;\\n\\tthis.generateTrigger();\\n\\t\\n};\\n\\nTHREE.GlitchPass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta ) \\n\\t{\\n\\t\\tthis.uniforms[ \\\"tDiffuse\\\" ].value = readBuffer;\\n\\t\\tthis.uniforms[ 'seed' ].value=Math.random();//default seeding\\n\\t\\tthis.uniforms[ 'byp' ].value=0;\\n\\t\\t\\n\\t\\tif(this.curF % this.randX ==0 || this.goWild==true)\\n\\t\\t{\\n\\t\\t\\tthis.uniforms[ 'amount' ].value=Math.random()/30;\\n\\t\\t\\tthis.uniforms[ 'angle' ].value=THREE.Math.randFloat(-Math.PI,Math.PI);\\n\\t\\t\\tthis.uniforms[ 'seed_x' ].value=THREE.Math.randFloat(-1,1);\\n\\t\\t\\tthis.uniforms[ 'seed_y' ].value=THREE.Math.randFloat(-1,1);\\n\\t\\t\\tthis.uniforms[ 'distortion_x' ].value=THREE.Math.randFloat(0,1);\\n\\t\\t\\tthis.uniforms[ 'distortion_y' ].value=THREE.Math.randFloat(0,1);\\n\\t\\t\\tthis.curF=0;\\n\\t\\t\\tthis.generateTrigger();\\n\\t\\t}\\n\\t\\telse if(this.curF % this.randX <this.randX/5)\\n\\t\\t{\\n\\t\\t\\tthis.uniforms[ 'amount' ].value=Math.random()/90;\\n\\t\\t\\tthis.uniforms[ 'angle' ].value=THREE.Math.randFloat(-Math.PI,Math.PI);\\n\\t\\t\\tthis.uniforms[ 'distortion_x' ].value=THREE.Math.randFloat(0,1);\\n\\t\\t\\tthis.uniforms[ 'distortion_y' ].value=THREE.Math.randFloat(0,1);\\n\\t\\t\\tthis.uniforms[ 'seed_x' ].value=THREE.Math.randFloat(-0.3,0.3);\\n\\t\\t\\tthis.uniforms[ 'seed_y' ].value=THREE.Math.randFloat(-0.3,0.3);\\n\\t\\t}\\n\\t\\telse if(this.goWild==false)\\n\\t\\t{\\n\\t\\t\\tthis.uniforms[ 'byp' ].value=1;\\n\\t\\t}\\n\\t\\tthis.curF++;\\n\\t\\t\\n\\t\\tthis.quad.material = this.material;\\n\\t\\tif ( this.renderToScreen ) \\n\\t\\t{\\n\\t\\t\\trenderer.render( this.scene, this.camera );\\n\\t\\t} \\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\trenderer.render( this.scene, this.camera, writeBuffer, false );\\n\\t\\t}\\n\\t},\\n\\tgenerateTrigger:function()\\n\\t{\\n\\t\\tthis.randX=THREE.Math.randInt(120,240);\\n\\t},\\n\\tgenerateHeightmap:function(dt_size)\\n\\t{\\n\\t\\tvar data_arr = new Float32Array( dt_size*dt_size * 3 );\\n\\t\\tconsole.log(dt_size);\\n\\t\\tvar length=dt_size*dt_size;\\n\\t\\t\\n\\t\\tfor ( var i = 0; i < length; i++) \\n\\t\\t{\\n\\t\\t\\tvar val=THREE.Math.randFloat(0,1);\\n\\t\\t\\tdata_arr[ i*3 + 0 ] = val;\\n\\t\\t\\tdata_arr[ i*3 + 1 ] = val;\\n\\t\\t\\tdata_arr[ i*3 + 2 ] = val;\\n\\t\\t}\\n\\t\\t\\n\\t\\tvar texture = new THREE.DataTexture( data_arr, dt_size, dt_size, THREE.RGBFormat, THREE.FloatType );\\n\\t\\tconsole.log(texture);\\n\\t\\tconsole.log(dt_size);\\n\\t\\ttexture.minFilter = THREE.NearestFilter;\\n\\t\\ttexture.magFilter = THREE.NearestFilter;\\n\\t\\ttexture.needsUpdate = true;\\n\\t\\ttexture.flipY = false;\\n\\t\\treturn texture;\\n\\t}\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/EffectComposer.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/EffectComposer.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.EffectComposer = function ( renderer, renderTarget ) {\\n\\n\\tthis.renderer = renderer;\\n\\n\\tif ( renderTarget === undefined ) {\\n\\n\\t\\tvar width = window.innerWidth || 1;\\n\\t\\tvar height = window.innerHeight || 1;\\n\\t\\tvar parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };\\n\\n\\t\\trenderTarget = new THREE.WebGLRenderTarget( width, height, parameters );\\n\\n\\t}\\n\\n\\tthis.renderTarget1 = renderTarget;\\n\\tthis.renderTarget2 = renderTarget.clone();\\n\\n\\tthis.writeBuffer = this.renderTarget1;\\n\\tthis.readBuffer = this.renderTarget2;\\n\\n\\tthis.passes = [];\\n\\n\\tif ( THREE.CopyShader === undefined )\\n\\t\\tconsole.error( \\\"THREE.EffectComposer relies on THREE.CopyShader\\\" );\\n\\n\\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\\n\\n};\\n\\nTHREE.EffectComposer.prototype = {\\n\\n\\tswapBuffers: function() {\\n\\n\\t\\tvar tmp = this.readBuffer;\\n\\t\\tthis.readBuffer = this.writeBuffer;\\n\\t\\tthis.writeBuffer = tmp;\\n\\n\\t},\\n\\n\\taddPass: function ( pass ) {\\n\\n\\t\\tthis.passes.push( pass );\\n\\n\\t},\\n\\n\\tinsertPass: function ( pass, index ) {\\n\\n\\t\\tthis.passes.splice( index, 0, pass );\\n\\n\\t},\\n\\n\\trender: function ( delta ) {\\n\\n\\t\\tthis.writeBuffer = this.renderTarget1;\\n\\t\\tthis.readBuffer = this.renderTarget2;\\n\\n\\t\\tvar maskActive = false;\\n\\n\\t\\tvar pass, i, il = this.passes.length;\\n\\n\\t\\tfor ( i = 0; i < il; i ++ ) {\\n\\n\\t\\t\\tpass = this.passes[ i ];\\n\\n\\t\\t\\tif ( !pass.enabled ) continue;\\n\\n\\t\\t\\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );\\n\\n\\t\\t\\tif ( pass.needsSwap ) {\\n\\n\\t\\t\\t\\tif ( maskActive ) {\\n\\n\\t\\t\\t\\t\\tvar context = this.renderer.context;\\n\\n\\t\\t\\t\\t\\tcontext.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\\n\\n\\t\\t\\t\\t\\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );\\n\\n\\t\\t\\t\\t\\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.swapBuffers();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( pass instanceof THREE.MaskPass ) {\\n\\n\\t\\t\\t\\tmaskActive = true;\\n\\n\\t\\t\\t} else if ( pass instanceof THREE.ClearMaskPass ) {\\n\\n\\t\\t\\t\\tmaskActive = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\treset: function ( renderTarget ) {\\n\\n\\t\\tif ( renderTarget === undefined ) {\\n\\n\\t\\t\\trenderTarget = this.renderTarget1.clone();\\n\\n\\t\\t\\trenderTarget.width = window.innerWidth;\\n\\t\\t\\trenderTarget.height = window.innerHeight;\\n\\n\\t\\t}\\n\\n\\t\\tthis.renderTarget1 = renderTarget;\\n\\t\\tthis.renderTarget2 = renderTarget.clone();\\n\\n\\t\\tthis.writeBuffer = this.renderTarget1;\\n\\t\\tthis.readBuffer = this.renderTarget2;\\n\\n\\t},\\n\\n\\tsetSize: function ( width, height ) {\\n\\n\\t\\tvar renderTarget = this.renderTarget1.clone();\\n\\n\\t\\trenderTarget.width = width;\\n\\t\\trenderTarget.height = height;\\n\\n\\t\\tthis.reset( renderTarget );\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/FilmPass.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/FilmPass.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {\\n\\n\\tif ( THREE.FilmShader === undefined )\\n\\t\\tconsole.error( \\\"THREE.FilmPass relies on THREE.FilmShader\\\" );\\n\\n\\tvar shader = THREE.FilmShader;\\n\\n\\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\\n\\n\\tthis.material = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: this.uniforms,\\n\\t\\tvertexShader: shader.vertexShader,\\n\\t\\tfragmentShader: shader.fragmentShader\\n\\n\\t} );\\n\\n\\tif ( grayscale !== undefined )\\tthis.uniforms.grayscale.value = grayscale;\\n\\tif ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;\\n\\tif ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;\\n\\tif ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;\\n\\n\\tthis.enabled = true;\\n\\tthis.renderToScreen = false;\\n\\tthis.needsSwap = true;\\n\\n\\n\\tthis.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\\n\\tthis.scene  = new THREE.Scene();\\n\\n\\tthis.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );\\n\\tthis.scene.add( this.quad );\\n\\n};\\n\\nTHREE.FilmPass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\\n\\n\\t\\tthis.uniforms[ \\\"tDiffuse\\\" ].value = readBuffer;\\n\\t\\tthis.uniforms[ \\\"time\\\" ].value += delta;\\n\\n\\t\\tthis.quad.material = this.material;\\n\\n\\t\\tif ( this.renderToScreen ) {\\n\\n\\t\\t\\trenderer.render( this.scene, this.camera );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\trenderer.render( this.scene, this.camera, writeBuffer, false );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/RenderPass.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/RenderPass.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\\n\\n\\tthis.scene = scene;\\n\\tthis.camera = camera;\\n\\n\\tthis.overrideMaterial = overrideMaterial;\\n\\n\\tthis.clearColor = clearColor;\\n\\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;\\n\\n\\tthis.oldClearColor = new THREE.Color();\\n\\tthis.oldClearAlpha = 1;\\n\\n\\tthis.enabled = true;\\n\\tthis.clear = true;\\n\\tthis.needsSwap = false;\\n\\n};\\n\\nTHREE.RenderPass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\\n\\n\\t\\tthis.scene.overrideMaterial = this.overrideMaterial;\\n\\n\\t\\tif ( this.clearColor ) {\\n\\n\\t\\t\\tthis.oldClearColor.copy( renderer.getClearColor() );\\n\\t\\t\\tthis.oldClearAlpha = renderer.getClearAlpha();\\n\\n\\t\\t\\trenderer.setClearColor( this.clearColor, this.clearAlpha );\\n\\n\\t\\t}\\n\\n\\t\\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\\n\\n\\t\\tif ( this.clearColor ) {\\n\\n\\t\\t\\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\\n\\n\\t\\t}\\n\\n\\t\\tthis.scene.overrideMaterial = null;\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/BokehPass.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/BokehPass.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * Depth-of-field post-process with bokeh shader\\n */\\n\\n\\nTHREE.BokehPass = function ( scene, camera, params ) {\\n\\n\\tthis.scene = scene;\\n\\tthis.camera = camera;\\n\\n\\tvar focus = ( params.focus !== undefined ) ? params.focus : 1.0;\\n\\tvar aspect = ( params.aspect !== undefined ) ? params.aspect : camera.aspect;\\n\\tvar aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;\\n\\tvar maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;\\n\\n\\t// render targets\\n\\n\\tvar width = params.width || window.innerWidth || 1;\\n\\tvar height = params.height || window.innerHeight || 1;\\n\\n\\tthis.renderTargetColor = new THREE.WebGLRenderTarget( width, height, {\\n\\t\\tminFilter: THREE.LinearFilter,\\n\\t\\tmagFilter: THREE.LinearFilter,\\n\\t\\tformat: THREE.RGBFormat\\n\\t} );\\n\\n\\tthis.renderTargetDepth = this.renderTargetColor.clone();\\n\\n\\t// depth material\\n\\n\\tthis.materialDepth = new THREE.MeshDepthMaterial();\\n\\n\\t// bokeh material\\n\\n\\tif ( THREE.BokehShader === undefined ) {\\n\\t\\tconsole.error( \\\"THREE.BokehPass relies on THREE.BokehShader\\\" );\\n\\t}\\n\\t\\n\\tvar bokehShader = THREE.BokehShader;\\n\\tvar bokehUniforms = THREE.UniformsUtils.clone( bokehShader.uniforms );\\n\\n\\tbokehUniforms[ \\\"tDepth\\\" ].value = this.renderTargetDepth;\\n\\n\\tbokehUniforms[ \\\"focus\\\" ].value = focus;\\n\\tbokehUniforms[ \\\"aspect\\\" ].value = aspect;\\n\\tbokehUniforms[ \\\"aperture\\\" ].value = aperture;\\n\\tbokehUniforms[ \\\"maxblur\\\" ].value = maxblur;\\n\\n\\tthis.materialBokeh = new THREE.ShaderMaterial({\\n\\t\\tuniforms: bokehUniforms,\\n\\t\\tvertexShader: bokehShader.vertexShader,\\n\\t\\tfragmentShader: bokehShader.fragmentShader\\n\\t});\\n\\n\\tthis.uniforms = bokehUniforms;\\n\\tthis.enabled = true;\\n\\tthis.needsSwap = false;\\n\\tthis.renderToScreen = false;\\n\\tthis.clear = false;\\n\\n\\tthis.camera2 = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\\n\\tthis.scene2  = new THREE.Scene();\\n\\n\\tthis.quad2 = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );\\n\\tthis.scene2.add( this.quad2 );\\n\\n};\\n\\nTHREE.BokehPass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\\n\\n\\t\\tthis.quad2.material = this.materialBokeh;\\n\\n\\t\\t// Render depth into texture\\n\\n\\t\\tthis.scene.overrideMaterial = this.materialDepth;\\n\\n\\t\\trenderer.render( this.scene, this.camera, this.renderTargetDepth, true );\\n\\n\\t\\t// Render bokeh composite\\n\\n\\t\\tthis.uniforms[ \\\"tColor\\\" ].value = readBuffer;\\n\\n\\t\\tif ( this.renderToScreen ) {\\n\\n\\t\\t\\trenderer.render( this.scene2, this.camera2 );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\trenderer.render( this.scene2, this.camera2, writeBuffer, this.clear );\\n\\n\\t\\t}\\n\\n\\t\\tthis.scene.overrideMaterial = null;\\n\\n\\t}\\n\\n};\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/MaskPass.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/MaskPass.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.MaskPass = function ( scene, camera ) {\\n\\n\\tthis.scene = scene;\\n\\tthis.camera = camera;\\n\\n\\tthis.enabled = true;\\n\\tthis.clear = true;\\n\\tthis.needsSwap = false;\\n\\n\\tthis.inverse = false;\\n\\n};\\n\\nTHREE.MaskPass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\\n\\n\\t\\tvar context = renderer.context;\\n\\n\\t\\t// don't update color or depth\\n\\n\\t\\tcontext.colorMask( false, false, false, false );\\n\\t\\tcontext.depthMask( false );\\n\\n\\t\\t// set up stencil\\n\\n\\t\\tvar writeValue, clearValue;\\n\\n\\t\\tif ( this.inverse ) {\\n\\n\\t\\t\\twriteValue = 0;\\n\\t\\t\\tclearValue = 1;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\twriteValue = 1;\\n\\t\\t\\tclearValue = 0;\\n\\n\\t\\t}\\n\\n\\t\\tcontext.enable( context.STENCIL_TEST );\\n\\t\\tcontext.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );\\n\\t\\tcontext.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );\\n\\t\\tcontext.clearStencil( clearValue );\\n\\n\\t\\t// draw into the stencil buffer\\n\\n\\t\\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\\n\\t\\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\\n\\n\\t\\t// re-enable update of color and depth\\n\\n\\t\\tcontext.colorMask( true, true, true, true );\\n\\t\\tcontext.depthMask( true );\\n\\n\\t\\t// only render where stencil is set to 1\\n\\n\\t\\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1\\n\\t\\tcontext.stencilOp( context.KEEP, context.KEEP, context.KEEP );\\n\\n\\t}\\n\\n};\\n\\n\\nTHREE.ClearMaskPass = function () {\\n\\n\\tthis.enabled = true;\\n\\n};\\n\\nTHREE.ClearMaskPass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\\n\\n\\t\\tvar context = renderer.context;\\n\\n\\t\\tcontext.disable( context.STENCIL_TEST );\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Postprocessing/TexturePass.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Postprocessing/TexturePass.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.TexturePass = function ( texture, opacity ) {\\n\\n\\tif ( THREE.CopyShader === undefined )\\n\\t\\tconsole.error( \\\"THREE.TexturePass relies on THREE.CopyShader\\\" );\\n\\n\\tvar shader = THREE.CopyShader;\\n\\n\\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\\n\\n\\tthis.uniforms[ \\\"opacity\\\" ].value = ( opacity !== undefined ) ? opacity : 1.0;\\n\\tthis.uniforms[ \\\"tDiffuse\\\" ].value = texture;\\n\\n\\tthis.material = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: this.uniforms,\\n\\t\\tvertexShader: shader.vertexShader,\\n\\t\\tfragmentShader: shader.fragmentShader\\n\\n\\t} );\\n\\n\\tthis.enabled = true;\\n\\tthis.needsSwap = false;\\n\\n\\n\\tthis.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\\n\\tthis.scene  = new THREE.Scene();\\n\\n\\tthis.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );\\n\\tthis.scene.add( this.quad );\\n\\n};\\n\\nTHREE.TexturePass.prototype = {\\n\\n\\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\\n\\n\\t\\tthis.quad.material = this.material;\\n\\n\\t\\trenderer.render( this.scene, this.camera, readBuffer );\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/ShaderToon.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/ShaderToon.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * ShaderToon currently contains:\\n *\\n *\\ttoon1\\n *\\ttoon2\\n *\\thatching\\n *\\tdotted\\n */\\n\\nTHREE.ShaderToon = {\\n\\n'toon1' : {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"uDirLightPos\\\":\\t{ type: \\\"v3\\\", value: new THREE.Vector3() },\\n\\t\\t\\\"uDirLightColor\\\": { type: \\\"c\\\", value: new THREE.Color( 0xeeeeee ) },\\n\\n\\t\\t\\\"uAmbientLightColor\\\": { type: \\\"c\\\", value: new THREE.Color( 0x050505 ) },\\n\\n\\t\\t\\\"uBaseColor\\\":  { type: \\\"c\\\", value: new THREE.Color( 0xffffff ) }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\t\\t\\\"varying vec3 vRefract;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\\"vec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\\\",\\n\\n\\t\\t\\t\\\"vNormal = normalize( normalMatrix * normal );\\\",\\n\\n\\t\\t\\t\\\"vec3 I = worldPosition.xyz - cameraPosition;\\\",\\n\\t\\t\\t\\\"vRefract = refract( normalize( I ), worldNormal, 1.02 );\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * mvPosition;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform vec3 uBaseColor;\\\",\\n\\n\\t\\t\\\"uniform vec3 uDirLightPos;\\\",\\n\\t\\t\\\"uniform vec3 uDirLightColor;\\\",\\n\\n\\t\\t\\\"uniform vec3 uAmbientLightColor;\\\",\\n\\n\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\n\\t\\t\\\"varying vec3 vRefract;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"float directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);\\\",\\n\\t\\t\\t\\\"vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;\\\",\\n\\n\\t\\t\\t\\\"float intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );\\\",\\n\\t\\t\\t\\\"intensity += length(lightWeighting) * 0.2;\\\",\\n\\n\\t\\t\\t\\\"float cameraWeighting = dot( normalize( vNormal ), vRefract );\\\",\\n\\t\\t\\t\\\"intensity += pow( 1.0 - length( cameraWeighting ), 6.0 );\\\",\\n\\t\\t\\t\\\"intensity = intensity * 0.2 + 0.3;\\\",\\n\\n\\t\\t\\t\\\"if ( intensity < 0.50 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"} else {\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n},\\n\\n'toon2' : {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"uDirLightPos\\\":\\t{ type: \\\"v3\\\", value: new THREE.Vector3() },\\n\\t\\t\\\"uDirLightColor\\\": { type: \\\"c\\\", value: new THREE.Color( 0xeeeeee ) },\\n\\n\\t\\t\\\"uAmbientLightColor\\\": { type: \\\"c\\\", value: new THREE.Color( 0x050505 ) },\\n\\n\\t\\t\\\"uBaseColor\\\":  { type: \\\"c\\\", value: new THREE.Color( 0xeeeeee ) },\\n\\t\\t\\\"uLineColor1\\\": { type: \\\"c\\\", value: new THREE.Color( 0x808080 ) },\\n\\t\\t\\\"uLineColor2\\\": { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\\"uLineColor3\\\": { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\\"uLineColor4\\\": { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\\"vNormal = normalize( normalMatrix * normal );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform vec3 uBaseColor;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor1;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor2;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor3;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor4;\\\",\\n\\n\\t\\t\\\"uniform vec3 uDirLightPos;\\\",\\n\\t\\t\\\"uniform vec3 uDirLightColor;\\\",\\n\\n\\t\\t\\\"uniform vec3 uAmbientLightColor;\\\",\\n\\n\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"float camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);\\\",\\n\\t\\t\\t\\\"float light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( uBaseColor, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"if ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor *= vec4( uLineColor1, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"if ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor *= vec4( uLineColor2, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n},\\n\\n'hatching' : {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"uDirLightPos\\\":\\t{ type: \\\"v3\\\", value: new THREE.Vector3() },\\n\\t\\t\\\"uDirLightColor\\\": { type: \\\"c\\\", value: new THREE.Color( 0xeeeeee ) },\\n\\n\\t\\t\\\"uAmbientLightColor\\\": { type: \\\"c\\\", value: new THREE.Color( 0x050505 ) },\\n\\n\\t\\t\\\"uBaseColor\\\":  { type: \\\"c\\\", value: new THREE.Color( 0xffffff ) },\\n\\t\\t\\\"uLineColor1\\\": { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\\"uLineColor2\\\": { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\\"uLineColor3\\\": { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\\"uLineColor4\\\": { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\\"vNormal = normalize( normalMatrix * normal );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform vec3 uBaseColor;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor1;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor2;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor3;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor4;\\\",\\n\\n\\t\\t\\\"uniform vec3 uDirLightPos;\\\",\\n\\t\\t\\\"uniform vec3 uDirLightColor;\\\",\\n\\n\\t\\t\\\"uniform vec3 uAmbientLightColor;\\\",\\n\\n\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);\\\",\\n\\t\\t\\t\\\"vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( uBaseColor, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"if ( length(lightWeighting) < 1.00 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"if ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = vec4( uLineColor1, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"if ( length(lightWeighting) < 0.75 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = vec4( uLineColor2, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"if ( length(lightWeighting) < 0.50 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = vec4( uLineColor3, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"if ( length(lightWeighting) < 0.3465 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = vec4( uLineColor4, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n},\\n\\n'dotted' : {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"uDirLightPos\\\":\\t{ type: \\\"v3\\\", value: new THREE.Vector3() },\\n\\t\\t\\\"uDirLightColor\\\": { type: \\\"c\\\", value: new THREE.Color( 0xeeeeee ) },\\n\\n\\t\\t\\\"uAmbientLightColor\\\": { type: \\\"c\\\", value: new THREE.Color( 0x050505 ) },\\n\\n\\t\\t\\\"uBaseColor\\\":  { type: \\\"c\\\", value: new THREE.Color( 0xffffff ) },\\n\\t\\t\\\"uLineColor1\\\": { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\\"vNormal = normalize( normalMatrix * normal );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform vec3 uBaseColor;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor1;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor2;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor3;\\\",\\n\\t\\t\\\"uniform vec3 uLineColor4;\\\",\\n\\n\\t\\t\\\"uniform vec3 uDirLightPos;\\\",\\n\\t\\t\\\"uniform vec3 uDirLightColor;\\\",\\n\\n\\t\\t\\\"uniform vec3 uAmbientLightColor;\\\",\\n\\n\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);\\\",\\n\\t\\t\\t\\\"vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( uBaseColor, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"if ( length(lightWeighting) < 1.00 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"if ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = vec4( uLineColor1, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"if ( length(lightWeighting) < 0.50 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"if ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = vec4( uLineColor1, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/MarchingCubes.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/MarchingCubes.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n *\\r\\n * Port of greggman's ThreeD version of marching cubes to Three.js\\r\\n * http://webglsamples.googlecode.com/hg/blob/blob.html\\r\\n */\\r\\n\\r\\nTHREE.MarchingCubes = function ( resolution, material, enableUvs, enableColors ) {\\r\\n\\r\\n\\tTHREE.ImmediateRenderObject.call( this );\\r\\n\\r\\n\\tthis.material = material;\\r\\n\\r\\n\\tthis.enableUvs = enableUvs !== undefined ? enableUvs : false;\\r\\n\\tthis.enableColors = enableColors !== undefined ? enableColors : false;\\r\\n\\r\\n\\t// functions have to be object properties\\r\\n\\t// prototype functions kill performance\\r\\n\\t// (tested and it was 4x slower !!!)\\r\\n\\r\\n\\tthis.init = function( resolution ) {\\r\\n\\r\\n\\t\\tthis.resolution = resolution;\\r\\n\\r\\n\\t\\t// parameters\\r\\n\\r\\n\\t\\tthis.isolation = 80.0;\\r\\n\\r\\n\\t\\t// size of field, 32 is pushing it in Javascript :)\\r\\n\\r\\n\\t\\tthis.size = resolution;\\r\\n\\t\\tthis.size2 = this.size * this.size;\\r\\n\\t\\tthis.size3 = this.size2 * this.size;\\r\\n\\t\\tthis.halfsize = this.size / 2.0;\\r\\n\\r\\n\\t\\t// deltas\\r\\n\\r\\n\\t\\tthis.delta = 2.0 / this.size;\\r\\n\\t\\tthis.yd = this.size;\\r\\n\\t\\tthis.zd = this.size2;\\r\\n\\r\\n\\t\\tthis.field = new Float32Array( this.size3 );\\r\\n\\t\\tthis.normal_cache = new Float32Array( this.size3 * 3 );\\r\\n\\r\\n\\t\\t// temp buffers used in polygonize\\r\\n\\r\\n\\t\\tthis.vlist = new Float32Array( 12 * 3 );\\r\\n\\t\\tthis.nlist = new Float32Array( 12 * 3 );\\r\\n\\r\\n\\t\\tthis.firstDraw = true;\\r\\n\\r\\n\\t\\t// immediate render mode simulator\\r\\n\\r\\n\\t\\tthis.maxCount = 4096; // TODO: find the fastest size for this buffer\\r\\n\\t\\tthis.count = 0;\\r\\n\\r\\n\\t\\tthis.hasPositions = false;\\r\\n\\t\\tthis.hasNormals = false;\\r\\n\\t\\tthis.hasColors = false;\\r\\n\\t\\tthis.hasUvs = false;\\r\\n\\r\\n\\t\\tthis.positionArray = new Float32Array( this.maxCount * 3 );\\r\\n\\t\\tthis.normalArray   = new Float32Array( this.maxCount * 3 );\\r\\n\\r\\n\\t\\tif ( this.enableUvs ) {\\r\\n\\r\\n\\t\\t\\tthis.uvArray = new Float32Array( this.maxCount * 2 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.enableColors ) {\\r\\n\\r\\n\\t\\t\\tthis.colorArray   = new Float32Array( this.maxCount * 3 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t///////////////////////\\r\\n\\t// Polygonization\\r\\n\\t///////////////////////\\r\\n\\r\\n\\tthis.lerp = function( a, b, t ) { return a + ( b - a ) * t; };\\r\\n\\r\\n\\tthis.VIntX = function( q, pout, nout, offset, isol, x, y, z, valp1, valp2 ) {\\r\\n\\r\\n\\t\\tvar mu = ( isol - valp1 ) / ( valp2 - valp1 ),\\r\\n\\t\\tnc = this.normal_cache;\\r\\n\\r\\n\\t\\tpout[ offset ] \\t   = x + mu * this.delta;\\r\\n\\t\\tpout[ offset + 1 ] = y;\\r\\n\\t\\tpout[ offset + 2 ] = z;\\r\\n\\r\\n\\t\\tnout[ offset ] \\t   = this.lerp( nc[ q ],     nc[ q + 3 ], mu );\\r\\n\\t\\tnout[ offset + 1 ] = this.lerp( nc[ q + 1 ], nc[ q + 4 ], mu );\\r\\n\\t\\tnout[ offset + 2 ] = this.lerp( nc[ q + 2 ], nc[ q + 5 ], mu );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.VIntY = function( q, pout, nout, offset, isol, x, y, z, valp1, valp2 ) {\\r\\n\\r\\n\\t\\tvar mu = ( isol - valp1 ) / ( valp2 - valp1 ),\\r\\n\\t\\tnc = this.normal_cache;\\r\\n\\r\\n\\t\\tpout[ offset ] \\t   = x;\\r\\n\\t\\tpout[ offset + 1 ] = y + mu * this.delta;\\r\\n\\t\\tpout[ offset + 2 ] = z;\\r\\n\\r\\n\\t\\tvar q2 = q + this.yd * 3;\\r\\n\\r\\n\\t\\tnout[ offset ] \\t   = this.lerp( nc[ q ],     nc[ q2 ],     mu );\\r\\n\\t\\tnout[ offset + 1 ] = this.lerp( nc[ q + 1 ], nc[ q2 + 1 ], mu );\\r\\n\\t\\tnout[ offset + 2 ] = this.lerp( nc[ q + 2 ], nc[ q2 + 2 ], mu );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.VIntZ = function( q, pout, nout, offset, isol, x, y, z, valp1, valp2 ) {\\r\\n\\r\\n\\t\\tvar mu = ( isol - valp1 ) / ( valp2 - valp1 ),\\r\\n\\t\\tnc = this.normal_cache;\\r\\n\\r\\n\\t\\tpout[ offset ] \\t   = x;\\r\\n\\t\\tpout[ offset + 1 ] = y;\\r\\n\\t\\tpout[ offset + 2 ] = z + mu * this.delta;\\r\\n\\r\\n\\t\\tvar q2 = q + this.zd * 3;\\r\\n\\r\\n\\t\\tnout[ offset ] \\t   = this.lerp( nc[ q ],     nc[ q2 ],     mu );\\r\\n\\t\\tnout[ offset + 1 ] = this.lerp( nc[ q + 1 ], nc[ q2 + 1 ], mu );\\r\\n\\t\\tnout[ offset + 2 ] = this.lerp( nc[ q + 2 ], nc[ q2 + 2 ], mu );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.compNorm = function( q ) {\\r\\n\\r\\n\\t\\tvar q3 = q * 3;\\r\\n\\r\\n\\t\\tif ( this.normal_cache[ q3 ] === 0.0 ) {\\r\\n\\r\\n\\t\\t\\tthis.normal_cache[ q3     ] = this.field[ q - 1  ] \\t    - this.field[ q + 1 ];\\r\\n\\t\\t\\tthis.normal_cache[ q3 + 1 ] = this.field[ q - this.yd ] - this.field[ q + this.yd ];\\r\\n\\t\\t\\tthis.normal_cache[ q3 + 2 ] = this.field[ q - this.zd ] - this.field[ q + this.zd ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// Returns total number of triangles. Fills triangles.\\r\\n\\t// (this is where most of time is spent - it's inner work of O(n3) loop )\\r\\n\\r\\n\\tthis.polygonize = function( fx, fy, fz, q, isol, renderCallback ) {\\r\\n\\r\\n\\t\\t// cache indices\\r\\n\\t\\tvar q1 = q + 1,\\r\\n\\t\\t\\tqy = q + this.yd,\\r\\n\\t\\t\\tqz = q + this.zd,\\r\\n\\t\\t\\tq1y = q1 + this.yd,\\r\\n\\t\\t\\tq1z = q1 + this.zd,\\r\\n\\t\\t\\tqyz = q + this.yd + this.zd,\\r\\n\\t\\t\\tq1yz = q1 + this.yd + this.zd;\\r\\n\\r\\n\\t\\tvar cubeindex = 0,\\r\\n\\t\\t\\tfield0 = this.field[ q ],\\r\\n\\t\\t\\tfield1 = this.field[ q1 ],\\r\\n\\t\\t\\tfield2 = this.field[ qy ],\\r\\n\\t\\t\\tfield3 = this.field[ q1y ],\\r\\n\\t\\t\\tfield4 = this.field[ qz ],\\r\\n\\t\\t\\tfield5 = this.field[ q1z ],\\r\\n\\t\\t\\tfield6 = this.field[ qyz ],\\r\\n\\t\\t\\tfield7 = this.field[ q1yz ];\\r\\n\\r\\n\\t\\tif ( field0 < isol ) cubeindex |= 1;\\r\\n\\t\\tif ( field1 < isol ) cubeindex |= 2;\\r\\n\\t\\tif ( field2 < isol ) cubeindex |= 8;\\r\\n\\t\\tif ( field3 < isol ) cubeindex |= 4;\\r\\n\\t\\tif ( field4 < isol ) cubeindex |= 16;\\r\\n\\t\\tif ( field5 < isol ) cubeindex |= 32;\\r\\n\\t\\tif ( field6 < isol ) cubeindex |= 128;\\r\\n\\t\\tif ( field7 < isol ) cubeindex |= 64;\\r\\n\\r\\n\\t\\t// if cube is entirely in/out of the surface - bail, nothing to draw\\r\\n\\r\\n\\t\\tvar bits = THREE.edgeTable[ cubeindex ];\\r\\n\\t\\tif ( bits === 0 ) return 0;\\r\\n\\r\\n\\t\\tvar d = this.delta,\\r\\n\\t\\t\\tfx2 = fx + d,\\r\\n\\t\\t\\tfy2 = fy + d,\\r\\n\\t\\t\\tfz2 = fz + d;\\r\\n\\r\\n\\t\\t// top of the cube\\r\\n\\r\\n\\t\\tif ( bits & 1 ) {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( q );\\r\\n\\t\\t\\tthis.compNorm( q1 );\\r\\n\\t\\t\\tthis.VIntX( q * 3, this.vlist, this.nlist, 0, isol, fx, fy, fz, field0, field1 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( bits & 2 ) {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( q1 );\\r\\n\\t\\t\\tthis.compNorm( q1y );\\r\\n\\t\\t\\tthis.VIntY( q1 * 3, this.vlist, this.nlist, 3, isol, fx2, fy, fz, field1, field3 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( bits & 4 ) {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( qy );\\r\\n\\t\\t\\tthis.compNorm( q1y );\\r\\n\\t\\t\\tthis.VIntX( qy * 3, this.vlist, this.nlist, 6, isol, fx, fy2, fz, field2, field3 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( bits & 8 ) {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( q );\\r\\n\\t\\t\\tthis.compNorm( qy );\\r\\n\\t\\t\\tthis.VIntY( q * 3, this.vlist, this.nlist, 9, isol, fx, fy, fz, field0, field2 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// bottom of the cube\\r\\n\\r\\n\\t\\tif ( bits & 16 )  {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( qz );\\r\\n\\t\\t\\tthis.compNorm( q1z );\\r\\n\\t\\t\\tthis.VIntX( qz * 3, this.vlist, this.nlist, 12, isol, fx, fy, fz2, field4, field5 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( bits & 32 )  {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( q1z );\\r\\n\\t\\t\\tthis.compNorm( q1yz );\\r\\n\\t\\t\\tthis.VIntY( q1z * 3,  this.vlist, this.nlist, 15, isol, fx2, fy, fz2, field5, field7 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( bits & 64 ) {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( qyz );\\r\\n\\t\\t\\tthis.compNorm( q1yz );\\r\\n\\t\\t\\tthis.VIntX( qyz * 3, this.vlist, this.nlist, 18, isol, fx, fy2, fz2, field6, field7 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( bits & 128 ) {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( qz );\\r\\n\\t\\t\\tthis.compNorm( qyz );\\r\\n\\t\\t\\tthis.VIntY( qz * 3,  this.vlist, this.nlist, 21, isol, fx, fy, fz2, field4, field6 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\t// vertical lines of the cube\\r\\n\\r\\n\\t\\tif ( bits & 256 ) {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( q );\\r\\n\\t\\t\\tthis.compNorm( qz );\\r\\n\\t\\t\\tthis.VIntZ( q * 3, this.vlist, this.nlist, 24, isol, fx, fy, fz, field0, field4 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( bits & 512 ) {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( q1 );\\r\\n\\t\\t\\tthis.compNorm( q1z );\\r\\n\\t\\t\\tthis.VIntZ( q1 * 3,  this.vlist, this.nlist, 27, isol, fx2, fy,  fz, field1, field5 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( bits & 1024 ) {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( q1y );\\r\\n\\t\\t\\tthis.compNorm( q1yz );\\r\\n\\t\\t\\tthis.VIntZ( q1y * 3, this.vlist, this.nlist, 30, isol, fx2, fy2, fz, field3, field7 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif ( bits & 2048 ) {\\r\\n\\r\\n\\t\\t\\tthis.compNorm( qy );\\r\\n\\t\\t\\tthis.compNorm( qyz );\\r\\n\\t\\t\\tthis.VIntZ( qy * 3, this.vlist, this.nlist, 33, isol, fx,  fy2, fz, field2, field6 );\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tcubeindex <<= 4;  // re-purpose cubeindex into an offset into triTable\\r\\n\\r\\n\\t\\tvar o1, o2, o3, numtris = 0, i = 0;\\r\\n\\r\\n\\t\\t// here is where triangles are created\\r\\n\\r\\n\\t\\twhile ( THREE.triTable[ cubeindex + i ] != -1 ) {\\r\\n\\r\\n\\t\\t\\to1 = cubeindex + i;\\r\\n\\t\\t\\to2 = o1 + 1;\\r\\n\\t\\t\\to3 = o1 + 2;\\r\\n\\r\\n\\t\\t\\tthis.posnormtriv( this.vlist, this.nlist,\\r\\n\\t\\t\\t\\t\\t\\t\\t  3 * THREE.triTable[ o1 ],\\r\\n\\t\\t\\t\\t\\t\\t\\t  3 * THREE.triTable[ o2 ],\\r\\n\\t\\t\\t\\t\\t\\t\\t  3 * THREE.triTable[ o3 ],\\r\\n\\t\\t\\t\\t\\t\\t\\t  renderCallback );\\r\\n\\r\\n\\t\\t\\ti += 3;\\r\\n\\t\\t\\tnumtris ++;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn numtris;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/////////////////////////////////////\\r\\n\\t// Immediate render mode simulator\\r\\n\\t/////////////////////////////////////\\r\\n\\r\\n\\tthis.posnormtriv = function( pos, norm, o1, o2, o3, renderCallback ) {\\r\\n\\r\\n\\t\\tvar c = this.count * 3;\\r\\n\\r\\n\\t\\t// positions\\r\\n\\r\\n\\t\\tthis.positionArray[ c ] \\t= pos[ o1 ];\\r\\n\\t\\tthis.positionArray[ c + 1 ] = pos[ o1 + 1 ];\\r\\n\\t\\tthis.positionArray[ c + 2 ] = pos[ o1 + 2 ];\\r\\n\\r\\n\\t\\tthis.positionArray[ c + 3 ] = pos[ o2 ];\\r\\n\\t\\tthis.positionArray[ c + 4 ] = pos[ o2 + 1 ];\\r\\n\\t\\tthis.positionArray[ c + 5 ] = pos[ o2 + 2 ];\\r\\n\\r\\n\\t\\tthis.positionArray[ c + 6 ] = pos[ o3 ];\\r\\n\\t\\tthis.positionArray[ c + 7 ] = pos[ o3 + 1 ];\\r\\n\\t\\tthis.positionArray[ c + 8 ] = pos[ o3 + 2 ];\\r\\n\\r\\n\\t\\t// normals\\r\\n\\r\\n\\t\\tthis.normalArray[ c ] \\t  = norm[ o1 ];\\r\\n\\t\\tthis.normalArray[ c + 1 ] = norm[ o1 + 1 ];\\r\\n\\t\\tthis.normalArray[ c + 2 ] = norm[ o1 + 2 ];\\r\\n\\r\\n\\t\\tthis.normalArray[ c + 3 ] = norm[ o2 ];\\r\\n\\t\\tthis.normalArray[ c + 4 ] = norm[ o2 + 1 ];\\r\\n\\t\\tthis.normalArray[ c + 5 ] = norm[ o2 + 2 ];\\r\\n\\r\\n\\t\\tthis.normalArray[ c + 6 ] = norm[ o3 ];\\r\\n\\t\\tthis.normalArray[ c + 7 ] = norm[ o3 + 1 ];\\r\\n\\t\\tthis.normalArray[ c + 8 ] = norm[ o3 + 2 ];\\r\\n\\r\\n\\t\\t// uvs\\r\\n\\r\\n\\t\\tif ( this.enableUvs ) {\\r\\n\\r\\n\\t\\t\\tvar d = this.count * 2;\\r\\n\\r\\n\\t\\t\\tthis.uvArray[ d ] \\t  = pos[ o1 ];\\r\\n\\t\\t\\tthis.uvArray[ d + 1 ] = pos[ o1 + 2 ];\\r\\n\\r\\n\\t\\t\\tthis.uvArray[ d + 2 ] = pos[ o2 ];\\r\\n\\t\\t\\tthis.uvArray[ d + 3 ] = pos[ o2 + 2 ];\\r\\n\\r\\n\\t\\t\\tthis.uvArray[ d + 4 ] = pos[ o3 ];\\r\\n\\t\\t\\tthis.uvArray[ d + 5 ] = pos[ o3 + 2 ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// colors\\r\\n\\r\\n\\t\\tif ( this.enableColors ) {\\r\\n\\r\\n\\t\\t\\tthis.colorArray[ c ] \\t = pos[ o1 ];\\r\\n\\t\\t\\tthis.colorArray[ c + 1 ] = pos[ o1 + 1 ];\\r\\n\\t\\t\\tthis.colorArray[ c + 2 ] = pos[ o1 + 2 ];\\r\\n\\r\\n\\t\\t\\tthis.colorArray[ c + 3 ] = pos[ o2 ];\\r\\n\\t\\t\\tthis.colorArray[ c + 4 ] = pos[ o2 + 1 ];\\r\\n\\t\\t\\tthis.colorArray[ c + 5 ] = pos[ o2 + 2 ];\\r\\n\\r\\n\\t\\t\\tthis.colorArray[ c + 6 ] = pos[ o3 ];\\r\\n\\t\\t\\tthis.colorArray[ c + 7 ] = pos[ o3 + 1 ];\\r\\n\\t\\t\\tthis.colorArray[ c + 8 ] = pos[ o3 + 2 ];\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.count += 3;\\r\\n\\r\\n\\t\\tif ( this.count >= this.maxCount - 3 ) {\\r\\n\\r\\n\\t\\t\\tthis.hasPositions = true;\\r\\n\\t\\t\\tthis.hasNormals = true;\\r\\n\\r\\n\\t\\t\\tif ( this.enableUvs ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.hasUvs = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif ( this.enableColors ) {\\r\\n\\r\\n\\t\\t\\t\\tthis.hasColors = true;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\trenderCallback( this );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.begin = function( ) {\\r\\n\\r\\n\\t\\tthis.count = 0;\\r\\n\\r\\n\\t\\tthis.hasPositions = false;\\r\\n\\t\\tthis.hasNormals = false;\\r\\n\\t\\tthis.hasUvs = false;\\r\\n\\t\\tthis.hasColors = false;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.end = function( renderCallback ) {\\r\\n\\r\\n\\t\\tif ( this.count === 0 )\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\tfor ( var i = this.count * 3; i < this.positionArray.length; i ++ )\\r\\n\\t\\t\\tthis.positionArray[ i ] = 0.0;\\r\\n\\r\\n\\t\\tthis.hasPositions = true;\\r\\n\\t\\tthis.hasNormals = true;\\r\\n\\r\\n\\t\\tif ( this.enableUvs ) {\\r\\n\\r\\n\\t\\t\\tthis.hasUvs = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( this.enableColors ) {\\r\\n\\r\\n\\t\\t\\tthis.hasColors = true;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trenderCallback( this );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/////////////////////////////////////\\r\\n\\t// Metaballs\\r\\n\\t/////////////////////////////////////\\r\\n\\r\\n\\t// Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after\\r\\n\\t// a fixed distance, determined by strength and subtract.\\r\\n\\r\\n\\tthis.addBall = function( ballx, bally, ballz, strength, subtract ) {\\r\\n\\r\\n\\t\\t// Let's solve the equation to find the radius:\\r\\n\\t\\t// 1.0 / (0.000001 + radius^2) * strength - subtract = 0\\r\\n\\t\\t// strength / (radius^2) = subtract\\r\\n\\t\\t// strength = subtract * radius^2\\r\\n\\t\\t// radius^2 = strength / subtract\\r\\n\\t\\t// radius = sqrt(strength / subtract)\\r\\n\\r\\n\\t\\tvar radius = this.size * Math.sqrt( strength / subtract ),\\r\\n\\t\\t\\tzs = ballz * this.size,\\r\\n\\t\\t\\tys = bally * this.size,\\r\\n\\t\\t\\txs = ballx * this.size;\\r\\n\\r\\n\\t\\tvar min_z = Math.floor( zs - radius ); if ( min_z < 1 ) min_z = 1;\\r\\n\\t\\tvar max_z = Math.floor( zs + radius ); if ( max_z > this.size - 1 ) max_z = this.size - 1;\\r\\n\\t\\tvar min_y = Math.floor( ys - radius ); if ( min_y < 1 ) min_y = 1;\\r\\n\\t\\tvar max_y = Math.floor( ys + radius ); if ( max_y > this.size - 1 ) max_y = this.size - 1;\\r\\n\\t\\tvar min_x = Math.floor( xs - radius ); if ( min_x < 1  ) min_x = 1;\\r\\n\\t\\tvar max_x = Math.floor( xs + radius ); if ( max_x > this.size - 1 ) max_x = this.size - 1;\\r\\n\\r\\n\\r\\n\\t\\t// Don't polygonize in the outer layer because normals aren't\\r\\n\\t\\t// well-defined there.\\r\\n\\r\\n\\t\\tvar x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;\\r\\n\\r\\n\\t\\tfor ( z = min_z; z < max_z; z++ ) {\\r\\n\\r\\n\\t\\t\\tz_offset = this.size2 * z,\\r\\n\\t\\t\\tfz = z / this.size - ballz,\\r\\n\\t\\t\\tfz2 = fz * fz;\\r\\n\\r\\n\\t\\t\\tfor ( y = min_y; y < max_y; y++ ) {\\r\\n\\r\\n\\t\\t\\t\\ty_offset = z_offset + this.size * y;\\r\\n\\t\\t\\t\\tfy = y / this.size - bally;\\r\\n\\t\\t\\t\\tfy2 = fy * fy;\\r\\n\\r\\n\\t\\t\\t\\tfor ( x = min_x; x < max_x; x++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfx = x / this.size - ballx;\\r\\n\\t\\t\\t\\t\\tval = strength / ( 0.000001 + fx*fx + fy2 + fz2 ) - subtract;\\r\\n\\t\\t\\t\\t\\tif ( val > 0.0 ) this.field[ y_offset + x ] += val;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.addPlaneX = function( strength, subtract ) {\\r\\n\\r\\n\\t\\tvar x, y, z, xx, val, xdiv, cxy,\\r\\n\\r\\n\\t\\t\\t// cache attribute lookups\\r\\n\\t\\t\\tsize = this.size,\\r\\n\\t\\t\\tyd = this.yd,\\r\\n\\t\\t\\tzd = this.zd,\\r\\n\\t\\t\\tfield = this.field,\\r\\n\\r\\n\\t\\t\\tdist = size * Math.sqrt( strength / subtract );\\r\\n\\r\\n\\t\\tif ( dist > size ) dist = size;\\r\\n\\r\\n\\t\\tfor ( x = 0; x < dist; x ++ ) {\\r\\n\\r\\n\\t\\t\\txdiv = x / size;\\r\\n\\t\\t\\txx = xdiv * xdiv;\\r\\n\\t\\t\\tval = strength / ( 0.0001 + xx ) - subtract;\\r\\n\\r\\n\\t\\t\\tif ( val > 0.0 ) {\\r\\n\\r\\n\\t\\t\\t\\tfor ( y = 0; y < size; y ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcxy = x + y * yd;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( z = 0; z < size; z ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfield[ zd * z + cxy ] += val;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.addPlaneY = function( strength, subtract ) {\\r\\n\\r\\n\\t\\tvar x, y, z, yy, val, ydiv, cy, cxy,\\r\\n\\r\\n\\t\\t\\t// cache attribute lookups\\r\\n\\t\\t\\tsize = this.size,\\r\\n\\t\\t\\tyd = this.yd,\\r\\n\\t\\t\\tzd = this.zd,\\r\\n\\t\\t\\tfield = this.field,\\r\\n\\r\\n\\t\\t\\tdist = size * Math.sqrt( strength / subtract );\\r\\n\\r\\n\\t\\tif ( dist > size ) dist = size;\\r\\n\\r\\n\\t\\tfor ( y = 0; y < dist; y ++ ) {\\r\\n\\r\\n\\t\\t\\tydiv = y / size;\\r\\n\\t\\t\\tyy = ydiv * ydiv;\\r\\n\\t\\t\\tval = strength / ( 0.0001 + yy ) - subtract;\\r\\n\\r\\n\\t\\t\\tif ( val > 0.0 ) {\\r\\n\\r\\n\\t\\t\\t\\tcy = y * yd;\\r\\n\\r\\n\\t\\t\\t\\tfor ( x = 0; x < size; x ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcxy = cy + x;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( z = 0; z < size; z ++ )\\r\\n\\t\\t\\t\\t\\t\\tfield[ zd * z + cxy ] += val;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.addPlaneZ = function( strength, subtract ) {\\r\\n\\r\\n\\t\\tvar x, y, z, zz, val, zdiv, cz, cyz,\\r\\n\\r\\n\\t\\t\\t// cache attribute lookups\\r\\n\\t\\t\\tsize = this.size,\\r\\n\\t\\t\\tyd = this.yd,\\r\\n\\t\\t\\tzd = this.zd,\\r\\n\\t\\t\\tfield = this.field,\\r\\n\\r\\n\\t\\t\\tdist = size * Math.sqrt( strength / subtract );\\r\\n\\r\\n\\t\\tif ( dist > size ) dist = size;\\r\\n\\r\\n\\t\\tfor ( z = 0; z < dist; z ++ ) {\\r\\n\\r\\n\\t\\t\\tzdiv = z / size;\\r\\n\\t\\t\\tzz = zdiv * zdiv;\\r\\n\\t\\t\\tval = strength / ( 0.0001 + zz ) - subtract;\\r\\n\\t\\t\\tif ( val > 0.0 ) {\\r\\n\\r\\n\\t\\t\\t\\tcz = zd * z;\\r\\n\\r\\n\\t\\t\\t\\tfor ( y = 0; y < size; y ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tcyz = cz + y * yd;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor ( x = 0; x < size; x ++ )\\r\\n\\t\\t\\t\\t\\t\\tfield[ cyz + x ] += val;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t/////////////////////////////////////\\r\\n\\t// Updates\\r\\n\\t/////////////////////////////////////\\r\\n\\r\\n\\tthis.reset = function() {\\r\\n\\r\\n\\t\\tvar i;\\r\\n\\r\\n\\t\\t// wipe the normal cache\\r\\n\\r\\n\\t\\tfor ( i = 0; i < this.size3; i ++ ) {\\r\\n\\r\\n\\t\\t\\tthis.normal_cache[ i * 3 ] = 0.0;\\r\\n\\t\\t\\tthis.field[ i ] = 0.0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.render = function( renderCallback ) {\\r\\n\\r\\n\\t\\tthis.begin();\\r\\n\\r\\n\\t\\t// Triangulate. Yeah, this is slow.\\r\\n\\r\\n\\t\\tvar q, x, y, z, fx, fy, fz, y_offset, z_offset, smin2 = this.size - 2;\\r\\n\\r\\n\\t\\tfor ( z = 1; z < smin2; z ++ ) {\\r\\n\\r\\n\\t\\t\\tz_offset = this.size2 * z;\\r\\n\\t\\t\\tfz = ( z - this.halfsize ) / this.halfsize; //+ 1\\r\\n\\r\\n\\t\\t\\tfor ( y = 1; y < smin2; y ++ ) {\\r\\n\\r\\n\\t\\t\\t\\ty_offset = z_offset + this.size * y;\\r\\n\\t\\t\\t\\tfy = ( y - this.halfsize ) / this.halfsize; //+ 1\\r\\n\\r\\n\\t\\t\\t\\tfor ( x = 1; x < smin2; x ++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tfx = ( x - this.halfsize ) / this.halfsize; //+ 1\\r\\n\\t\\t\\t\\t\\tq = y_offset + x;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.polygonize( fx, fy, fz, q, this.isolation, renderCallback );\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.end( renderCallback );\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.generateGeometry = function() {\\r\\n\\r\\n\\t\\tvar start = 0, geo = new THREE.Geometry();\\r\\n\\t\\tvar normals = [];\\r\\n\\r\\n\\t\\tvar geo_callback = function( object ) {\\r\\n\\r\\n\\t\\t\\tvar i, x, y, z, vertex, normal,\\r\\n\\t\\t\\t\\tface, a, b, c, na, nb, nc, nfaces;\\r\\n\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i < object.count; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\ta = i * 3;\\r\\n\\t\\t\\t\\tb = a + 1;\\r\\n\\t\\t\\t\\tc = a + 2;\\r\\n\\r\\n\\t\\t\\t\\tx = object.positionArray[ a ];\\r\\n\\t\\t\\t\\ty = object.positionArray[ b ];\\r\\n\\t\\t\\t\\tz = object.positionArray[ c ];\\r\\n\\t\\t\\t\\tvertex = new THREE.Vector3( x, y, z );\\r\\n\\r\\n\\t\\t\\t\\tx = object.normalArray[ a ];\\r\\n\\t\\t\\t\\ty = object.normalArray[ b ];\\r\\n\\t\\t\\t\\tz = object.normalArray[ c ];\\r\\n\\t\\t\\t\\tnormal = new THREE.Vector3( x, y, z );\\r\\n\\t\\t\\t\\tnormal.normalize();\\r\\n\\r\\n\\t\\t\\t\\tgeo.vertices.push( vertex );\\r\\n\\t\\t\\t\\tnormals.push( normal );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tnfaces = object.count / 3;\\r\\n\\r\\n\\t\\t\\tfor ( i = 0; i < nfaces; i ++ ) {\\r\\n\\r\\n\\t\\t\\t\\ta = ( start + i ) * 3;\\r\\n\\t\\t\\t\\tb = a + 1;\\r\\n\\t\\t\\t\\tc = a + 2;\\r\\n\\r\\n\\t\\t\\t\\tna = normals[ a ];\\r\\n\\t\\t\\t\\tnb = normals[ b ];\\r\\n\\t\\t\\t\\tnc = normals[ c ];\\r\\n\\r\\n\\t\\t\\t\\tface = new THREE.Face3( a, b, c, [ na, nb, nc ] );\\r\\n\\r\\n\\t\\t\\t\\tgeo.faces.push( face );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstart += nfaces;\\r\\n\\t\\t\\tobject.count = 0;\\r\\n\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tthis.render( geo_callback );\\r\\n\\r\\n\\t\\t// console.log( \\\"generated \\\" + geo.faces.length + \\\" triangles\\\" );\\r\\n\\r\\n\\t\\treturn geo;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.init( resolution );\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.MarchingCubes.prototype = Object.create( THREE.ImmediateRenderObject.prototype );\\r\\n\\r\\n\\r\\n/////////////////////////////////////\\r\\n// Marching cubes lookup tables\\r\\n/////////////////////////////////////\\r\\n\\r\\n// These tables are straight from Paul Bourke's page:\\r\\n// http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/\\r\\n// who in turn got them from Cory Gene Bloyd.\\r\\n\\r\\nTHREE.edgeTable = new Int32Array([\\r\\n0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,\\r\\n0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,\\r\\n0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,\\r\\n0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,\\r\\n0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,\\r\\n0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,\\r\\n0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,\\r\\n0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,\\r\\n0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,\\r\\n0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,\\r\\n0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,\\r\\n0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,\\r\\n0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,\\r\\n0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,\\r\\n0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,\\r\\n0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,\\r\\n0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,\\r\\n0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,\\r\\n0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,\\r\\n0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,\\r\\n0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,\\r\\n0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,\\r\\n0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,\\r\\n0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,\\r\\n0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,\\r\\n0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,\\r\\n0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,\\r\\n0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,\\r\\n0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,\\r\\n0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,\\r\\n0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,\\r\\n0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0])\\r\\n\\r\\nTHREE.triTable = new Int32Array([\\r\\n-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,\\r\\n2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1,\\r\\n8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1,\\r\\n3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1,\\r\\n4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1,\\r\\n4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,\\r\\n5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1,\\r\\n2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1,\\r\\n9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,\\r\\n2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1,\\r\\n10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1,\\r\\n5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1,\\r\\n5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1,\\r\\n10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1,\\r\\n8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1,\\r\\n2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1,\\r\\n7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1,\\r\\n2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1,\\r\\n11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1,\\r\\n5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1,\\r\\n11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1,\\r\\n11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1,\\r\\n5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1,\\r\\n2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,\\r\\n5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1,\\r\\n6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1,\\r\\n3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1,\\r\\n6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1,\\r\\n5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,\\r\\n10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1,\\r\\n6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1,\\r\\n8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1,\\r\\n7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1,\\r\\n3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,\\r\\n5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1,\\r\\n0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1,\\r\\n9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1,\\r\\n8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1,\\r\\n5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1,\\r\\n0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1,\\r\\n6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1,\\r\\n10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1,\\r\\n10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1,\\r\\n8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1,\\r\\n1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1,\\r\\n0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1,\\r\\n10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1,\\r\\n3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1,\\r\\n6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1,\\r\\n9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1,\\r\\n8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1,\\r\\n3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1,\\r\\n6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1,\\r\\n10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1,\\r\\n10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1,\\r\\n2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1,\\r\\n7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1,\\r\\n7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1,\\r\\n2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1,\\r\\n1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1,\\r\\n11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1,\\r\\n8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1,\\r\\n0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1,\\r\\n7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,\\r\\n10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,\\r\\n2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,\\r\\n6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1,\\r\\n7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1,\\r\\n2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1,\\r\\n10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1,\\r\\n10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1,\\r\\n0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1,\\r\\n7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1,\\r\\n6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1,\\r\\n8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1,\\r\\n6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1,\\r\\n4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1,\\r\\n10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1,\\r\\n8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1,\\r\\n1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1,\\r\\n8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1,\\r\\n10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1,\\r\\n10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,\\r\\n5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,\\r\\n11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1,\\r\\n9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,\\r\\n6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1,\\r\\n7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1,\\r\\n3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1,\\r\\n7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1,\\r\\n3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1,\\r\\n6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1,\\r\\n9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1,\\r\\n1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1,\\r\\n4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1,\\r\\n7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1,\\r\\n6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1,\\r\\n0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1,\\r\\n6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1,\\r\\n0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1,\\r\\n11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1,\\r\\n6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1,\\r\\n5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1,\\r\\n9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1,\\r\\n1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1,\\r\\n10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1,\\r\\n0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1,\\r\\n5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1,\\r\\n10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1,\\r\\n11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1,\\r\\n9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1,\\r\\n7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1,\\r\\n2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1,\\r\\n8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1,\\r\\n9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1,\\r\\n9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1,\\r\\n1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1,\\r\\n5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1,\\r\\n0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1,\\r\\n10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1,\\r\\n2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1,\\r\\n0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1,\\r\\n0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1,\\r\\n9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1,\\r\\n5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1,\\r\\n5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1,\\r\\n8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1,\\r\\n9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1,\\r\\n1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1,\\r\\n3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1,\\r\\n4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1,\\r\\n9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1,\\r\\n11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1,\\r\\n11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1,\\r\\n2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1,\\r\\n9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1,\\r\\n3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1,\\r\\n1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1,\\r\\n4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1,\\r\\n0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1,\\r\\n9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1,\\r\\n1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\\r\\n-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);\\r\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Car.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Car.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.Car = function () {\\n\\n\\tvar scope = this;\\n\\n\\t// car geometry manual parameters\\n\\n\\tthis.modelScale = 1;\\n\\n\\tthis.backWheelOffset = 2;\\n\\n\\tthis.autoWheelGeometry = true;\\n\\n\\t// car geometry parameters automatically set from wheel mesh\\n\\t// \\t- assumes wheel mesh is front left wheel in proper global\\n\\t//    position with respect to body mesh\\n\\t//\\t- other wheels are mirrored against car root\\n\\t//\\t- if necessary back wheels can be offset manually\\n\\n\\tthis.wheelOffset = new THREE.Vector3();\\n\\n\\tthis.wheelDiameter = 1;\\n\\n\\t// car \\\"feel\\\" parameters\\n\\n\\tthis.MAX_SPEED = 2200;\\n\\tthis.MAX_REVERSE_SPEED = -1500;\\n\\n\\tthis.MAX_WHEEL_ROTATION = 0.6;\\n\\n\\tthis.FRONT_ACCELERATION = 1250;\\n\\tthis.BACK_ACCELERATION = 1500;\\n\\n\\tthis.WHEEL_ANGULAR_ACCELERATION = 1.5;\\n\\n\\tthis.FRONT_DECCELERATION = 750;\\n\\tthis.WHEEL_ANGULAR_DECCELERATION = 1.0;\\n\\n\\tthis.STEERING_RADIUS_RATIO = 0.0023;\\n\\n\\tthis.MAX_TILT_SIDES = 0.05;\\n\\tthis.MAX_TILT_FRONTBACK = 0.015;\\n\\n\\t// internal control variables\\n\\n\\tthis.speed = 0;\\n\\tthis.acceleration = 0;\\n\\n\\tthis.wheelOrientation = 0;\\n\\tthis.carOrientation = 0;\\n\\n\\t// car rigging\\n\\n\\tthis.root = new THREE.Object3D();\\n\\n\\tthis.frontLeftWheelRoot = new THREE.Object3D();\\n\\tthis.frontRightWheelRoot = new THREE.Object3D();\\n\\n\\tthis.bodyMesh = null;\\n\\n\\tthis.frontLeftWheelMesh = null;\\n\\tthis.frontRightWheelMesh = null;\\n\\n\\tthis.backLeftWheelMesh = null;\\n\\tthis.backRightWheelMesh = null;\\n\\n\\tthis.bodyGeometry = null;\\n\\tthis.wheelGeometry = null;\\n\\n\\tthis.bodyMaterials = null;\\n\\tthis.wheelMaterials = null;\\n\\n\\t// internal helper variables\\n\\n\\tthis.loaded = false;\\n\\n\\tthis.meshes = [];\\n\\n\\t// API\\n\\n\\tthis.enableShadows = function ( enable ) {\\n\\n\\t\\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\\n\\n\\t\\t\\tthis.meshes[ i ].castShadow = enable;\\n\\t\\t\\tthis.meshes[ i ].receiveShadow = enable;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.setVisible = function ( enable ) {\\n\\n\\t\\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\\n\\n\\t\\t\\tthis.meshes[ i ].visible = enable;\\n\\t\\t\\tthis.meshes[ i ].visible = enable;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.loadPartsJSON = function ( bodyURL, wheelURL ) {\\n\\n\\t\\tvar loader = new THREE.JSONLoader();\\n\\n\\t\\tloader.load( bodyURL, function( geometry, materials ) { createBody( geometry, materials ) } );\\n\\t\\tloader.load( wheelURL, function( geometry, materials ) { createWheels( geometry, materials ) } );\\n\\n\\t};\\n\\n\\tthis.loadPartsBinary = function ( bodyURL, wheelURL ) {\\n\\n\\t\\tvar loader = new THREE.BinaryLoader();\\n\\n\\t\\tloader.load( bodyURL, function( geometry, materials ) { createBody( geometry, materials ) } );\\n\\t\\tloader.load( wheelURL, function( geometry, materials ) { createWheels( geometry, materials ) } );\\n\\n\\t};\\n\\n\\tthis.updateCarModel = function ( delta, controls ) {\\n\\n\\t\\t// speed and wheels based on controls\\n\\n\\t\\tif ( controls.moveForward ) {\\n\\n\\t\\t\\tthis.speed = THREE.Math.clamp( this.speed + delta * this.FRONT_ACCELERATION, this.MAX_REVERSE_SPEED, this.MAX_SPEED );\\n\\t\\t\\tthis.acceleration = THREE.Math.clamp( this.acceleration + delta, -1, 1 );\\n\\n\\t\\t}\\n\\n\\t\\tif ( controls.moveBackward ) {\\n\\n\\n\\t\\t\\tthis.speed = THREE.Math.clamp( this.speed - delta * this.BACK_ACCELERATION, this.MAX_REVERSE_SPEED, this.MAX_SPEED );\\n\\t\\t\\tthis.acceleration = THREE.Math.clamp( this.acceleration - delta, -1, 1 );\\n\\n\\t\\t}\\n\\n\\t\\tif ( controls.moveLeft ) {\\n\\n\\t\\t\\tthis.wheelOrientation = THREE.Math.clamp( this.wheelOrientation + delta * this.WHEEL_ANGULAR_ACCELERATION, - this.MAX_WHEEL_ROTATION, this.MAX_WHEEL_ROTATION );\\n\\n\\t\\t}\\n\\n\\t\\tif ( controls.moveRight ) {\\n\\n\\t\\t\\tthis.wheelOrientation = THREE.Math.clamp( this.wheelOrientation - delta * this.WHEEL_ANGULAR_ACCELERATION, - this.MAX_WHEEL_ROTATION, this.MAX_WHEEL_ROTATION );\\n\\n\\t\\t}\\n\\n\\t\\t// speed decay\\n\\n\\t\\tif ( ! ( controls.moveForward || controls.moveBackward ) ) {\\n\\n\\t\\t\\tif ( this.speed > 0 ) {\\n\\n\\t\\t\\t\\tvar k = exponentialEaseOut( this.speed / this.MAX_SPEED );\\n\\n\\t\\t\\t\\tthis.speed = THREE.Math.clamp( this.speed - k * delta * this.FRONT_DECCELERATION, 0, this.MAX_SPEED );\\n\\t\\t\\t\\tthis.acceleration = THREE.Math.clamp( this.acceleration - k * delta, 0, 1 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar k = exponentialEaseOut( this.speed / this.MAX_REVERSE_SPEED );\\n\\n\\t\\t\\t\\tthis.speed = THREE.Math.clamp( this.speed + k * delta * this.BACK_ACCELERATION, this.MAX_REVERSE_SPEED, 0 );\\n\\t\\t\\t\\tthis.acceleration = THREE.Math.clamp( this.acceleration + k * delta, -1, 0 );\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t}\\n\\n\\t\\t// steering decay\\n\\n\\t\\tif ( ! ( controls.moveLeft || controls.moveRight ) ) {\\n\\n\\t\\t\\tif ( this.wheelOrientation > 0 ) {\\n\\n\\t\\t\\t\\tthis.wheelOrientation = THREE.Math.clamp( this.wheelOrientation - delta * this.WHEEL_ANGULAR_DECCELERATION, 0, this.MAX_WHEEL_ROTATION );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.wheelOrientation = THREE.Math.clamp( this.wheelOrientation + delta * this.WHEEL_ANGULAR_DECCELERATION, - this.MAX_WHEEL_ROTATION, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// car update\\n\\n\\t\\tvar forwardDelta = this.speed * delta;\\n\\n\\t\\tthis.carOrientation += ( forwardDelta * this.STEERING_RADIUS_RATIO )* this.wheelOrientation;\\n\\n\\t\\t// displacement\\n\\n\\t\\tthis.root.position.x += Math.sin( this.carOrientation ) * forwardDelta;\\n\\t\\tthis.root.position.z += Math.cos( this.carOrientation ) * forwardDelta;\\n\\n\\t\\t// steering\\n\\n\\t\\tthis.root.rotation.y = this.carOrientation;\\n\\n\\t\\t// tilt\\n\\n\\t\\tif ( this.loaded ) {\\n\\n\\t\\t\\tthis.bodyMesh.rotation.z = this.MAX_TILT_SIDES * this.wheelOrientation * ( this.speed / this.MAX_SPEED );\\n\\t\\t\\tthis.bodyMesh.rotation.x = - this.MAX_TILT_FRONTBACK * this.acceleration;\\n\\n\\t\\t}\\n\\n\\t\\t// wheels rolling\\n\\n\\t\\tvar angularSpeedRatio = 1 / ( this.modelScale * ( this.wheelDiameter / 2 ) );\\n\\n\\t\\tvar wheelDelta = forwardDelta * angularSpeedRatio;\\n\\n\\t\\tif ( this.loaded ) {\\n\\n\\t\\t\\tthis.frontLeftWheelMesh.rotation.x += wheelDelta;\\n\\t\\t\\tthis.frontRightWheelMesh.rotation.x += wheelDelta;\\n\\t\\t\\tthis.backLeftWheelMesh.rotation.x += wheelDelta;\\n\\t\\t\\tthis.backRightWheelMesh.rotation.x += wheelDelta;\\n\\n\\t\\t}\\n\\n\\t\\t// front wheels steering\\n\\n\\t\\tthis.frontLeftWheelRoot.rotation.y = this.wheelOrientation;\\n\\t\\tthis.frontRightWheelRoot.rotation.y = this.wheelOrientation;\\n\\n\\t};\\n\\n\\t// internal helper methods\\n\\n\\tfunction createBody ( geometry, materials ) {\\n\\n\\t\\tscope.bodyGeometry = geometry;\\n\\t\\tscope.bodyMaterials = materials;\\n\\n\\t\\tcreateCar();\\n\\n\\t};\\n\\n\\tfunction createWheels ( geometry, materials ) {\\n\\n\\t\\tscope.wheelGeometry = geometry;\\n\\t\\tscope.wheelMaterials = materials;\\n\\n\\t\\tcreateCar();\\n\\n\\t};\\n\\n\\tfunction createCar () {\\n\\n\\t\\tif ( scope.bodyGeometry && scope.wheelGeometry ) {\\n\\n\\t\\t\\t// compute wheel geometry parameters\\n\\n\\t\\t\\tif ( scope.autoWheelGeometry ) {\\n\\n\\t\\t\\t\\tscope.wheelGeometry.computeBoundingBox();\\n\\n\\t\\t\\t\\tvar bb = scope.wheelGeometry.boundingBox;\\n\\n\\t\\t\\t\\tscope.wheelOffset.addVectors( bb.min, bb.max );\\n\\t\\t\\t\\tscope.wheelOffset.multiplyScalar( 0.5 );\\n\\n\\t\\t\\t\\tscope.wheelDiameter = bb.max.y - bb.min.y;\\n\\n\\t\\t\\t\\tscope.wheelGeometry.center();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// rig the car\\n\\n\\t\\t\\tvar s = scope.modelScale,\\n\\t\\t\\t\\tdelta = new THREE.Vector3();\\n\\n\\t\\t\\tvar bodyFaceMaterial = new THREE.MeshFaceMaterial( scope.bodyMaterials );\\n\\t\\t\\tvar wheelFaceMaterial = new THREE.MeshFaceMaterial( scope.wheelMaterials );\\n\\n\\t\\t\\t// body\\n\\n\\t\\t\\tscope.bodyMesh = new THREE.Mesh( scope.bodyGeometry, bodyFaceMaterial );\\n\\t\\t\\tscope.bodyMesh.scale.set( s, s, s );\\n\\n\\t\\t\\tscope.root.add( scope.bodyMesh );\\n\\n\\t\\t\\t// front left wheel\\n\\n\\t\\t\\tdelta.multiplyVectors( scope.wheelOffset, new THREE.Vector3( s, s, s ) );\\n\\n\\t\\t\\tscope.frontLeftWheelRoot.position.add( delta );\\n\\n\\t\\t\\tscope.frontLeftWheelMesh = new THREE.Mesh( scope.wheelGeometry, wheelFaceMaterial );\\n\\t\\t\\tscope.frontLeftWheelMesh.scale.set( s, s, s );\\n\\n\\t\\t\\tscope.frontLeftWheelRoot.add( scope.frontLeftWheelMesh );\\n\\t\\t\\tscope.root.add( scope.frontLeftWheelRoot );\\n\\n\\t\\t\\t// front right wheel\\n\\n\\t\\t\\tdelta.multiplyVectors( scope.wheelOffset, new THREE.Vector3( -s, s, s ) );\\n\\n\\t\\t\\tscope.frontRightWheelRoot.position.add( delta );\\n\\n\\t\\t\\tscope.frontRightWheelMesh = new THREE.Mesh( scope.wheelGeometry, wheelFaceMaterial );\\n\\n\\t\\t\\tscope.frontRightWheelMesh.scale.set( s, s, s );\\n\\t\\t\\tscope.frontRightWheelMesh.rotation.z = Math.PI;\\n\\n\\t\\t\\tscope.frontRightWheelRoot.add( scope.frontRightWheelMesh );\\n\\t\\t\\tscope.root.add( scope.frontRightWheelRoot );\\n\\n\\t\\t\\t// back left wheel\\n\\n\\t\\t\\tdelta.multiplyVectors( scope.wheelOffset, new THREE.Vector3( s, s, -s ) );\\n\\t\\t\\tdelta.z -= scope.backWheelOffset;\\n\\n\\t\\t\\tscope.backLeftWheelMesh = new THREE.Mesh( scope.wheelGeometry, wheelFaceMaterial );\\n\\n\\t\\t\\tscope.backLeftWheelMesh.position.add( delta );\\n\\t\\t\\tscope.backLeftWheelMesh.scale.set( s, s, s );\\n\\n\\t\\t\\tscope.root.add( scope.backLeftWheelMesh );\\n\\n\\t\\t\\t// back right wheel\\n\\n\\t\\t\\tdelta.multiplyVectors( scope.wheelOffset, new THREE.Vector3( -s, s, -s ) );\\n\\t\\t\\tdelta.z -= scope.backWheelOffset;\\n\\n\\t\\t\\tscope.backRightWheelMesh = new THREE.Mesh( scope.wheelGeometry, wheelFaceMaterial );\\n\\n\\t\\t\\tscope.backRightWheelMesh.position.add( delta );\\n\\t\\t\\tscope.backRightWheelMesh.scale.set( s, s, s );\\n\\t\\t\\tscope.backRightWheelMesh.rotation.z = Math.PI;\\n\\n\\t\\t\\tscope.root.add( scope.backRightWheelMesh );\\n\\n\\t\\t\\t// cache meshes\\n\\n\\t\\t\\tscope.meshes = [ scope.bodyMesh, scope.frontLeftWheelMesh, scope.frontRightWheelMesh, scope.backLeftWheelMesh, scope.backRightWheelMesh ];\\n\\n\\t\\t\\t// callback\\n\\n\\t\\t\\tscope.loaded = true;\\n\\n\\t\\t\\tif ( scope.callback ) {\\n\\n\\t\\t\\t\\tscope.callback( scope );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction quadraticEaseOut( k ) { return - k * ( k - 2 ); }\\n\\tfunction cubicEaseOut( k ) { return --k * k * k + 1; }\\n\\tfunction circularEaseOut( k ) { return Math.sqrt( 1 - --k * k ); }\\n\\tfunction sinusoidalEaseOut( k ) { return Math.sin( k * Math.PI / 2 ); }\\n\\tfunction exponentialEaseOut( k ) { return k === 1 ? 1 : - Math.pow( 2, - 10 * k ) + 1; }\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/ShaderSkin.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/ShaderSkin.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n */\\n\\n\\nTHREE.ShaderSkin = {\\n\\n\\t/* ------------------------------------------------------------------------------------------\\n\\t//\\tSimple skin shader\\n\\t//\\t\\t- per-pixel Blinn-Phong diffuse term mixed with half-Lambert wrap-around term (per color component)\\n\\t//\\t\\t- physically based specular term (Kelemen/Szirmay-Kalos specular reflectance)\\n\\t//\\n\\t//\\t\\t- diffuse map\\n\\t//\\t\\t- bump map\\n\\t//\\t\\t- specular map\\n\\t//\\t\\t- point, directional and hemisphere lights (use with \\\"lights: true\\\" material option)\\n\\t//\\t\\t- fog (use with \\\"fog: true\\\" material option)\\n\\t//\\t\\t- shadow maps\\n\\t//\\n\\t// ------------------------------------------------------------------------------------------ */\\n\\n\\t'skinSimple' : {\\n\\n\\t\\tuniforms: THREE.UniformsUtils.merge( [\\n\\n\\t\\t\\tTHREE.UniformsLib[ \\\"fog\\\" ],\\n\\t\\t\\tTHREE.UniformsLib[ \\\"lights\\\" ],\\n\\t\\t\\tTHREE.UniformsLib[ \\\"shadowmap\\\" ],\\n\\n\\t\\t\\t{\\n\\n\\t\\t\\t\\\"enableBump\\\"\\t: { type: \\\"i\\\", value: 0 },\\n\\t\\t\\t\\\"enableSpecular\\\": { type: \\\"i\\\", value: 0 },\\n\\n\\t\\t\\t\\\"tDiffuse\\\"\\t: { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"tBeckmann\\\"\\t: { type: \\\"t\\\", value: null },\\n\\n\\t\\t\\t\\\"diffuse\\\":  { type: \\\"c\\\", value: new THREE.Color( 0xeeeeee ) },\\n\\t\\t\\t\\\"specular\\\": { type: \\\"c\\\", value: new THREE.Color( 0x111111 ) },\\n\\t\\t\\t\\\"ambient\\\":  { type: \\\"c\\\", value: new THREE.Color( 0x050505 ) },\\n\\t\\t\\t\\\"opacity\\\": \\t  { type: \\\"f\\\", value: 1 },\\n\\n\\t\\t\\t\\\"uRoughness\\\": \\t  \\t\\t{ type: \\\"f\\\", value: 0.15 },\\n\\t\\t\\t\\\"uSpecularBrightness\\\": \\t{ type: \\\"f\\\", value: 0.75 },\\n\\n\\t\\t\\t\\\"bumpMap\\\"\\t: { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"bumpScale\\\" : { type: \\\"f\\\", value: 1 },\\n\\n\\t\\t\\t\\\"specularMap\\\" : { type: \\\"t\\\", value: null },\\n\\n\\t\\t\\t\\\"offsetRepeat\\\" : { type: \\\"v4\\\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\\n\\n\\t\\t\\t\\\"uWrapRGB\\\":\\t{ type: \\\"v3\\\", value: new THREE.Vector3( 0.75, 0.375, 0.1875 ) }\\n\\n\\t\\t\\t}\\n\\n\\t\\t] ),\\n\\n\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\\"#define USE_BUMPMAP\\\",\\n\\t\\t\\t\\\"#extension GL_OES_standard_derivatives : enable\\\",\\n\\n\\t\\t\\t\\\"uniform bool enableBump;\\\",\\n\\t\\t\\t\\\"uniform bool enableSpecular;\\\",\\n\\n\\t\\t\\t\\\"uniform vec3 ambient;\\\",\\n\\t\\t\\t\\\"uniform vec3 diffuse;\\\",\\n\\t\\t\\t\\\"uniform vec3 specular;\\\",\\n\\t\\t\\t\\\"uniform float opacity;\\\",\\n\\n\\t\\t\\t\\\"uniform float uRoughness;\\\",\\n\\t\\t\\t\\\"uniform float uSpecularBrightness;\\\",\\n\\n\\t\\t\\t\\\"uniform vec3 uWrapRGB;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tBeckmann;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D specularMap;\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"uniform vec3 ambientLightColor;\\\",\\n\\n\\t\\t\\t\\\"#if MAX_DIR_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"#if MAX_HEMI_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vViewPosition;\\\",\\n\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_pars_fragment\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"fog_pars_fragment\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"bumpmap_pars_fragment\\\" ],\\n\\n\\t\\t\\t// Fresnel term\\n\\n\\t\\t\\t\\\"float fresnelReflectance( vec3 H, vec3 V, float F0 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"float base = 1.0 - dot( V, H );\\\",\\n\\t\\t\\t\\t\\\"float exponential = pow( base, 5.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"return exponential + F0 * ( 1.0 - exponential );\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t// Kelemen/Szirmay-Kalos specular BRDF\\n\\n\\t\\t\\t\\\"float KS_Skin_Specular( vec3 N,\\\", \\t\\t// Bumped surface normal\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"vec3 L,\\\", \\t\\t// Points to light\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"vec3 V,\\\", \\t\\t// Points to eye\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"float m,\\\",  \\t// Roughness\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"float rho_s\\\", \\t// Specular brightness\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\") {\\\",\\n\\n\\t\\t\\t\\t\\\"float result = 0.0;\\\",\\n\\t\\t\\t\\t\\\"float ndotl = dot( N, L );\\\",\\n\\n\\t\\t\\t\\t\\\"if( ndotl > 0.0 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 h = L + V;\\\", // Unnormalized half-way vector\\n\\t\\t\\t\\t\\t\\\"vec3 H = normalize( h );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"float ndoth = dot( N, H );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"float PH = pow( 2.0 * texture2D( tBeckmann, vec2( ndoth, m ) ).x, 10.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"float F = fresnelReflectance( H, V, 0.028 );\\\",\\n\\t\\t\\t\\t\\t\\\"float frSpec = max( PH * F / dot( h, h ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"result = ndotl * rho_s * frSpec;\\\", // BRDF * dot(N,L) * rho_s\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"return result;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( vec3( 1.0 ), opacity );\\\",\\n\\n\\t\\t\\t\\t\\\"vec4 colDiffuse = texture2D( tDiffuse, vUv );\\\",\\n\\t\\t\\t\\t\\\"colDiffuse.rgb *= colDiffuse.rgb;\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = gl_FragColor * colDiffuse;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 normal = normalize( vNormal );\\\",\\n\\t\\t\\t\\t\\\"vec3 viewPosition = normalize( vViewPosition );\\\",\\n\\n\\t\\t\\t\\t\\\"float specularStrength;\\\",\\n\\n\\t\\t\\t\\t\\\"if ( enableSpecular ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec4 texelSpecular = texture2D( specularMap, vUv );\\\",\\n\\t\\t\\t\\t\\t\\\"specularStrength = texelSpecular.r;\\\",\\n\\n\\t\\t\\t\\t\\\"} else {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"specularStrength = 1.0;\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#ifdef USE_BUMPMAP\\\",\\n\\n\\t\\t\\t\\t\\t\\\"if ( enableBump ) normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// point lights\\n\\n\\t\\t\\t\\t\\\"vec3 specularTotal = vec3( 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 pointTotal = vec3( 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float lDistance = 1.0;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"if ( pointLightDistance[ i ] > 0.0 )\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"lVector = normalize( lVector );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float pointDiffuseWeightFull = max( dot( normal, lVector ), 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, lVector ) + 0.5, 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), uWrapRGB );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float pointSpecularWeight = KS_Skin_Specular( normal, lVector, viewPosition, uRoughness, uSpecularBrightness );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"pointTotal    += lDistance * diffuse * pointLightColor[ i ] * pointDiffuseWeight;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"specularTotal += lDistance * specular * pointLightColor[ i ] * pointSpecularWeight * specularStrength;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// directional lights\\n\\n\\t\\t\\t\\t\\\"#if MAX_DIR_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 dirTotal = vec3( 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 dirVector = normalize( lDirection.xyz );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float dirDiffuseWeightFull = max( dot( normal, dirVector ), 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float dirDiffuseWeightHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"vec3 dirDiffuseWeight = mix( vec3 ( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), uWrapRGB );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float dirSpecularWeight =  KS_Skin_Specular( normal, dirVector, viewPosition, uRoughness, uSpecularBrightness );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"dirTotal \\t   += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"specularTotal += specular * directionalLightColor[ i ] * dirSpecularWeight * specularStrength;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// hemisphere lights\\n\\n\\t\\t\\t\\t\\\"#if MAX_HEMI_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 hemiTotal = vec3( 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"vec3 lVector = normalize( lDirection.xyz );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float dotProduct = dot( normal, lVector );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"hemiTotal += diffuse * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\\",\\n\\n\\t\\t\\t\\t\\t\\t// specular (sky light)\\n\\n\\t\\t\\t\\t\\t\\t\\\"float hemiSpecularWeight = 0.0;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"hemiSpecularWeight += KS_Skin_Specular( normal, lVector, viewPosition, uRoughness, uSpecularBrightness );\\\",\\n\\n\\t\\t\\t\\t\\t\\t// specular (ground light)\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 lVectorGround = -lVector;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"hemiSpecularWeight += KS_Skin_Specular( normal, lVectorGround, viewPosition, uRoughness, uSpecularBrightness );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"specularTotal += specular * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight ) * hemiSpecularWeight * specularStrength;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// all lights contribution summation\\n\\n\\t\\t\\t\\t\\\"vec3 totalLight = vec3( 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"#if MAX_DIR_LIGHTS > 0\\\",\\n\\t\\t\\t\\t\\t\\\"totalLight += dirTotal;\\\",\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\t\\t\\t\\t\\t\\\"totalLight += pointTotal;\\\",\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"#if MAX_HEMI_LIGHTS > 0\\\",\\n\\t\\t\\t\\t\\t\\\"totalLight += hemiTotal;\\\",\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalLight + ambientLightColor * ambient ) + specularTotal;\\\",\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_fragment\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"linear_to_gamma_fragment\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"fog_fragment\\\" ],\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\\"uniform vec4 offsetRepeat;\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vViewPosition;\\\",\\n\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_pars_vertex\\\" ],\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\t\\\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"vViewPosition = -mvPosition.xyz;\\\",\\n\\n\\t\\t\\t\\t\\\"vNormal = normalize( normalMatrix * normal );\\\",\\n\\n\\t\\t\\t\\t\\\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\\",\\n\\n\\t\\t\\t\\t\\\"gl_Position = projectionMatrix * mvPosition;\\\",\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_vertex\\\" ],\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join( \\\"\\\\n\\\" )\\n\\n\\t},\\n\\n\\t/* ------------------------------------------------------------------------------------------\\n\\t//\\tSkin shader\\n\\t//\\t\\t- Blinn-Phong diffuse term (using normal + diffuse maps)\\n\\t//\\t\\t- subsurface scattering approximation by four blur layers\\n\\t//\\t\\t- physically based specular term (Kelemen/Szirmay-Kalos specular reflectance)\\n\\t//\\n\\t//\\t\\t- point and directional lights (use with \\\"lights: true\\\" material option)\\n\\t//\\n\\t//\\t\\t- based on Nvidia Advanced Skin Rendering GDC 2007 presentation\\n\\t//\\t\\t  and GPU Gems 3 Chapter 14. Advanced Techniques for Realistic Real-Time Skin Rendering\\n\\t//\\n\\t//\\t\\t\\thttp://developer.download.nvidia.com/presentations/2007/gdc/Advanced_Skin.pdf\\n\\t//\\t\\t\\thttp://http.developer.nvidia.com/GPUGems3/gpugems3_ch14.html\\n\\t// ------------------------------------------------------------------------------------------ */\\n\\n\\t'skin' : {\\n\\n\\t\\tuniforms: THREE.UniformsUtils.merge( [\\n\\n\\t\\t\\tTHREE.UniformsLib[ \\\"fog\\\" ],\\n\\t\\t\\tTHREE.UniformsLib[ \\\"lights\\\" ],\\n\\n\\t\\t\\t{\\n\\n\\t\\t\\t\\\"passID\\\": { type: \\\"i\\\", value: 0 },\\n\\n\\t\\t\\t\\\"tDiffuse\\\"\\t: { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"tNormal\\\"\\t: { type: \\\"t\\\", value: null },\\n\\n\\t\\t\\t\\\"tBlur1\\\"\\t: { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"tBlur2\\\"\\t: { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"tBlur3\\\"\\t: { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"tBlur4\\\"\\t: { type: \\\"t\\\", value: null },\\n\\n\\t\\t\\t\\\"tBeckmann\\\"\\t: { type: \\\"t\\\", value: null },\\n\\n\\t\\t\\t\\\"uNormalScale\\\": { type: \\\"f\\\", value: 1.0 },\\n\\n\\t\\t\\t\\\"diffuse\\\":  { type: \\\"c\\\", value: new THREE.Color( 0xeeeeee ) },\\n\\t\\t\\t\\\"specular\\\": { type: \\\"c\\\", value: new THREE.Color( 0x111111 ) },\\n\\t\\t\\t\\\"ambient\\\":  { type: \\\"c\\\", value: new THREE.Color( 0x050505 ) },\\n\\t\\t\\t\\\"opacity\\\": \\t  { type: \\\"f\\\", value: 1 },\\n\\n\\t\\t\\t\\\"uRoughness\\\": \\t  \\t\\t{ type: \\\"f\\\", value: 0.15 },\\n\\t\\t\\t\\\"uSpecularBrightness\\\": \\t{ type: \\\"f\\\", value: 0.75 }\\n\\n\\t\\t\\t}\\n\\n\\t\\t] ),\\n\\n\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\\"uniform vec3 ambient;\\\",\\n\\t\\t\\t\\\"uniform vec3 diffuse;\\\",\\n\\t\\t\\t\\\"uniform vec3 specular;\\\",\\n\\t\\t\\t\\\"uniform float opacity;\\\",\\n\\n\\t\\t\\t\\\"uniform float uRoughness;\\\",\\n\\t\\t\\t\\\"uniform float uSpecularBrightness;\\\",\\n\\n\\t\\t\\t\\\"uniform int passID;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tNormal;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D tBlur1;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tBlur2;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tBlur3;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tBlur4;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D tBeckmann;\\\",\\n\\n\\t\\t\\t\\\"uniform float uNormalScale;\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vTangent;\\\",\\n\\t\\t\\t\\\"varying vec3 vBinormal;\\\",\\n\\t\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"uniform vec3 ambientLightColor;\\\",\\n\\n\\t\\t\\t\\\"#if MAX_DIR_LIGHTS > 0\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\\",\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\\\",\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vViewPosition;\\\",\\n\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"fog_pars_fragment\\\" ],\\n\\n\\t\\t\\t\\\"float fresnelReflectance( vec3 H, vec3 V, float F0 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"float base = 1.0 - dot( V, H );\\\",\\n\\t\\t\\t\\t\\\"float exponential = pow( base, 5.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"return exponential + F0 * ( 1.0 - exponential );\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t// Kelemen/Szirmay-Kalos specular BRDF\\n\\n\\t\\t\\t\\\"float KS_Skin_Specular( vec3 N,\\\", \\t\\t// Bumped surface normal\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"vec3 L,\\\", \\t\\t// Points to light\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"vec3 V,\\\", \\t\\t// Points to eye\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"float m,\\\",  \\t// Roughness\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"float rho_s\\\", \\t// Specular brightness\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\") {\\\",\\n\\n\\t\\t\\t\\t\\\"float result = 0.0;\\\",\\n\\t\\t\\t\\t\\\"float ndotl = dot( N, L );\\\",\\n\\n\\t\\t\\t\\t\\\"if( ndotl > 0.0 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 h = L + V;\\\", // Unnormalized half-way vector\\n\\t\\t\\t\\t\\t\\\"vec3 H = normalize( h );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"float ndoth = dot( N, H );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"float PH = pow( 2.0 * texture2D( tBeckmann, vec2( ndoth, m ) ).x, 10.0 );\\\",\\n\\t\\t\\t\\t\\t\\\"float F = fresnelReflectance( H, V, 0.028 );\\\",\\n\\t\\t\\t\\t\\t\\\"float frSpec = max( PH * F / dot( h, h ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"result = ndotl * rho_s * frSpec;\\\", // BRDF * dot(N,L) * rho_s\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"return result;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"vec4 mColor = vec4( diffuse, opacity );\\\",\\n\\t\\t\\t\\t\\\"vec4 mSpecular = vec4( specular, opacity );\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\\\",\\n\\t\\t\\t\\t\\\"normalTex.xy *= uNormalScale;\\\",\\n\\t\\t\\t\\t\\\"normalTex = normalize( normalTex );\\\",\\n\\n\\t\\t\\t\\t\\\"vec4 colDiffuse = texture2D( tDiffuse, vUv );\\\",\\n\\t\\t\\t\\t\\\"colDiffuse *= colDiffuse;\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = gl_FragColor * colDiffuse;\\\",\\n\\n\\t\\t\\t\\t\\\"mat3 tsb = mat3( vTangent, vBinormal, vNormal );\\\",\\n\\t\\t\\t\\t\\\"vec3 finalNormal = tsb * normalTex;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 normal = normalize( finalNormal );\\\",\\n\\t\\t\\t\\t\\\"vec3 viewPosition = normalize( vViewPosition );\\\",\\n\\n\\t\\t\\t\\t// point lights\\n\\n\\t\\t\\t\\t\\\"vec3 specularTotal = vec3( 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec4 pointTotal = vec4( vec3( 0.0 ), 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 pointVector = normalize( vPointLight[ i ].xyz );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float pointDistance = vPointLight[ i ].w;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"pointTotal  += pointDistance * vec4( pointLightColor[ i ], 1.0 ) * ( mColor * pointDiffuseWeight );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"if ( passID == 1 )\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\\"specularTotal += pointDistance * mSpecular.xyz * pointLightColor[ i ] * KS_Skin_Specular( normal, pointVector, viewPosition, uRoughness, uSpecularBrightness );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// directional lights\\n\\n\\t\\t\\t\\t\\\"#if MAX_DIR_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec4 dirTotal = vec4( vec3( 0.0 ), 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 dirVector = normalize( lDirection.xyz );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"dirTotal  += vec4( directionalLightColor[ i ], 1.0 ) * ( mColor * dirDiffuseWeight );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"if ( passID == 1 )\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\\"specularTotal += mSpecular.xyz * directionalLightColor[ i ] * KS_Skin_Specular( normal, dirVector, viewPosition, uRoughness, uSpecularBrightness );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// all lights contribution summation\\n\\n\\t\\t\\t\\t\\\"vec4 totalLight = vec4( vec3( 0.0 ), opacity );\\\",\\n\\n\\t\\t\\t\\t\\\"#if MAX_DIR_LIGHTS > 0\\\",\\n\\t\\t\\t\\t\\t\\\"totalLight += dirTotal;\\\",\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\t\\t\\t\\t\\t\\\"totalLight += pointTotal;\\\",\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = gl_FragColor * totalLight;\\\",\\n\\n\\t\\t\\t\\t\\\"if ( passID == 0 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = vec4( sqrt( gl_FragColor.xyz ), gl_FragColor.w );\\\",\\n\\n\\t\\t\\t\\t\\\"} else if ( passID == 1 ) {\\\",\\n\\n\\t\\t\\t\\t\\t//\\\"#define VERSION1\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#ifdef VERSION1\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 nonblurColor = sqrt( gl_FragColor.xyz );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#else\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 nonblurColor = gl_FragColor.xyz;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 blur1Color = texture2D( tBlur1, vUv ).xyz;\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 blur2Color = texture2D( tBlur2, vUv ).xyz;\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 blur3Color = texture2D( tBlur3, vUv ).xyz;\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 blur4Color = texture2D( tBlur4, vUv ).xyz;\\\",\\n\\n\\n\\t\\t\\t\\t\\t//\\\"gl_FragColor = vec4( blur1Color, gl_FragColor.w );\\\",\\n\\n\\t\\t\\t\\t\\t//\\\"gl_FragColor = vec4( vec3( 0.22, 0.5, 0.7 ) * nonblurColor + vec3( 0.2, 0.5, 0.3 ) * blur1Color + vec3( 0.58, 0.0, 0.0 ) * blur2Color, gl_FragColor.w );\\\",\\n\\n\\t\\t\\t\\t\\t//\\\"gl_FragColor = vec4( vec3( 0.25, 0.6, 0.8 ) * nonblurColor + vec3( 0.15, 0.25, 0.2 ) * blur1Color + vec3( 0.15, 0.15, 0.0 ) * blur2Color + vec3( 0.45, 0.0, 0.0 ) * blur3Color, gl_FragColor.w );\\\",\\n\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = vec4( vec3( 0.22,  0.437, 0.635 ) * nonblurColor + \\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\\"vec3( 0.101, 0.355, 0.365 ) * blur1Color + \\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\\"vec3( 0.119, 0.208, 0.0 )   * blur2Color + \\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\\"vec3( 0.114, 0.0,   0.0 )   * blur3Color + \\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\\"vec3( 0.444, 0.0,   0.0 )   * blur4Color\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\\", gl_FragColor.w );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor.xyz *= pow( colDiffuse.xyz, vec3( 0.5 ) );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor.xyz += ambientLightColor * ambient * colDiffuse.xyz + specularTotal;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#ifndef VERSION1\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"fog_fragment\\\" ],\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\\"attribute vec4 tangent;\\\",\\n\\n\\t\\t\\t\\\"#ifdef VERTEX_TEXTURES\\\",\\n\\n\\t\\t\\t\\t\\\"uniform sampler2D tDisplacement;\\\",\\n\\t\\t\\t\\t\\\"uniform float uDisplacementScale;\\\",\\n\\t\\t\\t\\t\\\"uniform float uDisplacementBias;\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vTangent;\\\",\\n\\t\\t\\t\\\"varying vec3 vBinormal;\\\",\\n\\t\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\\",\\n\\n\\t\\t\\t\\t\\\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vViewPosition;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"vViewPosition = -mvPosition.xyz;\\\",\\n\\n\\t\\t\\t\\t\\\"vNormal = normalize( normalMatrix * normal );\\\",\\n\\n\\t\\t\\t\\t// tangent and binormal vectors\\n\\n\\t\\t\\t\\t\\\"vTangent = normalize( normalMatrix * tangent.xyz );\\\",\\n\\n\\t\\t\\t\\t\\\"vBinormal = cross( vNormal, vTangent ) * tangent.w;\\\",\\n\\t\\t\\t\\t\\\"vBinormal = normalize( vBinormal );\\\",\\n\\n\\t\\t\\t\\t\\\"vUv = uv;\\\",\\n\\n\\t\\t\\t\\t// point lights\\n\\n\\t\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"for( int i = 0; i < MAX_POINT_LIGHTS; i++ ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float lDistance = 1.0;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"if ( pointLightDistance[ i ] > 0.0 )\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"lVector = normalize( lVector );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vPointLight[ i ] = vec4( lVector, lDistance );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// displacement mapping\\n\\n\\t\\t\\t\\t\\\"#ifdef VERTEX_TEXTURES\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\\\",\\n\\t\\t\\t\\t\\t\\\"float df = uDisplacementScale * dv.x + uDisplacementBias;\\\",\\n\\t\\t\\t\\t\\t\\\"vec4 displacedPosition = vec4( vNormal.xyz * df, 0.0 ) + mvPosition;\\\",\\n\\t\\t\\t\\t\\t\\\"gl_Position = projectionMatrix * displacedPosition;\\\",\\n\\n\\t\\t\\t\\t\\\"#else\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_Position = projectionMatrix * mvPosition;\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShaderUV: [\\n\\n\\t\\t\\t\\\"attribute vec4 tangent;\\\",\\n\\n\\t\\t\\t\\\"#ifdef VERTEX_TEXTURES\\\",\\n\\n\\t\\t\\t\\t\\\"uniform sampler2D tDisplacement;\\\",\\n\\t\\t\\t\\t\\\"uniform float uDisplacementScale;\\\",\\n\\t\\t\\t\\t\\\"uniform float uDisplacementBias;\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vTangent;\\\",\\n\\t\\t\\t\\\"varying vec3 vBinormal;\\\",\\n\\t\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\\",\\n\\n\\t\\t\\t\\t\\\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vViewPosition;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"vViewPosition = -mvPosition.xyz;\\\",\\n\\n\\t\\t\\t\\t\\\"vNormal = normalize( normalMatrix * normal );\\\",\\n\\n\\t\\t\\t\\t// tangent and binormal vectors\\n\\n\\t\\t\\t\\t\\\"vTangent = normalize( normalMatrix * tangent.xyz );\\\",\\n\\n\\t\\t\\t\\t\\\"vBinormal = cross( vNormal, vTangent ) * tangent.w;\\\",\\n\\t\\t\\t\\t\\\"vBinormal = normalize( vBinormal );\\\",\\n\\n\\t\\t\\t\\t\\\"vUv = uv;\\\",\\n\\n\\t\\t\\t\\t// point lights\\n\\n\\t\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"for( int i = 0; i < MAX_POINT_LIGHTS; i++ ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float lDistance = 1.0;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"if ( pointLightDistance[ i ] > 0.0 )\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"lVector = normalize( lVector );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vPointLight[ i ] = vec4( lVector, lDistance );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"gl_Position = vec4( uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 0.0, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\t/* ------------------------------------------------------------------------------------------\\n\\t// Beckmann distribution function\\n\\t//\\t- to be used in specular term of skin shader\\n\\t//\\t- render a screen-aligned quad to precompute a 512 x 512 texture\\n\\t//\\n\\t//\\t\\t- from http://developer.nvidia.com/node/171\\n\\t ------------------------------------------------------------------------------------------ */\\n\\n\\t\\\"beckmann\\\" : {\\n\\n\\t\\tuniforms: {},\\n\\n\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"float PHBeckmann( float ndoth, float m ) {\\\",\\n\\n\\t\\t\\t\\t\\\"float alpha = acos( ndoth );\\\",\\n\\t\\t\\t\\t\\\"float ta = tan( alpha );\\\",\\n\\n\\t\\t\\t\\t\\\"float val = 1.0 / ( m * m * pow( ndoth, 4.0 ) ) * exp( -( ta * ta ) / ( m * m ) );\\\",\\n\\t\\t\\t\\t\\\"return val;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"float KSTextureCompute( vec2 tex ) {\\\",\\n\\n\\t\\t\\t\\t// Scale the value to fit within [0,1]  invert upon lookup.\\n\\n\\t\\t\\t\\t\\\"return 0.5 * pow( PHBeckmann( tex.x, tex.y ), 0.1 );\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"float x = KSTextureCompute( vUv );\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( x, x, x, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/ParametricGeometries.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/ParametricGeometries.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/*\\n * @author zz85\\n *\\n * Experimenting of primitive geometry creation using Surface Parametric equations\\n *\\n */\\n\\n\\nTHREE.ParametricGeometries = {\\n\\n\\tklein: function (v, u) {\\n\\t\\tu *= Math.PI;\\n\\t\\tv *= 2 * Math.PI;\\n\\n\\t\\tu = u * 2;\\n\\t\\tvar x, y, z;\\n\\t\\tif (u < Math.PI) {\\n\\t\\t\\tx = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(u) * Math.cos(v);\\n\\t\\t\\tz = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);\\n\\t\\t} else {\\n\\t\\t\\tx = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(v + Math.PI);\\n\\t\\t\\tz = -8 * Math.sin(u);\\n\\t\\t}\\n\\n\\t\\ty = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);\\n\\n\\t\\treturn new THREE.Vector3(x, y, z);\\n\\t},\\n\\n\\tplane: function (width, height) {\\n\\n\\t\\treturn function(u, v) {\\n\\t\\t\\tvar x = u * width;\\n\\t\\t\\tvar y = 0;\\n\\t\\t\\tvar z = v * height;\\n\\n\\t\\t\\treturn new THREE.Vector3(x, y, z);\\n\\t\\t};\\n\\t},\\n\\n\\tmobius: function(u, t) {\\n\\n\\t\\t// flat mobius strip\\n\\t\\t// http://www.wolframalpha.com/input/?i=M%C3%B6bius+strip+parametric+equations&lk=1&a=ClashPrefs_*Surface.MoebiusStrip.SurfaceProperty.ParametricEquations-\\n\\t\\tu = u - 0.5;\\n\\t\\tvar v = 2 * Math.PI * t;\\n\\n\\t\\tvar x, y, z;\\n\\n\\t\\tvar a = 2;\\n\\t\\tx = Math.cos(v) * (a + u * Math.cos(v/2));\\n\\t\\ty = Math.sin(v) * (a + u * Math.cos(v/2));\\n\\t\\tz = u * Math.sin(v/2);\\n\\t\\treturn new THREE.Vector3(x, y, z);\\n\\n\\t},\\n\\n\\tmobius3d: function(u, t) {\\n\\n\\t\\t// volumetric mobius strip\\n\\t\\tu *= Math.PI;\\n\\t\\tt *= 2 * Math.PI;\\n\\n\\t\\tu = u * 2;\\n\\t\\tvar phi = u / 2;\\n\\t\\tvar major = 2.25, a = 0.125, b = 0.65;\\n\\t\\tvar x, y, z;\\n\\t\\tx = a * Math.cos(t) * Math.cos(phi) - b * Math.sin(t) * Math.sin(phi);\\n\\t\\tz = a * Math.cos(t) * Math.sin(phi) + b * Math.sin(t) * Math.cos(phi);\\n\\t\\ty = (major + x) * Math.sin(u);\\n\\t\\tx = (major + x) * Math.cos(u);\\n\\t\\treturn new THREE.Vector3(x, y, z);\\n\\t}\\n\\n};\\n\\n\\n/*********************************************\\n *\\n * Parametric Replacement for TubeGeometry\\n *\\n *********************************************/\\n\\nTHREE.ParametricGeometries.TubeGeometry = function(path, segments, radius, segmentsRadius, closed, debug) {\\n\\n\\tthis.path = path;\\n\\tthis.segments = segments || 64;\\n\\tthis.radius = radius || 1;\\n\\tthis.segmentsRadius = segmentsRadius || 8;\\n\\tthis.closed = closed || false;\\n\\tif (debug) this.debug = new THREE.Object3D();\\n\\n\\n\\tvar scope = this,\\n\\n\\t\\ttangent, normal, binormal,\\n\\n\\t\\tnumpoints = this.segments + 1,\\n\\n\\t\\tx, y, z, tx, ty, tz, u, v,\\n\\n\\t\\tcx, cy, pos, pos2 = new THREE.Vector3(),\\n\\t\\ti, j, ip, jp, a, b, c, d, uva, uvb, uvc, uvd;\\n\\n\\tvar frames = new THREE.TubeGeometry.FrenetFrames(path, segments, closed),\\n\\t\\ttangents = frames.tangents,\\n\\t\\tnormals = frames.normals,\\n\\t\\tbinormals = frames.binormals;\\n\\n\\t\\t// proxy internals\\n\\t\\tthis.tangents = tangents;\\n\\t\\tthis.normals = normals;\\n\\t\\tthis.binormals = binormals;\\n\\n\\n\\n\\tvar ParametricTube = function(u, v) {\\n\\t\\tv *= 2 * Math.PI;\\n\\n\\t\\ti = u * (numpoints - 1);\\n\\t\\ti = Math.floor(i);\\n\\n\\t\\tpos = path.getPointAt(u);\\n\\n\\t\\ttangent = tangents[i];\\n\\t\\tnormal = normals[i];\\n\\t\\tbinormal = binormals[i];\\n\\n\\t\\tif (scope.debug) {\\n\\n\\t\\t\\tscope.debug.add(new THREE.ArrowHelper(tangent, pos, radius, 0x0000ff));\\n\\t\\t\\tscope.debug.add(new THREE.ArrowHelper(normal, pos, radius, 0xff0000));\\n\\t\\t\\tscope.debug.add(new THREE.ArrowHelper(binormal, pos, radius, 0x00ff00));\\n\\n\\t\\t}\\n\\n\\t\\tcx = -scope.radius * Math.cos(v); // TODO: Hack: Negating it so it faces outside.\\n\\t\\tcy = scope.radius * Math.sin(v);\\n\\n\\t\\tpos2.copy(pos);\\n\\t\\tpos2.x += cx * normal.x + cy * binormal.x;\\n\\t\\tpos2.y += cx * normal.y + cy * binormal.y;\\n\\t\\tpos2.z += cx * normal.z + cy * binormal.z;\\n\\n\\t\\treturn pos2.clone();\\n\\t};\\n\\n\\tTHREE.ParametricGeometry.call(this, ParametricTube, segments, segmentsRadius);\\n\\n};\\n\\nTHREE.ParametricGeometries.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\\n\\n\\n /*********************************************\\n  *\\n  * Parametric Replacement for TorusKnotGeometry\\n  *\\n  *********************************************/\\nTHREE.ParametricGeometries.TorusKnotGeometry = function ( radius, tube, segmentsR, segmentsT, p, q, heightScale ) {\\n\\n\\tvar scope = this;\\n\\n\\tthis.radius = radius || 200;\\n\\tthis.tube = tube || 40;\\n\\tthis.segmentsR = segmentsR || 64;\\n\\tthis.segmentsT = segmentsT || 8;\\n\\tthis.p = p || 2;\\n\\tthis.q = q || 3;\\n\\tthis.heightScale = heightScale || 1;\\n\\n\\n\\tvar TorusKnotCurve = THREE.Curve.create(\\n\\n\\t\\tfunction() {\\n\\t\\t},\\n\\n\\t\\tfunction(t) {\\n\\n\\t\\t\\tt *= Math.PI * 2;\\n\\n\\t\\t\\tvar r = 0.5;\\n\\n\\t\\t\\tvar tx = (1 + r * Math.cos(q * t)) * Math.cos(p * t),\\n\\t\\t\\t\\tty = (1 + r * Math.cos(q * t)) * Math.sin(p * t),\\n\\t\\t\\t\\ttz = r * Math.sin(q * t);\\n\\n\\t\\t\\treturn new THREE.Vector3(tx, ty * heightScale, tz).multiplyScalar(radius);\\n\\n\\t\\t}\\n\\n\\t);\\n\\tvar segments = segmentsR;\\n\\tvar radiusSegments = segmentsT;\\n\\tvar extrudePath = new TorusKnotCurve();\\n\\n\\tTHREE.ParametricGeometries.TubeGeometry.call( this, extrudePath, segments, tube, radiusSegments, true, false );\\n\\n\\n};\\n\\nTHREE.ParametricGeometries.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\\n\\n\\n /*********************************************\\n  *\\n  * Parametric Replacement for SphereGeometry\\n  *\\n  *********************************************/\\nTHREE.ParametricGeometries.SphereGeometry = function(size, u, v) {\\n\\n\\tfunction sphere(u, v) {\\n\\t\\tu *= Math.PI;\\n\\t\\tv *= 2 * Math.PI;\\n\\n\\t\\tvar x = size * Math.sin(u) * Math.cos(v);\\n\\t\\tvar y = size * Math.sin(u) * Math.sin(v);\\n\\t\\tvar z = size * Math.cos(u);\\n\\n\\n\\t\\treturn new THREE.Vector3(x, y, z);\\n\\t}\\n\\n\\tTHREE.ParametricGeometry.call(this, sphere, u, v, !true);\\n\\n};\\n\\nTHREE.ParametricGeometries.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\\n\\n\\n /*********************************************\\n  *\\n  * Parametric Replacement for PlaneGeometry\\n  *\\n  *********************************************/\\n\\nTHREE.ParametricGeometries.PlaneGeometry = function(width, depth, segmentsWidth, segmentsDepth) {\\n\\n\\tfunction plane(u, v) {\\n\\n\\t\\tvar x = u * width;\\n\\t\\tvar y = 0;\\n\\t\\tvar z = v * depth;\\n\\n\\t\\treturn new THREE.Vector3(x, y, z);\\n\\t}\\n\\n\\tTHREE.ParametricGeometry.call(this, plane, segmentsWidth, segmentsDepth);\\n\\n};\\n\\nTHREE.ParametricGeometries.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Ocean.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Ocean.js\",\n            \"module-type\": \"library\",\n            \"text\": \"ï»¿THREE.Ocean = function (renderer, camera, scene, options) {\\n\\t// flag used to trigger parameter changes\\n\\tthis.changed = true;\\n\\tthis.initial = true;\\n\\t\\n\\t// Assign required parameters as object properties\\n\\tthis.oceanCamera = new THREE.OrthographicCamera(); //camera.clone();\\n\\tthis.oceanCamera.position.z = 1;\\n\\tthis.renderer = renderer;\\n\\tthis.renderer.clearColor( 0xffffff );\\n\\t\\n\\tthis.scene = new THREE.Scene();\\n\\t\\n\\t// Enable necessary extensions\\n\\tthis.renderer.context.getExtension('OES_texture_float');\\n\\tthis.renderer.context.getExtension('OES_texture_float_linear');\\n\\t\\n\\t// Assign optional parameters as variables and object properties\\n\\tfunction optionalParameter(value, defaultValue) {\\n\\t\\treturn value !== undefined ? value : defaultValue;\\n\\t};\\n\\toptions = options || {};\\n\\tthis.clearColor = optionalParameter(options.CLEAR_COLOR, [1.0, 1.0, 1.0, 0.0]);\\n\\tthis.geometryOrigin = optionalParameter(options.GEOMETRY_ORIGIN, [-1000.0, -1000.0]);\\n\\tthis.sunDirectionX = optionalParameter(options.SUN_DIRECTION[0], -1.0);\\n\\tthis.sunDirectionY = optionalParameter(options.SUN_DIRECTION[1], 1.0);\\n\\tthis.sunDirectionZ = optionalParameter(options.SUN_DIRECTION[2], 1.0);\\n\\tthis.oceanColor = optionalParameter(options.OCEAN_COLOR, new THREE.Vector3(0.004, 0.016, 0.047));\\n\\tthis.skyColor = optionalParameter(options.SKY_COLOR, new THREE.Vector3(3.2, 9.6, 12.8));\\n\\tthis.exposure = optionalParameter(options.EXPOSURE, 0.35);\\n\\tthis.geometryResolution = optionalParameter(options.GEOMETRY_RESOLUTION, 32);\\n\\tthis.geometrySize = optionalParameter(options.GEOMETRY_SIZE, 2000);\\n\\tthis.resolution = optionalParameter(options.RESOLUTION, 64);\\n\\tthis.floatSize = optionalParameter(options.SIZE_OF_FLOAT, 4);\\n\\tthis.windX = optionalParameter(options.INITIAL_WIND[0], 10.0),\\n\\tthis.windY = optionalParameter(options.INITIAL_WIND[1], 10.0),\\n\\tthis.size = optionalParameter(options.INITIAL_SIZE, 250.0),\\n\\tthis.choppiness = optionalParameter(options.INITIAL_CHOPPINESS, 1.5);\\n\\t\\n\\t// \\n\\tthis.matrixNeedsUpdate = false;\\n\\t\\n\\t// Setup framebuffer pipeline\\n\\tvar LinearClampParams = {\\n\\t\\tminFilter: THREE.LinearFilter,\\n\\t\\tmagFilter: THREE.LinearFilter,\\n\\t\\twrapS: THREE.ClampToEdgeWrapping,\\n\\t\\twrapT: THREE.ClampToEdgeWrapping,\\n\\t\\tformat: THREE.RGBAFormat,\\n\\t\\tstencilBuffer: false,\\n\\t\\tdepthBuffer: false,\\n\\t\\tpremultiplyAlpha: false,\\n\\t\\ttype: THREE.FloatType\\n\\t};\\n\\tvar NearestClampParams = {\\n\\t\\tminFilter: THREE.NearestFilter,\\n\\t\\tmagFilter: THREE.NearestFilter,\\n\\t\\twrapS: THREE.ClampToEdgeWrapping,\\n\\t\\twrapT: THREE.ClampToEdgeWrapping,\\n\\t\\tformat: THREE.RGBAFormat,\\n\\t\\tstencilBuffer: false,\\n\\t\\tdepthBuffer: false,\\n\\t\\tpremultiplyAlpha:false,\\n\\t\\ttype: THREE.FloatType\\n\\t};\\n\\tvar NearestRepeatParams = {\\n\\t\\tminFilter: THREE.NearestFilter,\\n\\t\\tmagFilter: THREE.NearestFilter,\\n\\t\\twrapS: THREE.RepeatWrapping,\\n\\t\\twrapT: THREE.RepeatWrapping,\\n\\t\\tformat: THREE.RGBAFormat,\\n\\t\\tstencilBuffer: false,\\n\\t\\tdepthBuffer: false,\\n\\t\\tpremultiplyAlpha: false,\\n\\t\\ttype: THREE.FloatType\\n\\t};\\n\\tthis.initialSpectrumFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestRepeatParams);\\n\\tthis.spectrumFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\\n\\tthis.pingPhaseFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\\n\\tthis.pongPhaseFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\\n\\tthis.pingTransformFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\\n\\tthis.pongTransformFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\\n\\tthis.displacementMapFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, LinearClampParams);\\n\\tthis.normalMapFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, LinearClampParams);\\n\\t\\n\\t// Define shaders and constant uniforms\\n\\t////////////////////////////////////////\\n\\t\\n\\t// 0 - The vertex shader used in all of the simulation steps\\n\\tvar fullscreeenVertexShader = THREE.ShaderLib[\\\"ocean_sim_vertex\\\"];\\n\\t\\t\\n\\t// 1 - Horizontal wave vertices used for FFT\\n\\tvar oceanHorizontalShader = THREE.ShaderLib[\\\"ocean_subtransform\\\"];\\n\\tvar oceanHorizontalUniforms = THREE.UniformsUtils.clone(oceanHorizontalShader.uniforms);\\n\\tthis.materialOceanHorizontal = new THREE.ShaderMaterial({\\n\\t\\tuniforms: oceanHorizontalUniforms,\\n\\t\\tvertexShader: fullscreeenVertexShader.vertexShader,\\n\\t\\tfragmentShader: \\\"#define HORIZONTAL \\\\n\\\" + oceanHorizontalShader.fragmentShader\\n\\t});\\n\\tthis.materialOceanHorizontal.uniforms.u_transformSize = { type: \\\"f\\\", value: this.resolution };\\n\\tthis.materialOceanHorizontal.uniforms.u_subtransformSize = { type: \\\"f\\\", value: null };\\n\\tthis.materialOceanHorizontal.uniforms.u_input = { type: \\\"t\\\", value: null };\\n\\tthis.materialOceanHorizontal.depthTest = false;\\n\\t\\n\\t// 2 - Vertical wave vertices used for FFT\\n\\tvar oceanVerticalShader = THREE.ShaderLib[\\\"ocean_subtransform\\\"];\\n\\tvar oceanVerticalUniforms = THREE.UniformsUtils.clone(oceanVerticalShader.uniforms);\\n\\tthis.materialOceanVertical = new THREE.ShaderMaterial({\\n\\t\\tuniforms: oceanVerticalUniforms,\\n\\t\\tvertexShader: fullscreeenVertexShader.vertexShader,\\n\\t\\tfragmentShader: oceanVerticalShader.fragmentShader\\n\\t});\\n\\tthis.materialOceanVertical.uniforms.u_transformSize = { type: \\\"f\\\", value: this.resolution };\\n\\tthis.materialOceanVertical.uniforms.u_subtransformSize = { type: \\\"f\\\", value: null };\\n\\tthis.materialOceanVertical.uniforms.u_input = { type: \\\"t\\\", value: null };\\n\\tthis.materialOceanVertical.depthTest = false;\\n\\t\\n\\t// 3 - Initial spectrum used to generate height map\\n\\tvar initialSpectrumShader = THREE.ShaderLib[\\\"ocean_initial_spectrum\\\"];\\n\\tvar initialSpectrumUniforms = THREE.UniformsUtils.clone(initialSpectrumShader.uniforms);\\n\\tthis.materialInitialSpectrum = new THREE.ShaderMaterial({\\n\\t\\tuniforms: initialSpectrumUniforms,\\n\\t\\tvertexShader: fullscreeenVertexShader.vertexShader,\\n\\t\\tfragmentShader:initialSpectrumShader.fragmentShader\\n\\t});\\n\\tthis.materialInitialSpectrum.uniforms.u_wind = { type: \\\"v2\\\", value: new THREE.Vector2() };\\n\\tthis.materialInitialSpectrum.uniforms.u_resolution = { type: \\\"f\\\", value: this.resolution };\\n\\tthis.materialInitialSpectrum.depthTest = false;\\n\\t\\n\\t// 4 - Phases used to animate heightmap\\n\\tvar phaseShader = THREE.ShaderLib[\\\"ocean_phase\\\"];\\n\\tvar phaseUniforms = THREE.UniformsUtils.clone(phaseShader.uniforms);\\n\\tthis.materialPhase = new THREE.ShaderMaterial({\\n\\t\\tuniforms: phaseUniforms,\\n\\t\\tvertexShader: fullscreeenVertexShader.vertexShader,\\n\\t\\tfragmentShader: phaseShader.fragmentShader\\n\\t});\\n\\tthis.materialPhase.uniforms.u_resolution = { type: \\\"f\\\", value: this.resolution };\\n\\tthis.materialPhase.depthTest = false;\\n\\t\\n\\t// 5 - Shader used to update spectrum\\n\\tvar spectrumShader = THREE.ShaderLib[\\\"ocean_spectrum\\\"];\\n\\tvar spectrumUniforms = THREE.UniformsUtils.clone(spectrumShader.uniforms);\\n\\tthis.materialSpectrum = new THREE.ShaderMaterial({\\n\\t\\tuniforms: spectrumUniforms,\\n\\t\\tvertexShader: fullscreeenVertexShader.vertexShader,\\n\\t\\tfragmentShader: spectrumShader.fragmentShader\\n\\t});\\n\\tthis.materialSpectrum.uniforms.u_initialSpectrum = { type: \\\"t\\\", value: null };\\n\\tthis.materialSpectrum.uniforms.u_resolution = { type: \\\"f\\\", value: this.resolution };\\n\\tthis.materialSpectrum.depthTest = false;\\n\\n\\t// 6 - Shader used to update spectrum normals\\n\\tvar normalShader = THREE.ShaderLib[\\\"ocean_normals\\\"];\\n\\tvar normalUniforms = THREE.UniformsUtils.clone(normalShader.uniforms);\\n\\tthis.materialNormal = new THREE.ShaderMaterial({\\n\\t\\tuniforms: normalUniforms,\\n\\t\\tvertexShader: fullscreeenVertexShader.vertexShader,\\n\\t\\tfragmentShader: normalShader.fragmentShader\\n\\t});\\n\\tthis.materialNormal.uniforms.u_displacementMap = { type: \\\"t\\\", value: null };\\n\\tthis.materialNormal.uniforms.u_resolution = { type: \\\"f\\\", value: this.resolution };\\n\\tthis.materialNormal.depthTest = false;\\n\\n\\t// 7 - Shader used to update normals\\n\\tvar oceanShader = THREE.ShaderLib[\\\"ocean_main\\\"];\\n\\tvar oceanUniforms = THREE.UniformsUtils.clone(oceanShader.uniforms);\\n\\tvar oceanAttributes = THREE.UniformsUtils.clone(oceanShader.attributes);\\n\\tthis.materialOcean = new THREE.ShaderMaterial({\\n\\t\\tattributes: oceanAttributes,\\n\\t\\tuniforms: oceanUniforms,\\n\\t\\tvertexShader: oceanShader.vertexShader,\\n\\t\\tfragmentShader: oceanShader.fragmentShader\\n\\t});\\n\\t// this.materialOcean.wireframe = true;\\n\\tthis.materialOcean.uniforms.u_geometrySize = { type: \\\"f\\\", value: this.resolution };\\n\\tthis.materialOcean.uniforms.u_displacementMap = { type: \\\"t\\\", value: this.displacementMapFramebuffer };\\n\\tthis.materialOcean.uniforms.u_normalMap = { type: \\\"t\\\", value: this.normalMapFramebuffer }; \\n\\tthis.materialOcean.uniforms.u_oceanColor = { type: \\\"v3\\\", value: this.oceanColor }; \\n\\tthis.materialOcean.uniforms.u_skyColor = { type: \\\"v3\\\", value: this.skyColor };\\n\\tthis.materialOcean.uniforms.u_sunDirection = { type: \\\"v3\\\", value: new THREE.Vector3( this.sunDirectionX, this.sunDirectionY, this.sunDirectionZ ) };\\n\\tthis.materialOcean.uniforms.u_exposure = { type: \\\"f\\\", value: this.exposure };\\n\\n\\t// Disable blending to prevent default premultiplied alpha values\\n\\tthis.materialOceanHorizontal.blending = 0;\\n\\tthis.materialOceanVertical.blending = 0;\\n\\tthis.materialInitialSpectrum.blending = 0;\\n\\tthis.materialPhase.blending = 0;\\n\\tthis.materialSpectrum.blending = 0;\\n\\tthis.materialNormal.blending = 0;\\n\\tthis.materialOcean.blending = 0;\\n\\n\\t// Create the simulation plane\\n\\tthis.screenQuad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ) );\\n\\tthis.scene.add(this.screenQuad);\\n\\n\\t// Initialise spectrum data\\n\\tthis.generateSeedPhaseTexture();\\n\\n\\t// Generate the ocean mesh\\n\\tthis.generateMesh();\\n};\\n\\nTHREE.Ocean.prototype.generateMesh = function () {\\n\\n\\tvar geometry = new THREE.PlaneGeometry( this.geometrySize, this.geometrySize, this.geometryResolution, this.geometryResolution );\\n\\n\\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\\n\\n\\tthis.oceanMesh = new THREE.Mesh( geometry, this.materialOcean );\\n};\\n\\nTHREE.Ocean.prototype.render = function () {\\n\\tthis.scene.overrideMaterial = null;\\n\\t\\n\\tif (this.changed)\\n\\t\\tthis.renderInitialSpectrum();\\n\\t\\n\\tthis.renderWavePhase();\\n\\tthis.renderSpectrum();\\n\\tthis.renderSpectrumFFT();\\n\\tthis.renderNormalMap();\\n\\tthis.scene.overrideMaterial = null;\\n};\\n\\nTHREE.Ocean.prototype.generateSeedPhaseTexture = function() {\\n\\t// Setup the seed texture\\n\\tthis.pingPhase = true;\\n\\tvar phaseArray = new window.Float32Array(this.resolution * this.resolution * 4);\\n\\tfor (var i = 0; i < this.resolution; i++) {\\n\\t\\tfor (var j = 0; j < this.resolution; j++) {\\n\\t\\t\\tphaseArray[i * this.resolution * 4 + j * 4] =  Math.random() * 2.0 * Math.PI;\\n\\t\\t\\tphaseArray[i * this.resolution * 4 + j * 4 + 1] = 0.0;\\n\\t\\t\\tphaseArray[i * this.resolution * 4 + j * 4 + 2] = 0.0;\\n\\t\\t\\tphaseArray[i * this.resolution * 4 + j * 4 + 3] = 0.0;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tthis.pingPhaseTexture = new THREE.DataTexture(phaseArray, this.resolution, this.resolution, THREE.RGBAFormat);\\n\\tthis.pingPhaseTexture.minFilter = THREE.NearestFilter;\\n\\tthis.pingPhaseTexture.magFilter = THREE.NearestFilter;\\n\\tthis.pingPhaseTexture.wrapS = THREE.ClampToEdgeWrapping;\\n\\tthis.pingPhaseTexture.wrapT = THREE.ClampToEdgeWrapping;\\n\\tthis.pingPhaseTexture.type = THREE.FloatType;\\n\\tthis.pingPhaseTexture.needsUpdate = true;\\n};\\n\\nTHREE.Ocean.prototype.renderInitialSpectrum = function () {\\n\\tthis.scene.overrideMaterial = this.materialInitialSpectrum;\\n\\tthis.materialInitialSpectrum.uniforms.u_wind.value.set( this.windX, this.windY );\\n\\tthis.materialInitialSpectrum.uniforms.u_size.value = this.size;\\n\\tthis.renderer.render(this.scene, this.oceanCamera, this.initialSpectrumFramebuffer, true);\\n};\\n\\nTHREE.Ocean.prototype.renderWavePhase = function () {\\n\\tthis.scene.overrideMaterial = this.materialPhase;\\n\\tthis.screenQuad.material = this.materialPhase;\\n\\tif (this.initial) {\\n\\t\\tthis.materialPhase.uniforms.u_phases.value = this.pingPhaseTexture;\\n\\t\\tthis.initial = false;\\n\\t}else {\\n\\t\\tthis.materialPhase.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer  : this.pongPhaseFramebuffer;\\n\\t}\\n\\tthis.materialPhase.uniforms.u_deltaTime.value = this.deltaTime;\\n\\tthis.materialPhase.uniforms.u_size.value = this.size;\\n\\tthis.renderer.render(this.scene, this.oceanCamera, this.pingPhase ? this.pongPhaseFramebuffer : this.pingPhaseFramebuffer);\\n\\tthis.pingPhase = !this.pingPhase;\\n};\\n\\nTHREE.Ocean.prototype.renderSpectrum = function () {\\n\\tthis.scene.overrideMaterial = this.materialSpectrum;\\n\\tthis.materialSpectrum.uniforms.u_initialSpectrum.value = this.initialSpectrumFramebuffer;\\n\\tthis.materialSpectrum.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer : this.pongPhaseFramebuffer;\\n\\tthis.materialSpectrum.uniforms.u_choppiness.value = this.choppiness ;\\n\\tthis.materialSpectrum.uniforms.u_size.value = this.size ;\\n\\tthis.renderer.render(this.scene, this.oceanCamera, this.spectrumFramebuffer);\\n};\\n\\nTHREE.Ocean.prototype.renderSpectrumFFT = function() {\\n\\t// GPU FFT using Stockham formulation\\n\\tvar iterations = Math.log( this.resolution ) / Math.log(2); // log2\\n\\t\\n\\tthis.scene.overrideMaterial = this.materialOceanHorizontal;\\n\\n\\tfor (var i = 0; i < iterations; i++) {\\n\\t\\tif (i === 0) {\\n\\t\\t\\tthis.materialOceanHorizontal.uniforms.u_input.value = this.spectrumFramebuffer;\\n\\t\\t\\tthis.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow(2, (i % (iterations)) + 1);\\n\\t\\t\\tthis.renderer.render(this.scene, this.oceanCamera, this.pingTransformFramebuffer);\\n\\t\\t} \\n\\t\\telse if (i % 2 === 1) {\\n\\t\\t\\tthis.materialOceanHorizontal.uniforms.u_input.value = this.pingTransformFramebuffer;\\n\\t\\t\\tthis.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow(2, (i % (iterations)) + 1);\\n\\t\\t\\tthis.renderer.render(this.scene, this.oceanCamera, this.pongTransformFramebuffer);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.materialOceanHorizontal.uniforms.u_input.value = this.pongTransformFramebuffer;\\n\\t\\t\\tthis.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow(2, (i % (iterations)) + 1);\\n\\t\\t\\tthis.renderer.render(this.scene, this.oceanCamera, this.pingTransformFramebuffer);\\n\\t\\t}\\n\\t}\\n\\tthis.scene.overrideMaterial = this.materialOceanVertical;\\n\\tfor (var i = iterations; i < iterations*2; i++) {\\n\\t\\tif (i === iterations * 2 - 1) {\\n\\t\\t\\tthis.materialOceanVertical.uniforms.u_input.value = (iterations % 2 === 0) ? this.pingTransformFramebuffer : this.pongTransformFramebuffer;\\n\\t\\t\\tthis.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow(2, (i % (iterations)) + 1);\\n\\t\\t\\tthis.renderer.render(this.scene, this.oceanCamera, this.displacementMapFramebuffer);\\n\\t\\t}\\n\\t\\telse if (i % 2 === 1) {\\n\\t\\t\\tthis.materialOceanVertical.uniforms.u_input.value = this.pingTransformFramebuffer;\\n\\t\\t\\tthis.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow(2, (i % (iterations)) + 1);\\n\\t\\t\\tthis.renderer.render(this.scene, this.oceanCamera, this.pongTransformFramebuffer);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.materialOceanVertical.uniforms.u_input.value = this.pongTransformFramebuffer;\\n\\t\\t\\tthis.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow(2, (i % (iterations)) + 1);\\n\\t\\t\\tthis.renderer.render(this.scene, this.oceanCamera, this.pingTransformFramebuffer);\\n\\t\\t}\\n\\t}\\n};\\n\\nTHREE.Ocean.prototype.renderNormalMap = function () {\\n\\tthis.scene.overrideMaterial = this.materialNormal;\\n\\tif (this.changed) this.materialNormal.uniforms.u_size.value = this.size;\\n\\tthis.materialNormal.uniforms.u_displacementMap.value = this.displacementMapFramebuffer;\\n\\tthis.renderer.render(this.scene, this.oceanCamera, this.normalMapFramebuffer, true);\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/BlendShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/BlendShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Blend two textures\\n */\\n\\nTHREE.BlendShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse1\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"tDiffuse2\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"mixRatio\\\":  { type: \\\"f\\\", value: 0.5 },\\n\\t\\t\\\"opacity\\\":   { type: \\\"f\\\", value: 1.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float opacity;\\\",\\n\\t\\t\\\"uniform float mixRatio;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse1;\\\",\\n\\t\\t\\\"uniform sampler2D tDiffuse2;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 texel1 = texture2D( tDiffuse1, vUv );\\\",\\n\\t\\t\\t\\\"vec4 texel2 = texture2D( tDiffuse2, vUv );\\\",\\n\\t\\t\\t\\\"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/RGBShiftShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/RGBShiftShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author felixturner / http://airtight.cc/\\n *\\n * RGB Shift Shader\\n * Shifts red and blue channels from center in opposite directions\\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\\n * by Tom Butterworth / http://kriss.cx/tom/\\n *\\n * amount: shift distance (1 is width of input)\\n * angle: shift angle in radians\\n */\\n\\nTHREE.RGBShiftShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"amount\\\":   { type: \\\"f\\\", value: 0.005 },\\n\\t\\t\\\"angle\\\":    { type: \\\"f\\\", value: 0.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform float amount;\\\",\\n\\t\\t\\\"uniform float angle;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec2 offset = amount * vec2( cos(angle), sin(angle));\\\",\\n\\t\\t\\t\\\"vec4 cr = texture2D(tDiffuse, vUv + offset);\\\",\\n\\t\\t\\t\\\"vec4 cga = texture2D(tDiffuse, vUv);\\\",\\n\\t\\t\\t\\\"vec4 cb = texture2D(tDiffuse, vUv - offset);\\\",\\n\\t\\t\\t\\\"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/OceanShaders.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/OceanShaders.js\",\n            \"module-type\": \"library\",\n            \"text\": \"ï»¿// Author: Aleksandr Albert\\n// Website: www.routter.co.tt\\n\\n// Description: A deep water ocean shader set\\n// based on an implementation of a Tessendorf Waves\\n// originally presented by David Li ( www.david.li/waves )\\n\\n// The general method is to apply shaders to simulation Framebuffers\\n// and then sample these framebuffers when rendering the ocean mesh\\n\\n// The set uses 7 shaders:\\n\\n// -- Simulation shaders\\n// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)\\n// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)\\n// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate\\n// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate\\n// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate\\n// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate\\n\\n// -- Rendering Shader\\n// [7] ocean_main               -> Vertex and Fragment shader used to create the final render\\n\\n\\nTHREE.ShaderLib['ocean_sim_vertex'] = {\\n\\tvarying: {\\n\\t\\t\\\"vUV\\\": { type: \\\"v2\\\" }\\n\\t},\\n\\tvertexShader: [\\n\\t\\t'varying vec2 vUV;',\\n\\n\\t\\t'void main (void) {',\\n\\t\\t\\t'vUV = position.xy * 0.5 + 0.5;',\\n\\t\\t\\t'gl_Position = vec4(position, 1.0 );',\\n\\t\\t'}'\\n\\t].join('\\\\n')\\n};\\nTHREE.ShaderLib['ocean_subtransform'] = {\\n\\tuniforms: {\\n\\t\\t\\\"u_input\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"u_transformSize\\\": { type: \\\"f\\\", value: 512.0 },\\n\\t\\t\\\"u_subtransformSize\\\": { type: \\\"f\\\", value: 250.0 }\\n\\t},\\n\\tvarying: {\\n\\t\\t\\\"vUV\\\": { type: \\\"v2\\\" }\\n\\t},\\n\\tfragmentShader: [\\n\\t\\t//GPU FFT using a Stockham formulation\\n\\t\\t'precision highp float;',\\n\\n\\t\\t'const float PI = 3.14159265359;',\\n\\n\\t\\t'uniform sampler2D u_input;',\\n\\t\\t'uniform float u_transformSize;',\\n\\t\\t'uniform float u_subtransformSize;',\\n\\n\\t\\t'varying vec2 vUV;',\\n\\t\\t\\n\\t\\t'vec2 multiplyComplex (vec2 a, vec2 b) {',\\n\\t\\t\\t'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',\\n\\t\\t'}',\\n\\n\\t\\t'void main (void) {',\\n\\t\\t\\t'#ifdef HORIZONTAL',\\n\\t\\t\\t'float index = vUV.x * u_transformSize - 0.5;',\\n\\t\\t\\t'#else',\\n\\t\\t\\t'float index = vUV.y * u_transformSize - 0.5;',\\n\\t\\t\\t'#endif',\\n\\n\\t\\t\\t'float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);',\\n\\n\\t\\t\\t//transform two complex sequences simultaneously\\n\\t\\t\\t'#ifdef HORIZONTAL',\\n\\t\\t\\t'vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',\\n\\t\\t\\t'vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',\\n\\t\\t\\t'#else',\\n\\t\\t\\t'vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;',\\n\\t\\t\\t'vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;',\\n\\t\\t\\t'#endif',\\n\\n\\t\\t\\t'float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);',\\n\\t\\t\\t'vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));',\\n\\n\\t\\t\\t'vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);',\\n\\t\\t\\t'vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);',\\n\\n\\t\\t\\t'gl_FragColor = vec4(outputA, outputB);',\\n\\t\\t'}'\\n\\t].join('\\\\n')\\n};\\nTHREE.ShaderLib['ocean_initial_spectrum'] = {\\n\\tuniforms: {\\n\\t\\t\\\"u_wind\\\": { type: \\\"v2\\\", value: new THREE.Vector2(10.0, 10.0) },\\n\\t\\t\\\"u_resolution\\\": { type: \\\"f\\\", value: 512.0 },\\n\\t\\t\\\"u_size\\\": { type: \\\"f\\\", value: 250.0 },\\n\\t},\\n\\tfragmentShader: [\\n\\t\\t'precision highp float;',\\n\\n\\t\\t'const float PI = 3.14159265359;',\\n\\t\\t'const float G = 9.81;',\\n\\t\\t'const float KM = 370.0;',\\n\\t\\t'const float CM = 0.23;',\\n\\n\\t\\t'uniform vec2 u_wind;',\\n\\t\\t'uniform float u_resolution;',\\n\\t\\t'uniform float u_size;',\\n\\t\\t\\n\\t\\t'float square (float x) {',\\n\\t\\t\\t'return x * x;',\\n\\t\\t'}',\\n\\n\\t\\t'float omega (float k) {',\\n\\t\\t\\t'return sqrt(G * k * (1.0 + square(k / KM)));',\\n\\t\\t'}',\\n\\n\\t\\t'float tanh (float x) {',\\n\\t\\t\\t'return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));',\\n\\t\\t'}',\\n\\n\\t\\t'void main (void) {',\\n\\t\\t\\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\\n\\t\\t\\t\\n\\t\\t\\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\\n\\t\\t\\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\\n\\t\\t\\t\\n\\t\\t\\t'vec2 K = (2.0 * PI * vec2(n, m)) / u_size;',\\n\\t\\t\\t'float k = length(K);',\\n\\t\\t\\t\\n\\t\\t\\t'float l_wind = length(u_wind);',\\n\\n\\t\\t\\t'float Omega = 0.84;',\\n\\t\\t\\t'float kp = G * square(Omega / l_wind);',\\n\\n\\t\\t\\t'float c = omega(k) / k;',\\n\\t\\t\\t'float cp = omega(kp) / kp;',\\n\\n\\t\\t\\t'float Lpm = exp(-1.25 * square(kp / k));',\\n\\t\\t\\t'float gamma = 1.7;',\\n\\t\\t\\t'float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));',\\n\\t\\t\\t'float Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));',\\n\\t\\t\\t'float Jp = pow(gamma, Gamma);',\\n\\t\\t\\t'float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));',\\n\\t\\t\\t'float alphap = 0.006 * sqrt(Omega);',\\n\\t\\t\\t'float Bl = 0.5 * alphap * cp / c * Fp;',\\n\\n\\t\\t\\t'float z0 = 0.000037 * square(l_wind) / G * pow(l_wind / cp, 0.9);',\\n\\t\\t\\t'float uStar = 0.41 * l_wind / log(10.0 / z0);',\\n\\t\\t\\t'float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));',\\n\\t\\t\\t'float Fm = exp(-0.25 * square(k / KM - 1.0));',\\n\\t\\t\\t'float Bh = 0.5 * alpham * CM / c * Fm * Lpm;',\\n\\n\\t\\t\\t'float a0 = log(2.0) / 4.0;',\\n\\t\\t\\t'float am = 0.13 * uStar / CM;',\\n\\t\\t\\t'float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));',\\n\\n\\t\\t\\t'float cosPhi = dot(normalize(u_wind), normalize(K));',\\n\\n\\t\\t\\t'float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));',\\n\\n\\t\\t\\t'float dk = 2.0 * PI / u_size;',\\n\\t\\t\\t'float h = sqrt(S / 2.0) * dk;',\\n\\n\\t\\t\\t'if (K.x == 0.0 && K.y == 0.0) {',\\n\\t\\t\\t\\t'h = 0.0;', //no DC term\\n\\t\\t\\t'}',\\n\\t\\t\\t'gl_FragColor = vec4(h, 0.0, 0.0, 0.0);',\\n\\t\\t'}'\\n\\t].join('\\\\n')\\n};\\nTHREE.ShaderLib['ocean_phase'] = {\\n\\tuniforms: {\\n\\t\\t\\\"u_phases\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"u_deltaTime\\\": { type: \\\"f\\\", value: null },\\n\\t\\t\\\"u_resolution\\\": { type: \\\"f\\\", value: null },\\n\\t\\t\\\"u_size\\\": { type: \\\"f\\\", value: null },\\n\\t},\\n\\tvarying: {\\n\\t\\t\\\"vUV\\\": { type: \\\"v2\\\" }\\n\\t},\\n\\tfragmentShader: [\\n\\t\\t'precision highp float;',\\n\\n\\t\\t'const float PI = 3.14159265359;',\\n\\t\\t'const float G = 9.81;',\\n\\t\\t'const float KM = 370.0;',\\n\\n\\t\\t'varying vec2 vUV;',\\n\\n\\t\\t'uniform sampler2D u_phases;',\\n\\t\\t'uniform float u_deltaTime;',\\n\\t\\t'uniform float u_resolution;',\\n\\t\\t'uniform float u_size;',\\n\\n\\t\\t'float omega (float k) {',\\n\\t\\t\\t'return sqrt(G * k * (1.0 + k * k / KM * KM));',\\n\\t\\t'}',\\n\\n\\t\\t'void main (void) {',\\n\\t\\t\\t'float deltaTime = 1.0 / 60.0;',\\n\\t\\t\\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\\n\\t\\t\\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\\n\\t\\t\\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\\n\\t\\t\\t'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',\\n\\n\\t\\t\\t'float phase = texture2D(u_phases, vUV).r;',\\n\\t\\t\\t'float deltaPhase = omega(length(waveVector)) * u_deltaTime;',\\n\\t\\t\\t'phase = mod(phase + deltaPhase, 2.0 * PI);',\\n\\t\\t\\n\\t\\t\\t'gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);',\\n\\t\\t'}'\\n\\t].join('\\\\n')\\n};\\nTHREE.ShaderLib['ocean_spectrum'] = {\\n\\tuniforms: {\\n\\t\\t\\\"u_size\\\": { type: \\\"f\\\", value: null },\\n\\t\\t\\\"u_resolution\\\": { type: \\\"f\\\", value: null },\\n\\t\\t\\\"u_choppiness\\\": { type: \\\"f\\\", value: null },\\n\\t\\t\\\"u_phases\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"u_initialSpectrum\\\": { type: \\\"t\\\", value: null },\\n\\t},\\n\\tvarying: {\\n\\t\\t\\\"vUV\\\": { type: \\\"v2\\\" }\\n\\t},\\n\\tfragmentShader: [\\n\\t\\t'precision highp float;',\\n\\n\\t\\t'const float PI = 3.14159265359;',\\n\\t\\t'const float G = 9.81;',\\n\\t\\t'const float KM = 370.0;',\\n\\n\\t\\t'varying vec2 vUV;',\\n\\n\\t\\t'uniform float u_size;',\\n\\t\\t'uniform float u_resolution;',\\n\\t\\t'uniform float u_choppiness;',\\n\\t\\t'uniform sampler2D u_phases;',\\n\\t\\t'uniform sampler2D u_initialSpectrum;',\\n\\n\\t\\t'vec2 multiplyComplex (vec2 a, vec2 b) {',\\n\\t\\t\\t'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',\\n\\t\\t'}',\\n\\n\\t\\t'vec2 multiplyByI (vec2 z) {',\\n\\t\\t\\t'return vec2(-z[1], z[0]);',\\n\\t\\t'}',\\n\\n\\t\\t'float omega (float k) {',\\n\\t\\t\\t'return sqrt(G * k * (1.0 + k * k / KM * KM));',\\n\\t\\t'}',\\n\\n\\t\\t'void main (void) {',\\n\\t\\t\\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\\n\\t\\t\\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\\n\\t\\t\\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\\n\\t\\t\\t'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',\\n\\n\\t\\t\\t'float phase = texture2D(u_phases, vUV).r;',\\n\\t\\t\\t'vec2 phaseVector = vec2(cos(phase), sin(phase));',\\n\\n\\t\\t\\t'vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;',\\n\\t\\t\\t'vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;',\\n\\t\\t\\t'h0Star.y *= -1.0;',\\n\\n\\t\\t\\t'vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));',\\n\\n\\t\\t\\t'vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;',\\n\\t\\t\\t'vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;',\\n\\n\\t\\t\\t//no DC term\\n\\t\\t\\t'if (waveVector.x == 0.0 && waveVector.y == 0.0) {',\\n\\t\\t\\t\\t'h = vec2(0.0);',\\n\\t\\t\\t\\t'hX = vec2(0.0);',\\n\\t\\t\\t\\t'hZ = vec2(0.0);',\\n\\t\\t\\t'}',\\n\\t\\t\\n\\t\\t\\t'gl_FragColor = vec4(hX + multiplyByI(h), hZ);',\\n\\t\\t'}'\\n\\t].join('\\\\n')\\n};\\nTHREE.ShaderLib['ocean_normals'] = {\\n\\tuniforms: {\\n\\t\\t\\\"u_displacementMap\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"u_resolution\\\": { type: \\\"f\\\", value: null },\\n\\t\\t\\\"u_size\\\": { type: \\\"f\\\", value: null },\\n\\t},\\n\\tvarying: {\\n\\t\\t\\\"vUV\\\": { type: \\\"v2\\\" }\\n\\t},\\n\\tfragmentShader: [\\n\\t\\t'precision highp float;',\\n\\n\\t\\t'varying vec2 vUV;',\\n\\t\\t\\n\\t\\t'uniform sampler2D u_displacementMap;',\\n\\t\\t'uniform float u_resolution;',\\n\\t\\t'uniform float u_size;',\\n\\n\\t\\t'void main (void) {',\\n\\t\\t\\t'float texel = 1.0 / u_resolution;',\\n\\t\\t\\t'float texelSize = u_size / u_resolution;',\\n\\n\\t\\t\\t'vec3 center = texture2D(u_displacementMap, vUV).rgb;',\\n\\t\\t\\t'vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;',\\n\\t\\t\\t'vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;',\\n\\t\\t\\t'vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;',\\n\\t\\t\\t'vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;',\\n\\n\\t\\t\\t'vec3 topRight = cross(right, top);',\\n\\t\\t\\t'vec3 topLeft = cross(top, left);',\\n\\t\\t\\t'vec3 bottomLeft = cross(left, bottom);',\\n\\t\\t\\t'vec3 bottomRight = cross(bottom, right);',\\n\\t\\t\\n\\t\\t\\t'gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);',\\n\\t\\t'}'\\n\\t].join('\\\\n')\\n};\\nTHREE.ShaderLib['ocean_main'] = {\\n\\tuniforms: {\\n\\t\\t\\\"u_displacementMap\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"u_normalMap\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"u_geometrySize\\\": { type: \\\"f\\\", value: null },\\n\\t\\t\\\"u_size\\\": { type: \\\"f\\\", value: null },\\n\\t\\t\\\"u_projectionMatrix\\\": { type: \\\"m4\\\", value: null },\\n\\t\\t\\\"u_viewMatrix\\\": { type: \\\"m4\\\", value: null },\\n\\t\\t\\\"u_cameraPosition\\\": { type: \\\"v3\\\", value: null },\\n\\t\\t\\\"u_skyColor\\\": { type: \\\"v3\\\", value: null },\\n\\t\\t\\\"u_oceanColor\\\": { type: \\\"v3\\\", value: null },\\n\\t\\t\\\"u_sunDirection\\\": { type: \\\"v3\\\", value: null },\\n\\t\\t\\\"u_exposure\\\": { type: \\\"f\\\", value: null },\\n\\t},\\n\\tvarying: {\\n\\t\\t\\\"vPos\\\": { type: \\\"v3\\\" },\\n\\t\\t\\\"vUV\\\": { type: \\\"v2\\\" }\\n\\t},\\n\\tvertexShader: [\\n\\t\\t'precision highp float;',\\n\\t\\t\\n\\t\\t'varying vec3 vPos;',\\n\\t\\t'varying vec2 vUV;',\\n\\n\\t\\t'uniform mat4 u_projectionMatrix;',\\n\\t\\t'uniform mat4 u_viewMatrix;',\\n\\t\\t'uniform float u_size;',\\n\\t\\t'uniform float u_geometrySize;',\\n\\t\\t'uniform sampler2D u_displacementMap;',\\n\\n\\t\\t'void main (void) {',\\n\\t\\t\\t'vec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);',\\n\\t\\t\\t'vPos = newPos;',\\n\\t\\t\\t'vUV = uv;',\\n\\t\\t\\t'gl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);',\\n\\t\\t'}'\\n\\t].join('\\\\n'),\\n\\tfragmentShader: [\\n\\t\\t'precision highp float;',\\n\\n\\t\\t'varying vec3 vPos;',\\n\\t\\t'varying vec2 vUV;',\\n\\n\\t\\t'uniform sampler2D u_displacementMap;',\\n\\t\\t'uniform sampler2D u_normalMap;',\\n\\t\\t'uniform vec3 u_cameraPosition;',\\n\\t\\t'uniform vec3 u_oceanColor;',\\n\\t\\t'uniform vec3 u_skyColor;',\\n\\t\\t'uniform vec3 u_sunDirection;',\\n\\t\\t'uniform float u_exposure;',\\n\\n\\t\\t'vec3 hdr (vec3 color, float exposure) {',\\n\\t\\t\\t'return 1.0 - exp(-color * exposure);',\\n\\t\\t'}',\\n\\n\\t\\t'void main (void) {',\\n\\t\\t\\t'vec3 normal = texture2D(u_normalMap, vUV).rgb;',\\n\\n\\t\\t\\t'vec3 view = normalize(u_cameraPosition - vPos);',\\n\\t\\t\\t'float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);',\\n\\t\\t\\t'vec3 sky = fresnel * u_skyColor;',\\n\\n\\t\\t\\t'float diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);',\\n\\t\\t\\t'vec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;',\\n\\n\\t\\t\\t'vec3 color = sky + water;',\\n\\n\\t\\t\\t'gl_FragColor = vec4(hdr(color, u_exposure), 1.0);',\\n\\t\\t'}'\\n\\t].join('\\\\n')\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/BokehShader2.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/BokehShader2.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\\n *\\n * Depth-of-field shader with bokeh\\n * ported from GLSL shader by Martins Upitis\\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\\n *\\n * Requires #define RINGS and SAMPLES integers\\n */\\n\\n\\n\\nTHREE.BokehShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"textureWidth\\\":  { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\\"textureHeight\\\":  { type: \\\"f\\\", value: 1.0 },\\n\\n\\t\\t\\\"focalDepth\\\":   { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\\"focalLength\\\":   { type: \\\"f\\\", value: 24.0 },\\n\\t\\t\\\"fstop\\\": { type: \\\"f\\\", value: 0.9 },\\n\\n\\t\\t\\\"tColor\\\":   { type: \\\"t\\\", value: null },\\n\\t\\t\\\"tDepth\\\":   { type: \\\"t\\\", value: null },\\n\\n\\t\\t\\\"maxblur\\\":  { type: \\\"f\\\", value: 1.0 },\\n\\n\\t\\t\\\"showFocus\\\":   { type: \\\"i\\\", value: 0 },\\n\\t\\t\\\"manualdof\\\":   { type: \\\"i\\\", value: 0 },\\n\\t\\t\\\"vignetting\\\":   { type: \\\"i\\\", value: 0 },\\n\\t\\t\\\"depthblur\\\":   { type: \\\"i\\\", value: 0 },\\n\\n\\t\\t\\\"threshold\\\":  { type: \\\"f\\\", value: 0.5 },\\n\\t\\t\\\"gain\\\":  { type: \\\"f\\\", value: 2.0 },\\n\\t\\t\\\"bias\\\":  { type: \\\"f\\\", value: 0.5 },\\n\\t\\t\\\"fringe\\\":  { type: \\\"f\\\", value: 0.7 },\\n\\n\\t\\t\\\"znear\\\":  { type: \\\"f\\\", value: 0.1 },\\n\\t\\t\\\"zfar\\\":  { type: \\\"f\\\", value: 100 },\\n\\n\\t\\t\\\"noise\\\":  { type: \\\"i\\\", value: 1 },\\n\\t\\t\\\"dithering\\\":  { type: \\\"f\\\", value: 0.0001 },\\n\\t\\t\\\"pentagon\\\": { type: \\\"i\\\", value: 0 },\\n\\n\\t\\t\\\"shaderFocus\\\":  { type: \\\"i\\\", value: 1 },\\n\\t\\t\\\"focusCoords\\\":  { type: \\\"v2\\\", value: new THREE.Vector2()},\\n\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tColor;\\\",\\n\\t\\t\\\"uniform sampler2D tDepth;\\\",\\n\\t\\t\\\"uniform float textureWidth;\\\",\\n\\t\\t\\\"uniform float textureHeight;\\\",\\n\\n\\t\\t\\\"const float PI = 3.14159265;\\\",\\n\\n\\t\\t\\\"float width = textureWidth; //texture width\\\",\\n\\t\\t\\\"float height = textureHeight; //texture height\\\",\\n\\n\\t\\t\\\"vec2 texel = vec2(1.0/width,1.0/height);\\\",\\n\\n\\t\\t\\\"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\\\",\\n\\t\\t\\\"uniform float focalLength; //focal length in mm\\\",\\n\\t\\t\\\"uniform float fstop; //f-stop value\\\",\\n\\t\\t\\\"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\\\",\\n\\n\\t\\t\\\"/*\\\",\\n\\t\\t\\\"make sure that these two values are the same for your camera, otherwise distances will be wrong.\\\",\\n\\t\\t\\\"*/\\\",\\n\\n\\t\\t\\\"uniform float znear; // camera clipping start\\\",\\n\\t\\t\\\"uniform float zfar; // camera clipping end\\\",\\n\\n\\t\\t\\\"//------------------------------------------\\\",\\n\\t\\t\\\"//user variables\\\",\\n\\n\\t\\t\\\"const int samples = SAMPLES; //samples on the first ring\\\",\\n\\t\\t\\\"const int rings = RINGS; //ring count\\\",\\n\\n\\t\\t\\\"const int maxringsamples = rings * samples;\\\",\\n\\n\\t\\t\\\"uniform bool manualdof; // manual dof calculation\\\",\\n\\t\\t\\\"float ndofstart = 1.0; // near dof blur start\\\",\\n\\t\\t\\\"float ndofdist = 2.0; // near dof blur falloff distance\\\",\\n\\t\\t\\\"float fdofstart = 1.0; // far dof blur start\\\",\\n\\t\\t\\\"float fdofdist = 3.0; // far dof blur falloff distance\\\",\\n\\n\\t\\t\\\"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\\\",\\n\\n\\t\\t\\\"uniform bool vignetting; // use optical lens vignetting\\\",\\n\\n\\t\\t\\\"float vignout = 1.3; // vignetting outer border\\\",\\n\\t\\t\\\"float vignin = 0.0; // vignetting inner border\\\",\\n\\t\\t\\\"float vignfade = 22.0; // f-stops till vignete fades\\\",\\n\\n\\t\\t\\\"uniform bool shaderFocus;\\\",\\n\\n\\t\\t\\\"bool autofocus = shaderFocus;\\\",\\n\\t\\t\\\"//use autofocus in shader - use with focusCoords\\\",\\n\\t\\t\\\"// disable if you use external focalDepth value\\\",\\n\\n\\t\\t\\\"uniform vec2 focusCoords;\\\",\\n\\t\\t\\\"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\\\",\\n\\t\\t\\\"// if center of screen use vec2(0.5, 0.5);\\\",\\n\\n\\t\\t\\\"uniform float maxblur;\\\",\\n\\t\\t\\\"//clamp value of max blur (0.0 = no blur, 1.0 default)\\\",\\n\\n\\t\\t\\\"uniform float threshold; // highlight threshold;\\\",\\n\\t\\t\\\"uniform float gain; // highlight gain;\\\",\\n\\n\\t\\t\\\"uniform float bias; // bokeh edge bias\\\",\\n\\t\\t\\\"uniform float fringe; // bokeh chromatic aberration / fringing\\\",\\n\\n\\t\\t\\\"uniform bool noise; //use noise instead of pattern for sample dithering\\\",\\n\\n\\t\\t\\\"uniform float dithering;\\\",\\n\\t\\t\\\"float namount = dithering; //dither amount\\\",\\n\\n\\t\\t\\\"uniform bool depthblur; // blur the depth buffer\\\",\\n\\t\\t\\\"float dbsize = 1.25; // depth blur size\\\",\\n\\n\\t\\t\\\"/*\\\",\\n\\t\\t\\\"next part is experimental\\\",\\n\\t\\t\\\"not looking good with small sample and ring count\\\",\\n\\t\\t\\\"looks okay starting from samples = 4, rings = 4\\\",\\n\\t\\t\\\"*/\\\",\\n\\n\\t\\t\\\"uniform bool pentagon; //use pentagon as bokeh shape?\\\",\\n\\t\\t\\\"float feather = 0.4; //pentagon shape feather\\\",\\n\\n\\t\\t\\\"//------------------------------------------\\\",\\n\\n\\t\\t\\\"float penta(vec2 coords) {\\\",\\n\\t\\t\\t\\\"//pentagonal shape\\\",\\n\\t\\t\\t\\\"float scale = float(rings) - 1.3;\\\",\\n\\t\\t\\t\\\"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\\\",\\n\\t\\t\\t\\\"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\\\",\\n\\t\\t\\t\\\"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\\\",\\n\\t\\t\\t\\\"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\\\",\\n\\t\\t\\t\\\"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\\\",\\n\\t\\t\\t\\\"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\\\",\\n\\n\\t\\t\\t\\\"vec4  one = vec4( 1.0 );\\\",\\n\\n\\t\\t\\t\\\"vec4 P = vec4((coords),vec2(scale, scale));\\\",\\n\\n\\t\\t\\t\\\"vec4 dist = vec4(0.0);\\\",\\n\\t\\t\\t\\\"float inorout = -4.0;\\\",\\n\\n\\t\\t\\t\\\"dist.x = dot( P, HS0 );\\\",\\n\\t\\t\\t\\\"dist.y = dot( P, HS1 );\\\",\\n\\t\\t\\t\\\"dist.z = dot( P, HS2 );\\\",\\n\\t\\t\\t\\\"dist.w = dot( P, HS3 );\\\",\\n\\n\\t\\t\\t\\\"dist = smoothstep( -feather, feather, dist );\\\",\\n\\n\\t\\t\\t\\\"inorout += dot( dist, one );\\\",\\n\\n\\t\\t\\t\\\"dist.x = dot( P, HS4 );\\\",\\n\\t\\t\\t\\\"dist.y = HS5.w - abs( P.z );\\\",\\n\\n\\t\\t\\t\\\"dist = smoothstep( -feather, feather, dist );\\\",\\n\\t\\t\\t\\\"inorout += dist.x;\\\",\\n\\n\\t\\t\\t\\\"return clamp( inorout, 0.0, 1.0 );\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"float bdepth(vec2 coords) {\\\",\\n\\t\\t\\t\\\"// Depth buffer blur\\\",\\n\\t\\t\\t\\\"float d = 0.0;\\\",\\n\\t\\t\\t\\\"float kernel[9];\\\",\\n\\t\\t\\t\\\"vec2 offset[9];\\\",\\n\\n\\t\\t\\t\\\"vec2 wh = vec2(texel.x, texel.y) * dbsize;\\\",\\n\\n\\t\\t\\t\\\"offset[0] = vec2(-wh.x,-wh.y);\\\",\\n\\t\\t\\t\\\"offset[1] = vec2( 0.0, -wh.y);\\\",\\n\\t\\t\\t\\\"offset[2] = vec2( wh.x -wh.y);\\\",\\n\\n\\t\\t\\t\\\"offset[3] = vec2(-wh.x,  0.0);\\\",\\n\\t\\t\\t\\\"offset[4] = vec2( 0.0,   0.0);\\\",\\n\\t\\t\\t\\\"offset[5] = vec2( wh.x,  0.0);\\\",\\n\\n\\t\\t\\t\\\"offset[6] = vec2(-wh.x, wh.y);\\\",\\n\\t\\t\\t\\\"offset[7] = vec2( 0.0,  wh.y);\\\",\\n\\t\\t\\t\\\"offset[8] = vec2( wh.x, wh.y);\\\",\\n\\n\\t\\t\\t\\\"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\\\",\\n\\t\\t\\t\\\"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\\\",\\n\\t\\t\\t\\\"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\\\",\\n\\n\\n\\t\\t\\t\\\"for( int i=0; i<9; i++ ) {\\\",\\n\\t\\t\\t\\t\\\"float tmp = texture2D(tDepth, coords + offset[i]).r;\\\",\\n\\t\\t\\t\\t\\\"d += tmp * kernel[i];\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"return d;\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\n\\t\\t\\\"vec3 color(vec2 coords,float blur) {\\\",\\n\\t\\t\\t\\\"//processing the sample\\\",\\n\\n\\t\\t\\t\\\"vec3 col = vec3(0.0);\\\",\\n\\n\\t\\t\\t\\\"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\\\",\\n\\t\\t\\t\\\"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\\\",\\n\\t\\t\\t\\\"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\\\",\\n\\n\\t\\t\\t\\\"vec3 lumcoeff = vec3(0.299,0.587,0.114);\\\",\\n\\t\\t\\t\\\"float lum = dot(col.rgb, lumcoeff);\\\",\\n\\t\\t\\t\\\"float thresh = max((lum-threshold)*gain, 0.0);\\\",\\n\\t\\t\\t\\\"return col+mix(vec3(0.0),col,thresh*blur);\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"vec2 rand(vec2 coord) {\\\",\\n\\t\\t\\t\\\"// generating noise / pattern texture for dithering\\\",\\n\\n\\t\\t\\t\\\"float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;\\\",\\n\\t\\t\\t\\\"float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;\\\",\\n\\n\\t\\t\\t\\\"if (noise) {\\\",\\n\\t\\t\\t\\t\\\"noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\\\",\\n\\t\\t\\t\\t\\\"noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"return vec2(noiseX,noiseY);\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"vec3 debugFocus(vec3 col, float blur, float depth) {\\\",\\n\\t\\t\\t\\\"float edge = 0.002*depth; //distance based edge smoothing\\\",\\n\\t\\t\\t\\\"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\\\",\\n\\t\\t\\t\\\"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\\\",\\n\\n\\t\\t\\t\\\"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\\\",\\n\\t\\t\\t\\\"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\\\",\\n\\n\\t\\t\\t\\\"return col;\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"float linearize(float depth) {\\\",\\n\\t\\t\\t\\\"return -zfar * znear / (depth * (zfar - znear) - zfar);\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\n\\t\\t\\\"float vignette() {\\\",\\n\\t\\t\\t\\\"float dist = distance(vUv.xy, vec2(0.5,0.5));\\\",\\n\\t\\t\\t\\\"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\\\",\\n\\t\\t\\t\\\"return clamp(dist,0.0,1.0);\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\\\",\\n\\t\\t\\t\\\"float rings2 = float(rings);\\\",\\n\\t\\t\\t\\\"float step = PI*2.0 / float(ringsamples);\\\",\\n\\t\\t\\t\\\"float pw = cos(j*step)*i;\\\",\\n\\t\\t\\t\\\"float ph = sin(j*step)*i;\\\",\\n\\t\\t\\t\\\"float p = 1.0;\\\",\\n\\t\\t\\t\\\"if (pentagon) {\\\",\\n\\t\\t\\t\\t\\\"p = penta(vec2(pw,ph));\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\\"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\\\",\\n\\t\\t\\t\\\"return 1.0 * mix(1.0, i /rings2, bias) * p;\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\t\\t\\t\\\"//scene depth calculation\\\",\\n\\n\\t\\t\\t\\\"float depth = linearize(texture2D(tDepth,vUv.xy).x);\\\",\\n\\n\\t\\t\\t\\\"// Blur depth?\\\",\\n\\t\\t\\t\\\"if (depthblur) {\\\",\\n\\t\\t\\t\\t\\\"depth = linearize(bdepth(vUv.xy));\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"//focal plane calculation\\\",\\n\\n\\t\\t\\t\\\"float fDepth = focalDepth;\\\",\\n\\n\\t\\t\\t\\\"if (autofocus) {\\\",\\n\\n\\t\\t\\t\\t\\\"fDepth = linearize(texture2D(tDepth,focusCoords).x);\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"// dof blur factor calculation\\\",\\n\\n\\t\\t\\t\\\"float blur = 0.0;\\\",\\n\\n\\t\\t\\t\\\"if (manualdof) {\\\",\\n\\t\\t\\t\\t\\\"float a = depth-fDepth; // Focal plane\\\",\\n\\t\\t\\t\\t\\\"float b = (a-fdofstart)/fdofdist; // Far DoF\\\",\\n\\t\\t\\t\\t\\\"float c = (-a-ndofstart)/ndofdist; // Near Dof\\\",\\n\\t\\t\\t\\t\\\"blur = (a>0.0) ? b : c;\\\",\\n\\t\\t\\t\\\"} else {\\\",\\n\\t\\t\\t\\t\\\"float f = focalLength; // focal length in mm\\\",\\n\\t\\t\\t\\t\\\"float d = fDepth*1000.0; // focal plane in mm\\\",\\n\\t\\t\\t\\t\\\"float o = depth*1000.0; // depth in mm\\\",\\n\\n\\t\\t\\t\\t\\\"float a = (o*f)/(o-f);\\\",\\n\\t\\t\\t\\t\\\"float b = (d*f)/(d-f);\\\",\\n\\t\\t\\t\\t\\\"float c = (d-f)/(d*fstop*CoC);\\\",\\n\\n\\t\\t\\t\\t\\\"blur = abs(a-b)*c;\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"blur = clamp(blur,0.0,1.0);\\\",\\n\\n\\t\\t\\t\\\"// calculation of pattern for dithering\\\",\\n\\n\\t\\t\\t\\\"vec2 noise = rand(vUv.xy)*namount*blur;\\\",\\n\\n\\t\\t\\t\\\"// getting blur x and y step factor\\\",\\n\\n\\t\\t\\t\\\"float w = (1.0/width)*blur*maxblur+noise.x;\\\",\\n\\t\\t\\t\\\"float h = (1.0/height)*blur*maxblur+noise.y;\\\",\\n\\n\\t\\t\\t\\\"// calculation of final color\\\",\\n\\n\\t\\t\\t\\\"vec3 col = vec3(0.0);\\\",\\n\\n\\t\\t\\t\\\"if(blur < 0.05) {\\\",\\n\\t\\t\\t\\t\\\"//some optimization thingy\\\",\\n\\t\\t\\t\\t\\\"col = texture2D(tColor, vUv.xy).rgb;\\\",\\n\\t\\t\\t\\\"} else {\\\",\\n\\t\\t\\t\\t\\\"col = texture2D(tColor, vUv.xy).rgb;\\\",\\n\\t\\t\\t\\t\\\"float s = 1.0;\\\",\\n\\t\\t\\t\\t\\\"int ringsamples;\\\",\\n\\n\\t\\t\\t\\t\\\"for (int i = 1; i <= rings; i++) {\\\",\\n\\t\\t\\t\\t\\t\\\"/*unboxstart*/\\\",\\n\\t\\t\\t\\t\\t\\\"ringsamples = i * samples;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"for (int j = 0 ; j < maxringsamples ; j++) {\\\",\\n\\t\\t\\t\\t\\t\\t\\\"if (j >= ringsamples) break;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"s += gather(float(i), float(j), ringsamples, col, w, h, blur);\\\",\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\t\\t\\\"/*unboxend*/\\\",\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"col /= s; //divide by sample count\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"if (showFocus) {\\\",\\n\\t\\t\\t\\t\\\"col = debugFocus(col, blur, depth);\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"if (vignetting) {\\\",\\n\\t\\t\\t\\t\\\"col *= vignette();\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor.rgb = col;\\\",\\n\\t\\t\\t\\\"gl_FragColor.a = 1.0;\\\",\\n\\t\\t\\\"} \\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/EdgeShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/EdgeShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\\n *\\n * Edge Detection Shader using Frei-Chen filter\\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\\n *\\n * aspect: vec2 of (1/width, 1/height)\\n */\\n\\nTHREE.EdgeShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"aspect\\\":    { type: \\\"v2\\\", value: new THREE.Vector2( 512, 512 ) },\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"uniform vec2 aspect;\\\",\\n\\n\\t\\t\\\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\\\",\\n\\n\\n\\t\\t\\\"mat3 G[9];\\\",\\n\\n\\t\\t// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\\n\\n\\t\\t\\\"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\\\",\\n\\t\\t\\\"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\\\",\\n\\t\\t\\\"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\\\",\\n\\t\\t\\\"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\\\",\\n\\t\\t\\\"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\\\",\\n\\t\\t\\\"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\\\",\\n\\t\\t\\\"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\\\",\\n\\t\\t\\\"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\\\",\\n\\t\\t\\\"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\\\",\\n\\n\\t\\t\\\"void main(void)\\\",\\n\\t\\t\\\"{\\\",\\n\\n\\t\\t\\t\\\"G[0] = g0,\\\",\\n\\t\\t\\t\\\"G[1] = g1,\\\",\\n\\t\\t\\t\\\"G[2] = g2,\\\",\\n\\t\\t\\t\\\"G[3] = g3,\\\",\\n\\t\\t\\t\\\"G[4] = g4,\\\",\\n\\t\\t\\t\\\"G[5] = g5,\\\",\\n\\t\\t\\t\\\"G[6] = g6,\\\",\\n\\t\\t\\t\\\"G[7] = g7,\\\",\\n\\t\\t\\t\\\"G[8] = g8;\\\",\\n\\n\\t\\t\\t\\\"mat3 I;\\\",\\n\\t\\t\\t\\\"float cnv[9];\\\",\\n\\t\\t\\t\\\"vec3 sample;\\\",\\n\\n\\t\\t\\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\\n\\t\\t\\t\\\"for (float i=0.0; i<3.0; i++) {\\\",\\n\\t\\t\\t\\t\\\"for (float j=0.0; j<3.0; j++) {\\\",\\n\\t\\t\\t\\t\\t\\\"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\\\",\\n\\t\\t\\t\\t\\t\\\"I[int(i)][int(j)] = length(sample);\\\",\\n\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t/* calculate the convolution values for all the masks */\\n\\t\\t\\t\\\"for (int i=0; i<9; i++) {\\\",\\n\\t\\t\\t\\t\\\"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\\\",\\n\\t\\t\\t\\t\\\"cnv[i] = dp3 * dp3;\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\\\",\\n\\t\\t\\t\\\"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t].join(\\\"\\\\n\\\")\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/EdgeShader2.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/EdgeShader2.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\\n *\\n * Edge Detection Shader using Sobel filter\\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\\n *\\n * aspect: vec2 of (1/width, 1/height)\\n */\\n\\nTHREE.EdgeShader2 = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"aspect\\\":    { type: \\\"v2\\\", value: new THREE.Vector2( 512, 512 ) },\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\t\\t\\\"uniform vec2 aspect;\\\",\\n\\n\\n\\t\\t\\\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\\\",\\n\\n\\t\\t\\\"mat3 G[2];\\\",\\n\\n\\t\\t\\\"const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );\\\",\\n\\t\\t\\\"const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );\\\",\\n\\n\\n\\t\\t\\\"void main(void)\\\",\\n\\t\\t\\\"{\\\",\\n\\t\\t\\t\\\"mat3 I;\\\",\\n\\t\\t\\t\\\"float cnv[2];\\\",\\n\\t\\t\\t\\\"vec3 sample;\\\",\\n\\n\\t\\t\\t\\\"G[0] = g0;\\\",\\n\\t\\t\\t\\\"G[1] = g1;\\\",\\n\\n\\t\\t\\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\\n\\t\\t\\t\\\"for (float i=0.0; i<3.0; i++)\\\",\\n\\t\\t\\t\\\"for (float j=0.0; j<3.0; j++) {\\\",\\n\\t\\t\\t\\t\\\"sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\\\",\\n\\t\\t\\t\\t\\\"I[int(i)][int(j)] = length(sample);\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t/* calculate the convolution values for all the masks */\\n\\t\\t\\t\\\"for (int i=0; i<2; i++) {\\\",\\n\\t\\t\\t\\t\\\"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\\\",\\n\\t\\t\\t\\t\\\"cnv[i] = dp3 * dp3; \\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));\\\",\\n\\t\\t\\\"} \\\",\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/ConvolutionShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/ConvolutionShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Convolution shader\\n * ported from o3d sample to WebGL / GLSL\\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\\n */\\n\\nTHREE.ConvolutionShader = {\\n\\n\\tdefines: {\\n\\n\\t\\t\\\"KERNEL_SIZE_FLOAT\\\": \\\"25.0\\\",\\n\\t\\t\\\"KERNEL_SIZE_INT\\\": \\\"25\\\",\\n\\n\\t},\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\":        { type: \\\"t\\\", value: null },\\n\\t\\t\\\"uImageIncrement\\\": { type: \\\"v2\\\", value: new THREE.Vector2( 0.001953125, 0.0 ) },\\n\\t\\t\\\"cKernel\\\":         { type: \\\"fv1\\\", value: [] }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"uniform vec2 uImageIncrement;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float cKernel[ KERNEL_SIZE_INT ];\\\",\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform vec2 uImageIncrement;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec2 imageCoord = vUv;\\\",\\n\\t\\t\\t\\\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\\\",\\n\\n\\t\\t\\t\\\"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\\\",\\n\\n\\t\\t\\t\\t\\\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\\\",\\n\\t\\t\\t\\t\\\"imageCoord += uImageIncrement;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = sum;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tbuildKernel: function ( sigma ) {\\n\\n\\t\\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\\n\\n\\t\\tfunction gauss( x, sigma ) {\\n\\n\\t\\t\\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\\n\\n\\t\\t}\\n\\n\\t\\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\\n\\n\\t\\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\\n\\t\\thalfWidth = ( kernelSize - 1 ) * 0.5;\\n\\n\\t\\tvalues = new Array( kernelSize );\\n\\t\\tsum = 0.0;\\n\\t\\tfor ( i = 0; i < kernelSize; ++i ) {\\n\\n\\t\\t\\tvalues[ i ] = gauss( i - halfWidth, sigma );\\n\\t\\t\\tsum += values[ i ];\\n\\n\\t\\t}\\n\\n\\t\\t// normalize the kernel\\n\\n\\t\\tfor ( i = 0; i < kernelSize; ++i ) values[ i ] /= sum;\\n\\n\\t\\treturn values;\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/UnpackDepthRGBAShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/UnpackDepthRGBAShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Unpack RGBA depth shader\\n * - show RGBA encoded depth as monochrome color\\n */\\n\\nTHREE.UnpackDepthRGBAShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"opacity\\\":  { type: \\\"f\\\", value: 1.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float opacity;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t// RGBA depth\\n\\n\\t\\t\\\"float unpackDepth( const in vec4 rgba_depth ) {\\\",\\n\\n\\t\\t\\t\\\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\\",\\n\\t\\t\\t\\\"float depth = dot( rgba_depth, bit_shift );\\\",\\n\\t\\t\\t\\\"return depth;\\\",\\n\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"float depth = 1.0 - unpackDepth( texture2D( tDiffuse, vUv ) );\\\",\\n\\t\\t\\t\\\"gl_FragColor = opacity * vec4( vec3( depth ), 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/BokehShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/BokehShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Depth-of-field shader with bokeh\\n * ported from GLSL shader by Martins Upitis\\n * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\\n */\\n\\nTHREE.BokehShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tColor\\\":   { type: \\\"t\\\", value: null },\\n\\t\\t\\\"tDepth\\\":   { type: \\\"t\\\", value: null },\\n\\t\\t\\\"focus\\\":    { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\\"aspect\\\":   { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\\"aperture\\\": { type: \\\"f\\\", value: 0.025 },\\n\\t\\t\\\"maxblur\\\":  { type: \\\"f\\\", value: 1.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tColor;\\\",\\n\\t\\t\\\"uniform sampler2D tDepth;\\\",\\n\\n\\t\\t\\\"uniform float maxblur;\\\",  // max blur amount\\n\\t\\t\\\"uniform float aperture;\\\", // aperture - bigger values for shallower depth of field\\n\\n\\t\\t\\\"uniform float focus;\\\",\\n\\t\\t\\\"uniform float aspect;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec2 aspectcorrect = vec2( 1.0, aspect );\\\",\\n\\n\\t\\t\\t\\\"vec4 depth1 = texture2D( tDepth, vUv );\\\",\\n\\n\\t\\t\\t\\\"float factor = depth1.x - focus;\\\",\\n\\n\\t\\t\\t\\\"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\\\",\\n\\n\\t\\t\\t\\\"vec2 dofblur9 = dofblur * 0.9;\\\",\\n\\t\\t\\t\\\"vec2 dofblur7 = dofblur * 0.7;\\\",\\n\\t\\t\\t\\\"vec2 dofblur4 = dofblur * 0.4;\\\",\\n\\n\\t\\t\\t\\\"vec4 col = vec4( 0.0 );\\\",\\n\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\\\",\\n\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\\\",\\n\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\\\",\\n\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\\\",\\n\\t\\t\\t\\\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = col / 41.0;\\\",\\n\\t\\t\\t\\\"gl_FragColor.a = 1.0;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/HorizontalTiltShiftShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/HorizontalTiltShiftShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\\n *\\n * - 9 samples per pass\\n * - standard deviation 2.7\\n * - \\\"h\\\" and \\\"v\\\" parameters should be set to \\\"1 / width\\\" and \\\"1 / height\\\"\\n * - \\\"r\\\" parameter control where \\\"focused\\\" horizontal line lies\\n */\\n\\nTHREE.HorizontalTiltShiftShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"h\\\":        { type: \\\"f\\\", value: 1.0 / 512.0 },\\n\\t\\t\\\"r\\\":        { type: \\\"f\\\", value: 0.35 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform float h;\\\",\\n\\t\\t\\\"uniform float r;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 sum = vec4( 0.0 );\\\",\\n\\n\\t\\t\\t\\\"float hh = h * abs( r - vUv.y );\\\",\\n\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = sum;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/BrightnessContrastShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/BrightnessContrastShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author tapio / http://tapio.github.com/\\n *\\n * Brightness and contrast adjustment\\n * https://github.com/evanw/glfx.js\\n * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)\\n * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\\n */\\n\\nTHREE.BrightnessContrastShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\":   { type: \\\"t\\\", value: null },\\n\\t\\t\\\"brightness\\\": { type: \\\"f\\\", value: 0 },\\n\\t\\t\\\"contrast\\\":   { type: \\\"f\\\", value: 0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform float brightness;\\\",\\n\\t\\t\\\"uniform float contrast;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = texture2D( tDiffuse, vUv );\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor.rgb += brightness;\\\",\\n\\n\\t\\t\\t\\\"if (contrast > 0.0) {\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;\\\",\\n\\t\\t\\t\\\"} else {\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/DigitalGlitch.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/DigitalGlitch.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author felixturner / http://airtight.cc/\\n *\\n * RGB Shift Shader\\n * Shifts red and blue channels from center in opposite directions\\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\\n * by Tom Butterworth / http://kriss.cx/tom/\\n *\\n * amount: shift distance (1 is width of input)\\n * angle: shift angle in radians\\n */\\n\\nTHREE.DigitalGlitch = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\":\\t\\t{ type: \\\"t\\\", value: null },//diffuse texture\\n\\t\\t\\\"tDisp\\\":\\t\\t{ type: \\\"t\\\", value: null },//displacement texture for digital glitch squares\\n\\t\\t\\\"byp\\\":\\t\\t\\t{ type: \\\"i\\\", value: 0 },//apply the glitch ?\\n\\t\\t\\\"amount\\\":\\t\\t{ type: \\\"f\\\", value: 0.08 },\\n\\t\\t\\\"angle\\\":\\t\\t{ type: \\\"f\\\", value: 0.02 },\\n\\t\\t\\\"seed\\\":\\t\\t\\t{ type: \\\"f\\\", value: 0.02 },\\n\\t\\t\\\"seed_x\\\":\\t\\t{ type: \\\"f\\\", value: 0.02 },//-1,1\\n\\t\\t\\\"seed_y\\\":\\t\\t{ type: \\\"f\\\", value: 0.02 },//-1,1\\n\\t\\t\\\"distortion_x\\\":\\t{ type: \\\"f\\\", value: 0.5 },\\n\\t\\t\\\"distortion_y\\\":\\t{ type: \\\"f\\\", value: 0.6 },\\n\\t\\t\\\"col_s\\\":\\t\\t{ type: \\\"f\\\", value: 0.05 }\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\t\\t\\\"void main() {\\\",\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\\"}\\\"\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\t\\t\\\"uniform int byp;\\\",//should we apply the glitch ?\\n\\t\\t\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform sampler2D tDisp;\\\",\\n\\t\\t\\n\\t\\t\\\"uniform float amount;\\\",\\n\\t\\t\\\"uniform float angle;\\\",\\n\\t\\t\\\"uniform float seed;\\\",\\n\\t\\t\\\"uniform float seed_x;\\\",\\n\\t\\t\\\"uniform float seed_y;\\\",\\n\\t\\t\\\"uniform float distortion_x;\\\",\\n\\t\\t\\\"uniform float distortion_y;\\\",\\n\\t\\t\\\"uniform float col_s;\\\",\\n\\t\\t\\t\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\t\\t\\n\\t\\t\\n\\t\\t\\\"float rand(vec2 co){\\\",\\n\\t\\t\\t\\\"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\\",\\n\\t\\t\\\"}\\\",\\n\\t\\t\\t\\t\\n\\t\\t\\\"void main() {\\\",\\n\\t\\t\\t\\\"if(byp<1) {\\\",\\n\\t\\t\\t\\t\\\"vec2 p = vUv;\\\",\\n\\t\\t\\t\\t\\\"float xs = floor(gl_FragCoord.x / 0.5);\\\",\\n\\t\\t\\t\\t\\\"float ys = floor(gl_FragCoord.y / 0.5);\\\",\\n\\t\\t\\t\\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\\n\\t\\t\\t\\t\\\"vec4 normal = texture2D (tDisp, p*seed*seed);\\\",\\n\\t\\t\\t\\t\\\"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\\\",\\n\\t\\t\\t\\t\\t\\\"if(seed_x>0.){\\\",\\n\\t\\t\\t\\t\\t\\t\\\"p.y = 1. - (p.y + distortion_y);\\\",\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\t\\t\\\"else {\\\",\\n\\t\\t\\t\\t\\t\\t\\\"p.y = distortion_y;\\\",\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\t\\\"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\\\",\\n\\t\\t\\t\\t\\t\\\"if(seed_y>0.){\\\",\\n\\t\\t\\t\\t\\t\\t\\\"p.x=distortion_x;\\\",\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\t\\t\\\"else {\\\",\\n\\t\\t\\t\\t\\t\\t\\\"p.x = 1. - (p.x + distortion_x);\\\",\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\t\\\"p.x+=normal.x*seed_x*(seed/5.);\\\",\\n\\t\\t\\t\\t\\\"p.y+=normal.y*seed_y*(seed/5.);\\\",\\n\\t\\t\\t\\t//base from RGB shift shader\\n\\t\\t\\t\\t\\\"vec2 offset = amount * vec2( cos(angle), sin(angle));\\\",\\n\\t\\t\\t\\t\\\"vec4 cr = texture2D(tDiffuse, p + offset);\\\",\\n\\t\\t\\t\\t\\\"vec4 cga = texture2D(tDiffuse, p);\\\",\\n\\t\\t\\t\\t\\\"vec4 cb = texture2D(tDiffuse, p - offset);\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\\\",\\n\\t\\t\\t\\t//add noise\\n\\t\\t\\t\\t\\\"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor = gl_FragColor+ snow;\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\\"else {\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor=texture2D (tDiffuse, vUv);\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/KaleidoShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/KaleidoShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author felixturner / http://airtight.cc/\\n *\\n * Kaleidoscope Shader\\n * Radial reflection around center point\\n * Ported from: http://pixelshaders.com/editor/\\n * by Toby Schachman / http://tobyschachman.com/\\n *\\n * sides: number of reflections\\n * angle: initial angle in radians\\n */\\n\\nTHREE.KaleidoShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"sides\\\":    { type: \\\"f\\\", value: 6.0 },\\n\\t\\t\\\"angle\\\":    { type: \\\"f\\\", value: 0.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform float sides;\\\",\\n\\t\\t\\\"uniform float angle;\\\",\\n\\t\\t\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec2 p = vUv - 0.5;\\\",\\n\\t\\t\\t\\\"float r = length(p);\\\",\\n\\t\\t\\t\\\"float a = atan(p.y, p.x) + angle;\\\",\\n\\t\\t\\t\\\"float tau = 2. * 3.1416 ;\\\",\\n\\t\\t\\t\\\"a = mod(a, tau/sides);\\\",\\n\\t\\t\\t\\\"a = abs(a - tau/sides/2.) ;\\\",\\n\\t\\t\\t\\\"p = r * vec2(cos(a), sin(a));\\\",\\n\\t\\t\\t\\\"vec4 color = texture2D(tDiffuse, p + 0.5);\\\",\\n\\t\\t\\t\\\"gl_FragColor = color;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/VerticalBlurShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/VerticalBlurShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\n *\\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\\n *\\n * - 9 samples per pass\\n * - standard deviation 2.7\\n * - \\\"h\\\" and \\\"v\\\" parameters should be set to \\\"1 / width\\\" and \\\"1 / height\\\"\\n */\\n\\nTHREE.VerticalBlurShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"v\\\":        { type: \\\"f\\\", value: 1.0 / 512.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform float v;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 sum = vec4( 0.0 );\\\",\\n\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = sum;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/NormalMapShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/NormalMapShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Normal map shader\\n * - compute normals from heightmap\\n */\\n\\nTHREE.NormalMapShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"heightMap\\\":  { type: \\\"t\\\", value: null },\\n\\t\\t\\\"resolution\\\": { type: \\\"v2\\\", value: new THREE.Vector2( 512, 512 ) },\\n\\t\\t\\\"scale\\\":      { type: \\\"v2\\\", value: new THREE.Vector2( 1, 1 ) },\\n\\t\\t\\\"height\\\":     { type: \\\"f\\\", value: 0.05 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float height;\\\",\\n\\t\\t\\\"uniform vec2 resolution;\\\",\\n\\t\\t\\\"uniform sampler2D heightMap;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"float val = texture2D( heightMap, vUv ).x;\\\",\\n\\n\\t\\t\\t\\\"float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\\\",\\n\\t\\t\\t\\\"float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/ColorifyShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/ColorifyShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Colorify shader\\n */\\n\\nTHREE.ColorifyShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"color\\\":    { type: \\\"c\\\", value: new THREE.Color( 0xffffff ) }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform vec3 color;\\\",\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 texel = texture2D( tDiffuse, vUv );\\\",\\n\\n\\t\\t\\t\\\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\\\",\\n\\t\\t\\t\\\"float v = dot( texel.xyz, luma );\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( v * color, texel.w );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/TechnicolorShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/TechnicolorShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author flimshaw / http://charliehoey.com\\n *\\n * Technicolor Shader\\n * Simulates the look of the two-strip technicolor process popular in early 20th century films.\\n * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm\\n * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html\\n */\\n\\nTHREE.TechnicolorShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\\\",\\n\\t\\t\\t\\\"vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = newTex;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/DotScreenShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/DotScreenShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Dot screen shader\\n * based on glfx.js sepia shader\\n * https://github.com/evanw/glfx.js\\n */\\n\\nTHREE.DotScreenShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"tSize\\\":    { type: \\\"v2\\\", value: new THREE.Vector2( 256, 256 ) },\\n\\t\\t\\\"center\\\":   { type: \\\"v2\\\", value: new THREE.Vector2( 0.5, 0.5 ) },\\n\\t\\t\\\"angle\\\":    { type: \\\"f\\\", value: 1.57 },\\n\\t\\t\\\"scale\\\":    { type: \\\"f\\\", value: 1.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform vec2 center;\\\",\\n\\t\\t\\\"uniform float angle;\\\",\\n\\t\\t\\\"uniform float scale;\\\",\\n\\t\\t\\\"uniform vec2 tSize;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"float pattern() {\\\",\\n\\n\\t\\t\\t\\\"float s = sin( angle ), c = cos( angle );\\\",\\n\\n\\t\\t\\t\\\"vec2 tex = vUv * tSize - center;\\\",\\n\\t\\t\\t\\\"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\\\",\\n\\n\\t\\t\\t\\\"return ( sin( point.x ) * sin( point.y ) ) * 4.0;\\\",\\n\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 color = texture2D( tDiffuse, vUv );\\\",\\n\\n\\t\\t\\t\\\"float average = ( color.r + color.g + color.b ) / 3.0;\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/LuminosityShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/LuminosityShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Luminosity\\n * http://en.wikipedia.org/wiki/Luminosity\\n */\\n\\nTHREE.LuminosityShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 texel = texture2D( tDiffuse, vUv );\\\",\\n\\n\\t\\t\\t\\\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\\\",\\n\\n\\t\\t\\t\\\"float v = dot( texel.xyz, luma );\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( v, v, v, texel.w );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/HorizontalBlurShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/HorizontalBlurShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\n *\\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\\n *\\n * - 9 samples per pass\\n * - standard deviation 2.7\\n * - \\\"h\\\" and \\\"v\\\" parameters should be set to \\\"1 / width\\\" and \\\"1 / height\\\"\\n */\\n\\nTHREE.HorizontalBlurShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"h\\\":        { type: \\\"f\\\", value: 1.0 / 512.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform float h;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 sum = vec4( 0.0 );\\\",\\n\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = sum;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/FilmShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/FilmShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Film grain & scanlines shader\\n *\\n * - ported from HLSL to WebGL / GLSL\\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\\n *\\n * Screen Space Static Postprocessor\\n *\\n * Produces an analogue noise overlay similar to a film grain / TV static\\n *\\n * Original implementation and noise algorithm\\n * Pat 'Hawthorne' Shearon\\n *\\n * Optimized scanlines + noise version with intensity scaling\\n * Georg 'Leviathan' Steinrohder\\n *\\n * This version is provided under a Creative Commons Attribution 3.0 License\\n * http://creativecommons.org/licenses/by/3.0/\\n */\\n\\nTHREE.FilmShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\":   { type: \\\"t\\\", value: null },\\n\\t\\t\\\"time\\\":       { type: \\\"f\\\", value: 0.0 },\\n\\t\\t\\\"nIntensity\\\": { type: \\\"f\\\", value: 0.5 },\\n\\t\\t\\\"sIntensity\\\": { type: \\\"f\\\", value: 0.05 },\\n\\t\\t\\\"sCount\\\":     { type: \\\"f\\\", value: 4096 },\\n\\t\\t\\\"grayscale\\\":  { type: \\\"i\\\", value: 1 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t// control parameter\\n\\t\\t\\\"uniform float time;\\\",\\n\\n\\t\\t\\\"uniform bool grayscale;\\\",\\n\\n\\t\\t// noise effect intensity value (0 = no effect, 1 = full effect)\\n\\t\\t\\\"uniform float nIntensity;\\\",\\n\\n\\t\\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\\n\\t\\t\\\"uniform float sIntensity;\\\",\\n\\n\\t\\t// scanlines effect count value (0 = no effect, 4096 = full effect)\\n\\t\\t\\\"uniform float sCount;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t// sample the source\\n\\t\\t\\t\\\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\\\",\\n\\n\\t\\t\\t// make some noise\\n\\t\\t\\t\\\"float x = vUv.x * vUv.y * time *  1000.0;\\\",\\n\\t\\t\\t\\\"x = mod( x, 13.0 ) * mod( x, 123.0 );\\\",\\n\\t\\t\\t\\\"float dx = mod( x, 0.01 );\\\",\\n\\n\\t\\t\\t// add noise\\n\\t\\t\\t\\\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );\\\",\\n\\n\\t\\t\\t// get us a sine and cosine\\n\\t\\t\\t\\\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\\\",\\n\\n\\t\\t\\t// add scanlines\\n\\t\\t\\t\\\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\\\",\\n\\n\\t\\t\\t// interpolate between source and result by intensity\\n\\t\\t\\t\\\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\\\",\\n\\n\\t\\t\\t// convert to grayscale if desired\\n\\t\\t\\t\\\"if( grayscale ) {\\\",\\n\\n\\t\\t\\t\\t\\\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/FresnelShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/FresnelShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Based on Nvidia Cg tutorial\\n */\\n\\nTHREE.FresnelShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"mRefractionRatio\\\": { type: \\\"f\\\", value: 1.02 },\\n\\t\\t\\\"mFresnelBias\\\": { type: \\\"f\\\", value: 0.1 },\\n\\t\\t\\\"mFresnelPower\\\": { type: \\\"f\\\", value: 2.0 },\\n\\t\\t\\\"mFresnelScale\\\": { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\\"tCube\\\": { type: \\\"t\\\", value: null }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"uniform float mRefractionRatio;\\\",\\n\\t\\t\\\"uniform float mFresnelBias;\\\",\\n\\t\\t\\\"uniform float mFresnelScale;\\\",\\n\\t\\t\\\"uniform float mFresnelPower;\\\",\\n\\n\\t\\t\\\"varying vec3 vReflect;\\\",\\n\\t\\t\\\"varying vec3 vRefract[3];\\\",\\n\\t\\t\\\"varying float vReflectionFactor;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\\\",\\n\\n\\t\\t\\t\\\"vec3 I = worldPosition.xyz - cameraPosition;\\\",\\n\\n\\t\\t\\t\\\"vReflect = reflect( I, worldNormal );\\\",\\n\\t\\t\\t\\\"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\\\",\\n\\t\\t\\t\\\"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\\\",\\n\\t\\t\\t\\\"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\\\",\\n\\t\\t\\t\\\"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * mvPosition;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform samplerCube tCube;\\\",\\n\\n\\t\\t\\\"varying vec3 vReflect;\\\",\\n\\t\\t\\\"varying vec3 vRefract[3];\\\",\\n\\t\\t\\\"varying float vReflectionFactor;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\\\",\\n\\t\\t\\t\\\"vec4 refractedColor = vec4( 1.0 );\\\",\\n\\n\\t\\t\\t\\\"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\\\",\\n\\t\\t\\t\\\"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\\\",\\n\\t\\t\\t\\\"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/MirrorShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/MirrorShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author felixturner / http://airtight.cc/\\n *\\n * Mirror Shader\\n * Copies half the input to the other half\\n *\\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\\n */\\n\\nTHREE.MirrorShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"side\\\":     { type: \\\"i\\\", value: 1 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform int side;\\\",\\n\\t\\t\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec2 p = vUv;\\\",\\n\\t\\t\\t\\\"if (side == 0){\\\",\\n\\t\\t\\t\\t\\\"if (p.x > 0.5) p.x = 1.0 - p.x;\\\",\\n\\t\\t\\t\\\"}else if (side == 1){\\\",\\n\\t\\t\\t\\t\\\"if (p.x < 0.5) p.x = 1.0 - p.x;\\\",\\n\\t\\t\\t\\\"}else if (side == 2){\\\",\\n\\t\\t\\t\\t\\\"if (p.y < 0.5) p.y = 1.0 - p.y;\\\",\\n\\t\\t\\t\\\"}else if (side == 3){\\\",\\n\\t\\t\\t\\t\\\"if (p.y > 0.5) p.y = 1.0 - p.y;\\\",\\n\\t\\t\\t\\\"} \\\",\\n\\t\\t\\t\\\"vec4 color = texture2D(tDiffuse, p);\\\",\\n\\t\\t\\t\\\"gl_FragColor = color;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/DOFMipMapShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/DOFMipMapShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Depth-of-field shader using mipmaps\\n * - from Matt Handley @applmak\\n * - requires power-of-2 sized render target with enabled mipmaps\\n */\\n\\nTHREE.DOFMipMapShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tColor\\\":   { type: \\\"t\\\", value: null },\\n\\t\\t\\\"tDepth\\\":   { type: \\\"t\\\", value: null },\\n\\t\\t\\\"focus\\\":    { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\\"maxblur\\\":  { type: \\\"f\\\", value: 1.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float focus;\\\",\\n\\t\\t\\\"uniform float maxblur;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tColor;\\\",\\n\\t\\t\\\"uniform sampler2D tDepth;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 depth = texture2D( tDepth, vUv );\\\",\\n\\n\\t\\t\\t\\\"float factor = depth.x - focus;\\\",\\n\\n\\t\\t\\t\\\"vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = col;\\\",\\n\\t\\t\\t\\\"gl_FragColor.a = 1.0;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/HueSaturationShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/HueSaturationShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author tapio / http://tapio.github.com/\\n *\\n * Hue and saturation adjustment\\n * https://github.com/evanw/glfx.js\\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\\n */\\n\\nTHREE.HueSaturationShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\":   { type: \\\"t\\\", value: null },\\n\\t\\t\\\"hue\\\":        { type: \\\"f\\\", value: 0 },\\n\\t\\t\\\"saturation\\\": { type: \\\"f\\\", value: 0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform float hue;\\\",\\n\\t\\t\\\"uniform float saturation;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = texture2D( tDiffuse, vUv );\\\",\\n\\n\\t\\t\\t// hue\\n\\t\\t\\t\\\"float angle = hue * 3.14159265;\\\",\\n\\t\\t\\t\\\"float s = sin(angle), c = cos(angle);\\\",\\n\\t\\t\\t\\\"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\\\",\\n\\t\\t\\t\\\"float len = length(gl_FragColor.rgb);\\\",\\n\\t\\t\\t\\\"gl_FragColor.rgb = vec3(\\\",\\n\\t\\t\\t\\t\\\"dot(gl_FragColor.rgb, weights.xyz),\\\",\\n\\t\\t\\t\\t\\\"dot(gl_FragColor.rgb, weights.zxy),\\\",\\n\\t\\t\\t\\t\\\"dot(gl_FragColor.rgb, weights.yzx)\\\",\\n\\t\\t\\t\\\");\\\",\\n\\n\\t\\t\\t// saturation\\n\\t\\t\\t\\\"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\\\",\\n\\t\\t\\t\\\"if (saturation > 0.0) {\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\\\",\\n\\t\\t\\t\\\"} else {\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\\\",\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/FXAAShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/FXAAShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n * @author davidedc / http://www.sketchpatch.net/\\n *\\n * NVIDIA FXAA by Timothy Lottes\\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\\n * - WebGL port by @supereggbert\\n * http://www.glge.org/demos/fxaa/\\n */\\n\\nTHREE.FXAAShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\":   { type: \\\"t\\\", value: null },\\n\\t\\t\\\"resolution\\\": { type: \\\"v2\\\", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform vec2 resolution;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"#define FXAA_REDUCE_MIN   (1.0/128.0)\\\",\\n\\t\\t\\\"#define FXAA_REDUCE_MUL   (1.0/8.0)\\\",\\n\\t\\t\\\"#define FXAA_SPAN_MAX     8.0\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;\\\",\\n\\t\\t\\t\\\"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;\\\",\\n\\t\\t\\t\\\"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;\\\",\\n\\t\\t\\t\\\"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;\\\",\\n\\t\\t\\t\\\"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );\\\",\\n\\t\\t\\t\\\"vec3 rgbM  = rgbaM.xyz;\\\",\\n\\t\\t\\t\\\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\\\",\\n\\n\\t\\t\\t\\\"float lumaNW = dot( rgbNW, luma );\\\",\\n\\t\\t\\t\\\"float lumaNE = dot( rgbNE, luma );\\\",\\n\\t\\t\\t\\\"float lumaSW = dot( rgbSW, luma );\\\",\\n\\t\\t\\t\\\"float lumaSE = dot( rgbSE, luma );\\\",\\n\\t\\t\\t\\\"float lumaM  = dot( rgbM,  luma );\\\",\\n\\t\\t\\t\\\"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\\\",\\n\\t\\t\\t\\\"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\\\",\\n\\n\\t\\t\\t\\\"vec2 dir;\\\",\\n\\t\\t\\t\\\"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\\",\\n\\t\\t\\t\\\"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\\",\\n\\n\\t\\t\\t\\\"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\\\",\\n\\n\\t\\t\\t\\\"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\\\",\\n\\t\\t\\t\\\"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\\\",\\n\\t\\t\\t\\t  \\\"max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\\\",\\n\\t\\t\\t\\t\\t\\t\\\"dir * rcpDirMin)) * resolution;\\\",\\n\\t\\t\\t\\\"vec4 rgbA = (1.0/2.0) * (\\\",\\n        \\t\\\"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +\\\",\\n\\t\\t\\t\\\"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));\\\",\\n    \\t\\t\\\"vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\\\",\\n\\t\\t\\t\\\"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +\\\",\\n      \\t\\t\\\"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));\\\",\\n    \\t\\t\\\"float lumaB = dot(rgbB, vec4(luma, 0.0));\\\",\\n\\n\\t\\t\\t\\\"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = rgbA;\\\",\\n\\n\\t\\t\\t\\\"} else {\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor = rgbB;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/BasicShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/BasicShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://www.mrdoob.com\\n *\\n * Simple test shader\\n */\\n\\nTHREE.BasicShader = {\\n\\n\\tuniforms: {},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/FocusShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/FocusShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Focus shader\\n * based on PaintEffect postprocess from ro.me\\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\\n */\\n\\nTHREE.FocusShader = {\\n\\n\\tuniforms : {\\n\\n\\t\\t\\\"tDiffuse\\\":       { type: \\\"t\\\", value: null },\\n\\t\\t\\\"screenWidth\\\":    { type: \\\"f\\\", value: 1024 },\\n\\t\\t\\\"screenHeight\\\":   { type: \\\"f\\\", value: 1024 },\\n\\t\\t\\\"sampleDistance\\\": { type: \\\"f\\\", value: 0.94 },\\n\\t\\t\\\"waveFactor\\\":     { type: \\\"f\\\", value: 0.00125 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float screenWidth;\\\",\\n\\t\\t\\\"uniform float screenHeight;\\\",\\n\\t\\t\\\"uniform float sampleDistance;\\\",\\n\\t\\t\\\"uniform float waveFactor;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 color, org, tmp, add;\\\",\\n\\t\\t\\t\\\"float sample_dist, f;\\\",\\n\\t\\t\\t\\\"vec2 vin;\\\",\\n\\t\\t\\t\\\"vec2 uv = vUv;\\\",\\n\\n\\t\\t\\t\\\"add = color = org = texture2D( tDiffuse, uv );\\\",\\n\\n\\t\\t\\t\\\"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );\\\",\\n\\t\\t\\t\\\"sample_dist = dot( vin, vin ) * 2.0;\\\",\\n\\n\\t\\t\\t\\\"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;\\\",\\n\\n\\t\\t\\t\\\"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );\\\",\\n\\n\\t\\t\\t\\\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );\\\",\\n\\t\\t\\t\\\"if( tmp.b < color.b ) color = tmp;\\\",\\n\\n\\t\\t\\t\\\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );\\\",\\n\\t\\t\\t\\\"if( tmp.b < color.b ) color = tmp;\\\",\\n\\n\\t\\t\\t\\\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );\\\",\\n\\t\\t\\t\\\"if( tmp.b < color.b ) color = tmp;\\\",\\n\\n\\t\\t\\t\\\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );\\\",\\n\\t\\t\\t\\\"if( tmp.b < color.b ) color = tmp;\\\",\\n\\n\\t\\t\\t\\\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );\\\",\\n\\t\\t\\t\\\"if( tmp.b < color.b ) color = tmp;\\\",\\n\\n\\t\\t\\t\\\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );\\\",\\n\\t\\t\\t\\\"if( tmp.b < color.b ) color = tmp;\\\",\\n\\n\\t\\t\\t\\\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );\\\",\\n\\t\\t\\t\\\"if( tmp.b < color.b ) color = tmp;\\\",\\n\\n\\t\\t\\t\\\"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );\\\",\\n\\t\\t\\t\\\"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\n\\t].join(\\\"\\\\n\\\")\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/VerticalTiltShiftShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/VerticalTiltShiftShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\\n *\\n * - 9 samples per pass\\n * - standard deviation 2.7\\n * - \\\"h\\\" and \\\"v\\\" parameters should be set to \\\"1 / width\\\" and \\\"1 / height\\\"\\n * - \\\"r\\\" parameter control where \\\"focused\\\" horizontal line lies\\n */\\n\\nTHREE.VerticalTiltShiftShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"v\\\":        { type: \\\"f\\\", value: 1.0 / 512.0 },\\n\\t\\t\\\"r\\\":        { type: \\\"f\\\", value: 0.35 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform float v;\\\",\\n\\t\\t\\\"uniform float r;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 sum = vec4( 0.0 );\\\",\\n\\n\\t\\t\\t\\\"float vv = v * abs( r - vUv.y );\\\",\\n\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;\\\",\\n\\t\\t\\t\\\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = sum;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/SepiaShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/SepiaShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Sepia tone shader\\n * based on glfx.js sepia shader\\n * https://github.com/evanw/glfx.js\\n */\\n\\nTHREE.SepiaShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"amount\\\":   { type: \\\"f\\\", value: 1.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float amount;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 color = texture2D( tDiffuse, vUv );\\\",\\n\\t\\t\\t\\\"vec3 c = color.rgb;\\\",\\n\\n\\t\\t\\t\\\"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\\\",\\n\\t\\t\\t\\\"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\\\",\\n\\t\\t\\t\\\"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/CopyShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/CopyShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Full-screen textured quad shader\\n */\\n\\nTHREE.CopyShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"opacity\\\":  { type: \\\"f\\\", value: 1.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float opacity;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 texel = texture2D( tDiffuse, vUv );\\\",\\n\\t\\t\\t\\\"gl_FragColor = opacity * texel;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/ColorCorrectionShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/ColorCorrectionShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Color correction\\n */\\n\\nTHREE.ColorCorrectionShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"powRGB\\\":   { type: \\\"v3\\\", value: new THREE.Vector3( 2, 2, 2 ) },\\n\\t\\t\\\"mulRGB\\\":   { type: \\\"v3\\\", value: new THREE.Vector3( 1, 1, 1 ) }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform vec3 powRGB;\\\",\\n\\t\\t\\\"uniform vec3 mulRGB;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = texture2D( tDiffuse, vUv );\\\",\\n\\t\\t\\t\\\"gl_FragColor.rgb = mulRGB * pow( gl_FragColor.rgb, powRGB );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/SSAOShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/SSAOShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Screen-space ambient occlusion shader\\n * - ported from\\n *   SSAO GLSL shader v1.2\\n *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)\\n *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\\n * - modifications\\n * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)\\n * - refactoring and optimizations\\n */\\n\\nTHREE.SSAOShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\":     { type: \\\"t\\\", value: null },\\n\\t\\t\\\"tDepth\\\":       { type: \\\"t\\\", value: null },\\n\\t\\t\\\"size\\\":         { type: \\\"v2\\\", value: new THREE.Vector2( 512, 512 ) },\\n\\t\\t\\\"cameraNear\\\":   { type: \\\"f\\\", value: 1 },\\n\\t\\t\\\"cameraFar\\\":    { type: \\\"f\\\", value: 100 },\\n\\t\\t\\\"onlyAO\\\":       { type: \\\"i\\\", value: 0 },\\n\\t\\t\\\"aoClamp\\\":      { type: \\\"f\\\", value: 0.5 },\\n\\t\\t\\\"lumInfluence\\\": { type: \\\"f\\\", value: 0.5 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float cameraNear;\\\",\\n\\t\\t\\\"uniform float cameraFar;\\\",\\n\\n\\t\\t\\\"uniform bool onlyAO;\\\",      // use only ambient occlusion pass?\\n\\n\\t\\t\\\"uniform vec2 size;\\\",        // texture width, height\\n\\t\\t\\\"uniform float aoClamp;\\\",    // depth clamp - reduces haloing at screen edges\\n\\n\\t\\t\\\"uniform float lumInfluence;\\\",  // how much luminance affects occlusion\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\t\\t\\\"uniform sampler2D tDepth;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t// \\\"#define PI 3.14159265\\\",\\n\\t\\t\\\"#define DL 2.399963229728653\\\",  // PI * ( 3.0 - sqrt( 5.0 ) )\\n\\t\\t\\\"#define EULER 2.718281828459045\\\",\\n\\n\\t\\t// helpers\\n\\n\\t\\t\\\"float width = size.x;\\\",   // texture width\\n\\t\\t\\\"float height = size.y;\\\",  // texture height\\n\\n\\t\\t\\\"float cameraFarPlusNear = cameraFar + cameraNear;\\\",\\n\\t\\t\\\"float cameraFarMinusNear = cameraFar - cameraNear;\\\",\\n\\t\\t\\\"float cameraCoef = 2.0 * cameraNear;\\\",\\n\\n\\t\\t// user variables\\n\\n\\t\\t\\\"const int samples = 8;\\\",     // ao sample count\\n\\t\\t\\\"const float radius = 5.0;\\\",  // ao radius\\n\\n\\t\\t\\\"const bool useNoise = false;\\\",      // use noise instead of pattern for sample dithering\\n\\t\\t\\\"const float noiseAmount = 0.0003;\\\", // dithering amount\\n\\n\\t\\t\\\"const float diffArea = 0.4;\\\",   // self-shadowing reduction\\n\\t\\t\\\"const float gDisplace = 0.4;\\\",  // gauss bell center\\n\\n\\n\\t\\t// RGBA depth\\n\\n\\t\\t\\\"float unpackDepth( const in vec4 rgba_depth ) {\\\",\\n\\n\\t\\t\\t\\\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\\",\\n\\t\\t\\t\\\"float depth = dot( rgba_depth, bit_shift );\\\",\\n\\t\\t\\t\\\"return depth;\\\",\\n\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t// generating noise / pattern texture for dithering\\n\\n\\t\\t\\\"vec2 rand( const vec2 coord ) {\\\",\\n\\n\\t\\t\\t\\\"vec2 noise;\\\",\\n\\n\\t\\t\\t\\\"if ( useNoise ) {\\\",\\n\\n\\t\\t\\t\\t\\\"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\\\",\\n\\t\\t\\t\\t\\\"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"} else {\\\",\\n\\n\\t\\t\\t\\t\\\"float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );\\\",\\n\\t\\t\\t\\t\\\"float gg = fract( coord.t * ( height / 2.0 ) );\\\",\\n\\n\\t\\t\\t\\t\\\"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"return ( noise * 2.0  - 1.0 ) * noiseAmount;\\\",\\n\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"float readDepth( const in vec2 coord ) {\\\",\\n\\n\\t\\t\\t// \\\"return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );\\\",\\n\\t\\t\\t\\\"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );\\\",\\n\\n\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"float compareDepths( const in float depth1, const in float depth2, inout int far ) {\\\",\\n\\n\\t\\t\\t\\\"float garea = 2.0;\\\",                         // gauss bell width\\n\\t\\t\\t\\\"float diff = ( depth1 - depth2 ) * 100.0;\\\",  // depth difference (0-100)\\n\\n\\t\\t\\t// reduce left bell width to avoid self-shadowing\\n\\n\\t\\t\\t\\\"if ( diff < gDisplace ) {\\\",\\n\\n\\t\\t\\t\\t\\\"garea = diffArea;\\\",\\n\\n\\t\\t\\t\\\"} else {\\\",\\n\\n\\t\\t\\t\\t\\\"far = 1;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"float dd = diff - gDisplace;\\\",\\n\\t\\t\\t\\\"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\\\",\\n\\t\\t\\t\\\"return gauss;\\\",\\n\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"float calcAO( float depth, float dw, float dh ) {\\\",\\n\\n\\t\\t\\t\\\"float dd = radius - depth * radius;\\\",\\n\\t\\t\\t\\\"vec2 vv = vec2( dw, dh );\\\",\\n\\n\\t\\t\\t\\\"vec2 coord1 = vUv + dd * vv;\\\",\\n\\t\\t\\t\\\"vec2 coord2 = vUv - dd * vv;\\\",\\n\\n\\t\\t\\t\\\"float temp1 = 0.0;\\\",\\n\\t\\t\\t\\\"float temp2 = 0.0;\\\",\\n\\n\\t\\t\\t\\\"int far = 0;\\\",\\n\\t\\t\\t\\\"temp1 = compareDepths( depth, readDepth( coord1 ), far );\\\",\\n\\n\\t\\t\\t// DEPTH EXTRAPOLATION\\n\\n\\t\\t\\t\\\"if ( far > 0 ) {\\\",\\n\\n\\t\\t\\t\\t\\\"temp2 = compareDepths( readDepth( coord2 ), depth, far );\\\",\\n\\t\\t\\t\\t\\\"temp1 += ( 1.0 - temp1 ) * temp2;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"return temp1;\\\",\\n\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec2 noise = rand( vUv );\\\",\\n\\t\\t\\t\\\"float depth = readDepth( vUv );\\\",\\n\\n\\t\\t\\t\\\"float tt = clamp( depth, aoClamp, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );\\\",\\n\\t\\t\\t\\\"float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );\\\",\\n\\n\\t\\t\\t\\\"float ao = 0.0;\\\",\\n\\n\\t\\t\\t\\\"float dz = 1.0 / float( samples );\\\",\\n\\t\\t\\t\\\"float z = 1.0 - dz / 2.0;\\\",\\n\\t\\t\\t\\\"float l = 0.0;\\\",\\n\\n\\t\\t\\t\\\"for ( int i = 0; i <= samples; i ++ ) {\\\",\\n\\n\\t\\t\\t\\t\\\"float r = sqrt( 1.0 - z );\\\",\\n\\n\\t\\t\\t\\t\\\"float pw = cos( l ) * r;\\\",\\n\\t\\t\\t\\t\\\"float ph = sin( l ) * r;\\\",\\n\\t\\t\\t\\t\\\"ao += calcAO( depth, pw * w, ph * h );\\\",\\n\\t\\t\\t\\t\\\"z = z - dz;\\\",\\n\\t\\t\\t\\t\\\"l = l + DL;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"ao /= float( samples );\\\",\\n\\t\\t\\t\\\"ao = 1.0 - ao;\\\",\\n\\n\\t\\t\\t\\\"vec3 color = texture2D( tDiffuse, vUv ).rgb;\\\",\\n\\n\\t\\t\\t\\\"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\\\",\\n\\t\\t\\t\\\"float lum = dot( color.rgb, lumcoeff );\\\",\\n\\t\\t\\t\\\"vec3 luminance = vec3( lum );\\\",\\n\\n\\t\\t\\t\\\"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\\\",  // mix( color * ao, white, luminance )\\n\\n\\t\\t\\t\\\"if ( onlyAO ) {\\\",\\n\\n\\t\\t\\t\\t\\\"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\\\",  // ambient occlusion only\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( final, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/VignetteShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/VignetteShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Vignette shader\\n * based on PaintEffect postprocess from ro.me\\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\\n */\\n\\nTHREE.VignetteShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"offset\\\":   { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\\"darkness\\\": { type: \\\"f\\\", value: 1.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float offset;\\\",\\n\\t\\t\\\"uniform float darkness;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t// Eskil's vignette\\n\\n\\t\\t\\t\\\"vec4 texel = texture2D( tDiffuse, vUv );\\\",\\n\\t\\t\\t\\\"vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\\\",\\n\\t\\t\\t\\\"gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\\\",\\n\\n\\t\\t\\t/*\\n\\t\\t\\t// alternative version from glfx.js\\n\\t\\t\\t// this one makes more \\\"dusty\\\" look (as opposed to \\\"burned\\\")\\n\\n\\t\\t\\t\\\"vec4 color = texture2D( tDiffuse, vUv );\\\",\\n\\t\\t\\t\\\"float dist = distance( vUv, vec2( 0.5 ) );\\\",\\n\\t\\t\\t\\\"color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );\\\",\\n\\t\\t\\t\\\"gl_FragColor = color;\\\",\\n\\t\\t\\t*/\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/TriangleBlurShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/TriangleBlurShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\n *\\n * Triangle blur shader\\n * based on glfx.js triangle blur shader\\n * https://github.com/evanw/glfx.js\\n *\\n * A basic blur filter, which convolves the image with a\\n * pyramid filter. The pyramid filter is separable and is applied as two\\n * perpendicular triangle filters.\\n */\\n\\nTHREE.TriangleBlurShader = {\\n\\n\\tuniforms : {\\n\\n\\t\\t\\\"texture\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"delta\\\":   { type: \\\"v2\\\", value:new THREE.Vector2( 1, 1 )  }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"#define ITERATIONS 10.0\\\",\\n\\n\\t\\t\\\"uniform sampler2D texture;\\\",\\n\\t\\t\\\"uniform vec2 delta;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"float random( vec3 scale, float seed ) {\\\",\\n\\n\\t\\t\\t// use the fragment position for a different seed per-pixel\\n\\n\\t\\t\\t\\\"return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed );\\\",\\n\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 color = vec4( 0.0 );\\\",\\n\\n\\t\\t\\t\\\"float total = 0.0;\\\",\\n\\n\\t\\t\\t// randomize the lookup values to hide the fixed number of samples\\n\\n\\t\\t\\t\\\"float offset = random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );\\\",\\n\\n\\t\\t\\t\\\"for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {\\\",\\n\\n\\t\\t\\t\\t\\\"float percent = ( t + offset - 0.5 ) / ITERATIONS;\\\",\\n\\t\\t\\t\\t\\\"float weight = 1.0 - abs( percent );\\\",\\n\\n\\t\\t\\t\\t\\\"color += texture2D( texture, vUv + delta * percent ) * weight;\\\",\\n\\t\\t\\t\\t\\\"total += weight;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = color / total;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Shaders/BleachBypassShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Shaders/BleachBypassShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]\\n * - based on Nvidia example\\n * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass\\n */\\n\\nTHREE.BleachBypassShader = {\\n\\n\\tuniforms: {\\n\\n\\t\\t\\\"tDiffuse\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\\"opacity\\\":  { type: \\\"f\\\", value: 1.0 }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\t\\t\\\"uniform float opacity;\\\",\\n\\n\\t\\t\\\"uniform sampler2D tDiffuse;\\\",\\n\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 base = texture2D( tDiffuse, vUv );\\\",\\n\\n\\t\\t\\t\\\"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\\\",\\n\\t\\t\\t\\\"float lum = dot( lumCoeff, base.rgb );\\\",\\n\\t\\t\\t\\\"vec3 blend = vec3( lum );\\\",\\n\\n\\t\\t\\t\\\"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\\\",\\n\\n\\t\\t\\t\\\"vec3 result1 = 2.0 * base.rgb * blend;\\\",\\n\\t\\t\\t\\\"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\\\",\\n\\n\\t\\t\\t\\\"vec3 newColor = mix( result1, result2, L );\\\",\\n\\n\\t\\t\\t\\\"float A2 = opacity * base.a;\\\",\\n\\t\\t\\t\\\"vec3 mixRGB = A2 * newColor.rgb;\\\",\\n\\t\\t\\t\\\"mixRGB += ( ( 1.0 - A2 ) * base.rgb );\\\",\\n\\n\\t\\t\\t\\\"gl_FragColor = vec4( mixRGB, base.a );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/BlendCharacterGui.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/BlendCharacterGui.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author Michael Guerrero / http://realitymeltdown.com\\n */\\n\\nfunction BlendCharacterGui(animations) {\\n\\n\\tvar controls = {\\n\\n\\t\\tgui: null,\\n\\t\\t\\\"Lock Camera\\\": false,\\n\\t\\t\\\"Show Model\\\": true,\\n\\t\\t\\\"Show Skeleton\\\": false,\\n\\t\\t\\\"Time Scale\\\": 1.0,\\n\\t\\t\\\"Step Size\\\": 0.016,\\n\\t\\t\\\"Crossfade Time\\\": 3.5,\\n\\t\\t\\\"idle\\\": 0.33,\\n\\t\\t\\\"walk\\\": 0.33,\\n\\t\\t\\\"run\\\": 0.33\\n\\n\\t};\\n\\n\\tvar animations = animations;\\n\\n\\tthis.showModel = function() {\\n\\n\\t\\treturn controls['Show Model'];\\n\\n\\t};\\n\\n\\tthis.showSkeleton = function() {\\n\\n\\t\\treturn controls['Show Skeleton'];\\n\\n\\t};\\n\\n\\tthis.getTimeScale = function() {\\n\\n\\t\\treturn controls['Time Scale'];\\n\\n\\t};\\n\\n\\tthis.update = function() {\\n\\n\\t\\tcontrols[ 'idle'] = animations[ 'idle' ].weight;\\n\\t\\tcontrols[ 'walk'] = animations[ 'walk' ].weight;\\n\\t\\tcontrols[ 'run'] = animations[ 'run' ].weight;\\n\\n\\t};\\n\\n\\tvar init = function() {\\n\\n\\t\\tcontrols.gui = new dat.GUI();\\n\\n\\t\\tvar settings = controls.gui.addFolder( 'Settings' );\\n\\t\\tvar playback = controls.gui.addFolder( 'Playback' );\\n\\t\\tvar blending = controls.gui.addFolder( 'Blend Tuning' );\\n\\n\\t\\tsettings.add( controls, \\\"Lock Camera\\\" ).onChange( controls.lockCameraChanged );\\n\\t\\tsettings.add( controls, \\\"Show Model\\\" ).onChange( controls.showModelChanged );\\n\\t\\tsettings.add( controls, \\\"Show Skeleton\\\" ).onChange( controls.showSkeletonChanged );\\n\\t\\tsettings.add( controls, \\\"Time Scale\\\", 0, 1, 0.01 );\\n\\t\\tsettings.add( controls, \\\"Step Size\\\", 0.01, 0.1, 0.01 );\\n\\t\\tsettings.add( controls, \\\"Crossfade Time\\\", 0.1, 6.0, 0.05 );\\n\\n\\t\\t// These controls execute functions\\n\\t\\tplayback.add( controls, \\\"start\\\" );\\n\\t\\tplayback.add( controls, \\\"pause\\\" );\\n\\t\\tplayback.add( controls, \\\"step\\\" );\\n\\t\\tplayback.add( controls, \\\"idle to walk\\\" );\\n\\t\\tplayback.add( controls, \\\"walk to run\\\" );\\n\\t\\tplayback.add( controls, \\\"warp walk to run\\\" );\\n\\n\\t\\tblending.add( controls, \\\"idle\\\", 0, 1, 0.01).listen().onChange( controls.weight );\\n\\t\\tblending.add( controls, \\\"walk\\\", 0, 1, 0.01).listen().onChange( controls.weight );\\n\\t\\tblending.add( controls, \\\"run\\\", 0, 1, 0.01).listen().onChange( controls.weight );\\n\\n\\t\\tsettings.open();\\n\\t\\tplayback.open();\\n\\t\\tblending.open();\\n\\n\\t}\\n\\n\\tvar getAnimationData = function() {\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tdetail: {\\n\\n\\t\\t\\t\\tanims: [ \\\"idle\\\", \\\"walk\\\", \\\"run\\\" ],\\n\\n\\t\\t\\t\\tweights: [ controls['idle'],\\n\\t\\t\\t\\t\\t\\t   controls['walk'],\\n\\t\\t\\t\\t\\t\\t   controls['run'] ]\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\t}\\n\\n\\tcontrols.start = function() {\\n\\n\\t\\tvar startEvent = new CustomEvent( 'start-animation', getAnimationData() );\\n\\t\\twindow.dispatchEvent(startEvent);\\n\\n\\t};\\n\\n\\tcontrols.stop = function() {\\n\\n\\t\\tvar stopEvent = new CustomEvent( 'stop-animation' );\\n\\t\\twindow.dispatchEvent( stopEvent );\\n\\n\\t};\\n\\n\\tcontrols.pause = function() {\\n\\n\\t\\tvar pauseEvent = new CustomEvent( 'pause-animation' );\\n\\t\\twindow.dispatchEvent( pauseEvent );\\n\\n\\t};\\n\\n\\tcontrols.step = function() {\\n\\n\\t\\tvar stepData = { detail: { stepSize: controls['Step Size'] } };\\n\\t\\twindow.dispatchEvent( new CustomEvent('step-animation', stepData ));\\n\\n\\t};\\n\\n\\tcontrols.weight = function() {\\n\\n\\t\\t// renormalize\\n\\t\\tvar sum = controls['idle'] + controls['walk'] + controls['run'];\\n\\t\\tcontrols['idle'] /= sum;\\n\\t\\tcontrols['walk'] /= sum;\\n\\t\\tcontrols['run'] /= sum;\\n\\n\\t\\tvar weightEvent = new CustomEvent( 'weight-animation', getAnimationData() );\\n\\t\\twindow.dispatchEvent(weightEvent);\\n\\t};\\n\\n\\tcontrols.crossfade = function( from, to ) {\\n\\n\\t\\tvar fadeData = getAnimationData();\\n\\t\\tfadeData.detail.from = from;\\n\\t\\tfadeData.detail.to = to;\\n\\t\\tfadeData.detail.time = controls[ \\\"Crossfade Time\\\" ];\\n\\n\\t\\twindow.dispatchEvent( new CustomEvent( 'crossfade', fadeData ) );\\n\\t}\\n\\n\\tcontrols.warp = function( from, to ) {\\n\\n\\t\\tvar warpData = getAnimationData();\\n\\t\\twarpData.detail.from = 'walk';\\n\\t\\twarpData.detail.to = 'run';\\n\\t\\twarpData.detail.time = controls[ \\\"Crossfade Time\\\" ];\\n\\n\\t\\twindow.dispatchEvent( new CustomEvent( 'warp', warpData ) );\\n\\t}\\n\\n\\tcontrols['idle to walk'] = function() {\\n\\n\\t\\tcontrols.crossfade( 'idle', 'walk' );\\n\\n\\t};\\n\\n\\tcontrols['walk to run'] = function() {\\n\\n\\t\\tcontrols.crossfade( 'walk', 'run' );\\n\\n\\t};\\n\\n\\tcontrols['warp walk to run'] = function() {\\n\\n\\t\\tcontrols.warp( 'walk', 'run' );\\n\\n\\t};\\n\\n\\tcontrols.lockCameraChanged = function() {\\n\\n\\t\\tvar data = {\\n\\t\\t\\tdetail: {\\n\\t\\t\\t\\tshouldLock: controls['Lock Camera']\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\twindow.dispatchEvent( new CustomEvent( 'toggle-lock-camera', data ) );\\n\\t}\\n\\n\\tcontrols.showSkeletonChanged = function() {\\n\\n\\t\\tvar data = {\\n\\t\\t\\tdetail: {\\n\\t\\t\\t\\tshouldShow: controls['Show Skeleton']\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\twindow.dispatchEvent( new CustomEvent( 'toggle-show-skeleton', data ) );\\n\\t}\\n\\n\\n\\tcontrols.showModelChanged = function() {\\n\\n\\t\\tvar data = {\\n\\t\\t\\tdetail: {\\n\\t\\t\\t\\tshouldShow: controls['Show Model']\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\twindow.dispatchEvent( new CustomEvent( 'toggle-show-model', data ) );\\n\\t}\\n\\n\\n\\tinit.call(this);\\n\\n}\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Curves/NURBSCurve.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Curves/NURBSCurve.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author renej\\n * NURBS curve object\\n *\\n * Derives from Curve, overriding getPoint and getTangent.\\n *\\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\\n *\\n **/\\n\\n\\n/**************************************************************\\n *\\tNURBS curve\\n **************************************************************/\\n\\nTHREE.NURBSCurve = function ( degree, knots /* array of reals */, controlPoints /* array of Vector(2|3|4) */) {\\n\\n\\tthis.degree = degree;\\n\\tthis.knots = knots;\\n\\tthis.controlPoints = [];\\n\\tfor (var i = 0; i < controlPoints.length; ++i) { // ensure Vector4 for control points\\n\\t\\tvar point = controlPoints[i];\\n\\t\\tthis.controlPoints[i] = new THREE.Vector4(point.x, point.y, point.z, point.w);\\n\\t}\\n\\n};\\n\\n\\nTHREE.NURBSCurve.prototype = Object.create( THREE.Curve.prototype );\\n\\n\\nTHREE.NURBSCurve.prototype.getPoint = function ( t ) {\\n\\n\\tvar u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]); // linear mapping t->u\\n\\n\\t// following results in (wx, wy, wz, w) homogeneous point\\n\\tvar hpoint = THREE.NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);\\n\\n\\tif (hpoint.w != 1.0) { // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\\n\\t\\thpoint.divideScalar(hpoint.w);\\n\\t}\\n\\n\\treturn new THREE.Vector3(hpoint.x, hpoint.y, hpoint.z);\\n};\\n\\n\\nTHREE.NURBSCurve.prototype.getTangent = function ( t ) {\\n\\n\\tvar u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\\n\\tvar ders = THREE.NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);\\n\\tvar tangent = ders[1].clone();\\n\\ttangent.normalize();\\n\\n\\treturn tangent;\\n};\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Curves/NURBSSurface.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Curves/NURBSSurface.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author renej\\n * NURBS surface object\\n *\\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\\n *\\n **/\\n\\n\\n/**************************************************************\\n *\\tNURBS surface\\n **************************************************************/\\n\\nTHREE.NURBSSurface = function ( degree1, degree2, knots1, knots2 /* arrays of reals */, controlPoints /* array^2 of Vector(2|3|4) */) {\\n\\n\\tthis.degree1 = degree1;\\n\\tthis.degree2 = degree2;\\n\\tthis.knots1 = knots1;\\n\\tthis.knots2 = knots2;\\n\\tthis.controlPoints = [];\\n\\n\\tvar len1 = knots1.length - degree1 - 1;\\n\\tvar len2 = knots2.length - degree2 - 1;\\n\\n\\t// ensure Vector4 for control points\\n\\tfor (var i = 0; i < len1; ++i) {\\n\\t\\tthis.controlPoints[i] = []\\n\\t\\tfor (var j = 0; j < len2; ++j) {\\n\\t\\t\\tvar point = controlPoints[i][j];\\n\\t\\t\\tthis.controlPoints[i][j] = new THREE.Vector4(point.x, point.y, point.z, point.w);\\n\\t\\t}\\n\\t}\\n};\\n\\n\\nTHREE.NURBSSurface.prototype = {\\n\\n\\tconstructor: THREE.NURBSSurface,\\n\\n\\tgetPoint: function ( t1, t2 ) {\\n\\n\\t\\tvar u = this.knots1[0] + t1 * (this.knots1[this.knots1.length - 1] - this.knots1[0]); // linear mapping t1->u\\n\\t\\tvar v = this.knots2[0] + t2 * (this.knots2[this.knots2.length - 1] - this.knots2[0]); // linear mapping t2->u\\n\\n\\t\\treturn THREE.NURBSUtils.calcSurfacePoint(this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v);\\n\\t}\\n};\\n\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Curves/NURBSUtils.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Curves/NURBSUtils.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author renej\\n * NURBS utils\\n *\\n * See NURBSCurve and NURBSSurface.\\n *\\n **/\\n\\n\\n/**************************************************************\\n *\\tNURBS Utils\\n **************************************************************/\\n\\nTHREE.NURBSUtils = {\\n\\n\\t/*\\n\\tFinds knot vector span.\\n\\n\\tp : degree\\n\\tu : parametric value\\n\\tU : knot vector\\n\\t\\n\\treturns the span\\n\\t*/\\n\\tfindSpan: function( p,  u,  U ) {\\n\\t\\tvar n = U.length - p - 1;\\n\\n\\t\\tif (u >= U[n]) {\\n\\t\\t\\treturn n - 1;\\n\\t\\t}\\n\\n\\t\\tif (u <= U[p]) {\\n\\t\\t\\treturn p;\\n\\t\\t}\\n\\n\\t\\tvar low = p;\\n\\t\\tvar high = n;\\n\\t\\tvar mid = Math.floor((low + high) / 2);\\n\\n\\t\\twhile (u < U[mid] || u >= U[mid + 1]) {\\n\\t\\t  \\n\\t\\t\\tif (u < U[mid]) {\\n\\t\\t\\t\\thigh = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlow = mid;\\n\\t\\t\\t}\\n\\n\\t\\t\\tmid = Math.floor((low + high) / 2);\\n\\t\\t}\\n\\n\\t\\treturn mid;\\n\\t},\\n    \\n\\t\\t\\n\\t/*\\n\\tCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\\n   \\n\\tspan : span in which u lies\\n\\tu    : parametric point\\n\\tp    : degree\\n\\tU    : knot vector\\n\\t\\n\\treturns array[p+1] with basis functions values.\\n\\t*/\\n\\tcalcBasisFunctions: function( span, u, p, U ) {\\n\\t\\tvar N = [];\\n\\t\\tvar left = [];\\n\\t\\tvar right = [];\\n\\t\\tN[0] = 1.0;\\n\\n\\t\\tfor (var j = 1; j <= p; ++j) {\\n\\t   \\n\\t\\t\\tleft[j] = u - U[span + 1 - j];\\n\\t\\t\\tright[j] = U[span + j] - u;\\n\\n\\t\\t\\tvar saved = 0.0;\\n\\n\\t\\t\\tfor (var r = 0; r < j; ++r) {\\n\\n\\t\\t\\t\\tvar rv = right[r + 1];\\n\\t\\t\\t\\tvar lv = left[j - r];\\n\\t\\t\\t\\tvar temp = N[r] / (rv + lv);\\n\\t\\t\\t\\tN[r] = saved + rv * temp;\\n\\t\\t\\t\\tsaved = lv * temp;\\n\\t\\t\\t }\\n\\n\\t\\t\\t N[j] = saved;\\n\\t\\t }\\n\\n\\t\\t return N;\\n\\t},\\n\\n\\n\\t/*\\n\\tCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\\n \\n\\tp : degree of B-Spline\\n\\tU : knot vector\\n\\tP : control points (x, y, z, w)\\n\\tu : parametric point\\n\\n\\treturns point for given u\\n\\t*/\\n\\tcalcBSplinePoint: function( p, U, P, u ) {\\n\\t\\tvar span = this.findSpan(p, u, U);\\n\\t\\tvar N = this.calcBasisFunctions(span, u, p, U);\\n\\t\\tvar C = new THREE.Vector4(0, 0, 0, 0);\\n\\n\\t\\tfor (var j = 0; j <= p; ++j) {\\n\\t\\t\\tvar point = P[span - p + j];\\n\\t\\t\\tvar Nj = N[j];\\n\\t\\t\\tvar wNj = point.w * Nj;\\n\\t\\t\\tC.x += point.x * wNj;\\n\\t\\t\\tC.y += point.y * wNj;\\n\\t\\t\\tC.z += point.z * wNj;\\n\\t\\t\\tC.w += point.w * Nj;\\n\\t\\t}\\n\\n\\t\\treturn C;\\n\\t},\\n\\n\\n\\t/*\\n\\tCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\\n\\n\\tspan : span in which u lies\\n\\tu    : parametric point\\n\\tp    : degree\\n\\tn    : number of derivatives to calculate\\n\\tU    : knot vector\\n\\n\\treturns array[n+1][p+1] with basis functions derivatives\\n\\t*/\\n\\tcalcBasisFunctionDerivatives: function( span,  u,  p,  n,  U ) {\\n\\n\\t\\tvar zeroArr = [];\\n\\t\\tfor (var i = 0; i <= p; ++i)\\n\\t\\t\\tzeroArr[i] = 0.0;\\n\\n\\t\\tvar ders = [];\\n\\t\\tfor (var i = 0; i <= n; ++i)\\n\\t\\t\\tders[i] = zeroArr.slice(0);\\n\\n\\t\\tvar ndu = [];\\n\\t\\tfor (var i = 0; i <= p; ++i)\\n\\t\\t\\tndu[i] = zeroArr.slice(0);\\n\\n\\t\\tndu[0][0] = 1.0;\\n\\n\\t\\tvar left = zeroArr.slice(0);\\n\\t\\tvar right = zeroArr.slice(0);\\n\\n\\t\\tfor (var j = 1; j <= p; ++j) {\\n\\t\\t\\tleft[j] = u - U[span + 1 - j];\\n\\t\\t\\tright[j] = U[span + j] - u;\\n\\n\\t\\t\\tvar saved = 0.0;\\n\\n\\t\\t\\tfor (var r = 0; r < j; ++r) {\\n\\t\\t\\t\\tvar rv = right[r + 1];\\n\\t\\t\\t\\tvar lv = left[j - r];\\n\\t\\t\\t\\tndu[j][r] = rv + lv;\\n\\n\\t\\t\\t\\tvar temp = ndu[r][j - 1] / ndu[j][r];\\n\\t\\t\\t\\tndu[r][j] = saved + rv * temp;\\n\\t\\t\\t\\tsaved = lv * temp;\\n\\t\\t\\t}\\n\\n\\t\\t\\tndu[j][j] = saved;\\n\\t\\t}\\n\\n\\t\\tfor (var j = 0; j <= p; ++j) {\\n\\t\\t\\tders[0][j] = ndu[j][p];\\n\\t\\t}\\n\\n\\t\\tfor (var r = 0; r <= p; ++r) {\\n\\t\\t\\tvar s1 = 0;\\n\\t\\t\\tvar s2 = 1;\\n\\n\\t\\t\\tvar a = [];\\n\\t\\t\\tfor (var i = 0; i <= p; ++i) {\\n\\t\\t\\t\\ta[i] = zeroArr.slice(0);\\n\\t\\t\\t}\\n\\t\\t\\ta[0][0] = 1.0;\\n\\n\\t\\t\\tfor (var k = 1; k <= n; ++k) {\\n\\t\\t\\t\\tvar d = 0.0;\\n\\t\\t\\t\\tvar rk = r - k;\\n\\t\\t\\t\\tvar pk = p - k;\\n\\n\\t\\t\\t\\tif (r >= k) {\\n\\t\\t\\t\\t\\ta[s2][0] = a[s1][0] / ndu[pk + 1][rk];\\n\\t\\t\\t\\t\\td = a[s2][0] * ndu[rk][pk];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar j1 = (rk >= -1) ? 1 : -rk;\\n\\t\\t\\t\\tvar j2 = (r - 1 <= pk) ? k - 1 :  p - r;\\n\\n\\t\\t\\t\\tfor (var j = j1; j <= j2; ++j) {\\n\\t\\t\\t\\t\\ta[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j];\\n\\t\\t\\t\\t\\td += a[s2][j] * ndu[rk + j][pk];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (r <= pk) {\\n\\t\\t\\t\\t\\ta[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r];\\n\\t\\t\\t\\t\\td += a[s2][k] * ndu[r][pk];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tders[k][r] = d;\\n\\n\\t\\t\\t\\tvar j = s1;\\n\\t\\t\\t\\ts1 = s2;\\n\\t\\t\\t\\ts2 = j;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar r = p;\\n\\n\\t\\tfor (var k = 1; k <= n; ++k) {\\n\\t\\t\\tfor (var j = 0; j <= p; ++j) {\\n\\t\\t\\t\\tders[k][j] *= r;\\n\\t\\t\\t}\\n\\t\\t\\tr *= p - k;\\n\\t\\t}\\n\\n\\t\\treturn ders;\\n\\t},\\n\\n\\n \\t/*\\n\\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\\n\\n\\tp  : degree\\n\\tU  : knot vector\\n\\tP  : control points\\n\\tu  : Parametric points\\n\\tnd : number of derivatives\\n\\n\\treturns array[d+1] with derivatives\\n\\t*/\\n\\tcalcBSplineDerivatives: function( p,  U,  P,  u,  nd ) {\\n\\t\\tvar du = nd < p ? nd : p;\\n\\t\\tvar CK = [];\\n\\t\\tvar span = this.findSpan(p, u, U);\\n\\t\\tvar nders = this.calcBasisFunctionDerivatives(span, u, p, du, U);\\n\\t\\tvar Pw = [];\\n\\n\\t\\tfor (var i = 0; i < P.length; ++i) {\\n\\t\\t\\tvar point = P[i].clone();\\n\\t\\t\\tvar w = point.w;\\n\\n\\t\\t\\tpoint.x *= w;\\n\\t\\t\\tpoint.y *= w;\\n\\t\\t\\tpoint.z *= w;\\n\\n\\t\\t\\tPw[i] = point;\\n\\t\\t}\\n\\t\\tfor (var k = 0; k <= du; ++k) {\\n\\t\\t\\tvar point = Pw[span - p].clone().multiplyScalar(nders[k][0]);\\n\\n\\t\\t\\tfor (var j = 1; j <= p; ++j) {\\n\\t\\t\\t\\tpoint.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));\\n\\t\\t\\t}\\n\\n\\t\\t\\tCK[k] = point;\\n\\t\\t}\\n\\n\\t\\tfor (var k = du + 1; k <= nd + 1; ++k) {\\n\\t\\t\\tCK[k] = new THREE.Vector4(0, 0, 0);\\n\\t\\t}\\n\\n\\t\\treturn CK;\\n\\t},\\n\\n\\n\\t/*\\n\\tCalculate \\\"K over I\\\"\\n\\n\\treturns k!/(i!(k-i)!)\\n\\t*/\\n\\tcalcKoverI: function( k, i ) {\\n\\t\\tvar nom = 1;\\n\\n\\t\\tfor (var j = 2; j <= k; ++j) {\\n\\t\\t\\tnom *= j;\\n\\t\\t}\\n\\n\\t\\tvar denom = 1;\\n\\n\\t\\tfor (var j = 2; j <= i; ++j) {\\n\\t\\t\\tdenom *= j;\\n\\t\\t}\\n\\n\\t\\tfor (var j = 2; j <= k - i; ++j) {\\n\\t\\t\\tdenom *= j;\\n\\t\\t}\\n\\n\\t\\treturn nom / denom;\\n\\t},\\n\\n\\n\\t/*\\n\\tCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\\n\\n\\tPders : result of function calcBSplineDerivatives\\n\\n\\treturns array with derivatives for rational curve.\\n\\t*/\\n\\tcalcRationalCurveDerivatives: function ( Pders ) {\\n\\t\\tvar nd = Pders.length;\\n\\t\\tvar Aders = [];\\n\\t\\tvar wders = [];\\n\\n\\t\\tfor (var i = 0; i < nd; ++i) {\\n\\t\\t\\tvar point = Pders[i];\\n\\t\\t\\tAders[i] = new THREE.Vector3(point.x, point.y, point.z);\\n\\t\\t\\twders[i] = point.w;\\n\\t\\t}\\n\\n\\t\\tvar CK = [];\\n\\n\\t\\tfor (var k = 0; k < nd; ++k) {\\n\\t\\t\\tvar v = Aders[k].clone();\\n\\n\\t\\t\\tfor (var i = 1; i <= k; ++i) {\\n\\t\\t\\t\\tv.sub(CK[k - i].clone().multiplyScalar(this.calcKoverI(k,i) * wders[i]));\\n\\t\\t\\t}\\n\\n\\t\\t\\tCK[k] = v.divideScalar(wders[0]);\\n\\t\\t}\\n\\n\\t\\treturn CK;\\n\\t},\\n\\n\\n\\t/*\\n\\tCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\\n\\n\\tp  : degree\\n\\tU  : knot vector\\n\\tP  : control points in homogeneous space\\n\\tu  : parametric points\\n\\tnd : number of derivatives\\n\\n\\treturns array with derivatives.\\n\\t*/\\n\\tcalcNURBSDerivatives: function( p,  U,  P,  u,  nd ) {\\n\\t\\tvar Pders = this.calcBSplineDerivatives(p, U, P, u, nd);\\n\\t\\treturn this.calcRationalCurveDerivatives(Pders);\\n\\t},\\n\\n\\n\\t/*\\n\\tCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\\n \\n\\tp1, p2 : degrees of B-Spline surface\\n\\tU1, U2 : knot vectors\\n\\tP      : control points (x, y, z, w)\\n\\tu, v   : parametric values\\n\\n\\treturns point for given (u, v)\\n\\t*/\\n\\tcalcSurfacePoint: function( p, q, U, V, P, u, v ) {\\n\\t\\tvar uspan = this.findSpan(p, u, U);\\n\\t\\tvar vspan = this.findSpan(q, v, V);\\n\\t\\tvar Nu = this.calcBasisFunctions(uspan, u, p, U);\\n\\t\\tvar Nv = this.calcBasisFunctions(vspan, v, q, V);\\n\\t\\tvar temp = [];\\n\\n\\t\\tfor (var l = 0; l <= q; ++l) {\\n\\t\\t\\ttemp[l] = new THREE.Vector4(0, 0, 0, 0);\\n\\t\\t\\tfor (var k = 0; k <= p; ++k) {\\n\\t\\t\\t\\tvar point = P[uspan - p + k][vspan - q + l].clone();\\n\\t\\t\\t\\tvar w = point.w;\\n\\t\\t\\t\\tpoint.x *= w;\\n\\t\\t\\t\\tpoint.y *= w;\\n\\t\\t\\t\\tpoint.z *= w;\\n\\t\\t\\t\\ttemp[l].add(point.multiplyScalar(Nu[k]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar Sw = new THREE.Vector4(0, 0, 0, 0);\\n\\t\\tfor (var l = 0; l <= q; ++l) {\\n\\t\\t\\tSw.add(temp[l].multiplyScalar(Nv[l]));\\n\\t\\t}\\n\\n\\t\\tSw.divideScalar(Sw.w);\\n\\t\\treturn new THREE.Vector3(Sw.x, Sw.y, Sw.z);\\n\\t}\\n\\n};\\n\\n\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Geometries/ConvexGeometry.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Geometries/ConvexGeometry.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author qiao / https://github.com/qiao\\n * @fileoverview This is a convex hull generator using the incremental method. \\n * The complexity is O(n^2) where n is the number of vertices.\\n * O(nlogn) algorithms do exist, but they are much more complicated.\\n *\\n * Benchmark: \\n *\\n *  Platform: CPU: P7350 @2.00GHz Engine: V8\\n *\\n *  Num Vertices\\tTime(ms)\\n *\\n *     10           1\\n *     20           3\\n *     30           19\\n *     40           48\\n *     50           107\\n */\\n\\nTHREE.ConvexGeometry = function( vertices ) {\\n\\n\\tTHREE.Geometry.call( this );\\n\\n\\tvar faces = [ [ 0, 1, 2 ], [ 0, 2, 1 ] ]; \\n\\n\\tfor ( var i = 3; i < vertices.length; i++ ) {\\n\\n\\t\\taddPoint( i );\\n\\n\\t}\\n\\n\\n\\tfunction addPoint( vertexId ) {\\n\\n\\t\\tvar vertex = vertices[ vertexId ].clone();\\n\\n\\t\\tvar mag = vertex.length();\\n\\t\\tvertex.x += mag * randomOffset();\\n\\t\\tvertex.y += mag * randomOffset();\\n\\t\\tvertex.z += mag * randomOffset();\\n\\n\\t\\tvar hole = [];\\n\\n\\t\\tfor ( var f = 0; f < faces.length; ) {\\n\\n\\t\\t\\tvar face = faces[ f ];\\n\\n\\t\\t\\t// for each face, if the vertex can see it,\\n\\t\\t\\t// then we try to add the face's edges into the hole.\\n\\t\\t\\tif ( visible( face, vertex ) ) {\\n\\n\\t\\t\\t\\tfor ( var e = 0; e < 3; e++ ) {\\n\\n\\t\\t\\t\\t\\tvar edge = [ face[ e ], face[ ( e + 1 ) % 3 ] ];\\n\\t\\t\\t\\t\\tvar boundary = true;\\n\\n\\t\\t\\t\\t\\t// remove duplicated edges.\\n\\t\\t\\t\\t\\tfor ( var h = 0; h < hole.length; h++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( equalEdge( hole[ h ], edge ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\thole[ h ] = hole[ hole.length - 1 ];\\n\\t\\t\\t\\t\\t\\t\\thole.pop();\\n\\t\\t\\t\\t\\t\\t\\tboundary = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( boundary ) {\\n\\n\\t\\t\\t\\t\\t\\thole.push( edge );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// remove faces[ f ]\\n\\t\\t\\t\\tfaces[ f ] = faces[ faces.length - 1 ];\\n\\t\\t\\t\\tfaces.pop();\\n\\n\\t\\t\\t} else { // not visible\\n\\n\\t\\t\\t\\tf++;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// construct the new faces formed by the edges of the hole and the vertex\\n\\t\\tfor ( var h = 0; h < hole.length; h++ ) {\\n\\n\\t\\t\\tfaces.push( [ \\n\\t\\t\\t\\thole[ h ][ 0 ],\\n\\t\\t\\t\\thole[ h ][ 1 ],\\n\\t\\t\\t\\tvertexId\\n\\t\\t\\t] );\\n\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Whether the face is visible from the vertex\\n\\t */\\n\\tfunction visible( face, vertex ) {\\n\\n\\t\\tvar va = vertices[ face[ 0 ] ];\\n\\t\\tvar vb = vertices[ face[ 1 ] ];\\n\\t\\tvar vc = vertices[ face[ 2 ] ];\\n\\n\\t\\tvar n = normal( va, vb, vc );\\n\\n\\t\\t// distance from face to origin\\n\\t\\tvar dist = n.dot( va );\\n\\n\\t\\treturn n.dot( vertex ) >= dist; \\n\\n\\t}\\n\\n\\t/**\\n\\t * Face normal\\n\\t */\\n\\tfunction normal( va, vb, vc ) {\\n\\n\\t\\tvar cb = new THREE.Vector3();\\n\\t\\tvar ab = new THREE.Vector3();\\n\\n\\t\\tcb.subVectors( vc, vb );\\n\\t\\tab.subVectors( va, vb );\\n\\t\\tcb.cross( ab );\\n\\n\\t\\tcb.normalize();\\n\\n\\t\\treturn cb;\\n\\n\\t}\\n\\n\\t/**\\n\\t * Detect whether two edges are equal.\\n\\t * Note that when constructing the convex hull, two same edges can only\\n\\t * be of the negative direction.\\n\\t */\\n\\tfunction equalEdge( ea, eb ) {\\n\\n\\t\\treturn ea[ 0 ] === eb[ 1 ] && ea[ 1 ] === eb[ 0 ]; \\n\\n\\t}\\n\\n\\t/**\\n\\t * Create a random offset between -1e-6 and 1e-6.\\n\\t */\\n\\tfunction randomOffset() {\\n\\n\\t\\treturn ( Math.random() - 0.5 ) * 2 * 1e-6;\\n\\n\\t}\\n\\n\\n\\t/**\\n\\t * XXX: Not sure if this is the correct approach. Need someone to review.\\n\\t */\\n\\tfunction vertexUv( vertex ) {\\n\\n\\t\\tvar mag = vertex.length();\\n\\t\\treturn new THREE.Vector2( vertex.x / mag, vertex.y / mag );\\n\\n\\t}\\n\\n\\t// Push vertices into `this.vertices`, skipping those inside the hull\\n\\tvar id = 0;\\n\\tvar newId = new Array( vertices.length ); // map from old vertex id to new id\\n\\n\\tfor ( var i = 0; i < faces.length; i++ ) {\\n\\n\\t\\t var face = faces[ i ];\\n\\n\\t\\t for ( var j = 0; j < 3; j++ ) {\\n\\n\\t\\t\\t\\tif ( newId[ face[ j ] ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tnewId[ face[ j ] ] = id++;\\n\\t\\t\\t\\t\\t\\tthis.vertices.push( vertices[ face[ j ] ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tface[ j ] = newId[ face[ j ] ];\\n\\n\\t\\t }\\n\\n\\t}\\n\\n\\t// Convert faces into instances of THREE.Face3\\n\\tfor ( var i = 0; i < faces.length; i++ ) {\\n\\n\\t\\tthis.faces.push( new THREE.Face3( \\n\\t\\t\\t\\tfaces[ i ][ 0 ],\\n\\t\\t\\t\\tfaces[ i ][ 1 ],\\n\\t\\t\\t\\tfaces[ i ][ 2 ]\\n\\t\\t) );\\n\\n\\t}\\n\\n\\t// Compute UVs\\n\\tfor ( var i = 0; i < this.faces.length; i++ ) {\\n\\n\\t\\tvar face = this.faces[ i ];\\n\\n\\t\\tthis.faceVertexUvs[ 0 ].push( [\\n\\t\\t\\tvertexUv( this.vertices[ face.a ] ),\\n\\t\\t\\tvertexUv( this.vertices[ face.b ] ),\\n\\t\\t\\tvertexUv( this.vertices[ face.c ])\\n\\t\\t] );\\n\\n\\t}\\n\\n\\tthis.computeFaceNormals();\\n\\tthis.computeVertexNormals();\\n\\n};\\n\\nTHREE.ConvexGeometry.prototype = Object.create( THREE.Geometry.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Geometries/hilbert2D.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Geometries/hilbert2D.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * Hilbert Curve: Generates 2D-Coordinates in a very fast way.\\n *\\n * @author Dylan Grafmyre\\n *\\n * Based on work by:\\n * @author Thomas Diewald\\n * @link http://www.openprocessing.org/sketch/15493\\n *\\n * @param center     Center of Hilbert curve.\\n * @param size       Total width of Hilbert curve.\\n * @param iterations Number of subdivisions.\\n * @param v0         Corner index -X, -Z.\\n * @param v1         Corner index -X, +Z.\\n * @param v2         Corner index +X, +Z.\\n * @param v3         Corner index +X, -Z.\\n */\\nfunction hilbert2D (center, size, iterations, v0, v1, v2, v3) {\\n\\t// Default Vars\\n\\tvar center     = undefined !== center ? center : new THREE.Vector3(0, 0, 0),\\n\\t\\tsize       = undefined !== size ? size : 10,\\n\\t\\thalf       = size / 2,\\n\\t\\titerations = undefined !== iterations ? iterations : 1,\\n\\t\\tv0 = undefined !== v0 ? v0 : 0,\\n\\t\\tv1 = undefined !== v1 ? v1 : 1,\\n\\t\\tv2 = undefined !== v2 ? v2 : 2,\\n\\t\\tv3 = undefined !== v3 ? v3 : 3\\n\\t;\\n\\n\\tvar vec_s = [\\n\\t\\tnew THREE.Vector3( center.x - half, center.y, center.z - half ),\\n\\t\\tnew THREE.Vector3( center.x - half, center.y, center.z + half ),\\n\\t\\tnew THREE.Vector3( center.x + half, center.y, center.z + half ),\\n\\t\\tnew THREE.Vector3( center.x + half, center.y, center.z - half )\\n\\t];\\n\\n\\tvar vec = [\\n\\t\\tvec_s[ v0 ],\\n\\t\\tvec_s[ v1 ],\\n\\t\\tvec_s[ v2 ],\\n\\t\\tvec_s[ v3 ]\\n\\t];\\n\\n\\t// Recurse iterations\\n\\tif (0 <= --iterations) {\\n\\t\\tvar tmp = [];\\n\\n\\t\\tArray.prototype.push.apply( tmp, hilbert2D ( vec[ 0 ], half, iterations, v0, v3, v2, v1 ) );\\n\\t\\tArray.prototype.push.apply( tmp, hilbert2D ( vec[ 1 ], half, iterations, v0, v1, v2, v3 ) );\\n\\t\\tArray.prototype.push.apply( tmp, hilbert2D ( vec[ 2 ], half, iterations, v0, v1, v2, v3 ) );\\n\\t\\tArray.prototype.push.apply( tmp, hilbert2D ( vec[ 3 ], half, iterations, v2, v1, v0, v3 ) );\\n\\n\\t\\t// Return recursive call\\n\\t\\treturn tmp;\\n\\t}\\n\\n\\t// Return complete Hilbert Curve.\\n\\treturn vec;\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Geometries/hilbert3D.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Geometries/hilbert3D.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * Hilbert Curve: Generates 2D-Coordinates in a very fast way.\\n *\\n * @author Dylan Grafmyre\\n *\\n * Based on work by:\\n * @author Thomas Diewald\\n * @link http://www.openprocessing.org/visuals/?visualID=15599\\n *\\n * Based on `examples/canvas_lines_colors.html`:\\n * @author OpenShift guest\\n * @link https://github.com/mrdoob/three.js/blob/8413a860aa95ed29c79cbb7f857c97d7880d260f/examples/canvas_lines_colors.html\\n * @see  Line 149 - 186\\n *\\n * @param center     Center of Hilbert curve.\\n * @param size       Total width of Hilbert curve.\\n * @param iterations Number of subdivisions.\\n * @param v0         Corner index -X, +Y, -Z.\\n * @param v1         Corner index -X, +Y, +Z.\\n * @param v2         Corner index -X, -Y, +Z.\\n * @param v3         Corner index -X, -Y, -Z.\\n * @param v4         Corner index +X, -Y, -Z.\\n * @param v5         Corner index +X, -Y, +Z.\\n * @param v6         Corner index +X, +Y, +Z.\\n * @param v7         Corner index +X, +Y, -Z.\\n */\\nfunction hilbert3D(center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7) {\\n\\t// Default Vars\\n\\tvar center     = undefined !== center ? center : new THREE.Vector3(0, 0, 0),\\n\\t\\tsize       = undefined !== size ? size : 10,\\n\\t\\thalf       = size / 2,\\n\\t\\titerations = undefined !== iterations ? iterations : 1,\\n\\t\\tv0 = undefined !== v0 ? v0 : 0,\\n\\t\\tv1 = undefined !== v1 ? v1 : 1,\\n\\t\\tv2 = undefined !== v2 ? v2 : 2,\\n\\t\\tv3 = undefined !== v3 ? v3 : 3,\\n\\t\\tv4 = undefined !== v4 ? v4 : 4,\\n\\t\\tv5 = undefined !== v5 ? v5 : 5,\\n\\t\\tv6 = undefined !== v6 ? v6 : 6,\\n\\t\\tv7 = undefined !== v7 ? v7 : 7\\n\\t;\\n\\n\\tvar vec_s = [\\n\\t\\tnew THREE.Vector3( center.x - half, center.y + half, center.z - half ),\\n\\t\\tnew THREE.Vector3( center.x - half, center.y + half, center.z + half ),\\n\\t\\tnew THREE.Vector3( center.x - half, center.y - half, center.z + half ),\\n\\t\\tnew THREE.Vector3( center.x - half, center.y - half, center.z - half ),\\n\\t\\tnew THREE.Vector3( center.x + half, center.y - half, center.z - half ),\\n\\t\\tnew THREE.Vector3( center.x + half, center.y - half, center.z + half ),\\n\\t\\tnew THREE.Vector3( center.x + half, center.y + half, center.z + half ),\\n\\t\\tnew THREE.Vector3( center.x + half, center.y + half, center.z - half )\\n\\t];\\n\\n\\tvar vec = [\\n\\t\\tvec_s[ v0 ],\\n\\t\\tvec_s[ v1 ],\\n\\t\\tvec_s[ v2 ],\\n\\t\\tvec_s[ v3 ],\\n\\t\\tvec_s[ v4 ],\\n\\t\\tvec_s[ v5 ],\\n\\t\\tvec_s[ v6 ],\\n\\t\\tvec_s[ v7 ]\\n\\t];\\n\\n\\t// Recurse iterations\\n\\tif( --iterations >= 0 ) {\\n\\t\\tvar tmp = [];\\n\\n\\t\\tArray.prototype.push.apply( tmp, hilbert3D ( vec[ 0 ], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1 ) );\\n\\t\\tArray.prototype.push.apply( tmp, hilbert3D ( vec[ 1 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ) );\\n\\t\\tArray.prototype.push.apply( tmp, hilbert3D ( vec[ 2 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ) );\\n\\t\\tArray.prototype.push.apply( tmp, hilbert3D ( vec[ 3 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ) );\\n\\t\\tArray.prototype.push.apply( tmp, hilbert3D ( vec[ 4 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ) );\\n\\t\\tArray.prototype.push.apply( tmp, hilbert3D ( vec[ 5 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ) );\\n\\t\\tArray.prototype.push.apply( tmp, hilbert3D ( vec[ 6 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ) );\\n\\t\\tArray.prototype.push.apply( tmp, hilbert3D ( vec[ 7 ], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7 ) );\\n\\n\\t\\t// Return recursive call\\n\\t\\treturn tmp;\\n\\t}\\n\\n\\t// Return complete Hilbert Curve.\\n\\treturn vec;\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/PRNG.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/PRNG.js\",\n            \"module-type\": \"library\",\n            \"text\": \"// Park-Miller-Carta Pseudo-Random Number Generator\\n// https://github.com/pnitsch/BitmapData.js/blob/master/js/BitmapData.js\\n\\nvar PRNG = function () {\\n\\n\\tthis.seed = 1;\\n\\tthis.next = function() { return (this.gen() / 2147483647); };\\n\\tthis.nextRange = function(min, max)\\t{ return min + ((max - min) * this.next()) };\\n\\tthis.gen = function() { return this.seed = (this.seed * 16807) % 2147483647; };\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/AudioObject.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/AudioObject.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n * AudioObject\\n *\\n *\\t- 3d spatialized sound with Doppler-shift effect\\n *\\n *\\t- uses Audio API (currently supported in WebKit-based browsers)\\n *\\t\\thttps://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html\\n *\\n *\\t- based on Doppler effect demo from Chromium\\n * \\t\\thttp://chromium.googlecode.com/svn/trunk/samples/audio/doppler.html\\n *\\n * - parameters\\n *\\n *\\t\\t- listener\\n *\\t\\t\\tdopplerFactor\\t// A constant used to determine the amount of pitch shift to use when rendering a doppler effect.\\n *\\t\\t\\tspeedOfSound\\t// The speed of sound used for calculating doppler shift. The default value is 343.3 meters / second.\\n *\\n *\\t\\t- panner\\n *\\t\\t\\trefDistance\\t\\t// A reference distance for reducing volume as source move further from the listener.\\n *\\t\\t\\tmaxDistance\\t\\t// The maximum distance between source and listener, after which the volume will not be reduced any further.\\n *\\t\\t\\trolloffFactor\\t// Describes how quickly the volume is reduced as source moves away from listener.\\n * \\t\\t\\tconeInnerAngle\\t// An angle inside of which there will be no volume reduction.\\n *\\t\\t\\tconeOuterAngle \\t// An angle outside of which the volume will be reduced to a constant value of coneOuterGain.\\n *\\t\\t\\tconeOuterGain\\t// Amount of volume reduction outside of the coneOuterAngle.\\n */\\n\\nTHREE.AudioObject = function ( url, volume, playbackRate, loop ) {\\n\\n\\tTHREE.Object3D.call( this );\\n\\n\\tif ( playbackRate === undefined ) playbackRate = 1;\\n\\tif ( volume === undefined ) volume = 1;\\n\\tif ( loop === undefined ) loop = true;\\n\\n\\tif ( ! this.context ) {\\n\\n\\t\\ttry {\\n\\n\\t\\t\\tTHREE.AudioObject.prototype.context = new webkitAudioContext();\\n\\n\\t\\t} catch( error ) {\\n\\n\\t\\t\\tconsole.warn( \\\"THREE.AudioObject: webkitAudioContext not found\\\" );\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tthis.directionalSource = false;\\n\\n\\tthis.listener = this.context.listener;\\n\\tthis.panner = this.context.createPanner();\\n\\tthis.source = this.context.createBufferSource();\\n\\n\\tthis.masterGainNode = this.context.createGainNode();\\n\\tthis.dryGainNode = this.context.createGainNode();\\n\\n\\t// Setup initial gains\\n\\n\\tthis.masterGainNode.gain.value = volume;\\n\\tthis.dryGainNode.gain.value = 3.0;\\n\\n\\t// Connect dry mix\\n\\n\\tthis.source.connect( this.panner );\\n\\tthis.panner.connect( this.dryGainNode );\\n\\tthis.dryGainNode.connect( this.masterGainNode );\\n\\n\\t// Connect master gain\\n\\n\\tthis.masterGainNode.connect( this.context.destination );\\n\\n\\t// Set source parameters and load sound\\n\\n\\tthis.source.playbackRate.value = playbackRate;\\n\\tthis.source.loop = loop;\\n\\n\\tloadBufferAndPlay( url );\\n\\n\\t// private properties\\n\\n\\tvar soundPosition = new THREE.Vector3(),\\n\\tcameraPosition = new THREE.Vector3(),\\n\\toldSoundPosition = new THREE.Vector3(),\\n\\toldCameraPosition = new THREE.Vector3(),\\n\\n\\tsoundDelta = new THREE.Vector3(),\\n\\tcameraDelta = new THREE.Vector3(),\\n\\n\\tsoundFront = new THREE.Vector3(),\\n\\tcameraFront = new THREE.Vector3(),\\n\\tsoundUp = new THREE.Vector3(),\\n\\tcameraUp = new THREE.Vector3();\\n\\n\\tvar _this = this;\\n\\n\\t// API\\n\\n\\tthis.setVolume = function ( volume ) {\\n\\n\\t\\tthis.masterGainNode.gain.value = volume;\\n\\n\\t};\\n\\n\\tthis.update = function ( camera ) {\\n\\n\\t\\toldSoundPosition.copy( soundPosition );\\n\\t\\toldCameraPosition.copy( cameraPosition );\\n\\n\\t\\tsoundPosition.setFromMatrixPosition( this.matrixWorld );\\n\\t\\tcameraPosition.setFromMatrixPosition( camera.matrixWorld );\\n\\n\\t\\tsoundDelta.subVectors( soundPosition, oldSoundPosition );\\n\\t\\tcameraDelta.subVectors( cameraPosition, oldCameraPosition );\\n\\n\\t\\tcameraUp.copy( camera.up );\\n\\n\\t\\tcameraFront.set( 0, 0, -1 );\\n\\t\\tcameraFront.transformDirection( camera.matrixWorld );\\n\\n\\t\\tthis.listener.setPosition( cameraPosition.x, cameraPosition.y, cameraPosition.z );\\n\\t\\tthis.listener.setVelocity( cameraDelta.x, cameraDelta.y, cameraDelta.z );\\n\\t\\tthis.listener.setOrientation( cameraFront.x, cameraFront.y, cameraFront.z, cameraUp.x, cameraUp.y, cameraUp.z );\\n\\n\\t\\tthis.panner.setPosition( soundPosition.x, soundPosition.y, soundPosition.z );\\n\\t\\tthis.panner.setVelocity( soundDelta.x, soundDelta.y, soundDelta.z );\\n\\n\\t\\tif ( this.directionalSource ) {\\n\\n\\t\\t\\tsoundFront.set( 0, 0, -1 );\\n\\t\\t\\tsoundFront.transformDirection( this.matrixWorld );\\n\\n\\t\\t\\tsoundUp.copy( this.up );\\n\\t\\t\\tthis.panner.setOrientation( soundFront.x, soundFront.y, soundFront.z, soundUp.x, soundUp.y, soundUp.z );\\n\\n\\t\\t}\\n\\n\\n\\t};\\n\\n\\tfunction loadBufferAndPlay( url ) {\\n\\n\\t\\t// Load asynchronously\\n\\n\\t\\tvar request = new XMLHttpRequest();\\n\\t\\trequest.open( \\\"GET\\\", url, true );\\n\\t\\trequest.responseType = \\\"arraybuffer\\\";\\n\\n\\t\\trequest.onload = function() {\\n\\n\\t\\t\\t_this.source.buffer = _this.context.createBuffer( request.response, true );\\n\\t\\t\\t_this.source.noteOn( 0 );\\n\\n\\t\\t}\\n\\n\\t\\trequest.send();\\n\\n\\t}\\n\\n};\\n\\nTHREE.AudioObject.prototype = Object.create( THREE.Object3D.prototype );\\n\\nTHREE.AudioObject.prototype.context = null;\\nTHREE.AudioObject.prototype.type = null;\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Math/Lut.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Math/Lut.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author daron1337 / http://daron1337.github.io/\\n */\\n\\nTHREE.Lut = function ( colormap, numberofcolors ) {\\n\\n\\tthis.lut = new Array();\\n\\tthis.map = THREE.ColorMapKeywords[ colormap ];\\n\\tthis.n = numberofcolors;\\n\\tthis.mapname = colormap;\\n\\n\\tvar step = 1.0 / this.n;\\n\\n\\tfor ( var i = 0; i <= 1; i += step ) {\\n\\n\\t\\tfor ( var j = 0; j < this.map.length - 1; j ++ ) {\\n\\n\\t\\t\\tif ( i >= this.map[ j ][ 0 ] && i < this.map[ j + 1 ][ 0 ] ) {\\n\\n\\t\\t\\t\\tvar min = this.map[ j ][ 0 ];\\n\\t\\t\\t\\tvar max = this.map[ j + 1 ][ 0 ];\\n\\n\\t\\t\\t\\tvar color = new THREE.Color( 0xffffff );\\n\\t\\t\\t\\tvar minColor = new THREE.Color( 0xffffff ).setHex( this.map[ j ][ 1 ] );\\n\\t\\t\\t\\tvar maxColor = new THREE.Color( 0xffffff ).setHex( this.map[ j + 1 ][ 1 ] );\\n\\n\\t\\t\\t\\tcolor = minColor.lerp( maxColor, ( i - min ) / ( max - min ) );\\n\\n\\t\\t\\t\\tthis.lut.push(color);\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn this.set( this );\\n\\n};\\n\\nTHREE.Lut.prototype = {\\n\\n\\tconstructor: THREE.Lut,\\n\\n\\tlut: [], map: [], mapname: 'rainbow' , n: 256, minV: 0, maxV: 1, legend: null,\\n\\n\\tset: function ( value ) {\\n\\n\\t\\tif ( value instanceof THREE.Lut ) {\\n\\n\\t\\t\\tthis.copy( value );\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t},\\n\\n\\tsetMin: function ( min ) {\\n\\n\\t\\tthis.minV = min;\\n\\n\\t\\treturn this;\\n\\n\\t},\\n\\n\\tsetMax: function ( max ) {\\n\\n\\t\\tthis.maxV = max;\\n\\n\\t\\treturn this;\\n\\n\\t},\\n\\n\\tchangeNumberOfColors: function ( numberofcolors ) {\\n\\n\\t\\tthis.n = numberofcolors;\\n\\n\\t\\treturn new THREE.Lut( this.mapname, this.n );\\n\\n\\t},\\n\\n\\tchangeColorMap: function ( colormap ) {\\n\\n\\t\\tthis.mapname = colormap;\\n\\n\\t\\treturn new THREE.Lut( this.mapname, this.n );\\n\\n\\t},\\n\\n\\tcopy: function ( lut ) {\\n\\n\\t\\tthis.lut = lut.lut;\\n\\t\\tthis.mapname = lut.mapname;\\n\\t\\tthis.map = lut.map;\\n\\t\\tthis.n = lut.n;\\n\\t\\tthis.minV = lut.minV;\\n\\t\\tthis.maxV = lut.maxV;\\n\\n\\t\\treturn this;\\n\\n\\t},\\n\\n\\tgetColor: function ( alpha ) {\\n\\n\\t\\tif ( alpha <= this.minV ) {\\n\\n\\t\\t\\talpha = this.minV;\\n\\n\\t\\t} else if ( alpha >= this.maxV ) {\\n\\n\\t\\t\\talpha = this.maxV;\\n\\n\\t\\t}\\n\\n\\t\\talpha = ( alpha - this.minV ) / ( this.maxV - this.minV );\\n\\n\\t\\tvar colorPosition = Math.round ( alpha * this.n );\\n\\t\\tcolorPosition == this.n ? colorPosition -= 1 : colorPosition;\\n\\n\\t\\treturn this.lut[ colorPosition ];\\n\\n\\t},\\n\\n\\taddColorMap: function ( colormapName, arrayOfColors ) {\\n\\n\\t\\tTHREE.ColorMapKeywords[ colormapName ] = arrayOfColors;\\n\\n\\t},\\n\\n\\tsetLegendOn: function ( parameters ) {\\n\\n\\t\\tif ( parameters === undefined ) { parameters = {}; }\\n\\n\\t\\tthis.legend = {};\\n\\n\\t\\tthis.legend.layout = parameters.hasOwnProperty( 'layout' ) ? parameters[ 'layout' ] : 'vertical';\\n\\n\\t\\tthis.legend.position = parameters.hasOwnProperty( 'position' ) ? parameters[ 'position' ] : { 'x': 21.5, 'y': 8, 'z': 5 };\\n\\n\\t\\tthis.legend.dimensions = parameters.hasOwnProperty( 'dimensions' ) ? parameters[ 'dimensions' ] : { 'width': 0.5, 'height': 3 };\\n\\n\\t\\tthis.legend.canvas = document.createElement( 'canvas' );\\n\\n\\t\\tthis.legend.canvas.setAttribute( 'id', 'legend' );\\n\\t\\tthis.legend.canvas.setAttribute( 'hidden', true );\\n\\n\\t\\tdocument.body.appendChild( this.legend.canvas );\\n\\n\\t\\tthis.legend.ctx = this.legend.canvas.getContext( '2d' );\\n\\n\\t\\tthis.legend.canvas.setAttribute( 'width',  1 );\\n\\t\\tthis.legend.canvas.setAttribute( 'height', this.n );\\n\\n\\t\\tthis.legend.texture = new THREE.Texture( this.legend.canvas );\\n\\n\\t\\timageData = this.legend.ctx.getImageData( 0, 0, 1, this.n );\\n\\n\\t\\tdata = imageData.data;\\n\\t\\tlen = data.length;\\n\\n\\t\\tthis.map = THREE.ColorMapKeywords[ this.mapname ];\\n\\n\\t\\tvar k = 0;\\n\\n\\t\\tvar step = 1.0 / this.n;\\n\\n\\t\\tfor ( var i = 1; i >= 0; i-=step ) {\\n\\n\\t\\t\\tfor ( var j = this.map.length - 1; j >= 0; j-- ) {\\n\\n\\t\\t\\t\\tif ( i < this.map[ j ][ 0 ] && i >= this.map[ j - 1 ][ 0 ]  ) {\\n\\n\\t\\t\\t\\t\\tvar min = this.map[ j - 1 ][ 0 ];\\n\\t\\t\\t\\t\\tvar max = this.map[ j ][ 0 ];\\n\\t\\t\\t\\t\\tvar color = new THREE.Color( 0xffffff );\\n\\t\\t\\t\\t\\tvar minColor = new THREE.Color( 0xffffff ).setHex( this.map[ j - 1][ 1 ] );\\n\\t\\t\\t\\t\\tvar maxColor = new THREE.Color( 0xffffff ).setHex( this.map[ j ][ 1 ] );\\n\\t\\t\\t\\t\\tcolor = minColor.lerp( maxColor, ( i - min ) / ( max - min ) );\\n\\n\\t\\t\\t\\t\\tdata[ k * 4     ] = Math.round( color.r * 255 );\\n\\t\\t\\t\\t\\tdata[ k * 4 + 1 ] = Math.round( color.g * 255 );\\n\\t\\t\\t\\t\\tdata[ k * 4 + 2 ] = Math.round( color.b * 255 );\\n\\t\\t\\t\\t\\tdata[ k * 4 + 3 ] = 255;\\n\\n\\t\\t\\t\\t\\tk+=1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.legend.ctx.putImageData( imageData, 0, 0 );\\n\\t\\tthis.legend.texture.needsUpdate = true;\\n\\n\\t\\tthis.legend.legendGeometry = new THREE.PlaneGeometry( this.legend.dimensions.width , this.legend.dimensions.height );\\n\\t\\tthis.legend.legendMaterial = new THREE.MeshBasicMaterial( { map : this.legend.texture, side : THREE.DoubleSide } );\\n\\n\\t\\tthis.legend.mesh = new THREE.Mesh( this.legend.legendGeometry, this.legend.legendMaterial );\\n\\n\\t\\tif ( this.legend.layout == 'horizontal') {\\n\\n\\t\\t\\tthis.legend.mesh.rotation.z = - 90 * ( Math.PI / 180 );\\n\\n\\t\\t}\\n\\n\\t\\tthis.legend.mesh.position.copy( this.legend.position );\\n\\n\\t\\treturn this.legend.mesh;\\n\\n\\t},\\n\\n\\tsetLegendOff: function () {\\n\\n\\t\\tthis.legend = null;\\n\\n\\t\\treturn this.legend;\\n\\n\\t},\\n\\n\\tsetLegendLayout: function ( layout ) {\\n\\n\\t\\tif ( ! this.legend ) { return false; }\\n\\n\\t\\tif ( this.legend.layout == layout ) { return false; }\\n\\n\\t\\tif ( layout != 'horizontal' && layout != 'vertical' ) { return false; }\\n\\n\\t\\tthis.layout = layout;\\n\\n\\t\\tif ( layout == 'horizontal' ) {\\n\\n\\t\\t\\tthis.legend.mesh.rotation.z = 90 * ( Math.PI / 180 );\\n\\n\\t\\t}\\n\\n\\t\\tif ( layout == 'vertical' ) {\\n\\n\\t\\t\\tthis.legend.mesh.rotation.z = -90 * ( Math.PI / 180 );\\n\\n\\t\\t}\\n\\n\\t\\treturn this.legend.mesh;\\n\\n\\t},\\n\\n\\tsetLegendPosition: function ( position ) {\\n\\n\\t\\tthis.legend.position = new THREE.Vector3( position.x, position.y, position.z );\\n\\n\\t\\treturn this.legend;\\n\\n\\t},\\n\\n\\tsetLegendLabels: function ( parameters, callback ) {\\n\\n\\t\\tif ( ! this.legend ) { return false; }\\n\\n\\t\\tif ( typeof parameters === 'function') { callback = parameters; }\\n\\n\\t\\tif ( parameters === undefined ) { parameters = {}; }\\n\\n\\t\\tthis.legend.labels = {};\\n\\n\\t\\tthis.legend.labels.fontsize = parameters.hasOwnProperty( 'fontsize' ) ? parameters[ 'fontsize' ] : 24;\\n\\n\\t\\tthis.legend.labels.fontface = parameters.hasOwnProperty( 'fontface' ) ? parameters[ 'fontface' ] : 'Arial';\\n\\n\\t\\tthis.legend.labels.title = parameters.hasOwnProperty( 'title' ) ? parameters[ 'title' ] : '';\\n\\n\\t\\tthis.legend.labels.um = parameters.hasOwnProperty( 'um' ) ? ' [ '+ parameters[ 'um' ] + ' ]': '';\\n\\n\\t\\tthis.legend.labels.ticks = parameters.hasOwnProperty( 'ticks' ) ? parameters[ 'ticks' ] : 0;\\n\\n\\t\\tthis.legend.labels.decimal = parameters.hasOwnProperty( 'decimal' ) ? parameters[ 'decimal' ] : 2;\\n\\n\\t\\tthis.legend.labels.notation = parameters.hasOwnProperty( 'notation' ) ? parameters[ 'notation' ] : 'standard';\\n\\n\\t\\tvar backgroundColor = { r: 255, g: 100, b: 100, a: 0.8 };\\n\\t\\tvar borderColor =  { r: 255, g: 0, b: 0, a: 1.0 };\\n\\t\\tvar borderThickness = 4;\\n\\n\\t\\tvar canvasTitle = document.createElement( 'canvas' );\\n\\t\\tvar contextTitle = canvasTitle.getContext( '2d' );\\n\\n\\t\\tcontextTitle.font = 'Normal ' + this.legend.labels.fontsize * 1.2 + 'px ' + this.legend.labels.fontface;\\n\\n\\t\\tvar metrics = contextTitle.measureText( this.legend.labels.title.toString() + this.legend.labels.um.toString() );\\n\\t\\tvar textWidth = metrics.width;\\n\\n\\t\\tcontextTitle.fillStyle   = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + backgroundColor.a + ')';\\n\\n\\t\\tcontextTitle.strokeStyle = 'rgba(' + borderColor.r + ',' + borderColor.g + ',' + borderColor.b + ',' + borderColor.a + ')';\\n\\n\\t\\tcontextTitle.lineWidth = borderThickness;\\n\\n\\t\\tcontextTitle.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\\n\\n\\t\\tcontextTitle.fillText( this.legend.labels.title.toString() + this.legend.labels.um.toString(), borderThickness, this.legend.labels.fontsize + borderThickness );\\n\\n\\t\\tvar txtTitle = new THREE.Texture( canvasTitle );\\n\\n\\t\\ttxtTitle.needsUpdate = true;\\n\\n\\t\\tvar spriteMaterialTitle = new THREE.SpriteMaterial( { map: txtTitle, useScreenCoordinates: false } );\\n\\n\\t\\tvar spriteTitle = new THREE.Sprite( spriteMaterialTitle );\\n\\n\\t\\tspriteTitle.scale.set( 2, 1, 1.0 );\\n\\n\\t\\tif ( this.legend.layout == 'vertical' ) {\\n\\n\\t\\t\\tspriteTitle.position.set( this.legend.position.x + this.legend.dimensions.width, this.legend.position.y + ( this.legend.dimensions.height * 0.45 ), this.legend.position.z );\\n\\n\\t\\t}\\n\\n\\t\\tif ( this.legend.layout == 'horizontal' ) {\\n\\n\\t\\t\\tspriteTitle.position.set( this.legend.position.x * 1.015, this.legend.position.y + ( this.legend.dimensions.height * 0.03 ), this.legend.position.z );\\n\\n\\t\\t}\\n\\n\\t\\tif ( this.legend.labels.ticks > 0 ) {\\n\\n\\t\\t\\tvar ticks = {};\\n\\t\\t\\tvar lines = {};\\n\\n\\t\\t\\tif ( this.legend.layout == 'vertical' ) {\\n\\n\\t\\t\\t\\tvar topPositionY = this.legend.position.y + ( this.legend.dimensions.height * 0.36 );\\n\\t\\t\\t\\tvar bottomPositionY = this.legend.position.y - ( this.legend.dimensions.height * 0.61 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.legend.layout == 'horizontal' ) {\\n\\n\\t\\t\\t\\tvar topPositionX = this.legend.position.x + ( this.legend.dimensions.height * 0.75 );\\n\\t\\t\\t\\tvar bottomPositionX = this.legend.position.x - ( this.legend.dimensions.width * 1.2  ) ;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i < this.legend.labels.ticks; i++ ) {\\n\\n\\t\\t\\t\\tvar value = ( this.maxV - this.minV ) / ( this.legend.labels.ticks - 1  ) * i ;\\n\\n\\t\\t\\t\\tif ( callback ) {\\n\\n\\t\\t\\t\\t\\tvalue = callback ( value );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse {\\n\\n\\t\\t\\t\\t\\tif ( this.legend.labels.notation == 'scientific' ) {\\n\\n\\t\\t\\t\\t\\t\\tvalue = value.toExponential( this.legend.labels.decimal );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse {\\n\\n\\t\\t\\t\\t\\t\\tvalue = value.toFixed( this.legend.labels.decimal );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar canvasTick = document.createElement( 'canvas' );\\n\\t\\t\\t\\tvar contextTick = canvasTick.getContext( '2d' );\\n\\n\\t\\t\\t\\tcontextTick.font = 'Normal ' + this.legend.labels.fontsize + 'px ' + this.legend.labels.fontface;\\n\\n\\t\\t\\t\\tvar metrics = contextTick.measureText( value.toString() );\\n\\t\\t\\t\\tvar textWidth = metrics.width;\\n\\n\\t\\t\\t\\tcontextTick.fillStyle   = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + backgroundColor.a + ')';\\n\\n\\t\\t\\t\\tcontextTick.strokeStyle = 'rgba(' + borderColor.r + ',' + borderColor.g + ',' + borderColor.b + ',' + borderColor.a + ')';\\n\\n\\t\\t\\t\\tcontextTick.lineWidth = borderThickness;\\n\\n\\t\\t\\t\\tcontextTick.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\\n\\n\\t\\t\\t\\tcontextTick.fillText( value.toString(), borderThickness, this.legend.labels.fontsize + borderThickness );\\n\\n\\t\\t\\t\\tvar txtTick = new THREE.Texture( canvasTick );\\n\\n\\t\\t\\t\\ttxtTick.needsUpdate = true;\\n\\n\\t\\t\\t\\tvar spriteMaterialTick = new THREE.SpriteMaterial( { map: txtTick, useScreenCoordinates: false } );\\n\\n\\t\\t\\t\\tvar spriteTick = new THREE.Sprite( spriteMaterialTick );\\n\\n\\t\\t\\t\\tspriteTick.scale.set( 2, 1, 1.0 );\\n\\n\\t\\t\\t\\tif ( this.legend.layout == 'vertical' ) {\\n\\n\\t\\t\\t\\t\\tvar position = bottomPositionY + ( topPositionY - bottomPositionY ) * ( value / ( this.maxV - this.minV ) );\\n\\n\\t\\t\\t\\t\\tspriteTick.position.set( this.legend.position.x + ( this.legend.dimensions.width * 2.7 ), position, this.legend.position.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( this.legend.layout == 'horizontal' ) {\\n\\n\\t\\t\\t\\t\\tvar position = bottomPositionX + ( topPositionX - bottomPositionX ) * ( value / ( this.maxV - this.minV ) );\\n\\n\\t\\t\\t\\t\\tif ( this.legend.labels.ticks > 5 ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( i % 2 === 0 ) { var offset = 1.7; }\\n\\n\\t\\t\\t\\t\\t\\telse { var offset = 2.1; }\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse { var offset = 1.7; }\\n\\n\\t\\t\\t\\t\\tspriteTick.position.set( position, this.legend.position.y - this.legend.dimensions.width * offset, this.legend.position.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar material = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 2 } );\\n\\n\\t\\t\\t\\tvar geometry = new THREE.Geometry();\\n\\n\\n\\t\\t\\t\\tif ( this.legend.layout == 'vertical' ) {\\n\\n\\t\\t\\t\\t\\tvar linePosition = ( this.legend.position.y - ( this.legend.dimensions.height * 0.5 ) + 0.01 ) + ( this.legend.dimensions.height ) * ( value / ( this.maxV - this.minV ) * 0.99 );\\n\\n\\t\\t\\t\\t\\tgeometry.vertices.push( new THREE.Vector3( this.legend.position.x + this.legend.dimensions.width * 0.55, linePosition , this.legend.position.z  ) );\\n\\n\\t\\t\\t\\t\\tgeometry.vertices.push( new THREE.Vector3( this.legend.position.x + this.legend.dimensions.width * 0.7, linePosition, this.legend.position.z  ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( this.legend.layout == 'horizontal' ) {\\n\\n\\t\\t\\t\\t\\tvar linePosition = ( this.legend.position.x - ( this.legend.dimensions.height * 0.5 ) + 0.01 ) + ( this.legend.dimensions.height ) * ( value / ( this.maxV - this.minV ) * 0.99 );\\n\\n\\t\\t\\t\\t\\tgeometry.vertices.push( new THREE.Vector3( linePosition, this.legend.position.y - this.legend.dimensions.width * 0.55, this.legend.position.z  ) );\\n\\n\\t\\t\\t\\t\\tgeometry.vertices.push( new THREE.Vector3( linePosition, this.legend.position.y - this.legend.dimensions.width * 0.7, this.legend.position.z  ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar line = new THREE.Line( geometry, material );\\n\\n\\t\\t\\t\\tlines[ i ] = line;\\n\\t\\t\\t\\tticks[ i ] = spriteTick;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn { 'title': spriteTitle,  'ticks': ticks, 'lines': lines };\\n\\n\\t}\\n\\n};\\n\\n\\nTHREE.ColorMapKeywords = {\\n\\n  \\\"rainbow\\\":    [ [ 0.0, '0x0000FF' ], [ 0.2, '0x00FFFF' ], [ 0.5, '0x00FF00' ], [ 0.8, '0xFFFF00'],  [1.0, '0xFF0000' ] ],\\n  \\\"cooltowarm\\\": [ [ 0.0, '0x3C4EC2' ], [ 0.2, '0x9BBCFF' ], [ 0.5, '0xDCDCDC' ], [ 0.8, '0xF6A385'],  [1.0, '0xB40426' ] ],\\n  \\\"blackbody\\\" : [ [ 0.0, '0x000000' ], [ 0.2, '0x780000' ], [ 0.5, '0xE63200' ], [ 0.8, '0xFFFF00'],  [1.0, '0xFFFFFF' ] ],\\n  \\\"grayscale\\\" : [ [ 0.0, '0x000000' ], [ 0.2, '0x404040' ], [ 0.5, '0x7F7F80' ], [ 0.8, '0xBFBFBF'],  [1.0, '0xFFFFFF' ] ]\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Math/ColorConverter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Math/ColorConverter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author bhouston / http://exocortex.com/\\n * @author zz85 / http://github.com/zz85\\n */\\n\\nTHREE.ColorConverter = {\\n\\n\\tsetHSV: function ( color, h, s, v ) {\\n\\n\\t\\t// https://gist.github.com/xpansive/1337890#file-index-js\\n\\t\\treturn color.setHSL( h, ( s * v ) / ( ( h = ( 2 - s ) * v ) < 1 ? h : ( 2 - h ) ), h * 0.5 );\\n\\n\\t},\\n\\n\\tgetHSV: function( color ) {\\n\\n\\t\\tvar hsl = color.getHSL();\\n\\n\\t\\t// based on https://gist.github.com/xpansive/1337890#file-index-js\\n\\t\\thsl.s *= ( hsl.l < 0.5 ) ? hsl.l : ( 1 - hsl.l );\\n\\n\\t\\treturn {\\n\\t\\t\\th: hsl.h,\\n\\t\\t\\ts: 2 * hsl.s / ( hsl.l + hsl.s ),\\n\\t\\t\\tv: hsl.l + hsl.s\\n\\t\\t};\\n\\t},\\n\\n\\t// where c, m, y, k is between 0 and 1\\n\\t\\n\\tsetCMYK: function ( color, c, m, y, k ) {\\n\\n\\t\\tvar r = ( 1 - c ) * ( 1 - k );\\n\\t\\tvar g = ( 1 - m ) * ( 1 - k );\\n\\t\\tvar b = ( 1 - y ) * ( 1 - k );\\n\\n\\t\\treturn color.setRGB( r, g, b );\\n\\n\\t},\\n\\n\\tgetCMYK: function ( color ) {\\n\\n\\t\\tvar r = color.r;\\n\\t\\tvar g = color.g;\\n\\t\\tvar b = color.b;\\n\\t\\tvar k = 1 - Math.max(r, g, b);\\n\\t\\tvar c = ( 1 - r - k ) / ( 1 - k );\\n\\t\\tvar m = ( 1 - g - k ) / ( 1 - k );\\n\\t\\tvar y = ( 1 - b - k ) / ( 1 - k );\\n\\n\\t\\treturn {\\n\\t\\t\\tc: c, m: m, y: y, k: k\\n\\t\\t};\\n\\n\\t}\\n\\n\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Modifiers/TessellateModifier.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Modifiers/TessellateModifier.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * Break faces with edges longer than maxEdgeLength\\n * - not recursive\\n *\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.TessellateModifier = function ( maxEdgeLength ) {\\n\\n\\tthis.maxEdgeLength = maxEdgeLength;\\n\\n};\\n\\nTHREE.TessellateModifier.prototype.modify = function ( geometry ) {\\n\\n\\tvar i, il, face,\\n\\ta, b, c, d,\\n\\tva, vb, vc, vd,\\n\\tdab, dbc, dac, dcd, dad,\\n\\tm, m1, m2,\\n\\tvm, vm1, vm2,\\n\\tvnm, vnm1, vnm2,\\n\\tvcm, vcm1, vcm2,\\n\\ttriA, triB,\\n\\tquadA, quadB,\\n\\tedge;\\n\\n\\tvar faces = [];\\n\\tvar faceVertexUvs = [];\\n\\tvar maxEdgeLength = this.maxEdgeLength;\\n\\n\\tfor ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\\n\\n\\t\\tfaceVertexUvs[ i ] = [];\\n\\n\\t}\\n\\n\\tfor ( i = 0, il = geometry.faces.length; i < il; i ++ ) {\\n\\n\\t\\tface = geometry.faces[ i ];\\n\\n\\t\\tif ( face instanceof THREE.Face3 ) {\\n\\n\\t\\t\\ta = face.a;\\n\\t\\t\\tb = face.b;\\n\\t\\t\\tc = face.c;\\n\\n\\t\\t\\tva = geometry.vertices[ a ];\\n\\t\\t\\tvb = geometry.vertices[ b ];\\n\\t\\t\\tvc = geometry.vertices[ c ];\\n\\n\\t\\t\\tdab = va.distanceTo( vb );\\n\\t\\t\\tdbc = vb.distanceTo( vc );\\n\\t\\t\\tdac = va.distanceTo( vc );\\n\\n\\t\\t\\tif ( dab > maxEdgeLength || dbc > maxEdgeLength || dac > maxEdgeLength ) {\\n\\n\\t\\t\\t\\tm = geometry.vertices.length;\\n\\n\\t\\t\\t\\ttriA = face.clone();\\n\\t\\t\\t\\ttriB = face.clone();\\n\\n\\t\\t\\t\\tif ( dab >= dbc && dab >= dac ) {\\n\\n\\t\\t\\t\\t\\tvm = va.clone();\\n\\t\\t\\t\\t\\tvm.lerp( vb, 0.5 );\\n\\n\\t\\t\\t\\t\\ttriA.a = a;\\n\\t\\t\\t\\t\\ttriA.b = m;\\n\\t\\t\\t\\t\\ttriA.c = c;\\n\\n\\t\\t\\t\\t\\ttriB.a = m;\\n\\t\\t\\t\\t\\ttriB.b = b;\\n\\t\\t\\t\\t\\ttriB.c = c;\\n\\n\\t\\t\\t\\t\\tif ( face.vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tvnm = face.vertexNormals[ 0 ].clone();\\n\\t\\t\\t\\t\\t\\tvnm.lerp( face.vertexNormals[ 1 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\ttriA.vertexNormals[ 1 ].copy( vnm );\\n\\t\\t\\t\\t\\t\\ttriB.vertexNormals[ 0 ].copy( vnm );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( face.vertexColors.length === 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tvcm = face.vertexColors[ 0 ].clone();\\n\\t\\t\\t\\t\\t\\tvcm.lerp( face.vertexColors[ 1 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\ttriA.vertexColors[ 1 ].copy( vcm );\\n\\t\\t\\t\\t\\t\\ttriB.vertexColors[ 0 ].copy( vcm );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tedge = 0;\\n\\n\\t\\t\\t\\t} else if ( dbc >= dab && dbc >= dac ) {\\n\\n\\t\\t\\t\\t\\tvm = vb.clone();\\n\\t\\t\\t\\t\\tvm.lerp( vc, 0.5 );\\n\\n\\t\\t\\t\\t\\ttriA.a = a;\\n\\t\\t\\t\\t\\ttriA.b = b;\\n\\t\\t\\t\\t\\ttriA.c = m;\\n\\n\\t\\t\\t\\t\\ttriB.a = m;\\n\\t\\t\\t\\t\\ttriB.b = c;\\n\\t\\t\\t\\t\\ttriB.c = a;\\n\\n\\t\\t\\t\\t\\tif ( face.vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tvnm = face.vertexNormals[ 1 ].clone();\\n\\t\\t\\t\\t\\t\\tvnm.lerp( face.vertexNormals[ 2 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\ttriA.vertexNormals[ 2 ].copy( vnm );\\n\\n\\t\\t\\t\\t\\t\\ttriB.vertexNormals[ 0 ].copy( vnm );\\n\\t\\t\\t\\t\\t\\ttriB.vertexNormals[ 1 ].copy( face.vertexNormals[ 2 ] );\\n\\t\\t\\t\\t\\t\\ttriB.vertexNormals[ 2 ].copy( face.vertexNormals[ 0 ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( face.vertexColors.length === 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tvcm = face.vertexColors[ 1 ].clone();\\n\\t\\t\\t\\t\\t\\tvcm.lerp( face.vertexColors[ 2 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\ttriA.vertexColors[ 2 ].copy( vcm );\\n\\n\\t\\t\\t\\t\\t\\ttriB.vertexColors[ 0 ].copy( vcm );\\n\\t\\t\\t\\t\\t\\ttriB.vertexColors[ 1 ].copy( face.vertexColors[ 2 ] );\\n\\t\\t\\t\\t\\t\\ttriB.vertexColors[ 2 ].copy( face.vertexColors[ 0 ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tedge = 1;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvm = va.clone();\\n\\t\\t\\t\\t\\tvm.lerp( vc, 0.5 );\\n\\n\\t\\t\\t\\t\\ttriA.a = a;\\n\\t\\t\\t\\t\\ttriA.b = b;\\n\\t\\t\\t\\t\\ttriA.c = m;\\n\\n\\t\\t\\t\\t\\ttriB.a = m;\\n\\t\\t\\t\\t\\ttriB.b = b;\\n\\t\\t\\t\\t\\ttriB.c = c;\\n\\n\\t\\t\\t\\t\\tif ( face.vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tvnm = face.vertexNormals[ 0 ].clone();\\n\\t\\t\\t\\t\\t\\tvnm.lerp( face.vertexNormals[ 2 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\ttriA.vertexNormals[ 2 ].copy( vnm );\\n\\t\\t\\t\\t\\t\\ttriB.vertexNormals[ 0 ].copy( vnm );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( face.vertexColors.length === 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tvcm = face.vertexColors[ 0 ].clone();\\n\\t\\t\\t\\t\\t\\tvcm.lerp( face.vertexColors[ 2 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\ttriA.vertexColors[ 2 ].copy( vcm );\\n\\t\\t\\t\\t\\t\\ttriB.vertexColors[ 0 ].copy( vcm );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tedge = 2;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfaces.push( triA, triB );\\n\\t\\t\\t\\tgeometry.vertices.push( vm );\\n\\n\\t\\t\\t\\tvar j, jl, uvs, uvA, uvB, uvC, uvM, uvsTriA, uvsTriB;\\n\\n\\t\\t\\t\\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( geometry.faceVertexUvs[ j ].length ) {\\n\\n\\t\\t\\t\\t\\t\\tuvs = geometry.faceVertexUvs[ j ][ i ];\\n\\n\\t\\t\\t\\t\\t\\tuvA = uvs[ 0 ];\\n\\t\\t\\t\\t\\t\\tuvB = uvs[ 1 ];\\n\\t\\t\\t\\t\\t\\tuvC = uvs[ 2 ];\\n\\n\\t\\t\\t\\t\\t\\t// AB\\n\\n\\t\\t\\t\\t\\t\\tif ( edge === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tuvM = uvA.clone();\\n\\t\\t\\t\\t\\t\\t\\tuvM.lerp( uvB, 0.5 );\\n\\n\\t\\t\\t\\t\\t\\t\\tuvsTriA = [ uvA.clone(), uvM.clone(), uvC.clone() ];\\n\\t\\t\\t\\t\\t\\t\\tuvsTriB = [ uvM.clone(), uvB.clone(), uvC.clone() ];\\n\\n\\t\\t\\t\\t\\t\\t// BC\\n\\n\\t\\t\\t\\t\\t\\t} else if ( edge === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tuvM = uvB.clone();\\n\\t\\t\\t\\t\\t\\t\\tuvM.lerp( uvC, 0.5 );\\n\\n\\t\\t\\t\\t\\t\\t\\tuvsTriA = [ uvA.clone(), uvB.clone(), uvM.clone() ];\\n\\t\\t\\t\\t\\t\\t\\tuvsTriB = [ uvM.clone(), uvC.clone(), uvA.clone() ];\\n\\n\\t\\t\\t\\t\\t\\t// AC\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tuvM = uvA.clone();\\n\\t\\t\\t\\t\\t\\t\\tuvM.lerp( uvC, 0.5 );\\n\\n\\t\\t\\t\\t\\t\\t\\tuvsTriA = [ uvA.clone(), uvB.clone(), uvM.clone() ];\\n\\t\\t\\t\\t\\t\\t\\tuvsTriB = [ uvM.clone(), uvB.clone(), uvC.clone() ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfaceVertexUvs[ j ].push( uvsTriA, uvsTriB );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tfaces.push( face );\\n\\n\\t\\t\\t\\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\ta = face.a;\\n\\t\\t\\tb = face.b;\\n\\t\\t\\tc = face.c;\\n\\t\\t\\td = face.d;\\n\\n\\t\\t\\tva = geometry.vertices[ a ];\\n\\t\\t\\tvb = geometry.vertices[ b ];\\n\\t\\t\\tvc = geometry.vertices[ c ];\\n\\t\\t\\tvd = geometry.vertices[ d ];\\n\\n\\t\\t\\tdab = va.distanceTo( vb );\\n\\t\\t\\tdbc = vb.distanceTo( vc );\\n\\t\\t\\tdcd = vc.distanceTo( vd );\\n\\t\\t\\tdad = va.distanceTo( vd );\\n\\n\\t\\t\\tif ( dab > maxEdgeLength || dbc > maxEdgeLength || dcd > maxEdgeLength || dad > maxEdgeLength ) {\\n\\n\\t\\t\\t\\tm1 = geometry.vertices.length;\\n\\t\\t\\t\\tm2 = geometry.vertices.length + 1;\\n\\n\\t\\t\\t\\tquadA = face.clone();\\n\\t\\t\\t\\tquadB = face.clone();\\n\\n\\t\\t\\t\\tif ( ( dab >= dbc && dab >= dcd && dab >= dad ) || ( dcd >= dbc && dcd >= dab && dcd >= dad ) ) {\\n\\n\\t\\t\\t\\t\\tvm1 = va.clone();\\n\\t\\t\\t\\t\\tvm1.lerp( vb, 0.5 );\\n\\n\\t\\t\\t\\t\\tvm2 = vc.clone();\\n\\t\\t\\t\\t\\tvm2.lerp( vd, 0.5 );\\n\\n\\t\\t\\t\\t\\tquadA.a = a;\\n\\t\\t\\t\\t\\tquadA.b = m1;\\n\\t\\t\\t\\t\\tquadA.c = m2;\\n\\t\\t\\t\\t\\tquadA.d = d;\\n\\n\\t\\t\\t\\t\\tquadB.a = m1;\\n\\t\\t\\t\\t\\tquadB.b = b;\\n\\t\\t\\t\\t\\tquadB.c = c;\\n\\t\\t\\t\\t\\tquadB.d = m2;\\n\\n\\t\\t\\t\\t\\tif ( face.vertexNormals.length === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\tvnm1 = face.vertexNormals[ 0 ].clone();\\n\\t\\t\\t\\t\\t\\tvnm1.lerp( face.vertexNormals[ 1 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\tvnm2 = face.vertexNormals[ 2 ].clone();\\n\\t\\t\\t\\t\\t\\tvnm2.lerp( face.vertexNormals[ 3 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\tquadA.vertexNormals[ 1 ].copy( vnm1 );\\n\\t\\t\\t\\t\\t\\tquadA.vertexNormals[ 2 ].copy( vnm2 );\\n\\n\\t\\t\\t\\t\\t\\tquadB.vertexNormals[ 0 ].copy( vnm1 );\\n\\t\\t\\t\\t\\t\\tquadB.vertexNormals[ 3 ].copy( vnm2 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( face.vertexColors.length === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\tvcm1 = face.vertexColors[ 0 ].clone();\\n\\t\\t\\t\\t\\t\\tvcm1.lerp( face.vertexColors[ 1 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\tvcm2 = face.vertexColors[ 2 ].clone();\\n\\t\\t\\t\\t\\t\\tvcm2.lerp( face.vertexColors[ 3 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\tquadA.vertexColors[ 1 ].copy( vcm1 );\\n\\t\\t\\t\\t\\t\\tquadA.vertexColors[ 2 ].copy( vcm2 );\\n\\n\\t\\t\\t\\t\\t\\tquadB.vertexColors[ 0 ].copy( vcm1 );\\n\\t\\t\\t\\t\\t\\tquadB.vertexColors[ 3 ].copy( vcm2 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tedge = 0;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvm1 = vb.clone();\\n\\t\\t\\t\\t\\tvm1.lerp( vc, 0.5 );\\n\\n\\t\\t\\t\\t\\tvm2 = vd.clone();\\n\\t\\t\\t\\t\\tvm2.lerp( va, 0.5 );\\n\\n\\t\\t\\t\\t\\tquadA.a = a;\\n\\t\\t\\t\\t\\tquadA.b = b;\\n\\t\\t\\t\\t\\tquadA.c = m1;\\n\\t\\t\\t\\t\\tquadA.d = m2;\\n\\n\\t\\t\\t\\t\\tquadB.a = m2;\\n\\t\\t\\t\\t\\tquadB.b = m1;\\n\\t\\t\\t\\t\\tquadB.c = c;\\n\\t\\t\\t\\t\\tquadB.d = d;\\n\\n\\t\\t\\t\\t\\tif ( face.vertexNormals.length === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\tvnm1 = face.vertexNormals[ 1 ].clone();\\n\\t\\t\\t\\t\\t\\tvnm1.lerp( face.vertexNormals[ 2 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\tvnm2 = face.vertexNormals[ 3 ].clone();\\n\\t\\t\\t\\t\\t\\tvnm2.lerp( face.vertexNormals[ 0 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\tquadA.vertexNormals[ 2 ].copy( vnm1 );\\n\\t\\t\\t\\t\\t\\tquadA.vertexNormals[ 3 ].copy( vnm2 );\\n\\n\\t\\t\\t\\t\\t\\tquadB.vertexNormals[ 0 ].copy( vnm2 );\\n\\t\\t\\t\\t\\t\\tquadB.vertexNormals[ 1 ].copy( vnm1 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( face.vertexColors.length === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\tvcm1 = face.vertexColors[ 1 ].clone();\\n\\t\\t\\t\\t\\t\\tvcm1.lerp( face.vertexColors[ 2 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\tvcm2 = face.vertexColors[ 3 ].clone();\\n\\t\\t\\t\\t\\t\\tvcm2.lerp( face.vertexColors[ 0 ], 0.5 );\\n\\n\\t\\t\\t\\t\\t\\tquadA.vertexColors[ 2 ].copy( vcm1 );\\n\\t\\t\\t\\t\\t\\tquadA.vertexColors[ 3 ].copy( vcm2 );\\n\\n\\t\\t\\t\\t\\t\\tquadB.vertexColors[ 0 ].copy( vcm2 );\\n\\t\\t\\t\\t\\t\\tquadB.vertexColors[ 1 ].copy( vcm1 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tedge = 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfaces.push( quadA, quadB );\\n\\t\\t\\t\\tgeometry.vertices.push( vm1, vm2 );\\n\\n\\t\\t\\t\\tvar j, jl, uvs, uvA, uvB, uvC, uvD, uvM1, uvM2, uvsQuadA, uvsQuadB;\\n\\n\\t\\t\\t\\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( geometry.faceVertexUvs[ j ].length ) {\\n\\n\\t\\t\\t\\t\\t\\tuvs = geometry.faceVertexUvs[ j ][ i ];\\n\\n\\t\\t\\t\\t\\t\\tuvA = uvs[ 0 ];\\n\\t\\t\\t\\t\\t\\tuvB = uvs[ 1 ];\\n\\t\\t\\t\\t\\t\\tuvC = uvs[ 2 ];\\n\\t\\t\\t\\t\\t\\tuvD = uvs[ 3 ];\\n\\n\\t\\t\\t\\t\\t\\t// AB + CD\\n\\n\\t\\t\\t\\t\\t\\tif ( edge === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tuvM1 = uvA.clone();\\n\\t\\t\\t\\t\\t\\t\\tuvM1.lerp( uvB, 0.5 );\\n\\n\\t\\t\\t\\t\\t\\t\\tuvM2 = uvC.clone();\\n\\t\\t\\t\\t\\t\\t\\tuvM2.lerp( uvD, 0.5 );\\n\\n\\t\\t\\t\\t\\t\\t\\tuvsQuadA = [ uvA.clone(), uvM1.clone(), uvM2.clone(), uvD.clone() ];\\n\\t\\t\\t\\t\\t\\t\\tuvsQuadB = [ uvM1.clone(), uvB.clone(), uvC.clone(), uvM2.clone() ];\\n\\n\\t\\t\\t\\t\\t\\t// BC + AD\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tuvM1 = uvB.clone();\\n\\t\\t\\t\\t\\t\\t\\tuvM1.lerp( uvC, 0.5 );\\n\\n\\t\\t\\t\\t\\t\\t\\tuvM2 = uvD.clone();\\n\\t\\t\\t\\t\\t\\t\\tuvM2.lerp( uvA, 0.5 );\\n\\n\\t\\t\\t\\t\\t\\t\\tuvsQuadA = [ uvA.clone(), uvB.clone(), uvM1.clone(), uvM2.clone() ];\\n\\t\\t\\t\\t\\t\\t\\tuvsQuadB = [ uvM2.clone(), uvM1.clone(), uvC.clone(), uvD.clone() ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfaceVertexUvs[ j ].push( uvsQuadA, uvsQuadB );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tfaces.push( face );\\n\\n\\t\\t\\t\\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tgeometry.faces = faces;\\n\\tgeometry.faceVertexUvs = faceVertexUvs;\\n\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Modifiers/ExplodeModifier.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Modifiers/ExplodeModifier.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * Make all faces use unique vertices\\n * so that each face can be separated from others\\n *\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.ExplodeModifier = function () {\\n\\n};\\n\\nTHREE.ExplodeModifier.prototype.modify = function ( geometry ) {\\n\\n\\tvar vertices = [];\\n\\n\\tfor ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {\\n\\n\\t\\tvar n = vertices.length;\\n\\n\\t\\tvar face = geometry.faces[ i ];\\n\\n\\t\\tvar a = face.a;\\n\\t\\tvar b = face.b;\\n\\t\\tvar c = face.c;\\n\\n\\t\\tvar va = geometry.vertices[ a ];\\n\\t\\tvar vb = geometry.vertices[ b ];\\n\\t\\tvar vc = geometry.vertices[ c ];\\n\\n\\t\\tvertices.push( va.clone() );\\n\\t\\tvertices.push( vb.clone() );\\n\\t\\tvertices.push( vc.clone() );\\n\\n\\t\\tface.a = n;\\n\\t\\tface.b = n + 1;\\n\\t\\tface.c = n + 2;\\n\\n\\t}\\n\\n\\tgeometry.vertices = vertices;\\n\\tdelete geometry.__tmpVertices;\\n\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Modifiers/SubdivisionModifier.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Modifiers/SubdivisionModifier.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/*\\r\\n *\\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog \\r\\n *\\r\\n *\\tSubdivision Geometry Modifier \\r\\n *\\t\\tusing Loop Subdivision Scheme\\r\\n *\\r\\n *\\tReferences:\\r\\n *\\t\\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\\r\\n *\\t\\thttp://www.holmes3d.net/graphics/subdivision/\\r\\n *\\t\\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\\r\\n *\\r\\n *\\tKnown Issues:\\r\\n *\\t\\t- currently doesn't handle UVs\\r\\n *\\t\\t- currently doesn't handle \\\"Sharp Edges\\\"\\r\\n *\\r\\n */\\r\\n\\r\\nTHREE.SubdivisionModifier = function ( subdivisions ) {\\r\\n\\r\\n\\tthis.subdivisions = (subdivisions === undefined ) ? 1 : subdivisions;\\r\\n\\r\\n};\\r\\n\\r\\n// Applies the \\\"modify\\\" pattern\\r\\nTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\\r\\n\\r\\n\\tvar repeats = this.subdivisions;\\r\\n\\r\\n\\twhile ( repeats-- > 0 ) {\\r\\n\\t\\tthis.smooth( geometry );\\r\\n\\t}\\r\\n\\r\\n\\tdelete geometry.__tmpVertices;\\r\\n\\r\\n\\tgeometry.computeFaceNormals();\\r\\n\\tgeometry.computeVertexNormals();\\r\\n\\r\\n};\\r\\n\\r\\n(function() {\\r\\n\\r\\n\\t// Some constants\\r\\n\\tvar WARNINGS = !true; // Set to true for development\\r\\n\\tvar ABC = [ 'a', 'b', 'c' ];\\r\\n\\t\\r\\n\\r\\n\\tfunction getEdge( a, b, map ) {\\r\\n\\r\\n\\t\\tvar vertexIndexA = Math.min( a, b );\\r\\n\\t\\tvar vertexIndexB = Math.max( a, b );\\r\\n\\r\\n\\t\\tvar key = vertexIndexA + \\\"_\\\" + vertexIndexB;\\r\\n\\r\\n\\t\\treturn map[ key ];\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\\r\\n\\r\\n\\t\\tvar vertexIndexA = Math.min( a, b );\\r\\n\\t\\tvar vertexIndexB = Math.max( a, b );\\r\\n\\r\\n\\t\\tvar key = vertexIndexA + \\\"_\\\" + vertexIndexB;\\r\\n\\r\\n\\t\\tvar edge;\\r\\n\\r\\n\\t\\tif ( key in map ) {\\r\\n\\r\\n\\t\\t\\tedge = map[ key ];\\r\\n\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tvar vertexA = vertices[ vertexIndexA ];\\r\\n\\t\\t\\tvar vertexB = vertices[ vertexIndexB ];\\r\\n\\r\\n\\t\\t\\tedge = {\\r\\n\\r\\n\\t\\t\\t\\ta: vertexA, // pointer reference\\r\\n\\t\\t\\t\\tb: vertexB,\\r\\n\\t\\t\\t\\tnewEdge: null,\\r\\n\\t\\t\\t\\t// aIndex: a, // numbered reference\\r\\n\\t\\t\\t\\t// bIndex: b,\\r\\n\\t\\t\\t\\tfaces: [] // pointers to face\\r\\n\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tmap[ key ] = edge;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tedge.faces.push( face );\\r\\n\\r\\n\\t\\tmetaVertices[ a ].edges.push( edge );\\r\\n\\t\\tmetaVertices[ b ].edges.push( edge );\\r\\n\\t\\t\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\\r\\n\\r\\n\\t\\tvar i, il, face, edge;\\r\\n\\r\\n\\t\\tfor ( i = 0, il = vertices.length; i < il; i++ ) {\\r\\n\\t\\t\\tmetaVertices[ i ] = { edges: [] };\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tfor ( i = 0, il = faces.length; i < il; i++ ) {\\r\\n\\t\\t\\tface = faces[ i ];\\r\\n\\r\\n\\t\\t\\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\\r\\n\\t\\t\\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\\r\\n\\t\\t\\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction newFace( newFaces, a, b, c ) {\\r\\n\\r\\n\\t\\tnewFaces.push( new THREE.Face3( a, b, c ) );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t/////////////////////////////\\r\\n\\r\\n\\t// Performs one iteration of Subdivision\\r\\n\\tTHREE.SubdivisionModifier.prototype.smooth = function ( geometry ) {\\r\\n\\r\\n\\t\\tvar tmp = new THREE.Vector3();\\r\\n\\r\\n\\t\\tvar oldVertices, oldFaces;\\r\\n\\t\\tvar newVertices, newFaces; // newUVs = [];\\r\\n\\r\\n\\t\\tvar n, l, i, il, j, k;\\r\\n\\t\\tvar metaVertices, sourceEdges;\\r\\n\\r\\n\\t\\t// new stuff.\\r\\n\\t\\tvar sourceEdges, newEdgeVertices, newSourceVertices\\r\\n\\r\\n\\t\\toldVertices = geometry.vertices; // { x, y, z}\\r\\n\\t\\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\\r\\n\\r\\n\\t\\t/******************************************************\\r\\n\\t\\t *\\r\\n\\t\\t * Step 0: Preprocess Geometry to Generate edges Lookup\\r\\n\\t\\t *\\r\\n\\t\\t *******************************************************/\\r\\n\\r\\n\\t\\tmetaVertices = new Array( oldVertices.length );\\r\\n\\t\\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\\r\\n\\r\\n\\t\\tgenerateLookups(oldVertices, oldFaces, metaVertices, sourceEdges);\\r\\n\\r\\n\\r\\n\\t\\t/******************************************************\\r\\n\\t\\t *\\r\\n\\t\\t *\\tStep 1. \\r\\n\\t\\t *\\tFor each edge, create a new Edge Vertex,\\r\\n\\t\\t *\\tthen position it.\\r\\n\\t\\t *\\r\\n\\t\\t *******************************************************/\\r\\n\\r\\n\\t\\tnewEdgeVertices = [];\\r\\n\\t\\tvar other, currentEdge, newEdge, face;\\r\\n\\t\\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\\r\\n\\r\\n\\t\\tfor ( i in sourceEdges ) {\\r\\n\\r\\n\\t\\t\\tcurrentEdge = sourceEdges[ i ];\\r\\n\\t\\t\\tnewEdge = new THREE.Vector3();\\r\\n\\r\\n\\t\\t\\tedgeVertexWeight = 3 / 8;\\r\\n\\t\\t\\tadjacentVertexWeight = 1 / 8;\\r\\n\\r\\n\\t\\t\\tconnectedFaces = currentEdge.faces.length;\\r\\n\\r\\n\\t\\t\\t// check how many linked faces. 2 should be correct.\\r\\n\\t\\t\\tif ( connectedFaces != 2 ) {\\r\\n\\r\\n\\t\\t\\t\\t// if length is not 2, handle condition\\r\\n\\t\\t\\t\\tedgeVertexWeight = 0.5;\\r\\n\\t\\t\\t\\tadjacentVertexWeight = 0;\\r\\n\\r\\n\\t\\t\\t\\tif ( connectedFaces != 1 ) {\\r\\n\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tif (WARNINGS) console.warn('Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\\r\\n\\r\\n\\t\\t\\ttmp.set( 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\tfor ( j = 0; j < connectedFaces; j++ ) {\\r\\n\\r\\n\\t\\t\\t\\tface = currentEdge.faces[ j ];\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tfor ( k = 0; k < 3; k++ ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tother = oldVertices[ face[ ABC[k] ] ];\\r\\n\\t\\t\\t\\t\\tif (other !== currentEdge.a && other !== currentEdge.b ) break;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttmp.add( other );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttmp.multiplyScalar( adjacentVertexWeight );\\r\\n\\t\\t\\tnewEdge.add( tmp );\\r\\n\\r\\n\\t\\t\\tcurrentEdge.newEdge = newEdgeVertices.length;\\r\\n\\t\\t\\tnewEdgeVertices.push(newEdge);\\r\\n\\r\\n\\t\\t\\t// console.log(currentEdge, newEdge);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/******************************************************\\r\\n\\t\\t *\\r\\n\\t\\t *\\tStep 2. \\r\\n\\t\\t *\\tReposition each source vertices.\\r\\n\\t\\t *\\r\\n\\t\\t *******************************************************/\\r\\n\\r\\n\\t\\tvar beta, sourceVertexWeight, connectingVertexWeight;\\r\\n\\t\\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\\r\\n\\t\\tnewSourceVertices = [];\\r\\n\\r\\n\\t\\tfor ( i = 0, il = oldVertices.length; i < il; i++ ) {\\r\\n\\r\\n\\t\\t\\toldVertex = oldVertices[ i ];\\r\\n\\r\\n\\t\\t\\t// find all connecting edges (using lookupTable)\\r\\n\\t\\t\\tconnectingEdges = metaVertices[ i ].edges;\\r\\n\\t\\t\\tn = connectingEdges.length;\\r\\n\\t\\t\\tbeta;\\r\\n\\r\\n\\t\\t\\tif ( n == 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tbeta = 3 / 16;\\r\\n\\r\\n\\t\\t\\t} else if ( n > 3 ) {\\r\\n\\r\\n\\t\\t\\t\\tbeta = 3 / ( 8 * n ); // Warren's modified formula\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Loop's original beta formula\\r\\n\\t\\t\\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\\r\\n\\r\\n\\t\\t\\tsourceVertexWeight = 1 - n * beta;\\r\\n\\t\\t\\tconnectingVertexWeight = beta;\\r\\n\\r\\n\\t\\t\\tif ( n <= 2 ) {\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t// crease and boundary rules\\r\\n\\t\\t\\t\\t// console.warn('crease and boundary rules');\\r\\n\\r\\n\\t\\t\\t\\tif ( n == 2 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif (WARNINGS) console.warn('2 connecting edges', connectingEdges);\\r\\n\\t\\t\\t\\t\\tsourceVertexWeight = 3 / 4;\\r\\n\\t\\t\\t\\t\\tconnectingVertexWeight = 1 / 8;\\r\\n\\r\\n\\t\\t\\t\\t\\t// sourceVertexWeight = 1;\\r\\n\\t\\t\\t\\t\\t// connectingVertexWeight = 0;\\r\\n\\r\\n\\t\\t\\t\\t} else if ( n == 1 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif (WARNINGS) console.warn('only 1 connecting edge');\\r\\n\\r\\n\\t\\t\\t\\t} else if ( n == 0 ) {\\r\\n\\r\\n\\t\\t\\t\\t\\tif (WARNINGS) console.warn('0 connecting edges');\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\\r\\n\\r\\n\\t\\t\\ttmp.set( 0, 0, 0 );\\r\\n\\r\\n\\t\\t\\tfor ( j=0; j < n; j++ ) {\\r\\n\\r\\n\\t\\t\\t\\tconnectingEdge = connectingEdges[ j ];\\r\\n\\t\\t\\t\\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\\r\\n\\t\\t\\t\\ttmp.add( other );\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttmp.multiplyScalar( connectingVertexWeight );\\r\\n\\t\\t\\tnewSourceVertex.add( tmp );\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tnewSourceVertices.push( newSourceVertex );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\\t   \\r\\n\\t\\t/******************************************************\\r\\n\\t\\t *\\r\\n\\t\\t *\\tStep 3. \\r\\n\\t\\t *\\tGenerate Faces between source vertecies\\r\\n\\t\\t *\\tand edge vertices.\\r\\n\\t\\t *\\r\\n\\t\\t *******************************************************/\\r\\n\\r\\n\\t\\tnewVertices = newSourceVertices.concat( newEdgeVertices );\\r\\n\\t\\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\\r\\n\\t\\tnewFaces = [];\\r\\n\\r\\n\\t\\tfor ( i = 0, il = oldFaces.length; i < il; i++ ) {\\r\\n\\r\\n\\t\\t\\tface = oldFaces[ i ];\\r\\n\\r\\n\\t\\t\\t// find the 3 new edges vertex of each old face\\r\\n\\r\\n\\t\\t\\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\\r\\n\\t\\t\\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\\r\\n\\t\\t\\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\\r\\n\\r\\n\\t\\t\\t// create 4 faces.\\r\\n\\r\\n\\t\\t\\tnewFace( newFaces, edge1, edge2, edge3 );\\r\\n\\t\\t\\tnewFace( newFaces, face.a, edge1, edge3 );\\r\\n\\t\\t\\tnewFace( newFaces, face.b, edge2, edge1 );\\r\\n\\t\\t\\tnewFace( newFaces, face.c, edge3, edge2 );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Overwrite old arrays\\r\\n\\t\\tgeometry.vertices = newVertices;\\r\\n\\t\\tgeometry.faces = newFaces;\\r\\n\\r\\n\\t\\t// console.log('done');\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n})();\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/BlendCharacter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/BlendCharacter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author Michael Guerrero / http://realitymeltdown.com\\n */\\n\\nTHREE.BlendCharacter = function () {\\n\\n\\tthis.animations = {};\\n\\tthis.weightSchedule = [];\\n\\tthis.warpSchedule = [];\\n\\n\\tthis.load = function ( url, onLoad ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar loader = new THREE.JSONLoader();\\n\\t\\tloader.load( url, function( geometry, materials ) {\\n\\n\\t\\t\\tvar originalMaterial = materials[ 0 ];\\n\\t\\t\\toriginalMaterial.skinning = true;\\n\\n\\t\\t\\tTHREE.SkinnedMesh.call( scope, geometry, originalMaterial );\\n\\n\\t\\t\\t// Create the animations\\n\\n\\t\\t\\tfor ( var i = 0; i < geometry.animations.length; ++i ) {\\n\\n\\t\\t\\t\\tvar animName = geometry.animations[ i ].name;\\n\\t\\t\\t\\tscope.animations[ animName ] = new THREE.Animation( scope, geometry.animations[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Create the debug visualization\\n\\n\\t\\t\\tscope.skeletonHelper = new THREE.SkeletonHelper( scope );\\n\\t\\t\\tscope.skeletonHelper.material.linewidth = 3;\\n\\t\\t\\tscope.add( scope.skeletonHelper );\\n\\n\\t\\t\\tscope.showSkeleton( false );\\n\\n\\t\\t\\t// Loading is complete, fire the callback\\n\\t\\t\\tif ( onLoad !== undefined ) onLoad();\\n\\n\\t\\t} );\\n\\n\\t};\\n\\n\\tthis.update = function( dt ) {\\n\\n\\t\\tfor ( var i = this.weightSchedule.length - 1; i >= 0; --i ) {\\n\\n\\t\\t\\tvar data = this.weightSchedule[ i ];\\n\\t\\t\\tdata.timeElapsed += dt;\\n\\n\\t\\t\\t// If the transition is complete, remove it from the schedule\\n\\n\\t\\t\\tif ( data.timeElapsed > data.duration ) {\\n\\n\\t\\t\\t\\tdata.anim.weight = data.endWeight;\\n\\t\\t\\t\\tthis.weightSchedule.splice( i, 1 );\\n\\n\\t\\t\\t\\t// If we've faded out completely, stop the animation\\n\\n\\t\\t\\t\\tif ( data.anim.weight == 0 ) {\\n\\n\\t\\t\\t\\t\\tdata.anim.stop( 0 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// interpolate the weight for the current time\\n\\n\\t\\t\\t\\tdata.anim.weight = data.startWeight + (data.endWeight - data.startWeight) * data.timeElapsed / data.duration;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.updateWarps( dt );\\n\\t\\tthis.skeletonHelper.update();\\n\\n\\t};\\n\\n\\tthis.updateWarps = function( dt ) {\\n\\n\\t\\t// Warping modifies the time scale over time to make 2 animations of different\\n\\t\\t// lengths match. This is useful for smoothing out transitions that get out of\\n\\t\\t// phase such as between a walk and run cycle\\n\\n\\t\\tfor ( var i = this.warpSchedule.length - 1; i >= 0; --i ) {\\n\\n\\t\\t\\tvar data = this.warpSchedule[ i ];\\n\\t\\t\\tdata.timeElapsed += dt;\\n\\n\\t\\t\\tif ( data.timeElapsed > data.duration ) {\\n\\n\\t\\t\\t\\tdata.to.weight = 1;\\n\\t\\t\\t\\tdata.to.timeScale = 1;\\n\\t\\t\\t\\tdata.from.weight = 0;\\n\\t\\t\\t\\tdata.from.timeScale = 1;\\n\\t\\t\\t\\tdata.from.stop( 0 );\\n\\n\\t\\t\\t\\tthis.warpSchedule.splice( i, 1 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar alpha = data.timeElapsed / data.duration;\\n\\n\\t\\t\\t\\tvar fromLength = data.from.data.length;\\n\\t\\t\\t\\tvar toLength = data.to.data.length;\\n\\n\\t\\t\\t\\tvar fromToRatio = fromLength / toLength;\\n\\t\\t\\t\\tvar toFromRatio = toLength / fromLength;\\n\\n\\t\\t\\t\\t// scale from each time proportionally to the other animation\\n\\n\\t\\t\\t\\tdata.from.timeScale = ( 1 - alpha ) + fromToRatio * alpha;\\n\\t\\t\\t\\tdata.to.timeScale = alpha + toFromRatio * ( 1 - alpha );\\n\\n\\t\\t\\t\\tdata.from.weight = 1 - alpha;\\n\\t\\t\\t\\tdata.to.weight = alpha;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tthis.play = function(animName, weight) {\\n\\n\\t\\tthis.animations[ animName ].play( 0, weight );\\n\\n\\t};\\n\\n\\tthis.crossfade = function( fromAnimName, toAnimName, duration ) {\\n\\n\\t\\tvar fromAnim = this.animations[ fromAnimName ];\\n\\t\\tvar toAnim = this.animations[ toAnimName ];\\n\\n\\t\\tfromAnim.play( 0, 1 );\\n\\t\\ttoAnim.play( 0, 0 );\\n\\n\\t\\tthis.weightSchedule.push( {\\n\\n\\t\\t\\tanim: fromAnim,\\n\\t\\t\\tstartWeight: 1,\\n\\t\\t\\tendWeight: 0,\\n\\t\\t\\ttimeElapsed: 0,\\n\\t\\t\\tduration: duration\\n\\n\\t\\t} );\\n\\n\\t\\tthis.weightSchedule.push( {\\n\\n\\t\\t\\tanim: toAnim,\\n\\t\\t\\tstartWeight: 0,\\n\\t\\t\\tendWeight: 1,\\n\\t\\t\\ttimeElapsed: 0,\\n\\t\\t\\tduration: duration\\n\\n\\t\\t} );\\n\\n\\t};\\n\\n\\tthis.warp = function( fromAnimName, toAnimName, duration ) {\\n\\n\\t\\tvar fromAnim = this.animations[ fromAnimName ];\\n\\t\\tvar toAnim = this.animations[ toAnimName ];\\n\\n\\t\\tfromAnim.play( 0, 1 );\\n\\t\\ttoAnim.play( 0, 0 );\\n\\n\\t\\tthis.warpSchedule.push( {\\n\\n\\t\\t\\tfrom: fromAnim,\\n\\t\\t\\tto: toAnim,\\n\\t\\t\\ttimeElapsed: 0,\\n\\t\\t\\tduration: duration\\n\\n\\t\\t} );\\n\\n\\t};\\n\\n\\tthis.applyWeight = function(animName, weight) {\\n\\n\\t\\tthis.animations[ animName ].weight = weight;\\n\\n\\t};\\n\\n\\tthis.pauseAll = function() {\\n\\n\\t\\tfor ( var a in this.animations ) {\\n\\n\\t\\t\\tif ( this.animations[ a ].isPlaying ) {\\n\\n\\t\\t\\t\\tthis.animations[ a ].stop();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.unPauseAll = function() {\\n\\n\\tfor ( var a in this.animations ) {\\n\\n\\t  if ( this.animations[ a ].isPlaying && this.animations[ a ].isPaused ) {\\n\\n\\t\\tthis.animations[ a ].pause();\\n\\n\\t  }\\n\\n\\t}\\n\\n  };\\n\\n\\n\\tthis.stopAll = function() {\\n\\n\\t\\tfor ( a in this.animations ) {\\n\\n\\t\\t\\tif ( this.animations[ a ].isPlaying ) {\\n\\t\\t\\t\\tthis.animations[ a ].stop(0);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.animations[ a ].weight = 0;\\n\\n\\t\\t}\\n\\n\\t\\tthis.weightSchedule.length = 0;\\n\\t\\tthis.warpSchedule.length = 0;\\n\\n\\t}\\n\\n\\tthis.showSkeleton = function( boolean ) {\\n\\n\\t\\tthis.skeletonHelper.visible = boolean;\\n\\n\\t}\\n\\n\\tthis.showModel = function( boolean ) {\\n\\n\\t\\tthis.visible = boolean;\\n\\n\\t}\\n\\n};\\n\\n\\nTHREE.BlendCharacter.prototype = Object.create( THREE.SkinnedMesh.prototype );\\n\\nTHREE.BlendCharacter.prototype.getForward = function() {\\n\\n\\tvar forward = new THREE.Vector3();\\n\\n\\treturn function() {\\n\\n\\t\\t// pull the character's forward basis vector out of the matrix\\n\\t\\tforward.set(\\n\\t\\t\\t-this.matrix.elements[ 8 ],\\n\\t\\t\\t-this.matrix.elements[ 9 ],\\n\\t\\t\\t-this.matrix.elements[ 10 ]\\n\\t\\t);\\n\\n\\t\\treturn forward;\\n\\t}\\n}\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/SkyShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/SkyShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author zz85 / https://github.com/zz85\\n * \\n * Based on \\\"A Practical Analytic Model for Daylight\\\" \\n * aka The Preetham Model, the de facto standard analytic skydome model\\n * http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\\n * \\n * First implemented by Simon Wallner\\n * http://www.simonwallner.at/projects/atmospheric-scattering\\n * \\n * Improved by Martin Upitis\\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\\n * \\n * Three.js integration by zz85 http://twitter.com/blurspline\\n*/\\n\\nTHREE.ShaderLib['sky'] = {\\n\\n\\tuniforms: {\\n\\n\\t\\tluminance:\\t { type: \\\"f\\\", value:1 },\\n\\t\\tturbidity:\\t { type: \\\"f\\\", value:2 },\\n\\t\\treileigh:\\t { type: \\\"f\\\", value:1 },\\n\\t\\tmieCoefficient:\\t { type: \\\"f\\\", value:0.005 },\\n\\t\\tmieDirectionalG: { type: \\\"f\\\", value:0.8 },\\n\\t\\tsunPosition: \\t { type: \\\"v3\\\", value: new THREE.Vector3() }\\n\\n\\t},\\n\\n\\tvertexShader: [\\n\\n\\t\\t\\\"varying vec3 vWorldPosition;\\\",\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\\"vWorldPosition = worldPosition.xyz;\\\",\\n\\t\\t\\t\\\"vUv = uv;\\\",\\n\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\\"}\\\",\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tfragmentShader: [\\n\\n\\n\\t\\t\\\"uniform sampler2D skySampler;\\\",\\n\\t\\t\\\"uniform vec3 sunPosition;\\\",\\n\\t\\t\\\"varying vec3 vWorldPosition;\\\",\\n\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\n\\t\\t\\\"vec3 cameraPos = vec3(0., 0., 0.);\\\",\\n\\t\\t\\\"// uniform sampler2D sDiffuse;\\\",\\n\\t\\t\\\"// const float turbidity = 10.0; //\\\",\\n\\t\\t\\\"// const float reileigh = 2.; //\\\",\\n\\t\\t\\\"// const float luminance = 1.0; //\\\",\\n\\t\\t\\\"// const float mieCoefficient = 0.005;\\\",\\n\\t\\t\\\"// const float mieDirectionalG = 0.8;\\\",\\n\\n\\t\\t\\\"uniform float luminance;\\\",\\n\\t\\t\\\"uniform float turbidity;\\\",\\n\\t\\t\\\"uniform float reileigh;\\\",\\n\\t\\t\\\"uniform float mieCoefficient;\\\",\\n\\t\\t\\\"uniform float mieDirectionalG;\\\",\\n\\n\\n\\t\\t\\\"vec3 sunDirection = normalize(sunPosition);\\\",\\n\\t\\t\\\"float reileighCoefficient = reileigh;\\\",\\n\\n\\t\\t\\\"// constants for atmospheric scattering\\\",\\n\\t\\t\\\"const float e = 2.71828182845904523536028747135266249775724709369995957;\\\",\\n\\t\\t\\\"const float pi = 3.141592653589793238462643383279502884197169;\\\",\\n\\n\\t\\t\\\"const float n = 1.0003; // refractive index of air\\\",\\n\\t\\t\\\"const float N = 2.545E25; // number of molecules per unit volume for air at\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\\"// 288.15K and 1013mb (sea level -45 celsius)\\\",\\n\\t\\t\\\"const float pn = 0.035;\\t// depolatization factor for standard air\\\",\\n\\n\\t\\t\\\"// wavelength of used primaries, according to preetham\\\",\\n\\t\\t\\\"const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\\\",\\n\\n\\t\\t\\\"// mie stuff\\\",\\n\\t\\t\\\"// K coefficient for the primaries\\\",\\n\\t\\t\\\"const vec3 K = vec3(0.686, 0.678, 0.666);\\\",\\n\\t\\t\\\"const float v = 4.0;\\\",\\n\\n\\t\\t\\\"// optical length at zenith for molecules\\\",\\n\\t\\t\\\"const float rayleighZenithLength = 8.4E3;\\\",\\n\\t\\t\\\"const float mieZenithLength = 1.25E3;\\\",\\n\\t\\t\\\"const vec3 up = vec3(0.0, 1.0, 0.0);\\\",\\n\\n\\t\\t\\\"const float EE = 1000.0;\\\",\\n\\t\\t\\\"const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\\\",\\n\\t\\t\\\"// 66 arc seconds -> degrees, and the cosine of that\\\",\\n\\n\\t\\t\\\"// earth shadow hack\\\",\\n\\t\\t\\\"const float cutoffAngle = pi/1.95;\\\",\\n\\t\\t\\\"const float steepness = 1.5;\\\",\\n\\n\\n\\t\\t\\\"vec3 totalRayleigh(vec3 lambda)\\\",\\n\\t\\t\\\"{\\\",\\n\\t\\t\\t\\\"return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"float rayleighPhase(float cosTheta)\\\",\\n\\t\\t\\\"{\\t \\\",\\n\\t\\t\\t\\\"return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));\\\",\\n\\t\\t\\\"//\\treturn (1.0 / (3.0*pi)) * (1.0 + pow(cosTheta, 2.0));\\\",\\n\\t\\t\\\"//\\treturn (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"vec3 totalMie(vec3 lambda, vec3 K, float T)\\\",\\n\\t\\t\\\"{\\\",\\n\\t\\t\\t\\\"float c = (0.2 * T ) * 10E-18;\\\",\\n\\t\\t\\t\\\"return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"float hgPhase(float cosTheta, float g)\\\",\\n\\t\\t\\\"{\\\",\\n\\t\\t\\t\\\"return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"float sunIntensity(float zenithAngleCos)\\\",\\n\\t\\t\\\"{\\\",\\n\\t\\t\\t\\\"return EE * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t\\t\\\"// float logLuminance(vec3 c)\\\",\\n\\t\\t\\\"// {\\\",\\n\\t\\t\\\"// \\treturn log(c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722);\\\",\\n\\t\\t\\\"// }\\\",\\n\\n\\t\\t\\\"// Filmic ToneMapping http://filmicgames.com/archives/75\\\",\\n\\t\\t\\\"float A = 0.15;\\\",\\n\\t\\t\\\"float B = 0.50;\\\",\\n\\t\\t\\\"float C = 0.10;\\\",\\n\\t\\t\\\"float D = 0.20;\\\",\\n\\t\\t\\\"float E = 0.02;\\\",\\n\\t\\t\\\"float F = 0.30;\\\",\\n\\t\\t\\\"float W = 1000.0;\\\",\\n\\n\\t\\t\\\"vec3 Uncharted2Tonemap(vec3 x)\\\",\\n\\t\\t\\\"{\\\",\\n\\t\\t   \\\"return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\n\\t\\t\\\"void main() \\\",\\n\\t\\t\\\"{\\\",\\n\\t\\t\\t\\\"float sunfade = 1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);\\\",\\n\\n\\t\\t\\t\\\"// luminance =  1.0 ;// vWorldPosition.y / 450000. + 0.5; //sunPosition.y / 450000. * 1. + 0.5;\\\",\\n\\n\\t\\t\\t \\\"// gl_FragColor = vec4(sunfade, sunfade, sunfade, 1.0);\\\",\\n\\t\\t\\t\\n\\t\\t\\t\\\"reileighCoefficient = reileighCoefficient - (1.0* (1.0-sunfade));\\\",\\n\\t\\t\\t\\n\\t\\t\\t\\\"float sunE = sunIntensity(dot(sunDirection, up));\\\",\\n\\n\\t\\t\\t\\\"// extinction (absorbtion + out scattering) \\\",\\n\\t\\t\\t\\\"// rayleigh coefficients\\\",\\n\\t\\t\\t\\\"vec3 betaR = totalRayleigh(lambda) * reileighCoefficient;\\\",\\n\\n\\t\\t\\t\\\"// mie coefficients\\\",\\n\\t\\t\\t\\\"vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\\\",\\n\\n\\t\\t\\t\\\"// optical length\\\",\\n\\t\\t\\t\\\"// cutoff angle at 90 to avoid singularity in next formula.\\\",\\n\\t\\t\\t\\\"float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\\\",\\n\\t\\t\\t\\\"float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\\\",\\n\\t\\t\\t\\\"float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\\\",\\n\\n\\n\\n\\t\\t\\t\\\"// combined extinction factor\\t\\\",\\n\\t\\t\\t\\\"vec3 Fex = exp(-(betaR * sR + betaM * sM));\\\",\\n\\n\\t\\t\\t\\\"// in scattering\\\",\\n\\t\\t\\t\\\"float cosTheta = dot(normalize(vWorldPosition - cameraPos), sunDirection);\\\",\\n\\n\\t\\t\\t\\\"float rPhase = rayleighPhase(cosTheta*0.5+0.5);\\\",\\n\\t\\t\\t\\\"vec3 betaRTheta = betaR * rPhase;\\\",\\n\\n\\t\\t\\t\\\"float mPhase = hgPhase(cosTheta, mieDirectionalG);\\\",\\n\\t\\t\\t\\\"vec3 betaMTheta = betaM * mPhase;\\\",\\n\\n\\n\\t\\t\\t\\\"vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\\\",\\n\\t\\t\\t\\\"Lin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, sunDirection),5.0),0.0,1.0));\\\",\\n\\n\\t\\t\\t\\\"//nightsky\\\",\\n\\t\\t\\t\\\"vec3 direction = normalize(vWorldPosition - cameraPos);\\\",\\n\\t\\t\\t\\\"float theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]\\\",\\n\\t\\t\\t\\\"float phi = atan(direction.z, direction.x); // azimuth --> x-axis [-pi/2, pi/2]\\\",\\n\\t\\t\\t\\\"vec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);\\\",\\n\\t\\t\\t\\\"// vec3 L0 = texture2D(skySampler, uv).rgb+0.1 * Fex;\\\",\\n\\t\\t\\t\\\"vec3 L0 = vec3(0.1) * Fex;\\\",\\n\\t\\t\\t\\n\\t\\t\\t\\\"// composition + solar disc\\\",\\n\\t\\t\\t\\\"//if (cosTheta > sunAngularDiameterCos)\\\",\\n\\t\\t\\t\\\"float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);\\\",\\n\\t\\t\\t\\\"// if (normalize(vWorldPosition - cameraPos).y>0.0)\\\",\\n\\t\\t\\t\\\"L0 += (sunE * 19000.0 * Fex)*sundisk;\\\",\\n\\n\\n\\t\\t\\t\\\"vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));\\\",\\n\\t\\t\\t\\n\\t\\t\\t\\\"vec3 texColor = (Lin+L0);   \\\",\\n\\t\\t\\t\\\"texColor *= 0.04 ;\\\",\\n\\t\\t\\t\\\"texColor += vec3(0.0,0.001,0.0025)*0.3;\\\",\\n\\t\\t\\t\\n\\t\\t\\t\\\"float g_fMaxLuminance = 1.0;\\\",\\n\\t\\t\\t\\\"float fLumScaled = 0.1 / luminance;     \\\",\\n\\t\\t\\t\\\"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled); \\\",\\n\\n\\t\\t\\t\\\"float ExposureBias = fLumCompressed;\\\",\\n\\t\\t   \\n\\t\\t\\t\\\"vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);\\\",\\n\\t\\t\\t\\\"vec3 color = curr*whiteScale;\\\",\\n\\n\\t\\t\\t\\\"vec3 retColor = pow(color,vec3(1.0/(1.2+(1.2*sunfade))));\\\",\\n\\n\\t\\t\\t\\n\\t\\t\\t\\\"gl_FragColor.rgb = retColor;\\\",\\n\\t\\t\\t\\t\\n\\t\\t\\t\\\"gl_FragColor.a = 1.0;\\\",\\n\\t\\t\\\"}\\\",\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\\nTHREE.Sky = function () {\\n\\n\\tvar skyShader = THREE.ShaderLib[ \\\"sky\\\" ];\\n\\tvar skyUniforms = THREE.UniformsUtils.clone( skyShader.uniforms );\\n\\n\\tvar skyMat = new THREE.ShaderMaterial( { \\n\\t\\tfragmentShader: skyShader.fragmentShader, \\n\\t\\tvertexShader: skyShader.vertexShader, \\n\\t\\tuniforms: skyUniforms,\\n\\t\\tside: THREE.BackSide\\n\\t} );\\n\\n\\tvar skyGeo = new THREE.SphereGeometry( 450000, 32, 15 );\\n\\tvar skyMesh = new THREE.Mesh( skyGeo, skyMat );\\n\\n\\n\\t// Expose variables\\n\\tthis.mesh = skyMesh;\\n\\tthis.uniforms = skyUniforms;\\n\\n\\n};\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/SimulationRenderer.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/SimulationRenderer.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author zz85 https://github.com/zz85 / http://www.lab4games.net/zz85/blog\\n *\\n * Bird Simulation Render\\n *\\n * \\tA simple scene rendering a quad of the following shaders\\n *\\t1. Pass-thru Shader,\\n *\\t2. Bird Position Update Shader,\\n *\\t3. Bird Velocity Update Shader\\n *\\n */\\n\\nfunction SimulationRenderer(WIDTH, renderer) {\\n\\n\\tWIDTH = WIDTH || 4;\\n\\tvar camera = new THREE.Camera();\\n\\tcamera.position.z = 1;\\n\\n\\t// Init RTT stuff\\n\\tgl = renderer.getContext();\\n\\n\\tif( !gl.getExtension( \\\"OES_texture_float\\\" )) {\\n\\t\\talert( \\\"No OES_texture_float support for float textures!\\\" );\\n\\t\\treturn;\\n\\t}\\n\\n\\tif( gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) == 0) {\\n\\t\\talert( \\\"No support for vertex shader textures!\\\" );\\n\\t\\treturn;\\n\\t}\\n\\n\\tvar scene = new THREE.Scene();\\n\\n\\tvar uniforms = {\\n\\t\\ttime: { type: \\\"f\\\", value: 1.0 },\\n\\t\\tresolution: { type: \\\"v2\\\", value: new THREE.Vector2( WIDTH, WIDTH ) },\\n\\t\\ttexture: { type: \\\"t\\\", value: null }\\n\\t};\\n\\n\\tvar passThruShader = new THREE.ShaderMaterial( {\\n\\t\\tuniforms: uniforms,\\n\\t\\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\\n\\t\\tfragmentShader: document.getElementById( 'fragmentShader' ).textContent\\n\\t} );\\n\\n\\tvar mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), passThruShader );\\n\\n\\tvar positionShader = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: {\\n\\t\\t\\ttime: { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\tdelta: { type: \\\"f\\\", value: 0.0 },\\n\\t\\t\\tresolution: { type: \\\"v2\\\", value: new THREE.Vector2( WIDTH, WIDTH ) },\\n\\t\\t\\ttexturePosition: { type: \\\"t\\\", value: null },\\n\\t\\t\\ttextureVelocity: { type: \\\"t\\\", value: null },\\n\\t\\t},\\n\\t\\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\\n\\t\\tfragmentShader: document.getElementById( 'fragmentShaderPosition' ).textContent\\n\\n\\t} );\\n\\n\\tthis.positionShader = positionShader;\\n\\n\\tvar velocityShader = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms: {\\n\\t\\t\\ttime: { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\tdelta: { type: \\\"f\\\", value: 0.0 },\\n\\t\\t\\tresolution: { type: \\\"v2\\\", value: new THREE.Vector2( WIDTH, WIDTH ) },\\n\\t\\t\\ttexturePosition: { type: \\\"t\\\", value: null },\\n\\t\\t\\ttextureVelocity: { type: \\\"t\\\", value: null },\\n\\t\\t\\ttesting: { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\tseperationDistance: { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\talignmentDistance: { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\tcohesionDistance: { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\tfreedomFactor: { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\tpredator: { type: \\\"v3\\\", value: new THREE.Vector3() }\\n\\t\\t},\\n\\t\\tdefines: {\\n\\t\\t\\tWIDTH: WIDTH.toFixed(2)\\n\\t\\t},\\n\\t\\tvertexShader: document.getElementById( 'vertexShader' ).textContent,\\n\\t\\tfragmentShader: document.getElementById( 'fragmentShaderVelocity' ).textContent\\n\\n\\t} );\\n\\n\\tthis.velocityUniforms = velocityShader.uniforms;\\n\\n\\tscene.add( mesh );\\n\\n\\tvar flipflop = true;\\n\\tvar rtPosition1, rtPosition2, rtVelocity1, rtVelocity2;\\n\\n\\tfunction init() {\\n\\t\\tvar dtPosition = generatePositionTexture();\\n\\t\\tvar dtVelocity = generateVelocityTexture();\\n\\n\\t\\trtPosition1 = getRenderTarget( THREE.RGBAFormat );\\n\\t\\trtPosition2 = rtPosition1.clone();\\n\\t\\trtVelocity1 = getRenderTarget( THREE.RGBFormat );\\n\\t\\trtVelocity2 = rtVelocity1.clone();\\n\\n\\t\\tsimulator.renderTexture(dtPosition, rtPosition1);\\n\\t\\tsimulator.renderTexture(rtPosition1, rtPosition2);\\n\\n\\t\\tsimulator.renderTexture(dtVelocity, rtVelocity1);\\n\\t\\tsimulator.renderTexture(rtVelocity1, rtVelocity2);\\n\\n\\t\\tsimulator.velocityUniforms.testing.value = 10;\\n\\t}\\n\\n\\tthis.init = init;\\n\\n\\tfunction getRenderTarget( type ) {\\n\\t\\tvar renderTarget = new THREE.WebGLRenderTarget(WIDTH, WIDTH, {\\n\\t\\t\\twrapS: THREE.RepeatWrapping,\\n\\t\\t\\twrapT: THREE.RepeatWrapping,\\n\\t\\t\\tminFilter: THREE.NearestFilter,\\n\\t\\t\\tmagFilter: THREE.NearestFilter,\\n\\t\\t\\tformat: type,\\n\\t\\t\\ttype: THREE.FloatType,\\n\\t\\t\\tstencilBuffer: false\\n\\t\\t});\\n\\n\\t\\treturn renderTarget;\\n\\t}\\n\\n\\t// Takes a texture, and render out as another texture\\n\\tthis.renderTexture = function ( input, output ) {\\n\\t\\tmesh.material = passThruShader;\\n\\t\\tuniforms.texture.value = input;\\n\\t\\trenderer.render( scene, camera, output );\\n\\t}\\n\\n\\n\\tthis.renderPosition = function(position, velocity, output, delta) {\\n\\t\\tmesh.material = positionShader;\\n\\t\\tpositionShader.uniforms.texturePosition.value = position;\\n\\t\\tpositionShader.uniforms.textureVelocity.value = velocity;\\n\\t\\tpositionShader.uniforms.time.value = performance.now();\\n\\t\\tpositionShader.uniforms.delta.value = delta;\\n\\t\\trenderer.render( scene, camera, output );\\n\\t\\tthis.currentPosition = output;\\n\\t}\\n\\n\\tthis.renderVelocity = function(position, velocity, output, delta) {\\n\\t\\tmesh.material = velocityShader;\\n\\t\\tvelocityShader.uniforms.texturePosition.value = position;\\n\\t\\tvelocityShader.uniforms.textureVelocity.value = velocity;\\n\\t\\tvelocityShader.uniforms.time.value = performance.now();\\n\\t\\tvelocityShader.uniforms.delta.value = delta;\\n\\t\\trenderer.render( scene, camera, output );\\n\\t\\tthis.currentVelocity = output;\\n\\t}\\n\\n\\tthis.simulate = function( delta ) {\\n\\n\\t\\tif (flipflop) {\\n\\n\\t\\t\\tsimulator.renderVelocity( rtPosition1, rtVelocity1, rtVelocity2, delta );\\n\\t\\t\\tsimulator.renderPosition( rtPosition1, rtVelocity2, rtPosition2, delta );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tsimulator.renderVelocity( rtPosition2, rtVelocity2, rtVelocity1, delta );\\n\\t\\t\\tsimulator.renderPosition( rtPosition2, rtVelocity1, rtPosition1, delta );\\n\\n\\t\\t}\\n\\n\\t\\tflipflop = !flipflop;\\n\\n\\t}\\n\\n\\tfunction generatePositionTexture() {\\n\\n\\t\\tvar a = new Float32Array( PARTICLES * 4 );\\n\\n\\t\\tfor ( var k = 0, kl = a.length; k < kl; k += 4 ) {\\n\\n\\t\\t\\tvar x = Math.random() * BOUNDS - BOUNDS_HALF;\\n\\t\\t\\tvar y = Math.random() * BOUNDS - BOUNDS_HALF;\\n\\t\\t\\tvar z = Math.random() * BOUNDS - BOUNDS_HALF;\\n\\n\\t\\t\\ta[ k + 0 ] = x;\\n\\t\\t\\ta[ k + 1 ] = y;\\n\\t\\t\\ta[ k + 2 ] = z;\\n\\t\\t\\ta[ k + 3 ] = 1;\\n\\n\\t\\t}\\n\\n\\t\\tvar texture = new THREE.DataTexture( a, WIDTH, WIDTH, THREE.RGBAFormat, THREE.FloatType );\\n\\t\\ttexture.minFilter = THREE.NearestFilter;\\n\\t\\ttexture.magFilter = THREE.NearestFilter;\\n\\t\\ttexture.needsUpdate = true;\\n\\t\\ttexture.flipY = false;\\n\\n\\t\\treturn texture;\\n\\n\\t}\\n\\n\\tfunction generateVelocityTexture() {\\n\\n\\t\\tvar a = new Float32Array( PARTICLES * 3 );\\n\\n\\t\\tfor ( var k = 0, kl = a.length; k < kl; k += 3 ) {\\n\\n\\t\\t\\tvar x = Math.random() - 0.5;\\n\\t\\t\\tvar y = Math.random() - 0.5;\\n\\t\\t\\tvar z = Math.random() - 0.5;\\n\\n\\t\\t\\ta[ k + 0 ] = x * 10;\\n\\t\\t\\ta[ k + 1 ] = y * 10;\\n\\t\\t\\ta[ k + 2 ] = z * 10;\\n\\n\\t\\t}\\n\\n\\t\\tvar texture = new THREE.DataTexture( a, WIDTH, WIDTH, THREE.RGBFormat, THREE.FloatType );\\n\\t\\ttexture.minFilter = THREE.NearestFilter;\\n\\t\\ttexture.magFilter = THREE.NearestFilter;\\n\\t\\ttexture.needsUpdate = true;\\n\\t\\ttexture.flipY = false;\\n\\n\\t\\treturn texture;\\n\\n\\t}\\n\\n}\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/ImprovedNoise.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/ImprovedNoise.js\",\n            \"module-type\": \"library\",\n            \"text\": \"// http://mrl.nyu.edu/~perlin/noise/\\n\\nvar ImprovedNoise = function () {\\n\\n\\tvar p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,\\n\\t\\t 23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,\\n\\t\\t 174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,\\n\\t\\t 133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,\\n\\t\\t 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,\\n\\t\\t 202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,\\n\\t\\t 248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,\\n\\t\\t 178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,\\n\\t\\t 14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,\\n\\t\\t 93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\\n\\n\\tfor (var i=0; i < 256 ; i++) {\\n\\n\\t\\tp[256+i] = p[i];\\n\\n\\t}\\n\\n\\tfunction fade(t) {\\n\\n\\t\\treturn t * t * t * (t * (t * 6 - 15) + 10);\\n\\n\\t}\\n\\n\\tfunction lerp(t, a, b) {\\n\\n\\t\\treturn a + t * (b - a);\\n\\n\\t}\\n\\n\\tfunction grad(hash, x, y, z) {\\n\\n\\t\\tvar h = hash & 15;\\n\\t\\tvar u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;\\n\\t\\treturn ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\\n\\n\\t}\\n\\n\\treturn {\\n\\n\\t\\tnoise: function (x, y, z) {\\n\\n\\t\\t\\tvar floorX = ~~x, floorY = ~~y, floorZ = ~~z;\\n\\n\\t\\t\\tvar X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;\\n\\n\\t\\t\\tx -= floorX;\\n\\t\\t\\ty -= floorY;\\n\\t\\t\\tz -= floorZ;\\n\\n\\t\\t\\tvar xMinus1 = x -1, yMinus1 = y - 1, zMinus1 = z - 1;\\n\\n\\t\\t\\tvar u = fade(x), v = fade(y), w = fade(z);\\n\\n\\t\\t\\tvar A = p[X]+Y, AA = p[A]+Z, AB = p[A+1]+Z, B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;\\n\\n\\t\\t\\treturn lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), \\n\\t\\t\\t\\t\\t\\t\\tgrad(p[BA], xMinus1, y, z)),\\n\\t\\t\\t\\t\\t\\tlerp(u, grad(p[AB], x, yMinus1, z),\\n\\t\\t\\t\\t\\t\\t\\tgrad(p[BB], xMinus1, yMinus1, z))),\\n\\t\\t\\t\\t\\tlerp(v, lerp(u, grad(p[AA+1], x, y, zMinus1),\\n\\t\\t\\t\\t\\t\\t\\tgrad(p[BA+1], xMinus1, y, z-1)),\\n\\t\\t\\t\\t\\t\\tlerp(u, grad(p[AB+1], x, yMinus1, zMinus1),\\n\\t\\t\\t\\t\\t\\t\\tgrad(p[BB+1], xMinus1, yMinus1, zMinus1))));\\n\\n\\t\\t}\\n\\t}\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/ShaderTerrain.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/ShaderTerrain.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n *\\n */\\n\\nTHREE.ShaderTerrain = {\\n\\n\\t/* -------------------------------------------------------------------------\\n\\t//\\tDynamic terrain shader\\n\\t//\\t\\t- Blinn-Phong\\n\\t//\\t\\t- height + normal + diffuse1 + diffuse2 + specular + detail maps\\n\\t//\\t\\t- point, directional and hemisphere lights (use with \\\"lights: true\\\" material option)\\n\\t//\\t\\t- shadow maps receiving\\n\\t ------------------------------------------------------------------------- */\\n\\n\\t'terrain' : {\\n\\n\\t\\tuniforms: THREE.UniformsUtils.merge( [\\n\\n\\t\\t\\tTHREE.UniformsLib[ \\\"fog\\\" ],\\n\\t\\t\\tTHREE.UniformsLib[ \\\"lights\\\" ],\\n\\t\\t\\tTHREE.UniformsLib[ \\\"shadowmap\\\" ],\\n\\n\\t\\t\\t{\\n\\n\\t\\t\\t\\\"enableDiffuse1\\\"  : { type: \\\"i\\\", value: 0 },\\n\\t\\t\\t\\\"enableDiffuse2\\\"  : { type: \\\"i\\\", value: 0 },\\n\\t\\t\\t\\\"enableSpecular\\\"  : { type: \\\"i\\\", value: 0 },\\n\\t\\t\\t\\\"enableReflection\\\": { type: \\\"i\\\", value: 0 },\\n\\n\\t\\t\\t\\\"tDiffuse1\\\"\\t   : { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"tDiffuse2\\\"\\t   : { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"tDetail\\\"\\t   : { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"tNormal\\\"\\t   : { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"tSpecular\\\"\\t   : { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\\"tDisplacement\\\": { type: \\\"t\\\", value: null },\\n\\n\\t\\t\\t\\\"uNormalScale\\\": { type: \\\"f\\\", value: 1.0 },\\n\\n\\t\\t\\t\\\"uDisplacementBias\\\": { type: \\\"f\\\", value: 0.0 },\\n\\t\\t\\t\\\"uDisplacementScale\\\": { type: \\\"f\\\", value: 1.0 },\\n\\n\\t\\t\\t\\\"diffuse\\\": { type: \\\"c\\\", value: new THREE.Color( 0xeeeeee ) },\\n\\t\\t\\t\\\"specular\\\": { type: \\\"c\\\", value: new THREE.Color( 0x111111 ) },\\n\\t\\t\\t\\\"ambient\\\": { type: \\\"c\\\", value: new THREE.Color( 0x050505 ) },\\n\\t\\t\\t\\\"shininess\\\": { type: \\\"f\\\", value: 30 },\\n\\t\\t\\t\\\"opacity\\\": { type: \\\"f\\\", value: 1 },\\n\\n\\t\\t\\t\\\"uRepeatBase\\\"    : { type: \\\"v2\\\", value: new THREE.Vector2( 1, 1 ) },\\n\\t\\t\\t\\\"uRepeatOverlay\\\" : { type: \\\"v2\\\", value: new THREE.Vector2( 1, 1 ) },\\n\\n\\t\\t\\t\\\"uOffset\\\" : { type: \\\"v2\\\", value: new THREE.Vector2( 0, 0 ) }\\n\\n\\t\\t\\t}\\n\\n\\t\\t] ),\\n\\n\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\\"uniform vec3 ambient;\\\",\\n\\t\\t\\t\\\"uniform vec3 diffuse;\\\",\\n\\t\\t\\t\\\"uniform vec3 specular;\\\",\\n\\t\\t\\t\\\"uniform float shininess;\\\",\\n\\t\\t\\t\\\"uniform float opacity;\\\",\\n\\n\\t\\t\\t\\\"uniform bool enableDiffuse1;\\\",\\n\\t\\t\\t\\\"uniform bool enableDiffuse2;\\\",\\n\\t\\t\\t\\\"uniform bool enableSpecular;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D tDiffuse1;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tDiffuse2;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tDetail;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tNormal;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tSpecular;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tDisplacement;\\\",\\n\\n\\t\\t\\t\\\"uniform float uNormalScale;\\\",\\n\\n\\t\\t\\t\\\"uniform vec2 uRepeatOverlay;\\\",\\n\\t\\t\\t\\\"uniform vec2 uRepeatBase;\\\",\\n\\n\\t\\t\\t\\\"uniform vec2 uOffset;\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vTangent;\\\",\\n\\t\\t\\t\\\"varying vec3 vBinormal;\\\",\\n\\t\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"uniform vec3 ambientLightColor;\\\",\\n\\n\\t\\t\\t\\\"#if MAX_DIR_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"#if MAX_HEMI_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\\",\\n\\t\\t\\t\\t\\\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vViewPosition;\\\",\\n\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_pars_fragment\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"fog_pars_fragment\\\" ],\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( vec3( 1.0 ), opacity );\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 specularTex = vec3( 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"vec2 uvOverlay = uRepeatOverlay * vUv + uOffset;\\\",\\n\\t\\t\\t\\t\\\"vec2 uvBase = uRepeatBase * vUv;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 normalTex = texture2D( tDetail, uvOverlay ).xyz * 2.0 - 1.0;\\\",\\n\\t\\t\\t\\t\\\"normalTex.xy *= uNormalScale;\\\",\\n\\t\\t\\t\\t\\\"normalTex = normalize( normalTex );\\\",\\n\\n\\t\\t\\t\\t\\\"if( enableDiffuse1 && enableDiffuse2 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );\\\",\\n\\t\\t\\t\\t\\t\\\"vec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#ifdef GAMMA_INPUT\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"colDiffuse1.xyz *= colDiffuse1.xyz;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"colDiffuse2.xyz *= colDiffuse2.xyz;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = gl_FragColor * mix ( colDiffuse1, colDiffuse2, 1.0 - texture2D( tDisplacement, uvBase ) );\\\",\\n\\n\\t\\t\\t\\t\\\" } else if( enableDiffuse1 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = gl_FragColor * texture2D( tDiffuse1, uvOverlay );\\\",\\n\\n\\t\\t\\t\\t\\\"} else if( enableDiffuse2 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor = gl_FragColor * texture2D( tDiffuse2, uvOverlay );\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"if( enableSpecular )\\\",\\n\\t\\t\\t\\t\\t\\\"specularTex = texture2D( tSpecular, uvOverlay ).xyz;\\\",\\n\\n\\t\\t\\t\\t\\\"mat3 tsb = mat3( vTangent, vBinormal, vNormal );\\\",\\n\\t\\t\\t\\t\\\"vec3 finalNormal = tsb * normalTex;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 normal = normalize( finalNormal );\\\",\\n\\t\\t\\t\\t\\\"vec3 viewPosition = normalize( vViewPosition );\\\",\\n\\n\\t\\t\\t\\t// point lights\\n\\n\\t\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 pointDiffuse = vec3( 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 pointSpecular = vec3( 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float lDistance = 1.0;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"if ( pointLightDistance[ i ] > 0.0 )\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"lVector = normalize( lVector );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 pointHalfVector = normalize( lVector + viewPosition );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float pointDistance = lDistance;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"pointSpecular += pointDistance * pointLightColor[ i ] * specular * pointSpecularWeight * pointDiffuseWeight;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// directional lights\\n\\n\\t\\t\\t\\t\\\"#if MAX_DIR_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 dirDiffuse = vec3( 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 dirSpecular = vec3( 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 dirVector = normalize( lDirection.xyz );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"dirSpecular += directionalLightColor[ i ] * specular * dirSpecularWeight * dirDiffuseWeight;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// hemisphere lights\\n\\n\\t\\t\\t\\t\\\"#if MAX_HEMI_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 hemiDiffuse  = vec3( 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 hemiSpecular = vec3( 0.0 );\\\" ,\\n\\n\\t\\t\\t\\t\\t\\\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"vec3 lVector = normalize( lDirection.xyz );\\\",\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\t\\t\\t\\\"float dotProduct = dot( normal, lVector );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"hemiDiffuse += diffuse * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\\",\\n\\n\\t\\t\\t\\t\\t\\t// specular (sky light)\\n\\n\\t\\t\\t\\t\\t\\t\\\"float hemiSpecularWeight = 0.0;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t// specular (ground light)\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 lVectorGround = -lVector;\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\\",\\n\\t\\t\\t\\t\\t\\t\\\"hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"hemiSpecular += specular * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight ) * hemiSpecularWeight * hemiDiffuseWeight;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// all lights contribution summation\\n\\n\\t\\t\\t\\t\\\"vec3 totalDiffuse = vec3( 0.0 );\\\",\\n\\t\\t\\t\\t\\\"vec3 totalSpecular = vec3( 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"#if MAX_DIR_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"totalDiffuse += dirDiffuse;\\\",\\n\\t\\t\\t\\t\\t\\\"totalSpecular += dirSpecular;\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"#if MAX_HEMI_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"totalDiffuse += hemiDiffuse;\\\",\\n\\t\\t\\t\\t\\t\\\"totalSpecular += hemiSpecular;\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"#if MAX_POINT_LIGHTS > 0\\\",\\n\\n\\t\\t\\t\\t\\t\\\"totalDiffuse += pointDiffuse;\\\",\\n\\t\\t\\t\\t\\t\\\"totalSpecular += pointSpecular;\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t//\\\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient) + totalSpecular;\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\\\",\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_fragment\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"linear_to_gamma_fragment\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"fog_fragment\\\" ],\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\\"attribute vec4 tangent;\\\",\\n\\n\\t\\t\\t\\\"uniform vec2 uRepeatBase;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D tNormal;\\\",\\n\\n\\t\\t\\t\\\"#ifdef VERTEX_TEXTURES\\\",\\n\\n\\t\\t\\t\\t\\\"uniform sampler2D tDisplacement;\\\",\\n\\t\\t\\t\\t\\\"uniform float uDisplacementScale;\\\",\\n\\t\\t\\t\\t\\\"uniform float uDisplacementBias;\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vTangent;\\\",\\n\\t\\t\\t\\\"varying vec3 vBinormal;\\\",\\n\\t\\t\\t\\\"varying vec3 vNormal;\\\",\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"varying vec3 vViewPosition;\\\",\\n\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_pars_vertex\\\" ],\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vNormal = normalize( normalMatrix * normal );\\\",\\n\\n\\t\\t\\t\\t// tangent and binormal vectors\\n\\n\\t\\t\\t\\t\\\"vTangent = normalize( normalMatrix * tangent.xyz );\\\",\\n\\n\\t\\t\\t\\t\\\"vBinormal = cross( vNormal, vTangent ) * tangent.w;\\\",\\n\\t\\t\\t\\t\\\"vBinormal = normalize( vBinormal );\\\",\\n\\n\\t\\t\\t\\t// texture coordinates\\n\\n\\t\\t\\t\\t\\\"vUv = uv;\\\",\\n\\n\\t\\t\\t\\t\\\"vec2 uvBase = uv * uRepeatBase;\\\",\\n\\n\\t\\t\\t\\t// displacement mapping\\n\\n\\t\\t\\t\\t\\\"#ifdef VERTEX_TEXTURES\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 dv = texture2D( tDisplacement, uvBase ).xyz;\\\",\\n\\t\\t\\t\\t\\t\\\"float df = uDisplacementScale * dv.x + uDisplacementBias;\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 displacedPosition = normal * df + position;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\\\",\\n\\t\\t\\t\\t\\t\\\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"#else\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\t\\t\\\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"gl_Position = projectionMatrix * mvPosition;\\\",\\n\\n\\t\\t\\t\\t\\\"vViewPosition = -mvPosition.xyz;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 normalTex = texture2D( tNormal, uvBase ).xyz * 2.0 - 1.0;\\\",\\n\\t\\t\\t\\t\\\"vNormal = normalMatrix * normalTex;\\\",\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_vertex\\\" ],\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/WaterShader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/WaterShader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author jbouny / https://github.com/jbouny\\n *\\n * Work based on :\\n * @author Slayvin / http://slayvin.net : Flat mirror for three.js\\n * @author Stemkoski / http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\\n * @author Jonas Wagner / http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\\n */\\n\\nTHREE.ShaderLib['water'] = {\\n\\n\\tuniforms: { \\\"normalSampler\\\":\\t{ type: \\\"t\\\", value: null },\\n\\t\\t\\t\\t\\\"mirrorSampler\\\":\\t{ type: \\\"t\\\", value: null },\\n\\t\\t\\t\\t\\\"alpha\\\":\\t\\t\\t{ type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\t\\t\\\"time\\\":\\t\\t\\t\\t{ type: \\\"f\\\", value: 0.0 },\\n\\t\\t\\t\\t\\\"distortionScale\\\":\\t{ type: \\\"f\\\", value: 20.0 },\\n\\t\\t\\t\\t\\\"textureMatrix\\\" :\\t{ type: \\\"m4\\\", value: new THREE.Matrix4() },\\n\\t\\t\\t\\t\\\"sunColor\\\":\\t\\t\\t{ type: \\\"c\\\", value: new THREE.Color( 0x7F7F7F ) },\\n\\t\\t\\t\\t\\\"sunDirection\\\":\\t\\t{ type: \\\"v3\\\", value: new THREE.Vector3( 0.70707, 0.70707, 0 ) },\\n\\t\\t\\t\\t\\\"eye\\\":\\t\\t\\t\\t{ type: \\\"v3\\\", value: new THREE.Vector3( 0, 0, 0 ) },\\n\\t\\t\\t\\t\\\"waterColor\\\":\\t\\t{ type: \\\"c\\\", value: new THREE.Color( 0x555555 ) }\\n\\t},\\n\\n\\tvertexShader: [\\n\\t\\t'uniform mat4 textureMatrix;',\\n\\t\\t'uniform float time;',\\n\\n\\t\\t'varying vec4 mirrorCoord;',\\n\\t\\t'varying vec3 worldPosition;',\\n\\t\\t\\n\\t\\t'void main()',\\n\\t\\t'{',\\n\\t\\t'\\tmirrorCoord = modelMatrix * vec4( position, 1.0 );',\\n\\t\\t'\\tworldPosition = mirrorCoord.xyz;',\\n\\t\\t'\\tmirrorCoord = textureMatrix * mirrorCoord;',\\n\\t\\t'\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\\n\\t\\t'}'\\n\\t].join('\\\\n'),\\n\\n\\tfragmentShader: [\\n\\t\\t'precision highp float;',\\n\\t\\t\\n\\t\\t'uniform sampler2D mirrorSampler;',\\n\\t\\t'uniform float alpha;',\\n\\t\\t'uniform float time;',\\n\\t\\t'uniform float distortionScale;',\\n\\t\\t'uniform sampler2D normalSampler;',\\n\\t\\t'uniform vec3 sunColor;',\\n\\t\\t'uniform vec3 sunDirection;',\\n\\t\\t'uniform vec3 eye;',\\n\\t\\t'uniform vec3 waterColor;',\\n\\n\\t\\t'varying vec4 mirrorCoord;',\\n\\t\\t'varying vec3 worldPosition;',\\n\\t\\t\\n\\t\\t'vec4 getNoise( vec2 uv )',\\n\\t\\t'{',\\n\\t\\t'\\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);',\\n\\t\\t'\\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );',\\n\\t\\t'\\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );',\\n\\t\\t'\\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );',\\n\\t\\t'\\tvec4 noise = ( texture2D( normalSampler, uv0 ) ) +',\\n        '\\t\\t( texture2D( normalSampler, uv1 ) ) +',\\n        '\\t\\t( texture2D( normalSampler, uv2 ) ) +',\\n\\t\\t'\\t\\t( texture2D( normalSampler, uv3 ) );',\\n\\t\\t'\\treturn noise * 0.5 - 1.0;',\\n\\t\\t'}',\\n\\t\\t\\n\\t\\t'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor )',\\n\\t\\t'{',\\n\\t\\t'\\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );',\\n\\t\\t'\\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );',\\n\\t\\t'\\tspecularColor += pow( direction, shiny ) * sunColor * spec;',\\n\\t\\t'\\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;',\\n\\t\\t'}',\\n\\t\\t\\n\\t\\t'void main()',\\n\\t\\t'{',\\n\\t\\t'\\tvec4 noise = getNoise( worldPosition.xz );',\\n\\t\\t'\\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );',\\n\\n\\t\\t'\\tvec3 diffuseLight = vec3(0.0);',\\n\\t\\t'\\tvec3 specularLight = vec3(0.0);',\\n\\n\\t\\t'\\tvec3 worldToEye = eye-worldPosition;',\\n\\t\\t'\\tvec3 eyeDirection = normalize( worldToEye );',\\n\\t\\t'\\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );',\\n\\t\\t\\n\\t\\t'\\tfloat distance = length(worldToEye);',\\n\\n\\t\\t'\\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;',\\n\\t\\t'\\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.z + distortion ) );',\\n\\n\\t\\t'\\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );',\\n\\t\\t'\\tfloat rf0 = 0.3;',\\n\\t\\t'\\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );',\\n\\t\\t'\\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;',\\n\\t\\t'\\tvec3 albedo = mix( sunColor * diffuseLight * 0.3 + scatter, ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance );',\\n\\t\\t'\\tgl_FragColor = vec4( albedo, alpha );',\\n\\t\\t'}'\\n\\t].join('\\\\n')\\n\\n};\\n\\nTHREE.Water = function ( renderer, camera, scene, options ) {\\n\\n\\tTHREE.Object3D.call( this );\\n\\tthis.name = 'water_' + this.id;\\n\\n\\tfunction optionalParameter ( value, defaultValue ) {\\n\\t\\treturn value !== undefined ? value : defaultValue;\\n\\t};\\n\\n\\toptions = options || {};\\n\\t\\n\\tthis.matrixNeedsUpdate = true;\\n\\t\\n\\tvar width = optionalParameter( options.textureWidth, 512 );\\n\\tvar height = optionalParameter( options.textureHeight, 512 );\\n\\tthis.clipBias = optionalParameter( options.clipBias, 0.0 );\\n\\tthis.alpha = optionalParameter( options.alpha, 1.0 );\\n\\tthis.time = optionalParameter( options.time, 0.0 );\\n\\tthis.normalSampler = optionalParameter( options.waterNormals, null );\\n\\tthis.sunDirection = optionalParameter( options.sunDirection, new THREE.Vector3( 0.70707, 0.70707, 0.0 ) );\\n\\tthis.sunColor = new THREE.Color( optionalParameter( options.sunColor, 0xffffff ) );\\n\\tthis.waterColor = new THREE.Color( optionalParameter( options.waterColor, 0x7F7F7F ) );\\n\\tthis.eye = optionalParameter( options.eye, new THREE.Vector3( 0, 0, 0 ) );\\n\\tthis.distortionScale = optionalParameter( options.distortionScale, 20.0 );\\n\\t\\n\\tthis.renderer = renderer;\\n\\tthis.scene = scene;\\n\\tthis.mirrorPlane = new THREE.Plane();\\n\\tthis.normal = new THREE.Vector3( 0, 0, 1 );\\n\\tthis.mirrorWorldPosition = new THREE.Vector3();\\n\\tthis.cameraWorldPosition = new THREE.Vector3();\\n\\tthis.rotationMatrix = new THREE.Matrix4();\\n\\tthis.lookAtPosition = new THREE.Vector3( 0, 0, -1 );\\n\\tthis.clipPlane = new THREE.Vector4();\\n\\t\\n\\tif ( camera instanceof THREE.PerspectiveCamera )\\n\\t\\tthis.camera = camera;\\n\\telse \\n\\t{\\n\\t\\tthis.camera = new THREE.PerspectiveCamera();\\n\\t\\tconsole.log(this.name + ': camera is not a Perspective Camera!')\\n\\t}\\n\\n\\tthis.textureMatrix = new THREE.Matrix4();\\n\\n\\tthis.mirrorCamera = this.camera.clone();\\n\\t\\n\\tthis.texture = new THREE.WebGLRenderTarget( width, height );\\n\\tthis.tempTexture = new THREE.WebGLRenderTarget( width, height );\\n\\t\\n\\tvar mirrorShader = THREE.ShaderLib[ \\\"water\\\" ];\\n\\tvar mirrorUniforms = THREE.UniformsUtils.clone( mirrorShader.uniforms );\\n\\n\\tthis.material = new THREE.ShaderMaterial( { \\n\\t\\tfragmentShader: mirrorShader.fragmentShader, \\n\\t\\tvertexShader: mirrorShader.vertexShader, \\n\\t\\tuniforms: mirrorUniforms,\\n\\t\\ttransparent: true\\n\\t} );\\n\\n\\tthis.material.uniforms.mirrorSampler.value = this.texture;\\n\\tthis.material.uniforms.textureMatrix.value = this.textureMatrix;\\n\\tthis.material.uniforms.alpha.value = this.alpha;\\n\\tthis.material.uniforms.time.value = this.time;\\n\\tthis.material.uniforms.normalSampler.value = this.normalSampler;\\n\\tthis.material.uniforms.sunColor.value = this.sunColor;\\n\\tthis.material.uniforms.waterColor.value = this.waterColor;\\n\\tthis.material.uniforms.sunDirection.value = this.sunDirection;\\n\\tthis.material.uniforms.distortionScale.value = this.distortionScale;\\n\\t\\n\\tthis.material.uniforms.eye.value = this.eye;\\n\\t\\n\\tif ( !THREE.Math.isPowerOfTwo(width) || !THREE.Math.isPowerOfTwo(height) )\\n\\t{\\n\\t\\tthis.texture.generateMipmaps = false;\\n\\t\\tthis.tempTexture.generateMipmaps = false;\\n\\t}\\n\\n\\tthis.updateTextureMatrix();\\n\\tthis.render();\\n};\\n\\nTHREE.Water.prototype = Object.create( THREE.Mirror.prototype );\\n\\n\\nTHREE.Water.prototype.updateTextureMatrix = function () {\\n\\n\\tfunction sign(x) { return x ? x < 0 ? -1 : 1 : 0; }\\n\\n\\tthis.updateMatrixWorld();\\n\\tthis.camera.updateMatrixWorld();\\n\\n\\tthis.mirrorWorldPosition.setFromMatrixPosition( this.matrixWorld );\\n\\tthis.cameraWorldPosition.setFromMatrixPosition( this.camera.matrixWorld );\\n\\n\\tthis.rotationMatrix.extractRotation( this.matrixWorld );\\n\\n\\tthis.normal.set( 0, 0, 1 );\\n\\tthis.normal.applyMatrix4( this.rotationMatrix );\\n\\n\\tvar view = this.mirrorWorldPosition.clone().sub( this.cameraWorldPosition );\\n\\tview.reflect( this.normal ).negate();\\n\\tview.add( this.mirrorWorldPosition );\\n\\n\\tthis.rotationMatrix.extractRotation( this.camera.matrixWorld );\\n\\n\\tthis.lookAtPosition.set(0, 0, -1);\\n\\tthis.lookAtPosition.applyMatrix4( this.rotationMatrix );\\n\\tthis.lookAtPosition.add( this.cameraWorldPosition );\\n\\n\\tvar target = this.mirrorWorldPosition.clone().sub( this.lookAtPosition );\\n\\ttarget.reflect( this.normal ).negate();\\n\\ttarget.add( this.mirrorWorldPosition );\\n\\n\\tthis.up.set(0, -1, 0);\\n\\tthis.up.applyMatrix4( this.rotationMatrix );\\n\\tthis.up.reflect( this.normal ).negate();\\n\\n\\tthis.mirrorCamera.position.copy( view );\\n\\tthis.mirrorCamera.up = this.up;\\n\\tthis.mirrorCamera.lookAt( target );\\n\\tthis.mirrorCamera.aspect = this.camera.aspect;\\n\\n\\tthis.mirrorCamera.updateProjectionMatrix();\\n\\tthis.mirrorCamera.updateMatrixWorld();\\n\\tthis.mirrorCamera.matrixWorldInverse.getInverse(this.mirrorCamera.matrixWorld);\\n\\n\\t// Update the texture matrix\\n\\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\\n\\t\\t\\t\\t\\t\\t\\t0.0, 0.5, 0.0, 0.5,\\n\\t\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.5, 0.5,\\n\\t\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.0, 1.0 );\\n\\tthis.textureMatrix.multiply(this.mirrorCamera.projectionMatrix);\\n\\tthis.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse);\\n\\n\\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\\n\\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\\n\\tthis.mirrorPlane.setFromNormalAndCoplanarPoint( this.normal, this.mirrorWorldPosition );\\n\\tthis.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse);\\n\\n\\tthis.clipPlane.set(this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant );\\n\\n\\tvar q = new THREE.Vector4();\\n\\tvar projectionMatrix = this.mirrorCamera.projectionMatrix;\\n\\n\\tq.x = (sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\\n\\tq.y = (sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\\n\\tq.z = -1.0;\\n\\tq.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\\n\\n\\t// Calculate the scaled plane vector\\n\\tvar c = new THREE.Vector4();\\n\\tc = this.clipPlane.multiplyScalar( 2.0 / this.clipPlane.dot(q) );\\n\\n\\t// Replacing the third row of the projection matrix\\n\\tprojectionMatrix.elements[2] = c.x;\\n\\tprojectionMatrix.elements[6] = c.y;\\n\\tprojectionMatrix.elements[10] = c.z + 1.0 - this.clipBias;\\n\\tprojectionMatrix.elements[14] = c.w;\\n\\t\\n\\tvar worldCoordinates = new THREE.Vector3();\\n\\tworldCoordinates.setFromMatrixPosition( this.camera.matrixWorld );\\n\\tthis.eye = worldCoordinates;\\n\\tthis.material.uniforms.eye.value = this.eye;\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Octree.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Octree.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/*!\\n *\\n * threeoctree.js (r60) / https://github.com/collinhover/threeoctree\\n * (sparse) dynamic 3D spatial representation structure for fast searches.\\n *\\n * @author Collin Hover / http://collinhover.com/\\n * based on Dynamic Octree by Piko3D @ http://www.piko3d.com/ and Octree by Marek Pawlowski @ pawlowski.it\\n *\\n */\\n ( function ( THREE ) { \\\"use strict\\\";\\n\\t\\n\\t/*===================================================\\n\\n\\tutility\\n\\n\\t=====================================================*/\\n\\t\\n\\tfunction isNumber ( n ) {\\n\\t\\treturn !isNaN( n ) && isFinite( n );\\n\\t}\\n\\t\\n\\tfunction isArray ( target ) {\\n\\t\\treturn Object.prototype.toString.call( target ) === '[object Array]';\\n\\t}\\n\\t\\n\\tfunction toArray ( target ) {\\n\\t\\treturn target ? ( isArray ( target ) !== true ? [ target ] : target ) : [];\\n\\t}\\n\\t\\n\\tfunction indexOfValue( array, value ) {\\n\\t\\t\\n\\t\\tfor ( var i = 0, il = array.length; i < il; i++ ) {\\n\\t\\t\\t\\n\\t\\t\\tif ( array[ i ] === value ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn -1;\\n\\t\\t\\n\\t}\\n\\t\\n\\tfunction indexOfPropertyWithValue( array, property, value ) {\\n\\t\\t\\n\\t\\tfor ( var i = 0, il = array.length; i < il; i++ ) {\\n\\t\\t\\t\\n\\t\\t\\tif ( array[ i ][ property ] === value ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn -1;\\n\\t\\t\\n\\t}\\n\\n\\t/*===================================================\\n\\n\\toctree\\n\\n\\t=====================================================*/\\n\\n\\tTHREE.Octree = function ( parameters ) {\\n\\t\\t\\n\\t\\t// handle parameters\\n\\t\\t\\n\\t\\tparameters = parameters || {};\\n\\t\\t\\n\\t\\tparameters.tree = this;\\n\\t\\t\\n\\t\\t// static properties ( modification is not recommended )\\n\\t\\t\\n\\t\\tthis.nodeCount = 0;\\n\\t\\t\\n\\t\\tthis.INDEX_INSIDE_CROSS = -1;\\n\\t\\tthis.INDEX_OUTSIDE_OFFSET = 2;\\n\\t\\t\\n\\t\\tthis.INDEX_OUTSIDE_POS_X = isNumber( parameters.INDEX_OUTSIDE_POS_X ) ? parameters.INDEX_OUTSIDE_POS_X : 0;\\n\\t\\tthis.INDEX_OUTSIDE_NEG_X = isNumber( parameters.INDEX_OUTSIDE_NEG_X ) ? parameters.INDEX_OUTSIDE_NEG_X : 1;\\n\\t\\tthis.INDEX_OUTSIDE_POS_Y = isNumber( parameters.INDEX_OUTSIDE_POS_Y ) ? parameters.INDEX_OUTSIDE_POS_Y : 2;\\n\\t\\tthis.INDEX_OUTSIDE_NEG_Y = isNumber( parameters.INDEX_OUTSIDE_NEG_Y ) ? parameters.INDEX_OUTSIDE_NEG_Y : 3;\\n\\t\\tthis.INDEX_OUTSIDE_POS_Z = isNumber( parameters.INDEX_OUTSIDE_POS_Z ) ? parameters.INDEX_OUTSIDE_POS_Z : 4;\\n\\t\\tthis.INDEX_OUTSIDE_NEG_Z = isNumber( parameters.INDEX_OUTSIDE_NEG_Z ) ? parameters.INDEX_OUTSIDE_NEG_Z : 5;\\n\\t\\t\\n\\t\\tthis.INDEX_OUTSIDE_MAP = [];\\n\\t\\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_X ] = { index: this.INDEX_OUTSIDE_POS_X, count: 0, x: 1, y: 0, z: 0 };\\n\\t\\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_X ] = { index: this.INDEX_OUTSIDE_NEG_X, count: 0, x: -1, y: 0, z: 0 };\\n\\t\\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_Y ] = { index: this.INDEX_OUTSIDE_POS_Y, count: 0, x: 0, y: 1, z: 0 };\\n\\t\\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_Y ] = { index: this.INDEX_OUTSIDE_NEG_Y, count: 0, x: 0, y: -1, z: 0 };\\n\\t\\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_Z ] = { index: this.INDEX_OUTSIDE_POS_Z, count: 0, x: 0, y: 0, z: 1 };\\n\\t\\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_Z ] = { index: this.INDEX_OUTSIDE_NEG_Z, count: 0, x: 0, y: 0, z: -1 };\\n\\t\\t\\n\\t\\tthis.FLAG_POS_X = 1 << ( this.INDEX_OUTSIDE_POS_X + 1 );\\n\\t\\tthis.FLAG_NEG_X = 1 << ( this.INDEX_OUTSIDE_NEG_X + 1 );\\n\\t\\tthis.FLAG_POS_Y = 1 << ( this.INDEX_OUTSIDE_POS_Y + 1 );\\n\\t\\tthis.FLAG_NEG_Y = 1 << ( this.INDEX_OUTSIDE_NEG_Y + 1 );\\n\\t\\tthis.FLAG_POS_Z = 1 << ( this.INDEX_OUTSIDE_POS_Z + 1 );\\n\\t\\tthis.FLAG_NEG_Z = 1 << ( this.INDEX_OUTSIDE_NEG_Z + 1 );\\n\\t\\t\\n\\t\\tthis.utilVec31Search = new THREE.Vector3();\\n\\t\\tthis.utilVec32Search = new THREE.Vector3();\\n\\t\\t\\n\\t\\t// pass scene to see octree structure\\n\\t\\t\\n\\t\\tthis.scene = parameters.scene;\\n\\t\\t\\n\\t\\tif ( this.scene ) {\\n\\t\\t\\t\\n\\t\\t\\tthis.visualGeometry = new THREE.BoxGeometry( 1, 1, 1 );\\n\\t\\t\\tthis.visualMaterial = new THREE.MeshBasicMaterial( { color: 0xFF0066, wireframe: true, wireframeLinewidth: 1 } );\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\t// properties\\n\\t\\t\\n\\t\\tthis.objects = [];\\n\\t\\tthis.objectsMap = {};\\n\\t\\tthis.objectsData = [];\\n\\t\\tthis.objectsDeferred = [];\\n\\t\\t\\n\\t\\tthis.depthMax = isNumber( parameters.depthMax ) ? parameters.depthMax : Infinity;\\n\\t\\tthis.objectsThreshold = isNumber( parameters.objectsThreshold ) ? parameters.objectsThreshold : 8;\\n\\t\\tthis.overlapPct = isNumber( parameters.overlapPct ) ? parameters.overlapPct : 0.15;\\n\\t\\tthis.undeferred = parameters.undeferred || false;\\n\\t\\t\\n\\t\\tthis.root = parameters.root instanceof THREE.OctreeNode ? parameters.root : new THREE.OctreeNode( parameters );\\n\\t\\t\\n\\t};\\n\\n\\tTHREE.Octree.prototype = {\\n\\t\\t\\n\\t\\tupdate: function () {\\n\\t\\t\\t\\n\\t\\t\\t// add any deferred objects that were waiting for render cycle\\n\\t\\t\\t\\n\\t\\t\\tif ( this.objectsDeferred.length > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( var i = 0, il = this.objectsDeferred.length; i < il; i++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tvar deferred = this.objectsDeferred[ i ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.addDeferred( deferred.object, deferred.options );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.objectsDeferred.length = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tadd: function ( object, options ) {\\n\\t\\t\\t\\n\\t\\t\\t// add immediately\\n\\t\\t\\t\\n\\t\\t\\tif ( this.undeferred ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.updateObject( object );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.addDeferred( object, options );\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// defer add until update called\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.objectsDeferred.push( { object: object, options: options } );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\taddDeferred: function ( object, options ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tgeometry,\\n\\t\\t\\t\\tfaces,\\n\\t\\t\\t\\tuseFaces,\\n\\t\\t\\t\\tvertices,\\n\\t\\t\\t\\tuseVertices,\\n\\t\\t\\t\\tobjectData;\\n\\t\\t\\t\\n\\t\\t\\t// ensure object is not object data\\n\\t\\t\\t\\n\\t\\t\\tif ( object instanceof THREE.OctreeObjectData ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobject = object.object;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// check uuid to avoid duplicates\\n\\t\\t\\t\\n\\t\\t\\tif ( !object.uuid ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobject.uuid = THREE.Math.generateUUID();\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif ( !this.objectsMap[ object.uuid ] ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// store\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.objects.push( object );\\n\\t\\t\\t\\tthis.objectsMap[ object.uuid ] = object;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check options\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( options ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tuseFaces = options.useFaces;\\n\\t\\t\\t\\t\\tuseVertices = options.useVertices;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( useVertices === true ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tgeometry = object.geometry;\\n\\t\\t\\t\\t\\tvertices = geometry.vertices;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor ( i = 0, l = vertices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tthis.addObjectData( object, vertices[ i ] );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t} else if ( useFaces === true ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tgeometry = object.geometry;\\n\\t\\t\\t\\t\\tfaces = geometry.faces;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor ( i = 0, l = faces.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tthis.addObjectData( object, faces[ i ] );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.addObjectData( object );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\taddObjectData: function ( object, part ) {\\n\\t\\t\\t\\n\\t\\t\\tvar objectData = new THREE.OctreeObjectData( object, part );\\n\\t\\t\\t\\n\\t\\t\\t// add to tree objects data list\\n\\t\\t\\t\\n\\t\\t\\tthis.objectsData.push( objectData );\\n\\t\\t\\t\\n\\t\\t\\t// add to nodes\\n\\t\\t\\t\\n\\t\\t\\tthis.root.addObject( objectData );\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tremove: function ( object ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tobjectData = object,\\n\\t\\t\\t\\tindex,\\n\\t\\t\\t\\tobjectsDataRemoved;\\n\\t\\t\\t\\n\\t\\t\\t// ensure object is not object data for index search\\n\\t\\t\\t\\n\\t\\t\\tif ( object instanceof THREE.OctreeObjectData ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobject = object.object;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// check uuid\\n\\t\\t\\t\\n\\t\\t\\tif ( this.objectsMap[ object.uuid ] ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.objectsMap[ object.uuid ] = undefined;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check and remove from objects, nodes, and data lists\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindex = indexOfValue( this.objects, object );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( index !== -1 ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.objects.splice( index, 1 );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// remove from nodes\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tobjectsDataRemoved = this.root.removeObject( objectData );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// remove from objects data list\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor ( i = 0, l = objectsDataRemoved.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tobjectData = objectsDataRemoved[ i ];\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tindex = indexOfValue( this.objectsData, objectData );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tif ( index !== -1 ) {\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tthis.objectsData.splice( index, 1 );\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t} else if ( this.objectsDeferred.length > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check and remove from deferred\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindex = indexOfPropertyWithValue( this.objectsDeferred, 'object', object );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( index !== -1 ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.objectsDeferred.splice( index, 1 );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\textend: function ( octree ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tobjectsData,\\n\\t\\t\\t\\tobjectData;\\n\\t\\t\\t\\t\\n\\t\\t\\tif ( octree instanceof THREE.Octree ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// for each object data\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectsData = octree.objectsData;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = 0, l = objectsData.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tobjectData = objectsData[ i ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.add( objectData, { useFaces: objectData.faces, useVertices: objectData.vertices } );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\trebuild: function () {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tnode,\\n\\t\\t\\t\\tobject,\\n\\t\\t\\t\\tobjectData,\\n\\t\\t\\t\\tindexOctant,\\n\\t\\t\\t\\tindexOctantLast,\\n\\t\\t\\t\\tobjectsUpdate = [];\\n\\t\\t\\t\\n\\t\\t\\t// check all object data for changes in position\\n\\t\\t\\t// assumes all object matrices are up to date\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = this.objectsData.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectData = this.objectsData[ i ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode = objectData.node;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// update object\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectData.update();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if position has changed since last organization of object in tree\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( node instanceof THREE.OctreeNode && !objectData.positionLast.equals( objectData.position ) ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// get octant index of object within current node\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexOctantLast = objectData.indexOctant;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexOctant = node.getOctantIndex( objectData );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// if object octant index has changed\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif ( indexOctant !== indexOctantLast ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// add to update list\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tobjectsUpdate.push( objectData );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// update changed objects\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = objectsUpdate.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectData = objectsUpdate[ i ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// remove object from current node\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectData.node.removeObject( objectData );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// add object to tree root\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.root.addObject( objectData );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tupdateObject: function ( object ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tparentCascade = [ object ],\\n\\t\\t\\t\\tparent,\\n\\t\\t\\t\\tparentUpdate;\\n\\t\\t\\t\\n\\t\\t\\t// search all parents between object and root for world matrix update\\n\\t\\t\\t\\n\\t\\t\\tparent = object.parent;\\n\\t\\t\\t\\n\\t\\t\\twhile( parent ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tparentCascade.push( parent );\\n\\t\\t\\t\\tparent = parent.parent;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = parentCascade.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tparent = parentCascade[ i ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( parent.matrixWorldNeedsUpdate === true ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tparentUpdate = parent;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// update world matrix starting at uppermost parent that needs update\\n\\t\\t\\t\\n\\t\\t\\tif ( typeof parentUpdate !== 'undefined' ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tparentUpdate.updateMatrixWorld();\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tsearch: function ( position, radius, organizeByObject, direction ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tnode,\\n\\t\\t\\t\\tobjects,\\n\\t\\t\\t\\tobjectData,\\n\\t\\t\\t\\tobject,\\n\\t\\t\\t\\tresults,\\n\\t\\t\\t\\tresultData,\\n\\t\\t\\t\\tresultsObjectsIndices,\\n\\t\\t\\t\\tresultObjectIndex,\\n\\t\\t\\t\\tdirectionPct;\\n\\t\\t\\t\\n\\t\\t\\t// add root objects\\n\\t\\t\\t\\n\\t\\t\\tobjects = [].concat( this.root.objects );\\n\\t\\t\\t\\n\\t\\t\\t// ensure radius (i.e. distance of ray) is a number\\n\\t\\t\\t\\n\\t\\t\\tif ( !( radius > 0 ) ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tradius = Number.MAX_VALUE;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if direction passed, normalize and find pct\\n\\t\\t\\t\\n\\t\\t\\tif ( direction instanceof THREE.Vector3 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tdirection = this.utilVec31Search.copy( direction ).normalize();\\n\\t\\t\\t\\tdirectionPct = this.utilVec32Search.set( 1, 1, 1 ).divide( direction );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// search each node of root\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = this.root.nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode = this.root.nodesByIndex[ this.root.nodesIndices[ i ] ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjects = node.search( position, radius, objects, direction, directionPct );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if should organize results by object\\n\\t\\t\\t\\n\\t\\t\\tif ( organizeByObject === true ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tresults = [];\\n\\t\\t\\t\\tresultsObjectsIndices = [];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// for each object data found\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = 0, l = objects.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tobjectData = objects[ i ];\\n\\t\\t\\t\\t\\tobject = objectData.object;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tresultObjectIndex = indexOfValue( resultsObjectsIndices, object );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// if needed, create new result data\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif ( resultObjectIndex === -1 ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tresultData = {\\n\\t\\t\\t\\t\\t\\t\\tobject: object,\\n\\t\\t\\t\\t\\t\\t\\tfaces: [],\\n\\t\\t\\t\\t\\t\\t\\tvertices: []\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tresults.push( resultData );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tresultsObjectsIndices.push( object );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tresultData = results[ resultObjectIndex ];\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// object data has faces or vertices, add to list\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif ( objectData.faces ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tresultData.faces.push( objectData.faces );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t} else if ( objectData.vertices ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tresultData.vertices.push( objectData.vertices );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tresults = objects;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn results;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tsetRoot: function ( root ) { \\n\\t\\t\\t\\n\\t\\t\\tif ( root instanceof THREE.OctreeNode ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// store new root\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.root = root;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// update properties\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.root.updateProperties();\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetDepthEnd: function () {\\n\\t\\t\\t\\n\\t\\t\\treturn this.root.getDepthEnd();\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetNodeCountEnd: function () {\\n\\t\\t\\t\\n\\t\\t\\treturn this.root.getNodeCountEnd();\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetObjectCountEnd: function () {\\n\\t\\t\\t\\n\\t\\t\\treturn this.root.getObjectCountEnd();\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\ttoConsole: function () {\\n\\t\\t\\t\\n\\t\\t\\tthis.root.toConsole();\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t};\\n\\n\\t/*===================================================\\n\\n\\tobject data\\n\\n\\t=====================================================*/\\n\\n\\tTHREE.OctreeObjectData = function ( object, part ) {\\n\\t\\t\\n\\t\\t// properties\\n\\t\\t\\n\\t\\tthis.object = object;\\n\\t\\t\\n\\t\\t// handle part by type\\n\\t\\t\\n\\t\\tif ( part instanceof THREE.Face3 ) {\\n\\t\\t\\t\\n\\t\\t\\tthis.faces = part;\\n\\t\\t\\tthis.face3 = true;\\n\\t\\t\\tthis.utilVec31FaceBounds = new THREE.Vector3();\\n\\t\\t\\t\\n\\t\\t} else if ( part instanceof THREE.Vector3 ) {\\n\\t\\t\\t\\n\\t\\t\\tthis.vertices = part;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\tthis.radius = 0;\\n\\t\\tthis.position = new THREE.Vector3();\\n\\t\\t\\t\\n\\t\\t// initial update\\n\\t\\t\\n\\t\\tif ( this.object instanceof THREE.Object3D ) {\\n\\t\\t\\t\\n\\t\\t\\tthis.update();\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\tthis.positionLast = this.position.clone();\\n\\t\\t\\n\\t};\\n\\n\\tTHREE.OctreeObjectData.prototype = {\\n\\t\\t\\n\\t\\tupdate: function () {\\n\\t\\t\\t\\n\\t\\t\\tif ( this.face3 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.radius = this.getFace3BoundingRadius( this.object, this.faces );\\n\\t\\t\\t\\tthis.position.copy( this.faces.centroid ).applyMatrix4( this.object.matrixWorld );\\n\\t\\t\\t\\t\\n\\t\\t\\t} else if ( this.vertices ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.radius = this.object.material.size || 1;\\n\\t\\t\\t\\tthis.position.copy( this.vertices ).applyMatrix4( this.object.matrixWorld );\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( this.object.geometry ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif ( this.object.geometry.boundingSphere === null ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tthis.object.geometry.computeBoundingSphere();\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.radius = this.object.geometry.boundingSphere.radius;\\n\\t\\t\\t\\t\\tthis.position.copy( this.object.geometry.boundingSphere.center ).applyMatrix4( this.object.matrixWorld );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.radius = this.object.boundRadius;\\n\\t\\t\\t\\t\\tthis.position.setFromMatrixPosition( this.object.matrixWorld );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tthis.radius = this.radius * Math.max( this.object.scale.x, this.object.scale.y, this.object.scale.z );\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetFace3BoundingRadius: function ( object, face ) {\\n\\n\\t\\t\\tif ( face.centroid === undefined ) face.centroid = new THREE.Vector3();\\n\\t\\t\\t\\n\\t\\t\\tvar geometry = object.geometry || object,\\n\\t\\t\\t\\tvertices = geometry.vertices,\\n\\t\\t\\t\\tcentroid = face.centroid,\\n\\t\\t\\t\\tva = vertices[ face.a ], vb = vertices[ face.b ], vc = vertices[ face.c ],\\n\\t\\t\\t\\tcentroidToVert = this.utilVec31FaceBounds,\\n\\t\\t\\t\\tradius;\\n\\t\\t\\t\\t\\n\\t\\t\\tcentroid.addVectors( va, vb ).add( vc ).divideScalar( 3 );\\n\\t\\t\\tradius = Math.max( centroidToVert.subVectors( centroid, va ).length(), centroidToVert.subVectors( centroid, vb ).length(), centroidToVert.subVectors( centroid, vc ).length() );\\n\\t\\t\\t\\n\\t\\t\\treturn radius;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t};\\n\\n\\t/*===================================================\\n\\n\\tnode\\n\\n\\t=====================================================*/\\n\\n\\tTHREE.OctreeNode = function ( parameters ) {\\n\\t\\t\\n\\t\\t// utility\\n\\t\\t\\n\\t\\tthis.utilVec31Branch = new THREE.Vector3();\\n\\t\\tthis.utilVec31Expand = new THREE.Vector3();\\n\\t\\tthis.utilVec31Ray = new THREE.Vector3();\\n\\t\\t\\n\\t\\t// handle parameters\\n\\t\\t\\n\\t\\tparameters = parameters || {};\\n\\t\\t\\n\\t\\t// store or create tree\\n\\t\\t\\n\\t\\tif ( parameters.tree instanceof THREE.Octree ) {\\n\\t\\t\\t\\n\\t\\t\\tthis.tree = parameters.tree;\\n\\t\\t\\t\\n\\t\\t} else if ( parameters.parent instanceof THREE.OctreeNode !== true ) {\\n\\t\\t\\t\\n\\t\\t\\tparameters.root = this;\\n\\t\\t\\t\\n\\t\\t\\tthis.tree = new THREE.Octree( parameters );\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\t// basic properties\\n\\t\\t\\n\\t\\tthis.id = this.tree.nodeCount++;\\n\\t\\tthis.position = parameters.position instanceof THREE.Vector3 ? parameters.position : new THREE.Vector3();\\n\\t\\tthis.radius = parameters.radius > 0 ? parameters.radius : 1;\\n\\t\\tthis.indexOctant = parameters.indexOctant;\\n\\t\\tthis.depth = 0;\\n\\t\\t\\n\\t\\t// reset and assign parent\\n\\t\\t\\n\\t\\tthis.reset();\\n\\t\\tthis.setParent( parameters.parent );\\n\\t\\t\\n\\t\\t// additional properties\\n\\t\\t\\n\\t\\tthis.overlap = this.radius * this.tree.overlapPct;\\n\\t\\tthis.radiusOverlap = this.radius + this.overlap;\\n\\t\\tthis.left = this.position.x - this.radiusOverlap;\\n\\t\\tthis.right = this.position.x + this.radiusOverlap;\\n\\t\\tthis.bottom = this.position.y - this.radiusOverlap;\\n\\t\\tthis.top = this.position.y + this.radiusOverlap;\\n\\t\\tthis.back = this.position.z - this.radiusOverlap;\\n\\t\\tthis.front = this.position.z + this.radiusOverlap;\\n\\t\\t\\n\\t\\t// visual\\n\\t\\t\\n\\t\\tif ( this.tree.scene ) {\\n\\t\\t\\t\\n\\t\\t\\tthis.visual = new THREE.Mesh( this.tree.visualGeometry, this.tree.visualMaterial );\\n\\t\\t\\tthis.visual.scale.set( this.radiusOverlap * 2, this.radiusOverlap * 2, this.radiusOverlap * 2 );\\n\\t\\t\\tthis.visual.position.copy( this.position );\\n\\t\\t\\tthis.tree.scene.add( this.visual );\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t};\\n\\n\\tTHREE.OctreeNode.prototype = {\\n\\t\\t\\n\\t\\tsetParent: function ( parent ) {\\n\\t\\t\\t\\n\\t\\t\\t// store new parent\\n\\t\\t\\t\\n\\t\\t\\tif ( parent !== this && this.parent !== parent ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.parent = parent;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// update properties\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.updateProperties();\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tupdateProperties: function () {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l;\\n\\t\\t\\t\\n\\t\\t\\t// properties\\n\\t\\t\\t\\n\\t\\t\\tif ( this.parent instanceof THREE.OctreeNode ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.tree = this.parent.tree;\\n\\t\\t\\t\\tthis.depth = this.parent.depth + 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.depth = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// cascade\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = this.nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.nodesByIndex[ this.nodesIndices[ i ] ].updateProperties();\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\treset: function ( cascade, removeVisual ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tnode,\\n\\t\\t\\t\\tnodesIndices = this.nodesIndices || [],\\n\\t\\t\\t\\tnodesByIndex = this.nodesByIndex;\\n\\t\\t\\t\\n\\t\\t\\tthis.objects = [];\\n\\t\\t\\tthis.nodesIndices = [];\\n\\t\\t\\tthis.nodesByIndex = {};\\n\\t\\t\\t\\n\\t\\t\\t// unset parent in nodes\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode = nodesByIndex[ nodesIndices[ i ] ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode.setParent( undefined );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( cascade === true ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tnode.reset( cascade, removeVisual );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// visual\\n\\t\\t\\t\\n\\t\\t\\tif ( removeVisual === true && this.visual && this.visual.parent ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.visual.parent.remove( this.visual );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\taddNode: function ( node, indexOctant ) {\\n\\t\\t\\t\\n\\t\\t\\tnode.indexOctant = indexOctant;\\n\\t\\t\\t\\n\\t\\t\\tif ( indexOfValue( this.nodesIndices, indexOctant ) === -1 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.nodesIndices.push( indexOctant );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tthis.nodesByIndex[ indexOctant ] = node;\\n\\t\\t\\t\\n\\t\\t\\tif ( node.parent !== this ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode.setParent( this );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tremoveNode: function ( indexOctant ) {\\n\\t\\t\\t\\n\\t\\t\\tvar index,\\n\\t\\t\\t\\tnode;\\n\\t\\t\\t\\t\\n\\t\\t\\tindex = indexOfValue( this.nodesIndices, indexOctant );\\n\\t\\t\\t\\n\\t\\t\\tthis.nodesIndices.splice( index, 1 );\\n\\t\\t\\t\\n\\t\\t\\tnode = node || this.nodesByIndex[ indexOctant ];\\n\\t\\t\\t\\n\\t\\t\\tdelete this.nodesByIndex[ indexOctant ];\\n\\t\\t\\t\\n\\t\\t\\tif ( node.parent === this ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode.setParent( undefined );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\taddObject: function ( object ) {\\n\\t\\t\\t\\n\\t\\t\\tvar index,\\n\\t\\t\\t\\tindexOctant,\\n\\t\\t\\t\\tnode;\\n\\t\\t\\t\\n\\t\\t\\t// get object octant index\\n\\t\\t\\t\\n\\t\\t\\tindexOctant = this.getOctantIndex( object );\\n\\t\\t\\t\\n\\t\\t\\t// if object fully contained by an octant, add to subtree\\n\\t\\t\\tif ( indexOctant > -1 && this.nodesIndices.length > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode = this.branch( indexOctant );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode.addObject( object );\\n\\t\\t\\t\\t\\n\\t\\t\\t} else if ( indexOctant < -1 && this.parent instanceof THREE.OctreeNode ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if object lies outside bounds, add to parent node\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.parent.addObject( object );\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// add to this objects list\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindex = indexOfValue( this.objects, object );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( index === -1 ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.objects.push( object );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// node reference\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobject.node = this;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check if need to expand, split, or both\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.checkGrow();\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\taddObjectWithoutCheck: function ( objects ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tobject;\\n\\n\\t\\t\\tfor ( i = 0, l = objects.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobject = objects[ i ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.objects.push( object );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobject.node = this;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tremoveObject: function ( object ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tnodesRemovedFrom,\\n\\t\\t\\t\\tremoveData;\\n\\t\\t\\t\\n\\t\\t\\t// cascade through tree to find and remove object\\n\\t\\t\\t\\n\\t\\t\\tremoveData = this.removeObjectRecursive( object, { searchComplete: false, nodesRemovedFrom: [], objectsDataRemoved: [] } );\\n\\t\\t\\t\\n\\t\\t\\t// if object removed, try to shrink the nodes it was removed from\\n\\t\\t\\t\\n\\t\\t\\tnodesRemovedFrom = removeData.nodesRemovedFrom;\\n\\t\\t\\t\\n\\t\\t\\tif ( nodesRemovedFrom.length > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = 0, l = nodesRemovedFrom.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tnodesRemovedFrom[ i ].shrink();\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn removeData.objectsDataRemoved;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tremoveObjectRecursive: function ( object, removeData ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tindex = -1,\\n\\t\\t\\t\\tobjectData,\\n\\t\\t\\t\\tnode,\\n\\t\\t\\t\\tobjectRemoved;\\n\\t\\t\\t\\n\\t\\t\\t// find index of object in objects list\\n\\t\\t\\t\\n\\t\\t\\t// search and remove object data (fast)\\n\\t\\t\\tif ( object instanceof THREE.OctreeObjectData ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// remove from this objects list\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindex = indexOfValue( this.objects, object );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( index !== -1 ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.objects.splice( index, 1 );\\n\\t\\t\\t\\t\\tobject.node = undefined;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tremoveData.objectsDataRemoved.push( object );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tremoveData.searchComplete = objectRemoved = true;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\n\\t\\t\\t\\t// search each object data for object and remove (slow)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = this.objects.length - 1; i >= 0; i-- ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tobjectData = this.objects[ i ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif ( objectData.object === object ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tthis.objects.splice( i, 1 );\\n\\t\\t\\t\\t\\t\\tobjectData.node = undefined;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tremoveData.objectsDataRemoved.push( objectData );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tobjectRemoved = true;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tif ( !objectData.faces && !objectData.vertices ) {\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tremoveData.searchComplete = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if object data removed and this is not on nodes removed from\\n\\t\\t\\t\\n\\t\\t\\tif ( objectRemoved === true ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tremoveData.nodesRemovedFrom.push( this );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if search not complete, search nodes\\n\\t\\t\\t\\n\\t\\t\\tif ( removeData.searchComplete !== true ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = 0, l = this.nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// try removing object from node\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tremoveData = node.removeObjectRecursive( object, removeData );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif ( removeData.searchComplete === true ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn removeData;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tcheckGrow: function () {\\n\\t\\t\\t\\n\\t\\t\\t// if object count above max\\n\\t\\t\\t\\n\\t\\t\\tif ( this.objects.length > this.tree.objectsThreshold && this.tree.objectsThreshold > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.grow();\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgrow: function () {\\n\\t\\t\\t\\n\\t\\t\\tvar indexOctant,\\n\\t\\t\\t\\tobject,\\n\\t\\t\\t\\tobjectsExpand = [],\\n\\t\\t\\t\\tobjectsExpandOctants = [],\\n\\t\\t\\t\\tobjectsSplit = [],\\n\\t\\t\\t\\tobjectsSplitOctants = [],\\n\\t\\t\\t\\tobjectsRemaining = [],\\n\\t\\t\\t\\ti, l;\\n\\t\\t\\t\\n\\t\\t\\t// for each object\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = this.objects.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobject = this.objects[ i ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// get object octant index\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindexOctant = this.getOctantIndex( object );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if lies within octant\\n\\t\\t\\t\\tif ( indexOctant > -1 ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tobjectsSplit.push( object );\\n\\t\\t\\t\\t\\tobjectsSplitOctants.push( indexOctant );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t} else if ( indexOctant < -1 ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// lies outside radius\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tobjectsExpand.push( object );\\n\\t\\t\\t\\t\\tobjectsExpandOctants.push( indexOctant );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// lies across bounds between octants\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tobjectsRemaining.push( object );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if has objects to split\\n\\t\\t\\t\\n\\t\\t\\tif ( objectsSplit.length > 0) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectsRemaining = objectsRemaining.concat( this.split( objectsSplit, objectsSplitOctants ) );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if has objects to expand\\n\\t\\t\\t\\n\\t\\t\\tif ( objectsExpand.length > 0) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectsRemaining = objectsRemaining.concat( this.expand( objectsExpand, objectsExpandOctants ) );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// store remaining\\n\\t\\t\\t\\n\\t\\t\\tthis.objects = objectsRemaining;\\n\\t\\t\\t\\n\\t\\t\\t// merge check\\n\\t\\t\\t\\n\\t\\t\\tthis.checkMerge();\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tsplit: function ( objects, octants ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tindexOctant,\\n\\t\\t\\t\\tobject,\\n\\t\\t\\t\\tnode,\\n\\t\\t\\t\\tobjectsRemaining;\\n\\t\\t\\t\\n\\t\\t\\t// if not at max depth\\n\\t\\t\\t\\n\\t\\t\\tif ( this.depth < this.tree.depthMax ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjects = objects || this.objects;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\toctants = octants || [];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectsRemaining = [];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// for each object\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = 0, l = objects.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tobject = objects[ i ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// get object octant index\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexOctant = octants[ i ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// if object contained by octant, branch this tree\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif ( indexOctant > -1 ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tnode = this.branch( indexOctant );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tnode.addObject( object );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tobjectsRemaining.push( object );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if all objects, set remaining as new objects\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( objects === this.objects ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.objects = objectsRemaining;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectsRemaining = this.objects;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn objectsRemaining;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tbranch: function ( indexOctant ) {\\n\\t\\t\\t\\n\\t\\t\\tvar node,\\n\\t\\t\\t\\toverlap,\\n\\t\\t\\t\\tradius,\\n\\t\\t\\t\\tradiusOffset,\\n\\t\\t\\t\\toffset,\\n\\t\\t\\t\\tposition;\\n\\t\\t\\t\\n\\t\\t\\t// node exists\\n\\t\\t\\t\\n\\t\\t\\tif ( this.nodesByIndex[ indexOctant ] instanceof THREE.OctreeNode ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode = this.nodesByIndex[ indexOctant ];\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// properties\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tradius = ( this.radiusOverlap ) * 0.5;\\n\\t\\t\\t\\toverlap = radius * this.tree.overlapPct;\\n\\t\\t\\t\\tradiusOffset = radius - overlap;\\n\\t\\t\\t\\toffset = this.utilVec31Branch.set( indexOctant & 1 ? radiusOffset : -radiusOffset, indexOctant & 2 ? radiusOffset : -radiusOffset, indexOctant & 4 ? radiusOffset : -radiusOffset );\\n\\t\\t\\t\\tposition = new THREE.Vector3().addVectors( this.position, offset );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// node\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode = new THREE.OctreeNode( {\\n\\t\\t\\t\\t\\ttree: this.tree,\\n\\t\\t\\t\\t\\tparent: this,\\n\\t\\t\\t\\t\\tposition: position,\\n\\t\\t\\t\\t\\tradius: radius,\\n\\t\\t\\t\\t\\tindexOctant: indexOctant\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// store\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.addNode( node, indexOctant );\\n\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn node;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\texpand: function ( objects, octants ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tobject,\\n\\t\\t\\t\\tobjectsRemaining,\\n\\t\\t\\t\\tobjectsExpand,\\n\\t\\t\\t\\tindexOctant,\\n\\t\\t\\t\\tflagsOutside,\\n\\t\\t\\t\\tindexOutside,\\n\\t\\t\\t\\tindexOctantInverse,\\n\\t\\t\\t\\tiom = this.tree.INDEX_OUTSIDE_MAP,\\n\\t\\t\\t\\tindexOutsideCounts,\\n\\t\\t\\t\\tinfoIndexOutside1,\\n\\t\\t\\t\\tinfoIndexOutside2,\\n\\t\\t\\t\\tinfoIndexOutside3,\\n\\t\\t\\t\\tindexOutsideBitwise1,\\n\\t\\t\\t\\tindexOutsideBitwise2,\\n\\t\\t\\t\\tinfoPotential1,\\n\\t\\t\\t\\tinfoPotential2,\\n\\t\\t\\t\\tinfoPotential3,\\n\\t\\t\\t\\tindexPotentialBitwise1,\\n\\t\\t\\t\\tindexPotentialBitwise2,\\n\\t\\t\\t\\toctantX, octantY, octantZ,\\n\\t\\t\\t\\toverlap,\\n\\t\\t\\t\\tradius,\\n\\t\\t\\t\\tradiusOffset,\\n\\t\\t\\t\\tradiusParent,\\n\\t\\t\\t\\toverlapParent,\\n\\t\\t\\t\\toffset = this.utilVec31Expand,\\n\\t\\t\\t\\tposition,\\n\\t\\t\\t\\tparent;\\n\\t\\t\\t\\n\\t\\t\\t// handle max depth down tree\\n\\t\\t\\t\\n\\t\\t\\tif ( this.tree.root.getDepthEnd() < this.tree.depthMax ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjects = objects || this.objects;\\n\\t\\t\\t\\toctants = octants || [];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectsRemaining = [];\\n\\t\\t\\t\\tobjectsExpand = [];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// reset counts\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = 0, l = iom.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tiom[ i ].count = 0;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// for all outside objects, find outside octants containing most objects\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = 0, l = objects.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tobject = objects[ i ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// get object octant index\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexOctant = octants[ i ] ;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// if object outside this, include in calculations\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif ( indexOctant < -1 ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// convert octant index to outside flags\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tflagsOutside = -indexOctant - this.tree.INDEX_OUTSIDE_OFFSET;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// check against bitwise flags\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// x\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tif ( flagsOutside & this.tree.FLAG_POS_X ) {\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tiom[ this.tree.INDEX_OUTSIDE_POS_X ].count++;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t} else if ( flagsOutside & this.tree.FLAG_NEG_X ) {\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tiom[ this.tree.INDEX_OUTSIDE_NEG_X ].count++;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// y\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tif ( flagsOutside & this.tree.FLAG_POS_Y ) {\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tiom[ this.tree.INDEX_OUTSIDE_POS_Y ].count++;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t} else if ( flagsOutside & this.tree.FLAG_NEG_Y ) {\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tiom[ this.tree.INDEX_OUTSIDE_NEG_Y ].count++;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// z\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tif ( flagsOutside & this.tree.FLAG_POS_Z ) {\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tiom[ this.tree.INDEX_OUTSIDE_POS_Z ].count++;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t} else if ( flagsOutside & this.tree.FLAG_NEG_Z ) {\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tiom[ this.tree.INDEX_OUTSIDE_NEG_Z ].count++;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// store in expand list\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tobjectsExpand.push( object );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tobjectsRemaining.push( object );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if objects to expand\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( objectsExpand.length > 0 ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// shallow copy index outside map\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexOutsideCounts = iom.slice( 0 );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// sort outside index count so highest is first\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexOutsideCounts.sort( function ( a, b ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\treturn b.count - a.count;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// get highest outside indices\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// first is first\\n\\t\\t\\t\\t\\tinfoIndexOutside1 = indexOutsideCounts[ 0 ];\\n\\t\\t\\t\\t\\tindexOutsideBitwise1 = infoIndexOutside1.index | 1;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// second is ( one of next two bitwise OR 1 ) that is not opposite of ( first bitwise OR 1 )\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tinfoPotential1 = indexOutsideCounts[ 1 ];\\n\\t\\t\\t\\t\\tinfoPotential2 = indexOutsideCounts[ 2 ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tinfoIndexOutside2 = ( infoPotential1.index | 1 ) !== indexOutsideBitwise1 ? infoPotential1 : infoPotential2;\\n\\t\\t\\t\\t\\tindexOutsideBitwise2 = infoIndexOutside2.index | 1;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// third is ( one of next three bitwise OR 1 ) that is not opposite of ( first or second bitwise OR 1 )\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tinfoPotential1 = indexOutsideCounts[ 2 ];\\n\\t\\t\\t\\t\\tinfoPotential2 = indexOutsideCounts[ 3 ];\\n\\t\\t\\t\\t\\tinfoPotential3 = indexOutsideCounts[ 4 ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexPotentialBitwise1 = infoPotential1.index | 1;\\n\\t\\t\\t\\t\\tindexPotentialBitwise2 = infoPotential2.index | 1;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tinfoIndexOutside3 = indexPotentialBitwise1 !== indexOutsideBitwise1 && indexPotentialBitwise1 !== indexOutsideBitwise2 ? infoPotential1 : indexPotentialBitwise2 !== indexOutsideBitwise1 && indexPotentialBitwise2 !== indexOutsideBitwise2 ? infoPotential2 : infoPotential3;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// get this octant normal based on outside octant indices\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\toctantX = infoIndexOutside1.x + infoIndexOutside2.x + infoIndexOutside3.x;\\n\\t\\t\\t\\t\\toctantY = infoIndexOutside1.y + infoIndexOutside2.y + infoIndexOutside3.y;\\n\\t\\t\\t\\t\\toctantZ = infoIndexOutside1.z + infoIndexOutside2.z + infoIndexOutside3.z;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// get this octant indices based on octant normal\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexOctant = this.getOctantIndexFromPosition( octantX, octantY, octantZ );\\n\\t\\t\\t\\t\\tindexOctantInverse = this.getOctantIndexFromPosition( -octantX, -octantY, -octantZ );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// properties\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\toverlap = this.overlap;\\n\\t\\t\\t\\t\\tradius = this.radius;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// radius of parent comes from reversing overlap of this, unless overlap percent is 0\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tradiusParent = this.tree.overlapPct > 0 ? overlap / ( ( 0.5 * this.tree.overlapPct ) * ( 1 + this.tree.overlapPct ) ) : radius * 2; \\n\\t\\t\\t\\t\\toverlapParent = radiusParent * this.tree.overlapPct;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// parent offset is difference between radius + overlap of parent and child\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tradiusOffset = ( radiusParent + overlapParent ) - ( radius + overlap );\\n\\t\\t\\t\\t\\toffset.set( indexOctant & 1 ? radiusOffset : -radiusOffset, indexOctant & 2 ? radiusOffset : -radiusOffset, indexOctant & 4 ? radiusOffset : -radiusOffset );\\n\\t\\t\\t\\t\\tposition = new THREE.Vector3().addVectors( this.position, offset );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// parent\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tparent = new THREE.OctreeNode( {\\n\\t\\t\\t\\t\\t\\ttree: this.tree,\\n\\t\\t\\t\\t\\t\\tposition: position,\\n\\t\\t\\t\\t\\t\\tradius: radiusParent\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// set self as node of parent\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tparent.addNode( this, indexOctantInverse );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// set parent as root\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.tree.setRoot( parent );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// add all expand objects to parent\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor ( i = 0, l = objectsExpand.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tthis.tree.root.addObject( objectsExpand[ i ] );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if all objects, set remaining as new objects\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( objects === this.objects ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.objects = objectsRemaining;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectsRemaining = objects;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn objectsRemaining;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tshrink: function () {\\n\\t\\t\\t\\n\\t\\t\\t// merge check\\n\\t\\t\\t\\n\\t\\t\\tthis.checkMerge();\\n\\t\\t\\t\\n\\t\\t\\t// contract check\\n\\t\\t\\t\\n\\t\\t\\tthis.tree.root.checkContract();\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tcheckMerge: function () {\\n\\t\\t\\t\\n\\t\\t\\tvar nodeParent = this,\\n\\t\\t\\t\\tnodeMerge;\\n\\t\\t\\t\\n\\t\\t\\t// traverse up tree as long as node + entire subtree's object count is under minimum\\n\\t\\t\\t\\n\\t\\t\\twhile ( nodeParent.parent instanceof THREE.OctreeNode && nodeParent.getObjectCountEnd() < this.tree.objectsThreshold ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnodeMerge = nodeParent;\\n\\t\\t\\t\\tnodeParent = nodeParent.parent;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if parent node is not this, merge entire subtree into merge node\\n\\t\\t\\t\\n\\t\\t\\tif ( nodeParent !== this ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnodeParent.merge( nodeMerge );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tmerge: function ( nodes ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tj, k,\\n\\t\\t\\t\\tnode;\\n\\t\\t\\t\\n\\t\\t\\t// handle nodes\\n\\t\\t\\t\\n\\t\\t\\tnodes = toArray( nodes );\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = nodes.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode = nodes[ i ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// gather node + all subtree objects\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.addObjectWithoutCheck( node.getObjectsEnd() );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// reset node + entire subtree\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode.reset( true, true );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// remove node\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tthis.removeNode( node.indexOctant, node );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// merge check\\n\\t\\t\\t\\n\\t\\t\\tthis.checkMerge();\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tcheckContract: function () {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tnode,\\n\\t\\t\\t\\tnodeObjectsCount,\\n\\t\\t\\t\\tnodeHeaviest,\\n\\t\\t\\t\\tnodeHeaviestObjectsCount,\\n\\t\\t\\t\\toutsideHeaviestObjectsCount;\\n\\t\\t\\t\\n\\t\\t\\t// find node with highest object count\\n\\t\\t\\t\\n\\t\\t\\tif ( this.nodesIndices.length > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnodeHeaviestObjectsCount = 0;\\n\\t\\t\\t\\toutsideHeaviestObjectsCount = this.objects.length;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = 0, l = this.nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tnodeObjectsCount = node.getObjectCountEnd();\\n\\t\\t\\t\\t\\toutsideHeaviestObjectsCount += nodeObjectsCount;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif ( nodeHeaviest instanceof THREE.OctreeNode === false || nodeObjectsCount > nodeHeaviestObjectsCount ) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tnodeHeaviest = node;\\n\\t\\t\\t\\t\\t\\tnodeHeaviestObjectsCount = nodeObjectsCount;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// subtract heaviest count from outside count\\n\\t\\t\\t\\t\\n\\t\\t\\t\\toutsideHeaviestObjectsCount -= nodeHeaviestObjectsCount;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if should contract\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( outsideHeaviestObjectsCount < this.tree.objectsThreshold && nodeHeaviest instanceof THREE.OctreeNode ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tthis.contract( nodeHeaviest );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tcontract: function ( nodeRoot ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tnode;\\n\\t\\t\\t\\n\\t\\t\\t// handle all nodes\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = this.nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if node is not new root\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( node !== nodeRoot ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// add node + all subtree objects to root\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tnodeRoot.addObjectWithoutCheck( node.getObjectsEnd() );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// reset node + entire subtree\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tnode.reset( true, true );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// add own objects to root\\n\\t\\t\\t\\n\\t\\t\\tnodeRoot.addObjectWithoutCheck( this.objects );\\n\\t\\t\\t\\n\\t\\t\\t// reset self\\n\\t\\t\\t\\n\\t\\t\\tthis.reset( false, true );\\n\\t\\t\\t\\n\\t\\t\\t// set new root\\n\\t\\t\\t\\n\\t\\t\\tthis.tree.setRoot( nodeRoot );\\n\\t\\t\\t\\n\\t\\t\\t// contract check on new root\\n\\t\\t\\t\\n\\t\\t\\tnodeRoot.checkContract();\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetOctantIndex: function ( objectData ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tpositionObj,\\n\\t\\t\\t\\tradiusObj,\\n\\t\\t\\t\\tposition = this.position,\\n\\t\\t\\t\\tradiusOverlap = this.radiusOverlap,\\n\\t\\t\\t\\toverlap = this.overlap,\\n\\t\\t\\t\\tdeltaX, deltaY, deltaZ,\\n\\t\\t\\t\\tdistX, distY, distZ, \\n\\t\\t\\t\\tdistance,\\n\\t\\t\\t\\tindexOctant = 0;\\n\\t\\t\\t\\n\\t\\t\\t// handle type\\n\\t\\t\\t\\n\\t\\t\\tif ( objectData instanceof THREE.OctreeObjectData ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tradiusObj = objectData.radius;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tpositionObj = objectData.position;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// update object data position last\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectData.positionLast.copy( positionObj );\\n\\t\\t\\t\\t\\n\\t\\t\\t} else if ( objectData instanceof THREE.OctreeNode ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tpositionObj = objectData.position;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tradiusObj = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// find delta and distance\\n\\t\\t\\t\\n\\t\\t\\tdeltaX = positionObj.x - position.x;\\n\\t\\t\\tdeltaY = positionObj.y - position.y;\\n\\t\\t\\tdeltaZ = positionObj.z - position.z;\\n\\t\\t\\t\\n\\t\\t\\tdistX = Math.abs( deltaX );\\n\\t\\t\\tdistY = Math.abs( deltaY );\\n\\t\\t\\tdistZ = Math.abs( deltaZ );\\n\\t\\t\\tdistance = Math.max( distX, distY, distZ );\\n\\t\\t\\t\\n\\t\\t\\t// if outside, use bitwise flags to indicate on which sides object is outside of\\n\\t\\t\\t\\n\\t\\t\\tif ( distance + radiusObj > radiusOverlap ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// x\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( distX + radiusObj > radiusOverlap ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexOctant = indexOctant ^ ( deltaX > 0 ? this.tree.FLAG_POS_X : this.tree.FLAG_NEG_X );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// y\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( distY + radiusObj > radiusOverlap ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexOctant = indexOctant ^ ( deltaY > 0 ? this.tree.FLAG_POS_Y : this.tree.FLAG_NEG_Y );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// z\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( distZ + radiusObj > radiusOverlap ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tindexOctant = indexOctant ^ ( deltaZ > 0 ? this.tree.FLAG_POS_Z : this.tree.FLAG_NEG_Z );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectData.indexOctant = -indexOctant - this.tree.INDEX_OUTSIDE_OFFSET;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\treturn objectData.indexOctant;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// return octant index from delta xyz\\n\\t\\t\\t\\n\\t\\t\\tif ( deltaX - radiusObj > -overlap ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// x right\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindexOctant = indexOctant | 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t} else if ( !( deltaX + radiusObj < overlap ) ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// x left\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;\\n\\t\\t\\t\\treturn objectData.indexOctant;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif ( deltaY - radiusObj > -overlap ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// y right\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindexOctant = indexOctant | 2;\\n\\t\\t\\t\\t\\n\\t\\t\\t} else if ( !( deltaY + radiusObj < overlap ) ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// y left\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;\\n\\t\\t\\t\\treturn objectData.indexOctant;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tif ( deltaZ - radiusObj > -overlap ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// z right\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindexOctant = indexOctant | 4;\\n\\t\\t\\t\\t\\n\\t\\t\\t} else if ( !( deltaZ + radiusObj < overlap ) ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// z left\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;\\n\\t\\t\\t\\treturn objectData.indexOctant;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tobjectData.indexOctant = indexOctant;\\n\\t\\t\\treturn objectData.indexOctant;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetOctantIndexFromPosition: function ( x, y, z ) {\\n\\t\\t\\t\\n\\t\\t\\tvar indexOctant = 0;\\n\\t\\t\\t\\n\\t\\t\\tif ( x > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindexOctant = indexOctant | 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif ( y > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindexOctant = indexOctant | 2;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif ( z > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindexOctant = indexOctant | 4;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn indexOctant;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tsearch: function ( position, radius, objects, direction, directionPct ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tnode,\\n\\t\\t\\t\\tintersects;\\n\\t\\t\\t\\n\\t\\t\\t// test intersects by parameters\\n\\t\\t\\t\\n\\t\\t\\tif ( direction ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tintersects = this.intersectRay( position, direction, radius, directionPct );\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tintersects = this.intersectSphere( position, radius );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// if intersects\\n\\t\\t\\t\\n\\t\\t\\tif ( intersects === true ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// gather objects\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjects = objects.concat( this.objects );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// search subtree\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = 0, l = this.nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tobjects = node.search( position, radius, objects, direction );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn objects;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tintersectSphere: function ( position, radius ) {\\n\\t\\t\\t\\n\\t\\t\\tvar\\tdistance = radius * radius,\\n\\t\\t\\t\\tpx = position.x,\\n\\t\\t\\t\\tpy = position.y,\\n\\t\\t\\t\\tpz = position.z;\\n\\t\\t\\t\\n\\t\\t\\tif ( px < this.left ) {\\n\\t\\t\\t\\tdistance -= Math.pow( px - this.left, 2 );\\n\\t\\t\\t} else if ( px > this.right ) {\\n\\t\\t\\t\\tdistance -= Math.pow( px - this.right, 2 );\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif ( py < this.bottom ) {\\n\\t\\t\\t\\tdistance -= Math.pow( py - this.bottom, 2 );\\n\\t\\t\\t} else if ( py > this.top ) {\\n\\t\\t\\t\\tdistance -= Math.pow( py - this.top, 2 );\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif ( pz < this.back ) {\\n\\t\\t\\t\\tdistance -= Math.pow( pz - this.back, 2 );\\n\\t\\t\\t} else if ( pz > this.front ) {\\n\\t\\t\\t\\tdistance -= Math.pow( pz - this.front, 2 );\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn distance >= 0;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tintersectRay: function ( origin, direction, distance, directionPct ) {\\n\\t\\t\\t\\n\\t\\t\\tif ( typeof directionPct === 'undefined' ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tdirectionPct = this.utilVec31Ray.set( 1, 1, 1 ).divide( direction );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tvar t1 = ( this.left - origin.x ) * directionPct.x,\\n\\t\\t\\t\\tt2 = ( this.right - origin.x ) * directionPct.x,\\n\\t\\t\\t\\tt3 = ( this.bottom - origin.y ) * directionPct.y,\\n\\t\\t\\t\\tt4 = ( this.top - origin.y ) * directionPct.y,\\n\\t\\t\\t\\tt5 = ( this.back - origin.z ) * directionPct.z,\\n\\t\\t\\t\\tt6 = ( this.front - origin.z ) * directionPct.z,\\n\\t\\t\\t\\ttmax = Math.min( Math.min( Math.max( t1, t2), Math.max( t3, t4) ), Math.max( t5, t6) ),\\n\\t\\t\\t\\ttmin;\\n\\n\\t\\t\\t// ray would intersect in reverse direction, i.e. this is behind ray\\n\\t\\t\\tif (tmax < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\ttmin = Math.max( Math.max( Math.min( t1, t2), Math.min( t3, t4)), Math.min( t5, t6));\\n\\t\\t\\t\\n\\t\\t\\t// if tmin > tmax or tmin > ray distance, ray doesn't intersect AABB\\n\\t\\t\\tif( tmin > tmax || tmin > distance ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetDepthEnd: function ( depth ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tnode;\\n\\n\\t\\t\\tif ( this.nodesIndices.length > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( i = 0, l = this.nodesIndices.length; i < l; i++ ) {\\n\\n\\t\\t\\t\\t\\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\\n\\n\\t\\t\\t\\t\\tdepth = node.getDepthEnd( depth );\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdepth = !depth || this.depth > depth ? this.depth : depth;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn depth;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetNodeCountEnd: function () {\\n\\t\\t\\t\\n\\t\\t\\treturn this.tree.root.getNodeCountRecursive() + 1;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetNodeCountRecursive: function () {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tcount = this.nodesIndices.length;\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = this.nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount += this.nodesByIndex[ this.nodesIndices[ i ] ].getNodeCountRecursive();\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn count;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetObjectsEnd: function ( objects ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tnode;\\n\\t\\t\\t\\n\\t\\t\\tobjects = ( objects || [] ).concat( this.objects );\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = this.nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobjects = node.getObjectsEnd( objects );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn objects;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetObjectCountEnd: function () {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tcount = this.objects.length;\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = this.nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount += this.nodesByIndex[ this.nodesIndices[ i ] ].getObjectCountEnd();\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn count;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\tgetObjectCountStart: function () {\\n\\t\\t\\t\\n\\t\\t\\tvar count = this.objects.length,\\n\\t\\t\\t\\tparent = this.parent;\\n\\t\\t\\t\\n\\t\\t\\twhile( parent instanceof THREE.OctreeNode ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount += parent.objects.length;\\n\\t\\t\\t\\tparent = parent.parent;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn count;\\n\\t\\t\\t\\n\\t\\t},\\n\\t\\t\\n\\t\\ttoConsole: function ( space ) {\\n\\t\\t\\t\\n\\t\\t\\tvar i, l,\\n\\t\\t\\t\\tnode,\\n\\t\\t\\t\\tspaceAddition = '   ';\\n\\t\\t\\t\\n\\t\\t\\tspace = typeof space === 'string' ? space : spaceAddition;\\n\\t\\t\\t\\n\\t\\t\\tconsole.log( ( this.parent ? space + ' octree NODE > ' : ' octree ROOT > ' ), this, ' // id: ', this.id, ' // indexOctant: ', this.indexOctant, ' // position: ', this.position.x, this.position.y, this.position.z, ' // radius: ', this.radius, ' // depth: ', this.depth );\\n\\t\\t\\tconsole.log( ( this.parent ? space + ' ' : ' ' ), '+ objects ( ', this.objects.length, ' ) ', this.objects );\\n\\t\\t\\tconsole.log( ( this.parent ? space + ' ' : ' ' ), '+ children ( ', this.nodesIndices.length, ' )', this.nodesIndices, this.nodesByIndex );\\n\\t\\t\\t\\n\\t\\t\\tfor ( i = 0, l = this.nodesIndices.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tnode.toConsole( space + spaceAddition );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t};\\n\\n\\t/*===================================================\\n\\n\\traycaster additional functionality\\n\\n\\t=====================================================*/\\n\\t\\n\\tTHREE.Raycaster.prototype.intersectOctreeObject = function ( object, recursive ) {\\n\\t\\t\\n\\t\\tvar intersects,\\n\\t\\t\\toctreeObject,\\n\\t\\t\\tfacesAll,\\n\\t\\t\\tfacesSearch;\\n\\t\\t\\n\\t\\tif ( object.object instanceof THREE.Object3D ) {\\n\\t\\t\\t\\n\\t\\t\\toctreeObject = object;\\n\\t\\t\\tobject = octreeObject.object;\\n\\t\\t\\t\\n\\t\\t\\t// temporarily replace object geometry's faces with octree object faces\\n\\t\\t\\t\\n\\t\\t\\tfacesSearch = octreeObject.faces;\\n\\t\\t\\tfacesAll = object.geometry.faces;\\n\\t\\t\\t\\n\\t\\t\\tif ( facesSearch.length > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobject.geometry.faces = facesSearch;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// intersect\\n\\t\\t\\t\\n\\t\\t\\tintersects = this.intersectObject( object, recursive );\\n\\t\\t\\t\\n\\t\\t\\t// revert object geometry's faces\\n\\t\\t\\t\\n\\t\\t\\tif ( facesSearch.length > 0 ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tobject.geometry.faces = facesAll;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t} else {\\n\\t\\t\\t\\n\\t\\t\\tintersects = this.intersectObject( object, recursive );\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn intersects;\\n\\t\\t\\n\\t};\\n\\t\\n\\tTHREE.Raycaster.prototype.intersectOctreeObjects = function ( objects, recursive ) {\\n\\t\\t\\n\\t\\tvar i, il,\\n\\t\\t\\tintersects = [];\\n\\t\\t\\n\\t\\tfor ( i = 0, il = objects.length; i < il; i++ ) {\\n\\t\\t\\t\\n\\t\\t\\tintersects = intersects.concat( this.intersectOctreeObject( objects[ i ], recursive ) );\\n\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn intersects;\\n\\t\\t\\n\\t};\\n\\n}( THREE ) );\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/TypedArrayUtils.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/TypedArrayUtils.js\",\n            \"module-type\": \"library\",\n            \"text\": \"\\nTHREE.TypedArrayUtils = {};\\n\\n/**\\n * In-place quicksort for typed arrays (e.g. for Float32Array)\\n * provides fast sorting\\n * useful e.g. for a custom shader and/or BufferGeometry\\n *\\n * @author Roman Bolzern <roman.bolzern@fhnw.ch>, 2013\\n * @author I4DS http://www.fhnw.ch/i4ds, 2013\\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\\n *\\n * Complexity: http://bigocheatsheet.com/ see Quicksort\\n *\\n * Example: \\n * points: [x, y, z, x, y, z, x, y, z, ...]\\n * eleSize: 3 //because of (x, y, z)\\n * orderElement: 0 //order according to x\\n */\\n\\nTHREE.TypedArrayUtils.quicksortIP = function ( arr, eleSize, orderElement ) {\\n\\n\\tvar stack = [];\\n\\tvar sp = -1;\\n\\tvar left = 0;\\n\\tvar right = arr.length / eleSize - 1;\\n\\tvar tmp = 0.0, x = 0, y = 0;\\n\\n\\tvar swapF = function ( a, b ) {\\n\\n\\t\\ta *= eleSize; b *= eleSize;\\n\\n\\t\\tfor ( y = 0; y < eleSize; y ++ ) {\\n\\n\\t\\t\\ttmp = arr[ a + y ];\\n\\t\\t\\tarr[ a + y ]=arr[ b + y ];\\n\\t\\t\\tarr[ b + y ]=tmp;\\n\\n\\t\\t}\\n\\n\\t};\\n\\t\\n\\tvar i, j, swap = new Float32Array( eleSize ), temp = new Float32Array( eleSize );\\n\\n\\twhile ( true ) {\\n\\n\\t\\tif ( right - left <= 25 ) {\\n\\n\\t\\t\\tfor ( j= left + 1; j <= right; j ++ ) {\\n\\n\\t\\t\\t\\tfor ( x = 0; x < eleSize; x ++ ) {\\n\\t\\t\\t\\n\\t\\t\\t\\t\\tswap[ x ] = arr[ j * eleSize + x ];\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ti = j - 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile ( i >= left && arr[ i * eleSize + orderElement ] > swap[orderElement ] ) {\\n\\n\\t\\t\\t\\t\\tfor ( x = 0; x < eleSize; x ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tarr[ ( i + 1 ) * eleSize + x ] = arr[ i * eleSize + x ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ti --;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( x = 0; x < eleSize; x ++ ) {\\n\\n\\t\\t\\t\\t\\tarr[ ( i + 1 ) * eleSize + x ] = swap[ x ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif ( sp == -1 ) break;\\n\\n\\t\\t\\tright = stack[ sp -- ]; //?\\n\\t\\t\\tleft = stack[ sp -- ];\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tvar median = ( left + right ) >> 1;\\n\\n\\t\\t\\ti = left + 1;\\n\\t\\t\\tj = right;\\n\\t\\n\\t\\t\\tswapF( median, i );\\n\\n\\t\\t\\tif ( arr[ left * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {\\n\\t\\t\\n\\t\\t\\t\\tswapF( left, right );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( arr[ i * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {\\n\\t\\t\\n\\t\\t\\t\\tswapF( i, right );\\n\\t\\t\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( arr[ left * eleSize + orderElement ] > arr[ i * eleSize + orderElement ] ) {\\n\\t\\t\\n\\t\\t\\t\\tswapF( left, i );\\n\\t\\t\\t\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( x = 0; x < eleSize; x ++ ) {\\n\\n\\t\\t\\t\\ttemp[ x ] = arr[ i * eleSize + x ];\\n\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\twhile ( true ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tdo i ++; while ( arr[ i * eleSize + orderElement ] < temp[ orderElement ] );\\n\\t\\t\\t\\tdo j --; while ( arr[ j * eleSize + orderElement ] > temp[ orderElement ] );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( j < i ) break;\\n\\t\\t\\n\\t\\t\\t\\tswapF( i, j );\\n\\t\\t\\t\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( x = 0; x < eleSize; x ++ ) {\\n\\n\\t\\t\\t\\tarr[ ( left + 1 ) * eleSize + x ] = arr[ j * eleSize + x ];\\n\\t\\t\\t\\tarr[ j * eleSize + x ] = temp[ x ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( right - i + 1 >= j - left ) {\\n\\n\\t\\t\\t\\tstack[ ++ sp ] = i;\\n\\t\\t\\t\\tstack[ ++ sp ] = right;\\n\\t\\t\\t\\tright = j - 1;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tstack[ ++ sp ] = left;\\n\\t\\t\\t\\tstack[ ++ sp ] = j - 1;\\n\\t\\t\\t\\tleft = i;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn arr;\\n\\n};\\n\\n\\n\\n/**\\n * k-d Tree for typed arrays (e.g. for Float32Array), in-place\\n * provides fast nearest neighbour search\\n * useful e.g. for a custom shader and/or BufferGeometry, saves tons of memory\\n * has no insert and remove, only buildup and neares neighbour search\\n *\\n * Based on https://github.com/ubilabs/kd-tree-javascript by Ubilabs\\n *\\n * @author Roman Bolzern <roman.bolzern@fhnw.ch>, 2013\\n * @author I4DS http://www.fhnw.ch/i4ds, 2013\\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\\n *\\n * Requires typed array quicksort\\n *\\n * Example: \\n * points: [x, y, z, x, y, z, x, y, z, ...]\\n * metric: function(a, b){\\treturn Math.pow(a[0] - b[0], 2) +  Math.pow(a[1] - b[1], 2) +  Math.pow(a[2] - b[2], 2); }  //Manhatten distance\\n * eleSize: 3 //because of (x, y, z)\\n *\\n * Further information (including mathematical properties)\\n * http://en.wikipedia.org/wiki/Binary_tree\\n * http://en.wikipedia.org/wiki/K-d_tree\\n *\\n * If you want to further minimize memory usage, remove Node.depth and replace in search algorithm with a traversal to root node (see comments at THREE.TypedArrayUtils.Kdtree.prototype.Node)\\n */\\n\\n THREE.TypedArrayUtils.Kdtree = function ( points, metric, eleSize ) {\\n\\n\\tvar self = this;\\n\\t\\n\\tvar maxDepth = 0;\\n\\t\\n\\tvar getPointSet = function ( points, pos ) {\\n\\n\\t\\treturn points.subarray( pos * eleSize, pos * eleSize + eleSize );\\n\\n\\t};\\n\\t\\t\\n\\tfunction buildTree( points, depth, parent, pos ) {\\n\\n\\t\\tvar dim = depth % eleSize,\\n\\t\\t\\tmedian,\\n\\t\\t\\tnode,\\n\\t\\t\\tplength = points.length / eleSize;\\n\\n\\t\\tif ( depth > maxDepth ) maxDepth = depth;\\n\\t\\t\\n\\t\\tif ( plength === 0 ) return null;\\n\\t\\tif ( plength === 1 ) {\\n\\n\\t\\t\\treturn new self.Node( getPointSet( points, 0 ), depth, parent, pos );\\n\\n\\t\\t}\\n\\n\\t\\tTHREE.TypedArrayUtils.quicksortIP( points, eleSize, dim );\\n\\t\\t\\n\\t\\tmedian = Math.floor( plength / 2 );\\n\\t\\t\\n\\t\\tnode = new self.Node( getPointSet( points, median ) , depth, parent, median + pos );\\n\\t\\tnode.left = buildTree( points.subarray( 0, median * eleSize), depth + 1, node, pos );\\n\\t\\tnode.right = buildTree( points.subarray( ( median + 1 ) * eleSize, points.length ), depth + 1, node, pos + median + 1 );\\n\\n\\t\\treturn node;\\n\\t\\n\\t}\\n\\n\\tthis.root = buildTree( points, 0, null, 0 );\\n\\t\\t\\n\\tthis.getMaxDepth = function () { return maxDepth; };\\n\\t\\n\\tthis.nearest = function ( point, maxNodes , maxDistance ) {\\n\\t\\n\\t\\t /* point: array of size eleSize \\n\\t\\t\\tmaxNodes: max amount of nodes to return \\n\\t\\t\\tmaxDistance: maximum distance to point result nodes should have\\n\\t\\t\\tcondition (not implemented): function to test node before it's added to the result list, e.g. test for view frustum\\n\\t\\t*/\\n\\n\\t\\tvar i,\\n\\t\\t\\tresult,\\n\\t\\t\\tbestNodes;\\n\\n\\t\\tbestNodes = new THREE.TypedArrayUtils.Kdtree.BinaryHeap(\\n\\n\\t\\t\\tfunction ( e ) { return -e[ 1 ]; }\\n\\n\\t\\t);\\n\\n\\t\\tfunction nearestSearch( node ) {\\n\\n\\t\\t\\tvar bestChild,\\n\\t\\t\\t\\tdimension = node.depth % eleSize,\\n\\t\\t\\t\\townDistance = metric(point, node.obj),\\n\\t\\t\\t\\tlinearDistance = 0,\\n\\t\\t\\t\\totherChild,\\n\\t\\t\\t\\ti,\\n\\t\\t\\t\\tlinearPoint = [];\\n\\n\\t\\t\\tfunction saveNode( node, distance ) {\\n\\n\\t\\t\\t\\tbestNodes.push( [ node, distance ] );\\n\\n\\t\\t\\t\\tif ( bestNodes.size() > maxNodes ) {\\n\\n\\t\\t\\t\\t\\tbestNodes.pop();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( i = 0; i < eleSize; i += 1 ) {\\n\\n\\t\\t\\t\\tif ( i === node.depth % eleSize ) {\\n\\n\\t\\t\\t\\t\\tlinearPoint[ i ] = point[ i ];\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tlinearPoint[ i ] = node.obj[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tlinearDistance = metric( linearPoint, node.obj );\\n\\n\\t\\t\\t// if it's a leaf\\n\\n\\t\\t\\tif ( node.right === null && node.left === null ) {\\n\\n\\t\\t\\t\\tif ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {\\n\\n\\t\\t\\t\\t\\tsaveNode( node, ownDistance );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( node.right === null ) {\\n\\n\\t\\t\\t\\tbestChild = node.left;\\n\\n\\t\\t\\t} else if ( node.left === null ) {\\n\\n\\t\\t\\t\\tbestChild = node.right;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tif ( point[ dimension ] < node.obj[ dimension ] ) {\\n\\n\\t\\t\\t\\t\\tbestChild = node.left;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tbestChild = node.right;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// recursive search\\n\\n\\t\\t\\tnearestSearch( bestChild );\\n\\n\\t\\t\\tif ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {\\n\\n\\t\\t\\t\\tsaveNode( node, ownDistance );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if there's still room or the current distance is nearer than the best distance\\n\\n\\t\\t\\tif ( bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[ 1 ] ) {\\n\\n\\t\\t\\t\\tif ( bestChild === node.left ) {\\n\\n\\t\\t\\t\\t\\totherChild = node.right;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\totherChild = node.left;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( otherChild !== null ) {\\n\\n\\t\\t\\t\\t\\tnearestSearch( otherChild );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( maxDistance ) {\\n\\n\\t\\t\\tfor ( i = 0; i < maxNodes; i += 1 ) {\\n\\n\\t\\t\\t\\tbestNodes.push( [ null, maxDistance ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tnearestSearch( self.root );\\n\\n\\t\\tresult = [];\\n\\n\\t\\tfor ( i = 0; i < maxNodes; i += 1 ) {\\n\\n\\t\\t\\tif ( bestNodes.content[ i ][ 0 ] ) {\\n\\n\\t\\t\\t\\tresult.push( [ bestNodes.content[ i ][ 0 ], bestNodes.content[ i ][ 1 ] ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn result;\\n\\t\\n\\t};\\n\\t\\n};\\n\\n/**\\n * If you need to free up additional memory and agree with an additional O( log n ) traversal time you can get rid of \\\"depth\\\" and \\\"pos\\\" in Node:\\n * Depth can be easily done by adding 1 for every parent (care: root node has depth 0, not 1)\\n * Pos is a bit tricky: Assuming the tree is balanced (which is the case when after we built it up), perform the following steps:\\n *   By traversing to the root store the path e.g. in a bit pattern (01001011, 0 is left, 1 is right)\\n *   From buildTree we know that \\\"median = Math.floor( plength / 2 );\\\", therefore for each bit...\\n *     0: amountOfNodesRelevantForUs = Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\\n *     1: amountOfNodesRelevantForUs = Math.ceil( (pamountOfNodesRelevantForUs - 1) / 2 );\\n *        pos += Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\\n *     when recursion done, we still need to add all left children of target node:\\n *        pos += Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\\n *        and I think you need to +1 for the current position, not sure.. depends, try it out ^^\\n *\\n * I experienced that for 200'000 nodes you can get rid of 4 MB memory each, leading to 8 MB memory saved.\\n */\\nTHREE.TypedArrayUtils.Kdtree.prototype.Node = function ( obj, depth, parent, pos ) {\\n\\n\\tthis.obj = obj;\\n\\tthis.left = null;\\n\\tthis.right = null;\\n\\tthis.parent = parent;\\n\\tthis.depth = depth;\\n\\tthis.pos = pos;\\n\\n}; \\n\\n/**\\n * Binary heap implementation\\n * @author http://eloquentjavascript.net/appendix2.htm\\n */\\n\\nTHREE.TypedArrayUtils.Kdtree.BinaryHeap = function ( scoreFunction ) {\\n\\n\\tthis.content = [];\\n\\tthis.scoreFunction = scoreFunction;\\n\\n};\\n\\nTHREE.TypedArrayUtils.Kdtree.BinaryHeap.prototype = {\\n\\n\\tpush: function ( element ) {\\n\\n\\t\\t// Add the new element to the end of the array.\\n\\t\\tthis.content.push( element );\\n\\n\\t\\t// Allow it to bubble up.\\n\\t\\tthis.bubbleUp( this.content.length - 1 );\\n\\n\\t},\\n\\n\\tpop: function () {\\n\\n\\t\\t// Store the first element so we can return it later.\\n\\t\\tvar result = this.content[ 0 ];\\n\\n\\t\\t// Get the element at the end of the array.\\n\\t\\tvar end = this.content.pop();\\n\\n\\t\\t// If there are any elements left, put the end element at the\\n\\t\\t// start, and let it sink down.\\n\\t\\tif ( this.content.length > 0 ) {\\n\\n\\t\\t\\tthis.content[ 0 ] = end;\\n\\t\\t\\tthis.sinkDown( 0 );\\n\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\n\\t},\\n\\n\\tpeek: function () {\\n\\n\\t\\treturn this.content[ 0 ];\\n\\n\\t},\\n\\n\\tremove: function ( node ) {\\n\\n\\t\\tvar len = this.content.length;\\n\\n\\t\\t// To remove a value, we must search through the array to find it.\\n\\t\\tfor ( var i = 0; i < len; i ++ ) {\\n\\n\\t\\t\\tif ( this.content[ i ] == node ) {\\n\\n\\t\\t\\t\\t// When it is found, the process seen in 'pop' is repeated\\n\\t\\t\\t\\t// to fill up the hole.\\n\\t\\t\\t\\tvar end = this.content.pop();\\n\\n\\t\\t\\t\\tif ( i != len - 1 ) {\\n\\n\\t\\t\\t\\t\\tthis.content[ i ] = end;\\n\\n\\t\\t\\t\\t\\tif ( this.scoreFunction( end ) < this.scoreFunction( node ) ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.bubbleUp( i );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tthis.sinkDown( i );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthrow new Error( \\\"Node not found.\\\" );\\n\\n\\t},\\n\\n\\tsize: function () {\\n\\n\\t\\treturn this.content.length;\\n\\n\\t},\\n\\n\\tbubbleUp: function ( n ) {\\n\\n\\t\\t// Fetch the element that has to be moved.\\n\\t\\tvar element = this.content[ n ];\\n\\n\\t\\t// When at 0, an element can not go up any further.\\n\\t\\twhile ( n > 0 ) {\\n\\n\\t\\t\\t// Compute the parent element's index, and fetch it.\\n\\t\\t\\tvar parentN = Math.floor( ( n + 1 ) / 2 ) - 1,\\n\\t\\t\\t\\tparent = this.content[ parentN ];\\n\\n\\t\\t\\t// Swap the elements if the parent is greater.\\n\\t\\t\\tif ( this.scoreFunction( element ) < this.scoreFunction( parent ) ) {\\n\\n\\t\\t\\t\\tthis.content[ parentN ] = element;\\n\\t\\t\\t\\tthis.content[ n ] = parent;\\n\\n\\t\\t\\t\\t// Update 'n' to continue at the new position.\\n\\t\\t\\t\\tn = parentN;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Found a parent that is less, no need to move it further.\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tsinkDown: function ( n ) {\\n\\n\\t\\t// Look up the target element and its score.\\n\\t\\tvar length = this.content.length,\\n\\t\\t\\telement = this.content[ n ],\\n\\t\\t\\telemScore = this.scoreFunction( element );\\n\\n\\t\\twhile ( true ) {\\n\\n\\t\\t\\t// Compute the indices of the child elements.\\n\\t\\t\\tvar child2N = ( n + 1 ) * 2, child1N = child2N - 1;\\n\\n\\t\\t\\t// This is used to store the new position of the element, if any.\\n\\t\\t\\tvar swap = null;\\n\\n\\t\\t\\t// If the first child exists (is inside the array)...\\n\\t\\t\\tif ( child1N < length ) {\\n\\n\\t\\t\\t\\t// Look it up and compute its score.\\n\\t\\t\\t\\tvar child1 = this.content[ child1N ],\\n\\t\\t\\t\\t\\tchild1Score = this.scoreFunction( child1 );\\n\\n\\t\\t\\t\\t// If the score is less than our element's, we need to swap.\\n\\t\\t\\t\\tif ( child1Score < elemScore ) swap = child1N;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Do the same checks for the other child.\\n\\t\\t\\tif ( child2N < length ) {\\n\\n\\t\\t\\t\\tvar child2 = this.content[ child2N ],\\n\\t\\t\\t\\t\\tchild2Score = this.scoreFunction( child2 );\\n\\n\\t\\t\\t\\tif ( child2Score < ( swap === null ? elemScore : child1Score ) ) swap = child2N;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If the element needs to be moved, swap it, and continue.\\n\\t\\t\\tif ( swap !== null ) {\\n\\n\\t\\t\\t\\tthis.content[ n ] = this.content[ swap ];\\n\\t\\t\\t\\tthis.content[ swap ] = element;\\n\\t\\t\\t\\tn = swap;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Otherwise, we are done.\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Mirror.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Mirror.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\r\\n * @author Slayvin / http://slayvin.net\\r\\n */\\r\\n\\r\\nTHREE.ShaderLib['mirror'] = {\\r\\n\\r\\n\\tuniforms: { \\\"mirrorColor\\\": { type: \\\"c\\\", value: new THREE.Color(0x7F7F7F) },\\r\\n\\t\\t\\t\\t\\\"mirrorSampler\\\": { type: \\\"t\\\", value: null },\\r\\n\\t\\t\\t\\t\\\"textureMatrix\\\" : { type: \\\"m4\\\", value: new THREE.Matrix4() }\\r\\n\\t},\\r\\n\\r\\n\\tvertexShader: [\\r\\n\\r\\n\\t\\t\\\"uniform mat4 textureMatrix;\\\",\\r\\n\\r\\n\\t\\t\\\"varying vec4 mirrorCoord;\\\",\\r\\n\\r\\n\\t\\t\\\"void main() {\\\",\\r\\n\\r\\n\\t\\t\\t\\\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\",\\r\\n\\t\\t\\t\\\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\",\\r\\n\\t\\t\\t\\\"mirrorCoord = textureMatrix * worldPosition;\\\",\\r\\n\\r\\n\\t\\t\\t\\\"gl_Position = projectionMatrix * mvPosition;\\\",\\r\\n\\r\\n\\t\\t\\\"}\\\"\\r\\n\\r\\n\\t].join(\\\"\\\\n\\\"),\\r\\n\\r\\n\\tfragmentShader: [\\r\\n\\r\\n\\t\\t\\\"uniform vec3 mirrorColor;\\\",\\r\\n\\t\\t\\\"uniform sampler2D mirrorSampler;\\\",\\r\\n\\r\\n\\t\\t\\\"varying vec4 mirrorCoord;\\\",\\r\\n\\r\\n\\t\\t\\\"float blendOverlay(float base, float blend) {\\\",\\r\\n\\t\\t\\t\\\"return( base < 0.5 ? ( 2.0 * base * blend ) : (1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\\",\\r\\n\\t\\t\\\"}\\\",\\r\\n\\t\\t\\r\\n\\t\\t\\\"void main() {\\\",\\r\\n\\r\\n\\t\\t\\t\\\"vec4 color = texture2DProj(mirrorSampler, mirrorCoord);\\\",\\r\\n\\t\\t\\t\\\"color = vec4(blendOverlay(mirrorColor.r, color.r), blendOverlay(mirrorColor.g, color.g), blendOverlay(mirrorColor.b, color.b), 1.0);\\\",\\r\\n\\r\\n\\t\\t\\t\\\"gl_FragColor = color;\\\",\\r\\n\\r\\n\\t\\t\\\"}\\\"\\r\\n\\r\\n\\t].join(\\\"\\\\n\\\")\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.Mirror = function ( renderer, camera, options ) {\\r\\n\\r\\n\\tTHREE.Object3D.call( this );\\r\\n\\r\\n\\tthis.name = 'mirror_' + this.id;\\r\\n\\r\\n\\toptions = options || {};\\r\\n\\r\\n\\tthis.matrixNeedsUpdate = true;\\r\\n\\r\\n\\tvar width = options.textureWidth !== undefined ? options.textureWidth : 512;\\r\\n\\tvar height = options.textureHeight !== undefined ? options.textureHeight : 512;\\r\\n\\r\\n\\tthis.clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\\r\\n\\r\\n\\tvar mirrorColor = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(0x7F7F7F);\\r\\n\\r\\n\\tthis.renderer = renderer;\\r\\n\\tthis.mirrorPlane = new THREE.Plane();\\r\\n\\tthis.normal = new THREE.Vector3( 0, 0, 1 );\\r\\n\\tthis.mirrorWorldPosition = new THREE.Vector3();\\r\\n\\tthis.cameraWorldPosition = new THREE.Vector3();\\r\\n\\tthis.rotationMatrix = new THREE.Matrix4();\\r\\n\\tthis.lookAtPosition = new THREE.Vector3(0, 0, -1);\\r\\n\\tthis.clipPlane = new THREE.Vector4();\\r\\n\\t\\r\\n\\t// For debug only, show the normal and plane of the mirror\\r\\n\\tvar debugMode = options.debugMode !== undefined ? options.debugMode : false;\\r\\n\\r\\n\\tif ( debugMode ) {\\r\\n\\r\\n\\t\\tvar arrow = new THREE.ArrowHelper(new THREE.Vector3( 0, 0, 1 ), new THREE.Vector3( 0, 0, 0 ), 10, 0xffff80 );\\r\\n\\t\\tvar planeGeometry = new THREE.Geometry();\\r\\n\\t\\tplaneGeometry.vertices.push( new THREE.Vector3( -10, -10, 0 ) );\\r\\n\\t\\tplaneGeometry.vertices.push( new THREE.Vector3( 10, -10, 0 ) );\\r\\n\\t\\tplaneGeometry.vertices.push( new THREE.Vector3( 10, 10, 0 ) );\\r\\n\\t\\tplaneGeometry.vertices.push( new THREE.Vector3( -10, 10, 0 ) );\\r\\n\\t\\tplaneGeometry.vertices.push( planeGeometry.vertices[0] );\\r\\n\\t\\tvar plane = new THREE.Line( planeGeometry, new THREE.LineBasicMaterial( { color: 0xffff80 } ) );\\r\\n\\r\\n\\t\\tthis.add(arrow);\\r\\n\\t\\tthis.add(plane);\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( camera instanceof THREE.PerspectiveCamera ) {\\r\\n\\r\\n\\t\\tthis.camera = camera;\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\tthis.camera = new THREE.PerspectiveCamera();\\r\\n\\t\\tconsole.log( this.name + ': camera is not a Perspective Camera!' );\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.textureMatrix = new THREE.Matrix4();\\r\\n\\r\\n\\tthis.mirrorCamera = this.camera.clone();\\r\\n\\r\\n\\tthis.texture = new THREE.WebGLRenderTarget( width, height );\\r\\n\\tthis.tempTexture = new THREE.WebGLRenderTarget( width, height );\\r\\n\\r\\n\\tvar mirrorShader = THREE.ShaderLib[ \\\"mirror\\\" ];\\r\\n\\tvar mirrorUniforms = THREE.UniformsUtils.clone( mirrorShader.uniforms );\\r\\n\\r\\n\\tthis.material = new THREE.ShaderMaterial( {\\r\\n\\r\\n\\t\\tfragmentShader: mirrorShader.fragmentShader,\\r\\n\\t\\tvertexShader: mirrorShader.vertexShader,\\r\\n\\t\\tuniforms: mirrorUniforms\\r\\n\\r\\n\\t} );\\r\\n\\r\\n\\tthis.material.uniforms.mirrorSampler.value = this.texture;\\r\\n\\tthis.material.uniforms.mirrorColor.value = mirrorColor;\\r\\n\\tthis.material.uniforms.textureMatrix.value = this.textureMatrix;\\r\\n\\r\\n\\tif ( !THREE.Math.isPowerOfTwo(width) || !THREE.Math.isPowerOfTwo( height ) ) {\\r\\n\\r\\n\\t\\tthis.texture.generateMipmaps = false;\\r\\n\\t\\tthis.tempTexture.generateMipmaps = false;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tthis.updateTextureMatrix();\\r\\n\\tthis.render();\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.Mirror.prototype = Object.create( THREE.Object3D.prototype );\\r\\n\\r\\nTHREE.Mirror.prototype.renderWithMirror = function ( otherMirror ) {\\r\\n\\r\\n\\t// update the mirror matrix to mirror the current view\\r\\n\\tthis.updateTextureMatrix();\\r\\n\\tthis.matrixNeedsUpdate = false;\\r\\n\\r\\n\\t// set the camera of the other mirror so the mirrored view is the reference view\\r\\n\\tvar tempCamera = otherMirror.camera;\\r\\n\\totherMirror.camera = this.mirrorCamera;\\r\\n\\r\\n\\t// render the other mirror in temp texture\\r\\n\\totherMirror.renderTemp();\\r\\n\\totherMirror.material.uniforms.mirrorSampler.value = otherMirror.tempTexture;\\r\\n\\r\\n\\t// render the current mirror\\r\\n\\tthis.render();\\r\\n\\tthis.matrixNeedsUpdate = true;\\r\\n\\r\\n\\t// restore material and camera of other mirror\\r\\n\\totherMirror.material.uniforms.mirrorSampler.value = otherMirror.texture;\\r\\n\\totherMirror.camera = tempCamera;\\r\\n\\r\\n\\t// restore texture matrix of other mirror\\r\\n\\totherMirror.updateTextureMatrix();\\r\\n};\\r\\n\\r\\nTHREE.Mirror.prototype.updateTextureMatrix = function () {\\r\\n\\r\\n\\tvar sign = THREE.Math.sign;\\r\\n\\r\\n\\tthis.updateMatrixWorld();\\r\\n\\tthis.camera.updateMatrixWorld();\\r\\n\\r\\n\\tthis.mirrorWorldPosition.setFromMatrixPosition( this.matrixWorld );\\r\\n\\tthis.cameraWorldPosition.setFromMatrixPosition( this.camera.matrixWorld );\\r\\n\\r\\n\\tthis.rotationMatrix.extractRotation( this.matrixWorld );\\r\\n\\r\\n\\tthis.normal.set( 0, 0, 1 );\\r\\n\\tthis.normal.applyMatrix4( this.rotationMatrix );\\r\\n\\r\\n\\tvar view = this.mirrorWorldPosition.clone().sub( this.cameraWorldPosition );\\r\\n\\tview.reflect( this.normal ).negate();\\r\\n\\tview.add( this.mirrorWorldPosition );\\r\\n\\r\\n\\tthis.rotationMatrix.extractRotation( this.camera.matrixWorld );\\r\\n\\r\\n\\tthis.lookAtPosition.set(0, 0, -1);\\r\\n\\tthis.lookAtPosition.applyMatrix4( this.rotationMatrix );\\r\\n\\tthis.lookAtPosition.add( this.cameraWorldPosition );\\r\\n\\r\\n\\tvar target = this.mirrorWorldPosition.clone().sub( this.lookAtPosition );\\r\\n\\ttarget.reflect( this.normal ).negate();\\r\\n\\ttarget.add( this.mirrorWorldPosition );\\r\\n\\r\\n\\tthis.up.set( 0, -1, 0 );\\r\\n\\tthis.up.applyMatrix4( this.rotationMatrix );\\r\\n\\tthis.up.reflect( this.normal ).negate();\\r\\n\\r\\n\\tthis.mirrorCamera.position.copy( view );\\r\\n\\tthis.mirrorCamera.up = this.up;\\r\\n\\tthis.mirrorCamera.lookAt( target );\\r\\n\\r\\n\\tthis.mirrorCamera.updateProjectionMatrix();\\r\\n\\tthis.mirrorCamera.updateMatrixWorld();\\r\\n\\tthis.mirrorCamera.matrixWorldInverse.getInverse( this.mirrorCamera.matrixWorld );\\r\\n\\r\\n\\t// Update the texture matrix\\r\\n\\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\\r\\n\\t\\t\\t\\t\\t\\t\\t0.0, 0.5, 0.0, 0.5,\\r\\n\\t\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.5, 0.5,\\r\\n\\t\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.0, 1.0 );\\r\\n\\tthis.textureMatrix.multiply( this.mirrorCamera.projectionMatrix );\\r\\n\\tthis.textureMatrix.multiply( this.mirrorCamera.matrixWorldInverse );\\r\\n\\r\\n\\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\\r\\n\\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\\r\\n\\tthis.mirrorPlane.setFromNormalAndCoplanarPoint( this.normal, this.mirrorWorldPosition );\\r\\n\\tthis.mirrorPlane.applyMatrix4( this.mirrorCamera.matrixWorldInverse );\\r\\n\\r\\n\\tthis.clipPlane.set( this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant );\\r\\n\\r\\n\\tvar q = new THREE.Vector4();\\r\\n\\tvar projectionMatrix = this.mirrorCamera.projectionMatrix;\\r\\n\\r\\n\\tq.x = ( sign(this.clipPlane.x) + projectionMatrix.elements[8] ) / projectionMatrix.elements[0];\\r\\n\\tq.y = ( sign(this.clipPlane.y) + projectionMatrix.elements[9] ) / projectionMatrix.elements[5];\\r\\n\\tq.z = - 1.0;\\r\\n\\tq.w = ( 1.0 + projectionMatrix.elements[10] ) / projectionMatrix.elements[14];\\r\\n\\r\\n\\t// Calculate the scaled plane vector\\r\\n\\tvar c = new THREE.Vector4();\\r\\n\\tc = this.clipPlane.multiplyScalar( 2.0 / this.clipPlane.dot(q) );\\r\\n\\r\\n\\t// Replacing the third row of the projection matrix\\r\\n\\tprojectionMatrix.elements[2] = c.x;\\r\\n\\tprojectionMatrix.elements[6] = c.y;\\r\\n\\tprojectionMatrix.elements[10] = c.z + 1.0 - this.clipBias;\\r\\n\\tprojectionMatrix.elements[14] = c.w;\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.Mirror.prototype.render = function () {\\r\\n\\r\\n\\tif ( this.matrixNeedsUpdate ) this.updateTextureMatrix();\\r\\n\\r\\n\\tthis.matrixNeedsUpdate = true;\\r\\n\\r\\n\\t// Render the mirrored view of the current scene into the target texture\\r\\n\\tvar scene = this;\\r\\n\\r\\n\\twhile ( scene.parent !== undefined ) {\\r\\n\\r\\n\\t\\tscene = scene.parent;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( scene !== undefined && scene instanceof THREE.Scene) {\\r\\n\\r\\n\\t\\tthis.renderer.render( scene, this.mirrorCamera, this.texture, true );\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.Mirror.prototype.renderTemp = function () {\\r\\n\\r\\n\\tif ( this.matrixNeedsUpdate ) this.updateTextureMatrix();\\r\\n\\r\\n\\tthis.matrixNeedsUpdate = true;\\r\\n\\r\\n\\t// Render the mirrored view of the current scene into the target texture\\r\\n\\tvar scene = this;\\r\\n\\r\\n\\twhile ( scene.parent !== undefined ) {\\r\\n\\r\\n\\t\\tscene = scene.parent;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif ( scene !== undefined && scene instanceof THREE.Scene) {\\r\\n\\r\\n\\t\\tthis.renderer.render( scene, this.mirrorCamera, this.tempTexture, true );\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Sparks.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Sparks.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/*\\n * @author zz85 (http://github.com/zz85 http://www.lab4games.net/zz85/blog)\\n *\\n * a simple to use javascript 3d particles system inspired by FliNT and Stardust\\n * created with TWEEN.js and THREE.js\\n *\\n * for feature requests or bugs, please visit https://github.com/zz85/sparks.js\\n *\\n * licensed under the MIT license\\n */\\n\\nvar SPARKS = {};\\n\\n/********************************\\n* Emitter Class\\n*\\n*   Creates and Manages Particles\\n*********************************/\\n\\nSPARKS.Emitter = function (counter) {\\n\\n    this._counter = counter ? counter : new SPARKS.SteadyCounter(10); // provides number of particles to produce\\n\\n    this._particles = [];\\n\\n\\n    this._initializers = []; // use for creation of particles\\n    this._actions = [];     // uses action to update particles\\n    this._activities = [];  //  not supported yet\\n\\n    this._handlers = [];\\n\\n    this.callbacks = {};\\n};\\n\\n\\nSPARKS.Emitter.prototype = {\\n\\n\\t_TIMESTEP: 15,\\n\\t_timer: null,\\n\\t_lastTime: null,\\n\\t_timerStep: 10,\\n\\t_velocityVerlet: true,\\n\\n\\t// run its built in timer / stepping\\n\\tstart: function() {\\n\\t\\tthis._lastTime = Date.now();\\n\\t\\tthis._timer = setTimeout(this.step, this._timerStep, this);\\n\\t\\tthis._isRunning = true;\\n\\t},\\n\\n\\tstop: function() {\\n\\t\\tthis._isRunning = false;\\n\\t\\tclearTimeout(this._timer);\\n\\t},\\n\\n\\tisRunning: function() {\\n\\t\\treturn this._isRunning & true;\\n\\t},\\n\\n\\t// Step gets called upon by the engine\\n\\t// but attempts to call update() on a regular basics\\n\\t// This method is also described in http://gameclosure.com/2011/04/11/deterministic-delta-tee-in-js-games/\\n\\tstep: function(emitter) {\\n\\n\\t\\tvar time = Date.now();\\n\\t\\tvar elapsed = time - emitter._lastTime;\\n\\n\\t\\tif (!this._velocityVerlet) {\\n\\t\\t\\t// if elapsed is way higher than time step, (usually after switching tabs, or excution cached in ff)\\n\\t\\t\\t// we will drop cycles. perhaps set to a limit of 10 or something?\\n\\t\\t\\tvar maxBlock = emitter._TIMESTEP * 20;\\n\\n\\t\\t\\tif (elapsed >= maxBlock) {\\n\\t\\t\\t\\t//console.log('warning: sparks.js is fast fowarding engine, skipping steps', elapsed / emitter._TIMESTEP);\\n\\t\\t\\t\\t//emitter.update( (elapsed - maxBlock) / 1000);\\n\\t\\t\\t\\telapsed = maxBlock;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(elapsed >= emitter._TIMESTEP) {\\n\\t\\t\\t\\temitter.update(emitter._TIMESTEP / 1000);\\n\\t\\t\\t\\telapsed -= emitter._TIMESTEP;\\n\\t\\t\\t}\\n\\t\\t\\temitter._lastTime = time - elapsed;\\n\\n\\t\\t} else {\\n\\t\\t\\temitter.update(elapsed/1000);\\n\\t\\t\\temitter._lastTime = time;\\n\\t\\t}\\n\\n\\n\\n\\t\\tif (emitter._isRunning)\\n\\t\\tsetTimeout(emitter.step, emitter._timerStep, emitter);\\n\\n\\t},\\n\\n\\n\\t// Update particle engine in seconds, not milliseconds\\n    update: function(time) {\\n\\n\\t\\tvar i, j;\\n        var len = this._counter.updateEmitter( this, time );\\n\\n        // Create particles\\n        for( i = 0; i < len; i++ ) {\\n            this.createParticle();\\n        }\\n\\n        // Update activities\\n        len = this._activities.length;\\n        for ( i = 0; i < len; i++ )\\n        {\\n            this._activities[i].update( this, time );\\n        }\\n\\n\\n        len = this._actions.length;\\n\\n\\t\\tvar particle;\\n\\t\\tvar action;\\n        var len2 = this._particles.length;\\n\\n        for( j = 0; j < len; j++ )\\n        {\\n            action = this._actions[j];\\n            for ( i = 0; i < len2; ++i )\\n            {\\n                particle = this._particles[i];\\n                action.update( this, particle, time );\\n            }\\n        }\\n\\n\\n        // remove dead particles\\n        for ( i = len2; i--; )\\n        {\\n            particle = this._particles[i];\\n            if ( particle.isDead )\\n            {\\n                //particle =\\n\\t\\t\\t\\tthis._particles.splice( i, 1 );\\n                this.dispatchEvent(\\\"dead\\\", particle);\\n\\t\\t\\t\\tSPARKS.VectorPool.release(particle.position); //\\n\\t\\t\\t\\tSPARKS.VectorPool.release(particle.velocity);\\n\\n            } else {\\n                this.dispatchEvent(\\\"updated\\\", particle);\\n            }\\n        }\\n\\n\\t\\tthis.dispatchEvent(\\\"loopUpdated\\\");\\n\\n    },\\n\\n    createParticle: function() {\\n        var particle = new SPARKS.Particle();\\n        // In future, use a Particle Factory\\n        var len = this._initializers.length, i;\\n\\n        for ( i = 0; i < len; i++ ) {\\n            this._initializers[i].initialize( this, particle );\\n        }\\n\\n        this._particles.push( particle );\\n\\n        this.dispatchEvent(\\\"created\\\", particle); // ParticleCreated\\n\\n        return particle;\\n    },\\n\\n    addInitializer: function (initializer) {\\n        this._initializers.push(initializer);\\n    },\\n\\n    addAction: function (action) {\\n        this._actions.push(action);\\n    },\\n\\n    removeInitializer: function (initializer) {\\n\\t\\tvar index = this._initializers.indexOf(initializer);\\n\\t\\tif (index > -1) {\\n\\t\\t\\tthis._initializers.splice( index, 1 );\\n\\t\\t}\\n    },\\n\\n    removeAction: function (action) {\\n\\t\\tvar index = this._actions.indexOf(action);\\n\\t\\tif (index > -1) {\\n\\t\\t\\tthis._actions.splice( index, 1 );\\n\\t\\t}\\n\\t\\t//console.log('removeAction', index, this._actions);\\n    },\\n\\n    addCallback: function(name, callback) {\\n        this.callbacks[name] = callback;\\n    },\\n\\n    dispatchEvent: function(name, args) {\\n        var callback = this.callbacks[name];\\n        if (callback) {\\n            callback(args);\\n        }\\n\\n    }\\n\\n\\n};\\n\\n\\n/*\\n * Constant Names for\\n * Events called by emitter.dispatchEvent()\\n *\\n */\\nSPARKS.EVENT_PARTICLE_CREATED = \\\"created\\\"\\nSPARKS.EVENT_PARTICLE_UPDATED = \\\"updated\\\"\\nSPARKS.EVENT_PARTICLE_DEAD = \\\"dead\\\";\\nSPARKS.EVENT_LOOP_UPDATED = \\\"loopUpdated\\\";\\n\\n\\n\\n/*\\n * Steady Counter attempts to produces a particle rate steadily\\n *\\n */\\n\\n// Number of particles per seconds\\nSPARKS.SteadyCounter = function(rate) {\\n    this.rate = rate;\\n\\n\\t// we use a shortfall counter to make up for slow emitters\\n\\tthis.leftover = 0;\\n\\n};\\n\\nSPARKS.SteadyCounter.prototype.updateEmitter = function(emitter, time) {\\n\\n\\tvar targetRelease = time * this.rate + this.leftover;\\n\\tvar actualRelease = Math.floor(targetRelease);\\n\\n\\tthis.leftover = targetRelease - actualRelease;\\n\\n\\treturn actualRelease;\\n};\\n\\n\\n/*\\n * Shot Counter produces specified particles\\n * on a single impluse or burst\\n */\\n\\nSPARKS.ShotCounter = function(particles) {\\n\\tthis.particles = particles;\\n\\tthis.used = false;\\n};\\n\\nSPARKS.ShotCounter.prototype.updateEmitter = function(emitter, time) {\\n\\n\\tif (this.used) {\\n\\t\\treturn 0;\\n\\t} else {\\n\\t\\tthis.used = true;\\n\\t}\\n\\n\\treturn this.particles;\\n};\\n\\n\\n/********************************\\n* Particle Class\\n*\\n*   Represents a single particle\\n*********************************/\\nSPARKS.Particle = function() {\\n\\n    /**\\n     * The lifetime of the particle, in seconds.\\n     */\\n    this.lifetime = 0;\\n\\n    /**\\n     * The age of the particle, in seconds.\\n     */\\n    this.age = 0;\\n\\n    /**\\n     * The energy of the particle.\\n     */\\n    this.energy = 1;\\n\\n    /**\\n     * Whether the particle is dead and should be removed from the stage.\\n     */\\n    this.isDead = false;\\n\\n    this.target = null; // tag\\n\\n    /**\\n     * For 3D\\n     */\\n\\n     this.position = SPARKS.VectorPool.get().set(0,0,0); //new THREE.Vector3( 0, 0, 0 );\\n     this.velocity = SPARKS.VectorPool.get().set(0,0,0); //new THREE.Vector3( 0, 0, 0 );\\n\\tthis._oldvelocity = SPARKS.VectorPool.get().set(0,0,0);\\n     // rotation vec3\\n     // angVelocity vec3\\n     // faceAxis vec3\\n\\n};\\n\\n\\n/********************************\\n* Action Classes\\n*\\n*   An abstract class which have\\n*   update function\\n*********************************/\\nSPARKS.Action = function() {\\n    this._priority = 0;\\n};\\n\\n\\nSPARKS.Age = function(easing) {\\n    this._easing = (easing == null) ? TWEEN.Easing.Linear.None : easing;\\n};\\n\\nSPARKS.Age.prototype.update = function (emitter, particle, time) {\\n    particle.age += time;\\n    if( particle.age >= particle.lifetime )\\n    {\\n        particle.energy = 0;\\n        particle.isDead = true;\\n    }\\n    else\\n    {\\n        var t = this._easing(particle.age / particle.lifetime);\\n        particle.energy = -1 * t + 1;\\n    }\\n};\\n\\n/*\\n// Mark particle as dead when particle's < 0\\n\\nSPARKS.Death = function(easing) {\\n    this._easing = (easing == null) ? TWEEN.Linear.None : easing;\\n};\\n\\nSPARKS.Death.prototype.update = function (emitter, particle, time) {\\n    if (particle.life <= 0) {\\n        particle.isDead = true;\\n    }\\n};\\n*/\\n\\n\\nSPARKS.Move = function() {\\n\\n};\\n\\nSPARKS.Move.prototype.update = function(emitter, particle, time) {\\n    // attempt verlet velocity updating.\\n    var p = particle.position;\\n\\tvar v = particle.velocity;\\n    var old = particle._oldvelocity;\\n\\n\\tif (this._velocityVerlet) {\\n\\t\\tp.x += (v.x + old.x) * 0.5 * time;\\n\\t\\tp.y += (v.y + old.y) * 0.5 * time;\\n\\t\\tp.z += (v.z + old.z) * 0.5 * time;\\n\\t} else {\\n\\t\\tp.x += v.x * time;\\n\\t\\tp.y += v.y * time;\\n\\t\\tp.z += v.z * time;\\n\\t}\\n\\n    //  OldVel = Vel;\\n    // Vel = Vel + Accel * dt;\\n    // Pos = Pos + (vel + Vel + Accel * dt) * 0.5 * dt;\\n\\n\\n\\n};\\n\\n/* Marks particles found in specified zone dead */\\nSPARKS.DeathZone = function(zone) {\\n    this.zone = zone;\\n};\\n\\nSPARKS.DeathZone.prototype.update = function(emitter, particle, time) {\\n\\n    if (this.zone.contains(particle.position)) {\\n\\t\\tparticle.isDead = true;\\n\\t}\\n\\n};\\n\\n/*\\n * SPARKS.ActionZone applies an action when particle is found in zone\\n */\\nSPARKS.ActionZone = function(action, zone) {\\n\\tthis.action = action;\\n    this.zone = zone;\\n};\\n\\nSPARKS.ActionZone.prototype.update = function(emitter, particle, time) {\\n\\n    if (this.zone.contains(particle.position)) {\\n\\t\\tthis.action.update( emitter, particle, time );\\n\\t}\\n\\n};\\n\\n/*\\n * Accelerate action affects velocity in specified 3d direction\\n */\\nSPARKS.Accelerate = function(x,y,z) {\\n\\n\\tif (x instanceof THREE.Vector3) {\\n\\t\\tthis.acceleration = x;\\n\\t\\treturn;\\n\\t}\\n\\n    this.acceleration = new THREE.Vector3(x,y,z);\\n\\n};\\n\\nSPARKS.Accelerate.prototype.update = function(emitter, particle, time) {\\n    var acc = this.acceleration;\\n\\n    var v = particle.velocity;\\n\\n\\tparticle._oldvelocity.set(v.x, v.y, v.z);\\n\\n    v.x += acc.x * time;\\n    v.y += acc.y * time;\\n    v.z += acc.z * time;\\n\\n};\\n\\n/*\\n * Accelerate Factor accelerate based on a factor of particle's velocity.\\n */\\nSPARKS.AccelerateFactor = function(factor) {\\n    this.factor = factor;\\n};\\n\\nSPARKS.AccelerateFactor.prototype.update = function(emitter, particle, time) {\\n    var factor = this.factor;\\n\\n    var v = particle.velocity;\\n\\tvar len = v.length();\\n\\tvar adjFactor;\\n    if (len>0) {\\n\\n\\t\\tadjFactor = factor * time / len;\\n\\t\\tadjFactor += 1;\\n\\n\\t\\tv.multiplyScalar(adjFactor);\\n\\t\\t// v.x *= adjFactor;\\n\\t\\t// \\t    v.y *= adjFactor;\\n\\t\\t// \\t    v.z *= adjFactor;\\n\\t}\\n\\n};\\n\\n/*\\nAccelerateNormal\\n * AccelerateVelocity affects velocity based on its velocity direction\\n */\\nSPARKS.AccelerateVelocity = function(factor) {\\n\\n\\tthis.factor = factor;\\n\\n};\\n\\nSPARKS.AccelerateVelocity.prototype.update = function(emitter, particle, time) {\\n    var factor = this.factor;\\n\\n    var v = particle.velocity;\\n\\n\\n    v.z += - v.x * factor;\\n    v.y += v.z * factor;\\n    v.x +=  v.y * factor;\\n\\n};\\n\\n\\n/* Set the max ammount of x,y,z drift movements in a second */\\nSPARKS.RandomDrift = function(x,y,z) {\\n\\tif (x instanceof THREE.Vector3) {\\n\\t\\tthis.drift = x;\\n\\t\\treturn;\\n\\t}\\n\\n    this.drift = new THREE.Vector3(x,y,z);\\n}\\n\\n\\nSPARKS.RandomDrift.prototype.update = function(emitter, particle, time) {\\n    var drift = this.drift;\\n\\n    var v = particle.velocity;\\n\\n    v.x += ( Math.random() - 0.5 ) * drift.x * time;\\n    v.y += ( Math.random() - 0.5 ) * drift.y * time;\\n    v.z += ( Math.random() - 0.5 ) * drift.z * time;\\n\\n};\\n\\n/********************************\\n* Zone Classes\\n*\\n*   An abstract classes which have\\n*   getLocation() function\\n*********************************/\\nSPARKS.Zone = function() {\\n};\\n\\n// TODO, contains() for Zone\\n\\nSPARKS.PointZone = function(pos) {\\n    this.pos = pos;\\n};\\n\\nSPARKS.PointZone.prototype.getLocation = function() {\\n    return this.pos;\\n};\\n\\nSPARKS.PointZone = function(pos) {\\n    this.pos = pos;\\n};\\n\\nSPARKS.PointZone.prototype.getLocation = function() {\\n    return this.pos;\\n};\\n\\nSPARKS.LineZone = function(start, end) {\\n    this.start = start;\\n\\tthis.end = end;\\n\\tthis._length = end.clone().sub( start );\\n};\\n\\nSPARKS.LineZone.prototype.getLocation = function() {\\n    var len = this._length.clone();\\n\\n\\tlen.multiplyScalar( Math.random() );\\n\\treturn len.add( this.start );\\n\\n};\\n\\n// Basically a RectangleZone\\nSPARKS.ParallelogramZone = function(corner, side1, side2) {\\n    this.corner = corner;\\n\\tthis.side1 = side1;\\n\\tthis.side2 = side2;\\n};\\n\\nSPARKS.ParallelogramZone.prototype.getLocation = function() {\\n\\n\\tvar d1 = this.side1.clone().multiplyScalar( Math.random() );\\n\\tvar d2 = this.side2.clone().multiplyScalar( Math.random() );\\n\\td1.add(d2);\\n\\treturn d1.add( this.corner );\\n\\n};\\n\\nSPARKS.CubeZone = function(position, x, y, z) {\\n    this.position = position;\\n\\tthis.x = x;\\n\\tthis.y = y;\\n\\tthis.z = z;\\n};\\n\\nSPARKS.CubeZone.prototype.getLocation = function() {\\n    //TODO use pool?\\n\\n\\tvar location = this.position.clone();\\n\\tlocation.x += Math.random() * this.x;\\n\\tlocation.y += Math.random() * this.y;\\n\\tlocation.z += Math.random() * this.z;\\n\\n\\treturn location;\\n\\n};\\n\\n\\nSPARKS.CubeZone.prototype.contains = function(position) {\\n\\n\\tvar startX = this.position.x;\\n\\tvar startY = this.position.y;\\n\\tvar startZ = this.position.z;\\n\\tvar x = this.x; // width\\n\\tvar y = this.y; // depth\\n\\tvar z = this.z; // height\\n\\n\\tif (x<0) {\\n\\t\\tstartX += x;\\n\\t\\tx = Math.abs(x);\\n\\t}\\n\\n\\tif (y<0) {\\n\\t\\tstartY += y;\\n\\t\\ty = Math.abs(y);\\n\\t}\\n\\n\\tif (z<0) {\\n\\t\\tstartZ += z;\\n\\t\\tz = Math.abs(z);\\n\\t}\\n\\n\\tvar diffX = position.x - startX;\\n\\tvar diffY = position.y - startY;\\n\\tvar diffZ = position.z - startZ;\\n\\n\\tif ( (diffX > 0) && (diffX < x) &&\\n\\t\\t\\t(diffY > 0) && (diffY < y) &&\\n\\t\\t\\t(diffZ > 0) && (diffZ < z) ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\treturn false;\\n\\n};\\n\\n\\n\\n/**\\n * The constructor creates a DiscZone 3D zone.\\n *\\n * @param centre The point at the center of the disc.\\n * @param normal A vector normal to the disc.\\n * @param outerRadius The outer radius of the disc.\\n * @param innerRadius The inner radius of the disc. This defines the hole\\n * in the center of the disc. If set to zero, there is no hole.\\n */\\n\\n/*\\n// BUGGY!!\\nSPARKS.DiscZone = function(center, radiusNormal, outerRadius, innerRadius) {\\n    this.center = center;\\n\\tthis.radiusNormal = radiusNormal;\\n\\tthis.outerRadius = (outerRadius==undefined) ? 0 : outerRadius;\\n\\tthis.innerRadius = (innerRadius==undefined) ? 0 : innerRadius;\\n\\n};\\n\\nSPARKS.DiscZone.prototype.getLocation = function() {\\n    var rand = Math.random();\\n\\tvar _innerRadius = this.innerRadius;\\n\\tvar _outerRadius = this.outerRadius;\\n\\tvar center = this.center;\\n\\tvar _normal = this.radiusNormal;\\n\\n\\t_distToOrigin = _normal.dot( center );\\n\\n\\tvar radius = _innerRadius + (1 - rand * rand ) * ( _outerRadius - _innerRadius );\\n\\tvar angle = Math.random() * SPARKS.Utils.TWOPI;\\n\\n\\tvar _distToOrigin = _normal.dot( center );\\n\\tvar axes = SPARKS.Utils.getPerpendiculars( _normal.clone() );\\n\\tvar _planeAxis1 = axes[0];\\n\\tvar _planeAxis2 = axes[1];\\n\\n\\tvar p = _planeAxis1.clone();\\n\\tp.multiplyScalar( radius * Math.cos( angle ) );\\n\\tvar p2 = _planeAxis2.clone();\\n\\tp2.multiplyScalar( radius * Math.sin( angle ) );\\n\\tp.add( p2 );\\n\\treturn _center.add( p );\\n\\n};\\n*/\\n\\nSPARKS.SphereCapZone = function(x, y, z, minr, maxr, angle) {\\n    this.x = x;\\n    this.y = y;\\n    this.z = z;\\n    this.minr = minr;\\n    this.maxr = maxr;\\n    this.angle = angle;\\n};\\n\\nSPARKS.SphereCapZone.prototype.getLocation = function() {\\n    var theta = Math.PI *2  * SPARKS.Utils.random();\\n    var r = SPARKS.Utils.random();\\n\\n    //new THREE.Vector3\\n    var v =  SPARKS.VectorPool.get().set(r * Math.cos(theta), -1 / Math.tan(this.angle * SPARKS.Utils.DEGREE_TO_RADIAN), r * Math.sin(theta));\\n\\n    //v.length = StardustMath.interpolate(0, _minRadius, 1, _maxRadius, Math.random());\\n\\n    var i = this.minr - ((this.minr-this.maxr) *  Math.random() );\\n    v.multiplyScalar(i);\\n\\n\\tv.__markedForReleased = true;\\n\\n    return v;\\n};\\n\\n\\n/********************************\\n* Initializer Classes\\n*\\n*   Classes which initializes\\n*   particles. Implements initialize( emitter:Emitter, particle:Particle )\\n*********************************/\\n\\n// Specifies random life between max and min\\nSPARKS.Lifetime = function(min, max) {\\n    this._min = min;\\n\\n    this._max = max ? max : min;\\n\\n};\\n\\nSPARKS.Lifetime.prototype.initialize = function( emitter/*Emitter*/, particle/*Particle*/ ) {\\n    particle.lifetime = this._min + SPARKS.Utils.random() * ( this._max - this._min );\\n};\\n\\n\\nSPARKS.Position = function(zone) {\\n    this.zone = zone;\\n};\\n\\nSPARKS.Position.prototype.initialize = function( emitter/*Emitter*/, particle/*Particle*/ ) {\\n    var pos = this.zone.getLocation();\\n    particle.position.set(pos.x, pos.y, pos.z);\\n};\\n\\nSPARKS.Velocity = function(zone) {\\n    this.zone = zone;\\n};\\n\\nSPARKS.Velocity.prototype.initialize = function( emitter/*Emitter*/, particle/*Particle*/ ) {\\n    var pos = this.zone.getLocation();\\n    particle.velocity.set(pos.x, pos.y, pos.z);\\n\\tif (pos.__markedForReleased) {\\n\\t\\t//console.log(\\\"release\\\");\\n\\t\\tSPARKS.VectorPool.release(pos);\\n\\t\\tpos.__markedForReleased = false;\\n\\t}\\n};\\n\\nSPARKS.Target = function(target, callback) {\\n    this.target = target;\\n    this.callback = callback;\\n};\\n\\nSPARKS.Target.prototype.initialize = function( emitter, particle ) {\\n\\n    if (this.callback) {\\n        particle.target = this.callback();\\n    } else {\\n        particle.target = this.target;\\n    }\\n\\n};\\n\\n/********************************\\n* VectorPool\\n*\\n*  Reuse much of Vectors if possible\\n*********************************/\\n\\nSPARKS.VectorPool = {\\n\\t__pools: [],\\n\\n\\t// Get a new Vector\\n\\tget: function() {\\n\\t\\tif (this.__pools.length>0) {\\n\\t\\t\\treturn this.__pools.pop();\\n\\t\\t}\\n\\n\\t\\treturn this._addToPool();\\n\\n\\t},\\n\\n\\t// Release a vector back into the pool\\n\\trelease: function(v) {\\n\\t\\tthis.__pools.push(v);\\n\\t},\\n\\n\\t// Create a bunch of vectors and add to the pool\\n\\t_addToPool: function() {\\n\\t\\t//console.log(\\\"creating some pools\\\");\\n\\n\\t\\tfor (var i=0, size = 100; i < size; i++) {\\n\\t\\t\\tthis.__pools.push(new THREE.Vector3());\\n\\t\\t}\\n\\n\\t\\treturn new THREE.Vector3();\\n\\n\\t}\\n\\n\\n\\n};\\n\\n\\n/********************************\\n* Util Classes\\n*\\n*   Classes which initializes\\n*   particles. Implements initialize( emitter:Emitter, particle:Particle )\\n*********************************/\\nSPARKS.Utils = {\\n    random: function() {\\n        return Math.random();\\n    },\\n    DEGREE_TO_RADIAN: Math.PI / 180,\\n\\tTWOPI: Math.PI * 2,\\n\\n\\tgetPerpendiculars: function(normal) {\\n\\t\\tvar p1 = this.getPerpendicular( normal );\\n\\t\\tvar p2 = normal.cross( p1 );\\n\\t\\tp2.normalize();\\n\\t\\treturn [ p1, p2 ];\\n\\t},\\n\\n\\tgetPerpendicular: function( v )\\n\\t{\\n\\t\\tif( v.x == 0 )\\n\\t\\t{\\n\\t\\t\\treturn new THREE.Vector3D( 1, 0, 0 );\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tvar temp = new THREE.Vector3( v.y, -v.x, 0 );\\n\\t\\t\\treturn temp.normalize();\\n\\t\\t}\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Cameras/CombinedCamera.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Cameras/CombinedCamera.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n *\\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\\n *\\n *\\tA general perpose camera, for setting FOV, Lens Focal Length,\\n *\\t\\tand switching between perspective and orthographic views easily.\\n *\\t\\tUse this only if you do not wish to manage\\n *\\t\\tboth a Orthographic and Perspective Camera\\n *\\n */\\n\\n\\nTHREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {\\n\\n\\tTHREE.Camera.call( this );\\n\\n\\tthis.fov = fov;\\n\\n\\tthis.left = -width / 2;\\n\\tthis.right = width / 2\\n\\tthis.top = height / 2;\\n\\tthis.bottom = -height / 2;\\n\\n\\t// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\\n\\n\\tthis.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, \\torthoNear, orthoFar );\\n\\tthis.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );\\n\\n\\tthis.zoom = 1;\\n\\n\\tthis.toPerspective();\\n\\n\\tvar aspect = width/height;\\n\\n};\\n\\nTHREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );\\n\\nTHREE.CombinedCamera.prototype.toPerspective = function () {\\n\\n\\t// Switches to the Perspective Camera\\n\\n\\tthis.near = this.cameraP.near;\\n\\tthis.far = this.cameraP.far;\\n\\n\\tthis.cameraP.fov =  this.fov / this.zoom ;\\n\\n\\tthis.cameraP.updateProjectionMatrix();\\n\\n\\tthis.projectionMatrix = this.cameraP.projectionMatrix;\\n\\n\\tthis.inPerspectiveMode = true;\\n\\tthis.inOrthographicMode = false;\\n\\n};\\n\\nTHREE.CombinedCamera.prototype.toOrthographic = function () {\\n\\n\\t// Switches to the Orthographic camera estimating viewport from Perspective\\n\\n\\tvar fov = this.fov;\\n\\tvar aspect = this.cameraP.aspect;\\n\\tvar near = this.cameraP.near;\\n\\tvar far = this.cameraP.far;\\n\\n\\t// The size that we set is the mid plane of the viewing frustum\\n\\n\\tvar hyperfocus = ( near + far ) / 2;\\n\\n\\tvar halfHeight = Math.tan( fov / 2 ) * hyperfocus;\\n\\tvar planeHeight = 2 * halfHeight;\\n\\tvar planeWidth = planeHeight * aspect;\\n\\tvar halfWidth = planeWidth / 2;\\n\\n\\thalfHeight /= this.zoom;\\n\\thalfWidth /= this.zoom;\\n\\n\\tthis.cameraO.left = -halfWidth;\\n\\tthis.cameraO.right = halfWidth;\\n\\tthis.cameraO.top = halfHeight;\\n\\tthis.cameraO.bottom = -halfHeight;\\n\\n\\t// this.cameraO.left = -farHalfWidth;\\n\\t// this.cameraO.right = farHalfWidth;\\n\\t// this.cameraO.top = farHalfHeight;\\n\\t// this.cameraO.bottom = -farHalfHeight;\\n\\n\\t// this.cameraO.left = this.left / this.zoom;\\n\\t// this.cameraO.right = this.right / this.zoom;\\n\\t// this.cameraO.top = this.top / this.zoom;\\n\\t// this.cameraO.bottom = this.bottom / this.zoom;\\n\\n\\tthis.cameraO.updateProjectionMatrix();\\n\\n\\tthis.near = this.cameraO.near;\\n\\tthis.far = this.cameraO.far;\\n\\tthis.projectionMatrix = this.cameraO.projectionMatrix;\\n\\n\\tthis.inPerspectiveMode = false;\\n\\tthis.inOrthographicMode = true;\\n\\n};\\n\\n\\nTHREE.CombinedCamera.prototype.setSize = function( width, height ) {\\n\\n\\tthis.cameraP.aspect = width / height;\\n\\tthis.left = -width / 2;\\n\\tthis.right = width / 2\\n\\tthis.top = height / 2;\\n\\tthis.bottom = -height / 2;\\n\\n};\\n\\n\\nTHREE.CombinedCamera.prototype.setFov = function( fov ) {\\n\\n\\tthis.fov = fov;\\n\\n\\tif ( this.inPerspectiveMode ) {\\n\\n\\t\\tthis.toPerspective();\\n\\n\\t} else {\\n\\n\\t\\tthis.toOrthographic();\\n\\n\\t}\\n\\n};\\n\\n// For mantaining similar API with PerspectiveCamera\\n\\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function() {\\n\\n\\tif ( this.inPerspectiveMode ) {\\n\\n\\t\\tthis.toPerspective();\\n\\n\\t} else {\\n\\n\\t\\tthis.toPerspective();\\n\\t\\tthis.toOrthographic();\\n\\n\\t}\\n\\n};\\n\\n/*\\n* Uses Focal Length (in mm) to estimate and set FOV\\n* 35mm (fullframe) camera is used if frame size is not specified;\\n* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\\n*/\\nTHREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {\\n\\n\\tif ( frameHeight === undefined ) frameHeight = 24;\\n\\n\\tvar fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\\n\\n\\tthis.setFov( fov );\\n\\n\\treturn fov;\\n};\\n\\n\\nTHREE.CombinedCamera.prototype.setZoom = function( zoom ) {\\n\\n\\tthis.zoom = zoom;\\n\\n\\tif ( this.inPerspectiveMode ) {\\n\\n\\t\\tthis.toPerspective();\\n\\n\\t} else {\\n\\n\\t\\tthis.toOrthographic();\\n\\n\\t}\\n\\n};\\n\\nTHREE.CombinedCamera.prototype.toFrontView = function() {\\n\\n\\tthis.rotation.x = 0;\\n\\tthis.rotation.y = 0;\\n\\tthis.rotation.z = 0;\\n\\n\\t// should we be modifing the matrix instead?\\n\\n\\tthis.rotationAutoUpdate = false;\\n\\n};\\n\\nTHREE.CombinedCamera.prototype.toBackView = function() {\\n\\n\\tthis.rotation.x = 0;\\n\\tthis.rotation.y = Math.PI;\\n\\tthis.rotation.z = 0;\\n\\tthis.rotationAutoUpdate = false;\\n\\n};\\n\\nTHREE.CombinedCamera.prototype.toLeftView = function() {\\n\\n\\tthis.rotation.x = 0;\\n\\tthis.rotation.y = - Math.PI / 2;\\n\\tthis.rotation.z = 0;\\n\\tthis.rotationAutoUpdate = false;\\n\\n};\\n\\nTHREE.CombinedCamera.prototype.toRightView = function() {\\n\\n\\tthis.rotation.x = 0;\\n\\tthis.rotation.y = Math.PI / 2;\\n\\tthis.rotation.z = 0;\\n\\tthis.rotationAutoUpdate = false;\\n\\n};\\n\\nTHREE.CombinedCamera.prototype.toTopView = function() {\\n\\n\\tthis.rotation.x = - Math.PI / 2;\\n\\tthis.rotation.y = 0;\\n\\tthis.rotation.z = 0;\\n\\tthis.rotationAutoUpdate = false;\\n\\n};\\n\\nTHREE.CombinedCamera.prototype.toBottomView = function() {\\n\\n\\tthis.rotation.x = Math.PI / 2;\\n\\tthis.rotation.y = 0;\\n\\tthis.rotation.z = 0;\\n\\tthis.rotationAutoUpdate = false;\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/ProxyGeometry.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/ProxyGeometry.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author kile / http://kile.stravaganza.org/\\n * @author alteredq / http://alteredqualia.com/\\n * @author mikael emtinger / http://gomo.se/\\n * @author zz85 / http://www.lab4games.net/zz85/blog\\n * @author bhouston / http://exocortex.com\\n * @author jbaicoianu / http://baicoianu.com\\n */\\n\\nTHREE.ProxyGeometry = function ( ) {\\n\\n\\tTHREE.BufferGeometry.call( this );\\n\\n\\tthis.addEventListener( 'allocate', this.onGeometryAllocate);\\n\\n\\t// TODO - implement as BufferGeometry attributes\\n\\tthis.morphTargets = [];\\n\\tthis.morphColors = [];\\n\\n};\\n\\nTHREE.ProxyGeometry.prototype = Object.create( THREE.IndexedGeometry2.prototype );\\n\\nObject.defineProperties(THREE.ProxyGeometry.prototype, {\\n\\tvertices: { \\n\\t\\tenumerable: true, \\n\\t\\tconfigurable: true, \\n\\t\\tget: function() { return this.createVertexProxies(); }\\n\\t},\\n\\tfaces: {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function() { return this.createFaceProxies() } \\n\\t},\\n\\tfaceVertexUvs: {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function() { return this.createUvProxies() } \\n\\t},\\n\\tcolors: {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function() { return this.createColorProxies() } \\n\\t},\\n\\tskinIndices: {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function() { return this.createSkinIndexProxies() } \\n\\t},\\n\\tskinWeights: {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function() { return this.createSkinWeightProxies() } \\n\\t},\\n\\t// TODO - fill in additional proxies:\\n\\t// - morphColors\\n\\t// - morphNormals\\n\\t// - morphTargets\\n\\n\\tverticesNeedUpdate: {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function() { if (this.attributes[ 'position' ]) return this.attributes[ 'position' ].needsUpdate; } ,\\n\\t\\tset: function(v) { if (this.attributes[ 'position' ]) this.attributes[ 'position' ].needsUpdate = v; } \\n\\t},\\n\\tcolorsNeedUpdate: {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function() { if (this.attributes[ 'color' ]) return this.attributes[ 'color' ].needsUpdate; } ,\\n\\t\\tset: function(v) { if (this.attributes[ 'color' ]) this.attributes[ 'color' ].needsUpdate = v; } \\n\\t},\\n\\tnormalsNeedUpdate: {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function() { if (this.attributes[ 'normal' ]) return this.attributes[ 'normal' ].needsUpdate; } ,\\n\\t\\tset: function(v) { if (this.attributes[ 'normal' ]) this.attributes[ 'normal' ].needsUpdate = v; } \\n\\t},\\n});\\n\\nTHREE.ProxyGeometry.prototype.createVertexProxies = function(values) {\\n\\n\\tif (!this.hasOwnProperty('vertices')) {\\n\\n\\t\\t// Replace the prototype getter with a local array property\\n\\n\\t\\tObject.defineProperty( this, \\\"vertices\\\", { value: [], writable: true } );\\n\\n\\t} else {\\n\\n\\t\\t// Start with a new, empty array\\n\\n\\t\\tthis.vertices = [];\\n\\n\\t}\\n\\n\\t// If the attribute buffer has already been populated, set up proxy objects\\n\\n\\tthis.populateProxyFromBuffer(this.vertices, \\\"position\\\", THREE.ProxyVector3, 3);\\n\\n\\t// If values were passed in, store them in the buffer via the proxy objects\\n\\n\\tif (values) {\\n\\n\\t\\tfor (var i = 0; i < values.length; i++) {\\n\\n\\t\\t\\tthis.vertices[i].copy(values[i]);\\n\\n\\t\\t}\\n\\t}\\n\\n\\t// Return a reference to the newly-created array\\n\\n\\treturn this.vertices;\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.createFaceProxies = function(values) {\\n\\n\\tif (!this.hasOwnProperty(\\\"faces\\\")) {\\n\\n\\t\\t// Replace the prototype getter with a local array property\\n\\n\\t\\tObject.defineProperty( this, \\\"faces\\\", { value: [], writable: true } );\\n\\n\\t} else {\\n\\n\\t\\t// Start with a new, empty array\\n\\n\\t\\tthis.faces = [];\\n\\t}\\n\\n\\t// If the attribute buffer has already been populated, set up proxy objects\\n\\n\\tvar faces = this.faces,\\n\\t\\t\\tindexarray = false,\\n\\t\\t\\tpositionarray = false,\\n\\t\\t\\tnormalarray = false,\\n\\t\\t\\tcolorarray = false,\\n\\t\\t\\ttangentarray = false;\\n\\n\\tif ( this.attributes[ 'index' ] ) {\\n\\t\\tindexarray = this.attributes[ 'index' ].array;\\n\\t}\\n\\tif ( this.attributes[ 'position' ] ) {\\n\\t\\tpositionarray = this.attributes[ 'position' ].array;\\n\\t}\\n\\tif (this.attributes[ 'normal' ]) {\\n\\t\\tnormalarray = this.attributes[ 'normal' ].array;\\n\\t}\\n\\tif (this.attributes[ 'color' ]) {\\n\\t\\tcolorarray = this.attributes[ 'color' ].array;\\n\\t}\\n\\tif (this.attributes[ 'tangent' ]) {\\n\\t\\ttangentarray = this.attributes[ 'tangent' ].array;\\n\\t}\\n\\n\\t// TODO - this should be accomplished using \\\"virtual\\\" functions on various classes (IndexedGeometry, SmoothGeometry, etc)\\n\\n\\tif (indexarray) {\\n\\n\\t\\tfor ( var i = 0, l = indexarray.length / 3; i < l; i ++ ) {\\n\\n\\t\\t\\tvar o = i * 3;\\n\\n\\t\\t\\tvar face = new THREE.ProxyFace3( indexarray, i * 3 );\\n\\t\\t\\tfaces.push(face);\\n\\n\\t\\t}\\n\\n\\t} else if (positionarray) {\\n\\n\\t\\tfor ( var i = 0, l = positionarray.length / 3; i < l; i += 3 ) {\\n\\n\\t\\t\\tvar o = i * 3;\\n\\t\\t\\tvar v1 = i, v2 = i+1, v3 = i+2;\\n\\n\\t\\t\\tvar face = new THREE.ProxyFace3( v1, v2, v3 );\\n\\t\\t\\tfaces.push(face);\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// If values were passed in, store them in the buffer via the proxy objects\\n\\n\\tif (values) {\\n\\n\\t\\tfor (var i = 0, l = values.length; i < l; i++) {\\n\\n\\t\\t\\tvar f = faces[i],\\n\\t\\t\\t    v = values[i];\\n\\n\\t\\t\\tf.a = v.a;\\n\\t\\t\\tf.b = v.b;\\n\\t\\t\\tf.c = v.c;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tif (normalarray) {\\n\\n\\t\\tthis.createFaceVertexNormalProxies(values);\\n\\n\\t}\\n\\n\\tif (colorarray) {\\n\\n\\t\\tthis.createFaceVertexColorProxies(values);\\n\\n\\t}\\n\\n\\tif (tangentarray) {\\n\\n\\t\\tthis.createFaceVertexTangentProxies(values);\\n\\n\\t}\\n\\n\\t// Return a reference to the newly-created array\\n\\n\\treturn this.faces;\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.createFaceVertexNormalProxies = function(values) {\\n\\n\\tif ( this.attributes[ 'normal' ] && this.attributes[ 'normal' ].array ) {\\n\\n\\t\\tvar normalarray = this.attributes[ 'normal' ].array;\\n\\n\\t\\tfor (var i = 0, l = this.faces.length; i < l; i++) {\\n\\n\\t\\t\\tvar f = this.faces[i];\\n\\n\\t\\t\\tf.vertexNormals = [\\n\\t\\t\\t\\tnew THREE.ProxyVector3(normalarray, f.a * 3),\\n\\t\\t\\t\\tnew THREE.ProxyVector3(normalarray, f.b * 3),\\n\\t\\t\\t\\tnew THREE.ProxyVector3(normalarray, f.c * 3),\\n\\t\\t\\t];\\n\\t\\t\\tf.normal = new THREE.MultiVector3(f.vertexNormals);\\n\\n\\t\\t}\\n\\t}\\n\\n\\t// If values were passed in, store them in the buffer via the proxy objects\\n\\n\\tif (values) {\\n\\n\\t\\tfor (var i = 0, l = values.length; i < l; i++) {\\n\\n\\t\\t\\tvar f = this.faces[i],\\n\\t\\t\\t    v = values[i];\\n\\n\\t\\t\\tif (v.vertexNormals.length > 0) {\\n\\n\\t\\t\\t\\tfor (var j = 0, l2 = f.vertexNormals.length; j < l2; j++) {\\n\\n\\t\\t\\t\\t\\tf.vertexNormals[j].copy(v.vertexNormals[j]);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if (v.normal) {\\n\\n\\t\\t\\t\\tf.normal.copy(v.normal);\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.createFaceVertexColorProxies = function(values) {\\n\\n\\tif ( this.attributes[ 'color' ] && this.attributes[ 'color' ].array ) {\\n\\n\\t\\tvar colorarray = this.attributes[ 'color' ].array;\\n\\n\\t\\tfor (var i = 0, l = this.faces.length; i < l; i++) {\\n\\t\\t\\tvar f = this.faces[i];\\n\\n\\t\\t\\tif ( this.attributes[ 'index' ] ) {\\n\\t\\t\\t\\tf.vertexColors = [\\n\\t\\t\\t\\t\\t\\tnew THREE.ProxyColor(colorarray, f.a * 3),\\n\\t\\t\\t\\t\\t\\tnew THREE.ProxyColor(colorarray, f.b * 3),\\n\\t\\t\\t\\t\\t\\tnew THREE.ProxyColor(colorarray, f.c * 3),\\n\\t\\t\\t\\t\\t];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar o = i * 9;\\n\\n\\t\\t\\t\\tf.vertexColors = [\\n\\t\\t\\t\\t\\t\\tnew THREE.ProxyColor(colorarray, o),\\n\\t\\t\\t\\t\\t\\tnew THREE.ProxyColor(colorarray, o + 3),\\n\\t\\t\\t\\t\\t\\tnew THREE.ProxyColor(colorarray, o + 6),\\n\\t\\t\\t\\t\\t];\\n\\t\\t\\t}\\n\\t\\t\\tf.color = new THREE.MultiColor(f.vertexColors);\\n\\n\\t\\t}\\n\\t}\\n\\n\\t// If values were passed in, store them in the buffer via the proxy objects\\n\\n\\tif (values) {\\n\\n\\t\\tfor (var i = 0, l = values.length; i < l; i++) {\\n\\n\\t\\t\\tvar f = this.faces[i],\\n\\t\\t\\t    v = values[i];\\n\\n\\t\\t\\tfor (var j = 0, l2 = f.vertexColors.length; j < l2; j++) {\\n\\n\\t\\t\\t\\tif (v.vertexColors.length > 0) {\\n\\n\\t\\t\\t\\t\\tf.vertexColors[j].copy(v.vertexColors[j]);\\n\\n\\t\\t\\t\\t} else if (v.color) {\\n\\n\\t\\t\\t\\t\\tf.color.copy(v.color);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.createFaceVertexTangentProxies = function(values) {\\n\\n\\tif ( this.attributes[ 'tangent' ] && this.attributes[ 'tangent' ].array ) {\\n\\n\\t\\tvar tangentarray = this.attributes[ 'tangent' ].array;\\n\\n\\t\\tfor (var i = 0, l = this.faces.length; i < l; i++) {\\n\\n\\t\\t\\tvar f = this.faces[i];\\n\\n\\t\\t\\tf.vertexTangents = [\\n\\t\\t\\t\\tnew THREE.ProxyVector3(tangentarray, f.a * 3),\\n\\t\\t\\t\\tnew THREE.ProxyVector3(tangentarray, f.b * 3),\\n\\t\\t\\t\\tnew THREE.ProxyVector3(tangentarray, f.c * 3),\\n\\t\\t\\t];\\n\\n\\t\\t}\\n\\t}\\n\\n\\t// If values were passed in, store them in the buffer via the proxy objects\\n\\n\\tif (values) {\\n\\n\\t\\tfor (var i = 0, l = values.length; i < l; i++) {\\n\\n\\t\\t\\tvar f = this.faces[i],\\n\\t\\t\\t    v = values[i];\\n\\n\\t\\t\\tif (v.vertexTangents.length > 0) {\\n\\n\\t\\t\\t\\tfor (var j = 0, l2 = f.vertexTangents.length; j < l2; j++) {\\n\\n\\t\\t\\t\\t\\tf.vertexTangents[j].copy(v.vertexTangents[j]);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.createUvProxies = function(values) {\\n\\n\\t// Replace the prototype getter with a local array property\\n\\n\\tif (!this.hasOwnProperty(\\\"faceVertexUvs\\\")) {\\n\\t\\tObject.defineProperty( this, \\\"faceVertexUvs\\\", { value: [[]], writable: true } );\\n\\t} else {\\n\\t\\tthis.faceVertexUvs = [[]];\\n\\t}\\n\\n\\t// If the attribute buffer has already been populated, set up proxy objects\\n\\n\\tif ( this.attributes[ 'uv' ] && this.attributes[ 'uv' ].array ) {\\n\\n\\t\\tvar faces = this.faces;\\n\\t\\tvar uvarray = this.attributes[ 'uv' ].array;\\n\\n\\t\\tfor (var i = 0, l = faces.length; i < l; i++) {\\n\\t\\t\\tvar f = faces[i];\\n\\n\\t\\t\\tthis.faceVertexUvs[0][i] = [];\\n\\n\\t\\t\\tif ( this.attributes[ 'index' ] ) {\\n\\t\\t\\t\\tthis.faceVertexUvs[0][i][0] = new THREE.ProxyVector2(uvarray, f.a * 2);\\n\\t\\t\\t\\tthis.faceVertexUvs[0][i][1] = new THREE.ProxyVector2(uvarray, f.b * 2);\\n\\t\\t\\t\\tthis.faceVertexUvs[0][i][2] = new THREE.ProxyVector2(uvarray, f.c * 2);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar o = i * 6;\\n\\t\\t\\t\\tthis.faceVertexUvs[0][i][0] = new THREE.ProxyVector2(uvarray, o);\\n\\t\\t\\t\\tthis.faceVertexUvs[0][i][1] = new THREE.ProxyVector2(uvarray, o + 2);\\n\\t\\t\\t\\tthis.faceVertexUvs[0][i][2] = new THREE.ProxyVector2(uvarray, o + 4);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\n\\t}\\n\\n\\t// If values were passed in, store them in the buffer via the proxy objects\\n\\n\\tif (values) {\\n\\n\\t\\tfor (var i = 0, l = values.length; i < l; i++) {\\n\\n\\t\\t\\tfor (var j = 0, l2 = values[i].length; j < l2; j++) {\\n\\n\\t\\t\\t\\tvar uv = values[i][j];\\n\\t\\t\\t\\tthis.faceVertexUvs[0][i][j].copy(uv);\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Return a reference to the newly-created array\\n\\n\\treturn this.faceVertexUvs;\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.createSkinIndexProxies = function(values) {\\n\\n\\t// Replace the prototype getter with a local array property\\n\\n\\tif (!this.hasOwnProperty('skinIndices')) {\\n\\t\\tObject.defineProperty( this, \\\"skinIndices\\\", { value: [], writable: true } );\\n\\t} else {\\n\\t\\tthis.skinIndices = [];\\n\\t}\\n\\n\\t// If the attribute buffer has already been populated, set up proxy objects\\n\\n\\tthis.populateProxyFromBuffer(this.skinIndices, \\\"skinIndex\\\", THREE.ProxyVector4, 4);\\n\\n\\t// If values were passed in, store them in the buffer via the proxy objects\\n\\n\\tif (values) {\\n\\n\\t\\tfor (var i = 0; i < values.length; i++) {\\n\\n\\t\\t\\tthis.skinIndices[i].copy(values[i]);\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Return a reference to the newly-created array\\n\\n\\treturn this.skinIndices;\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.createSkinWeightProxies = function(values) {\\n\\n\\t// Replace the prototype getter with a local array property\\n\\n\\tif (!this.hasOwnProperty('skinWeights')) {\\n\\t\\tObject.defineProperty( this, \\\"skinWeights\\\", { value: [], writable: true } );\\n\\t} else {\\n\\t\\tthis.skinWeights = [];\\n\\t}\\n\\n\\t// If the attribute buffer has already been populated, set up proxy objects\\n\\n\\tthis.populateProxyFromBuffer(this.skinWeights, \\\"skinWeight\\\", THREE.ProxyVector4, 4);\\n\\n\\t// If values were passed in, store them in the buffer via the proxy objects\\n\\n\\tif (values) {\\n\\n\\t\\tfor (var i = 0; i < values.length; i++) {\\n\\n\\t\\t\\tthis.skinWeights[i].copy(values[i]);\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Return a reference to the newly-created array\\n\\n\\treturn this.skinWeights;\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.createColorProxies = function(values) {\\n\\n\\t// Replace the prototype getter with a local array property\\n\\n\\tif (!this.hasOwnProperty('colors')) {\\n\\t\\tObject.defineProperty( this, \\\"colors\\\", { value: [], writable: true } );\\n\\t} else {\\n\\t\\tthis.colors = [];\\n\\t}\\n\\n\\t// If the attribute buffer has already been populated, set up proxy objects\\n\\n\\tthis.populateProxyFromBuffer(this.colors, \\\"color\\\", THREE.ProxyColor, 3);\\n\\n\\t// If values were passed in, store them in the buffer via the proxy objects\\n\\n\\tif (values) {\\n\\n\\t\\tfor (var i = 0; i < values.length; i++) {\\n\\n\\t\\t\\tthis.colors[i].copy(values[i]);\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Return a reference to the newly-created array\\n\\n\\treturn this.colors;\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.populateProxyFromBuffer = function(attr, buffername, proxytype, itemsize, offset, count) {\\n\\n\\tif ( this.attributes[ buffername ] && this.attributes[ buffername ].array ) {\\n\\n\\t\\tvar array = this.attributes[ buffername ].array;\\n\\t\\tvar size = itemsize || this.attributes[ buffername ].itemSize;\\n\\t\\tvar start = offset || 0;\\n\\t\\t\\n\\t\\tcount = count || (array.length / size - start);\\n\\n\\t\\tfor ( var i = start, l = start + count; i < l; i ++ ) {\\n\\n\\t\\t\\tattr.push( new proxytype( array, i * size ) );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n}\\n\\n/*\\n * Checks for duplicate vertices with hashmap.\\n * Duplicated vertices are removed\\n * and faces' vertices are updated.\\n */\\n\\nTHREE.ProxyGeometry.prototype.mergeVertices = function () {\\n\\n\\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\\n\\tvar unique = [], changes = [];\\n\\n\\tvar v, key;\\n\\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\\n\\tvar precision = Math.pow( 10, precisionPoints );\\n\\tvar i,il, face;\\n\\tvar indices, k, j, jl, u;\\n\\n\\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\\n\\n\\t\\tv = this.vertices[ i ];\\n\\t\\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\\n\\n\\t\\tif ( verticesMap[ key ] === undefined ) {\\n\\n\\t\\t\\tverticesMap[ key ] = i;\\n\\t\\t\\tunique.push( this.vertices[ i ] );\\n\\t\\t\\tchanges[ i ] = unique.length - 1;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\\n\\t\\t\\tchanges[ i ] = changes[ verticesMap[ key ] ];\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\n\\t// if faces are completely degenerate after merging vertices, we\\n\\t// have to remove them from the geometry.\\n\\tvar faceIndicesToRemove = [];\\n\\n\\tfor( i = 0, il = this.faces.length; i < il; i ++ ) {\\n\\n\\t\\tface = this.faces[ i ];\\n\\n\\t\\tface.a = changes[ face.a ];\\n\\t\\tface.b = changes[ face.b ];\\n\\t\\tface.c = changes[ face.c ];\\n\\n\\t\\tindices = [ face.a, face.b, face.c ];\\n\\n\\t\\tvar dupIndex = -1;\\n\\n\\t\\t// if any duplicate vertices are found in a Face3\\n\\t\\t// we have to remove the face as nothing can be saved\\n\\t\\tfor ( var n = 0; n < 3; n ++ ) {\\n\\t\\t\\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\\n\\n\\t\\t\\t\\tdupIndex = n;\\n\\t\\t\\t\\tfaceIndicesToRemove.push( i );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\\n\\t\\tvar idx = faceIndicesToRemove[ i ];\\n\\n\\t\\tthis.faces.splice( idx, 1 );\\n\\n\\t\\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\tthis.faceVertexUvs[ j ].splice( idx, 1 );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Use unique set of vertices\\n\\n\\tvar diff = this.vertices.length - unique.length;\\n\\tthis.vertices = unique;\\n\\treturn diff;\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.onGeometryAllocate = function (ev) {\\n\\n\\t// Prevent allocate event listener from firing multiple times\\n\\tthis.removeEventListener( 'allocate', this.onGeometryAllocate);\\n\\n\\tif (this.hasOwnProperty('vertices')) {\\n\\t\\tvar attr = new THREE.Float32Attribute(this.vertices.length, 3);\\n\\t\\tthis.addAttribute('position', attr);\\n\\t\\tthis.createVertexProxies(this.vertices);\\n\\t}\\n\\tif (this.hasOwnProperty('faces')) {\\n\\t\\tvar idxattr = new THREE.Uint16Attribute(this.faces.length, 3);\\n\\t\\tthis.addAttribute('index', idxattr);\\n\\n\\t\\tif (this.faces.length > 0) {\\n\\t\\t\\tvar hasnormals = (this.hasOwnProperty('normals') || this.faces[0].normal || this.faces[0].vertexNormals.length > 0);\\n\\t\\t\\tvar hascolors = (this.hasOwnProperty('colors') || this.faces[0].color || this.faces[0].vertexColors.length > 0);\\n\\t\\t\\tvar hastangents = (this.faces[0].vertexTangents.length > 0);\\n\\n\\t\\t\\tif (hasnormals) {\\n\\t\\t\\t\\tvar normalattr = new THREE.Float32Attribute(this.vertices.length, 3);\\n\\t\\t\\t\\tthis.addAttribute('normal', normalattr);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (hascolors) {\\n\\t\\t\\t\\tvar colorattr = new THREE.Float32Attribute(this.faces.length * 3, 3);\\n\\t\\t\\t\\tthis.addAttribute('color', colorattr);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (hastangents) {\\n\\t\\t\\t\\tvar tangentattr = new THREE.Float32Attribute(this.faces.length * 3, 3);\\n\\t\\t\\t\\tthis.addAttribute('tangent', tangentattr);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.createFaceProxies(this.faces);\\n\\t}\\n\\n\\tif (this.hasOwnProperty('faceVertexUvs')) {\\n\\n\\t\\tvar uvattr = new THREE.Float32Attribute(this.faces.length * 3, 2);\\n\\t\\tthis.addAttribute('uv', uvattr);\\n\\t\\tthis.createUvProxies(this.faceVertexUvs[0]);\\n\\n\\t}\\n\\n\\tif (this.hasOwnProperty('skinIndices')) {\\n\\n\\t\\tvar skinidxattr = new THREE.Float32Attribute(this.skinIndices.length, 4);\\n\\t\\tthis.addAttribute('skinIndex', skinidxattr);\\n\\t\\tthis.createSkinIndexProxies(this.skinIndices);\\n\\n\\t}\\n\\n\\tif (this.hasOwnProperty('skinWeights')) {\\n\\n\\t\\tvar skinweightattr = new THREE.Float32Attribute(this.skinWeights.length, 4);\\n\\t\\tthis.addAttribute('skinWeight', skinweightattr);\\n\\t\\tthis.createSkinWeightProxies(this.skinWeights);\\n\\n\\t}\\n}\\n\\nTHREE.ProxyGeometry.prototype.computeFaceNormals = function() {\\n\\n\\tthis.dispatchEvent( { type: 'allocate' } );\\n\\n\\treturn THREE.BufferGeometry.prototype.computeFaceNormals.call(this);\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.computeVertexNormals = function() {\\n\\n\\tthis.dispatchEvent( { type: 'allocate' } );\\n\\n\\treturn THREE.BufferGeometry.prototype.computeVertexNormals.call(this);\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.computeTangents = function() {\\n\\n\\tthis.dispatchEvent( { type: 'allocate' } );\\n\\n\\tvar ret = THREE.BufferGeometry.prototype.computeTangents.call(this);\\n\\n\\t// FIXME - this doesn't work yet\\n\\t//this.createFaceVertexTangentProxies();\\n\\n\\treturn ret;\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.computeBoundingSphere = function() {\\n\\n\\tthis.dispatchEvent( { type: 'allocate' } );\\n\\n\\treturn THREE.BufferGeometry.prototype.computeBoundingSphere.call(this);\\n\\n}\\n\\nTHREE.ProxyGeometry.prototype.computeBoundingBox = function () {\\n\\n\\tthis.dispatchEvent( { type: 'allocate' } );\\n\\n\\treturn THREE.BufferGeometry.prototype.computeBoundingBox.call(this);\\n\\n}\\nTHREE.ProxyGeometry.prototype.clone = function () {\\n\\n\\tvar buff = THREE.BufferGeometry.prototype.clone.call(this);\\n\\tvar geo = new THREE.ProxyGeometry();\\n\\tgeo.attributes = buff.attributes;\\n\\tgeo.offsets = buff.offsets;\\n\\n\\treturn geo;\\n\\n}\\n\\nTHREE.EventDispatcher.prototype.apply( THREE.ProxyGeometry.prototype );\\n\\nTHREE.ProxyGeometryIdCount = 0;\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/IndexedTypedGeometry.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/IndexedTypedGeometry.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.IndexedTypedGeometry = function () {\\n\\n\\tTHREE.BufferGeometry.call( this );\\n\\n};\\n\\nTHREE.IndexedTypedGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\\n\\nTHREE.IndexedTypedGeometry.prototype.setArrays = function ( indices, vertices, normals, uvs ) {\\n\\n\\tthis.indices = indices;\\n\\tthis.vertices = vertices;\\n\\tthis.normals = normals;\\n\\tthis.uvs = uvs;\\n\\n\\tthis.attributes[ 'index' ] = { array: indices, itemSize: 1 };\\n\\tthis.attributes[ 'position' ] = { array: vertices, itemSize: 3 };\\n\\tthis.attributes[ 'normal' ] = { array: normals, itemSize: 3 };\\n\\tthis.attributes[ 'uv' ] = { array: uvs, itemSize: 2 };\\n\\n\\treturn this;\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/TypedGeometry.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/TypedGeometry.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.TypedGeometry = function ( size ) {\\n\\n\\tTHREE.BufferGeometry.call( this );\\n\\n\\tif ( size !== undefined ) {\\n\\n\\t\\tthis.vertices = new Float32Array( size * 3 * 3 );\\n\\t\\tthis.normals = new Float32Array( size * 3 * 3 );\\n\\t\\tthis.uvs = new Float32Array( size * 3 * 2 );\\n\\n\\t\\tthis.attributes[ 'position' ] = { array: this.vertices, itemSize: 3 };\\n\\t\\tthis.attributes[ 'normal' ] = { array: this.normals, itemSize: 3 };\\n\\t\\tthis.attributes[ 'uv' ] = { array: this.uvs, itemSize: 2 };\\n\\n\\t}\\n\\n};\\n\\nTHREE.TypedGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\\n\\nTHREE.TypedGeometry.prototype.setArrays = function ( vertices, normals, uvs ) {\\n\\n\\tthis.vertices = vertices;\\n\\tthis.normals = normals;\\n\\tthis.uvs = uvs;\\n\\n\\tthis.attributes[ 'position' ] = { array: vertices, itemSize: 3 };\\n\\tthis.attributes[ 'normal' ] = { array: normals, itemSize: 3 };\\n\\tthis.attributes[ 'uv' ] = { array: uvs, itemSize: 2 };\\n\\n\\treturn this;\\n\\n};\\n\\nTHREE.TypedGeometry.prototype.merge = ( function () {\\n\\n\\tvar offset = 0;\\n\\tvar normalMatrix = new THREE.Matrix3();\\n\\n\\treturn function ( geometry, matrix, startOffset ) {\\n\\n\\t\\tif ( startOffset !== undefined ) offset = startOffset;\\n\\n\\t\\tvar offset2 = offset * 2;\\n\\t\\tvar offset3 = offset * 3;\\n\\n\\t\\tvar vertices = this.attributes[ 'position' ].array;\\n\\t\\tvar normals = this.attributes[ 'normal' ].array;\\n\\t\\tvar uvs = this.attributes[ 'uv' ].array;\\n\\n\\t\\tif ( geometry instanceof THREE.TypedGeometry ) {\\n\\n\\t\\t\\tvar vertices2 = geometry.attributes[ 'position' ].array;\\n\\t\\t\\tvar normals2 = geometry.attributes[ 'normal' ].array;\\n\\t\\t\\tvar uvs2 = geometry.attributes[ 'uv' ].array;\\n\\n\\t\\t\\tfor ( var i = 0, l = vertices2.length; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\tvertices[ i + offset3     ] = vertices2[ i     ];\\n\\t\\t\\t\\tvertices[ i + offset3 + 1 ] = vertices2[ i + 1 ];\\n\\t\\t\\t\\tvertices[ i + offset3 + 2 ] = vertices2[ i + 2 ];\\n\\n\\t\\t\\t\\tnormals[ i + offset3     ] = normals2[ i     ];\\n\\t\\t\\t\\tnormals[ i + offset3 + 1 ] = normals2[ i + 1 ];\\n\\t\\t\\t\\tnormals[ i + offset3 + 2 ] = normals2[ i + 2 ];\\n\\n\\t\\t\\t\\tuvs[ i + offset2     ] = uvs2[ i     ];\\n\\t\\t\\t\\tuvs[ i + offset2 + 1 ] = uvs2[ i + 1 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else if ( geometry instanceof THREE.IndexedTypedGeometry ) {\\n\\n\\t\\t\\tvar indices2 = geometry.attributes[ 'index' ].array;\\n\\t\\t\\tvar vertices2 = geometry.attributes[ 'position' ].array;\\n\\t\\t\\tvar normals2 = geometry.attributes[ 'normal' ].array;\\n\\t\\t\\tvar uvs2 = geometry.attributes[ 'uv' ].array;\\n\\n\\t\\t\\tfor ( var i = 0, l = indices2.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar index = indices2[ i ];\\n\\n\\t\\t\\t\\tvar index3 = index * 3;\\n\\t\\t\\t\\tvar i3 = i * 3;\\n\\n\\t\\t\\t\\tvertices[ i3 + offset3 ] = vertices2[ index3 ];\\n\\t\\t\\t\\tvertices[ i3 + offset3 + 1 ] = vertices2[ index3 + 1 ];\\n\\t\\t\\t\\tvertices[ i3 + offset3 + 2 ] = vertices2[ index3 + 2 ];\\n\\n\\t\\t\\t\\tnormals[ i3 + offset3 ] = normals2[ index3 ];\\n\\t\\t\\t\\tnormals[ i3 + offset3 + 1 ] = normals2[ index3 + 1 ];\\n\\t\\t\\t\\tnormals[ i3 + offset3 + 2 ] = normals2[ index3 + 2 ];\\n\\n\\t\\t\\t\\tvar index2 = index * 2;\\n\\t\\t\\t\\tvar i2 = i * 2;\\n\\n\\t\\t\\t\\tuvs[ i2 + offset2 ] = uvs2[ index2 ];\\n\\t\\t\\t\\tuvs[ i2 + offset2 + 1 ] = uvs2[ index2 + 1 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( matrix !== undefined ) {\\n\\n\\t\\t\\t\\tmatrix.applyToVector3Array( vertices, offset3, indices2.length * 3 );\\n\\n\\t\\t\\t\\tnormalMatrix.getNormalMatrix( matrix );\\n\\t\\t\\t\\tnormalMatrix.applyToVector3Array( normals, offset3, indices2.length * 3 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\toffset += indices2.length;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n} )();\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/PlaneTypedGeometry.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/PlaneTypedGeometry.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\\n */\\n\\nTHREE.PlaneTypedGeometry = function ( width, height, widthSegments, heightSegments ) {\\n\\n\\tthis.parameters = {\\n\\t\\twidth: width,\\n\\t\\theight: height,\\n\\t\\twidthSegments: widthSegments,\\n\\t\\theightSegments: heightSegments\\n\\t};\\n\\n\\tvar width_half = width / 2;\\n\\tvar height_half = height / 2;\\n\\n\\tvar gridX = widthSegments || 1;\\n\\tvar gridY = heightSegments || 1;\\n\\n\\tvar gridX1 = gridX + 1;\\n\\tvar gridY1 = gridY + 1;\\n\\n\\tvar segment_width = width / gridX;\\n\\tvar segment_height = height / gridY;\\n\\n\\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\\n\\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\\n\\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\\n\\n\\tvar offset = 0;\\n\\tvar offset2 = 0;\\n\\n\\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\tvar y = iy * segment_height - height_half;\\n\\n\\t\\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\tvar x = ix * segment_width - width_half;\\n\\n\\t\\t\\tvertices[ offset     ] = x;\\n\\t\\t\\tvertices[ offset + 1 ] = - y;\\n\\n\\t\\t\\tnormals[ offset + 2 ] = 1;\\n\\n\\t\\t\\tuvs[ offset2     ] = ix / gridX;\\n\\t\\t\\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\\n\\n\\t\\t\\toffset += 3;\\n\\t\\t\\toffset2 += 2;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\toffset = 0;\\n\\n\\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\\n\\n\\tfor ( var iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\tfor ( var ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\tvar a = ix + gridX1 * iy;\\n\\t\\t\\tvar b = ix + gridX1 * ( iy + 1 );\\n\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\tindices[ offset     ] = a;\\n\\t\\t\\tindices[ offset + 1 ] = b;\\n\\t\\t\\tindices[ offset + 2 ] = d;\\n\\n\\t\\t\\tindices[ offset + 3 ] = b;\\n\\t\\t\\tindices[ offset + 4 ] = c;\\n\\t\\t\\tindices[ offset + 5 ] = d;\\n\\n\\t\\t\\toffset += 6;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tTHREE.IndexedTypedGeometry.call( this );\\n\\n\\tthis.setArrays( indices, vertices, normals, uvs );\\n\\tthis.computeBoundingSphere();\\n\\n};\\n\\nTHREE.PlaneTypedGeometry.prototype = Object.create( THREE.IndexedTypedGeometry.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry4.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry4.js\",\n            \"module-type\": \"library\",\n            \"text\": \"THREE.Geometry4 = function ( size ) {\\n\\n        THREE.BufferGeometry.call( this );\\n\\n        var verticesBuffer = new ArrayBuffer( size * 3 * 4 );\\n        var normalsBuffer = new ArrayBuffer( size * 3 * 4 );\\n        var uvsBuffer = new ArrayBuffer( size * 2 * 4 );\\n\\n        this.attributes[ 'position' ] = { array: new Float32Array( verticesBuffer, 0, size * 3 ), itemSize: 3 };\\n        this.attributes[ 'normal' ] = { array: new Float32Array( normalsBuffer, 0, size * 3 ), itemSize: 3 };\\n        this.attributes[ 'uv' ] = { array: new Float32Array( uvsBuffer, 0, size * 2 ), itemSize: 2 };\\n\\n        this.vertices = new THREE.VectorArrayProxy( this.attributes[ 'position' ] );\\n        this.normals = new THREE.VectorArrayProxy( this.attributes[ 'normal' ] );\\n        this.uvs = new THREE.VectorArrayProxy( this.attributes[ 'uv' ] );\\n\\n};\\nTHREE.Geometry4.prototype = Object.create( THREE.BufferGeometry.prototype );\\n\\nTHREE.VectorArrayProxy = function(attribute) {\\n\\n        // Acts as a proxy for an array of vectors, by setting up accessors which return THREE.Vector*Proxy objects\\n\\n        this.attribute = attribute;\\n\\n        for (var i = 0, l = this.attribute.array.length / this.attribute.itemSize; i < l; i++)  {\\n\\n                Object.defineProperty(this, i, {\\n                        get: (function(i) { return function() { return this.getValue(i); }})(i),\\n                        set: (function(i) { return function(v) { return this.setValue(i, v); }})(i),\\n                });\\n\\n        }\\n\\n}\\n\\nTHREE.VectorArrayProxy.prototype.getValue = function(i) {\\n\\n        // Allocates a new THREE.Vector2Proxy or THREE.Vector3Proxy depending on the itemSize of our attribute\\n\\n        var subarray = this.attribute.array.subarray(i * this.attribute.itemSize, (i + 1) * this.attribute.itemSize);\\n\\n        switch (this.attribute.itemSize) {\\n\\n                case 2:\\n                        return new THREE.Vector2Proxy(subarray);\\n\\n                case 3:\\n                        return new THREE.Vector3Proxy(subarray);\\n\\n        }\\n\\n}\\nTHREE.VectorArrayProxy.prototype.setValue = function(i, v) {\\n\\n        var vec = this[i];\\n        vec.copy(v);\\n\\n}\\n\\n// Vector Proxy Objects\\n\\nTHREE.Vector2Proxy = function(subarray) {\\n\\n        this.subarray = subarray;\\n\\n}\\nTHREE.Vector2Proxy.prototype = Object.create( THREE.Vector2.prototype );\\nObject.defineProperty(THREE.Vector2Proxy.prototype, 'x', { get: function() { return this.subarray[0]; }, set: function(v) { this.subarray[0] = v; } });\\nObject.defineProperty(THREE.Vector2Proxy.prototype, 'y', { get: function() { return this.subarray[1]; }, set: function(v) { this.subarray[1] = v; } });\\n\\n\\nTHREE.Vector3Proxy = function(subarray) {\\n\\n        this.subarray = subarray;\\n\\n}\\nTHREE.Vector3Proxy.prototype = Object.create( THREE.Vector3.prototype );\\n\\nObject.defineProperty(THREE.Vector3Proxy.prototype, 'x', { get: function() { return this.subarray[0]; }, set: function(v) { this.subarray[0] = v; } });\\nObject.defineProperty(THREE.Vector3Proxy.prototype, 'y', { get: function() { return this.subarray[1]; }, set: function(v) { this.subarray[1] = v; } });\\nObject.defineProperty(THREE.Vector3Proxy.prototype, 'z', { get: function() { return this.subarray[2]; }, set: function(v) { this.subarray[2] = v; } });\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneBufferGeometry.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneBufferGeometry.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\\n */\\n\\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\\n\\n\\tTHREE.BufferGeometry.call( this );\\n\\n\\tthis.parameters = {\\n\\t\\twidth: width,\\n\\t\\theight: height,\\n\\t\\twidthSegments: widthSegments,\\n\\t\\theightSegments: heightSegments\\n\\t};\\n\\n\\tvar width_half = width / 2;\\n\\tvar height_half = height / 2;\\n\\n\\tvar gridX = widthSegments || 1;\\n\\tvar gridY = heightSegments || 1;\\n\\n\\tvar gridX1 = gridX + 1;\\n\\tvar gridY1 = gridY + 1;\\n\\n\\tvar segment_width = width / gridX;\\n\\tvar segment_height = height / gridY;\\n\\n\\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\\n\\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\\n\\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\\n\\n\\tvar offset = 0;\\n\\tvar offset2 = 0;\\n\\n\\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\tvar y = iy * segment_height - height_half;\\n\\n\\t\\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\tvar x = ix * segment_width - width_half;\\n\\n\\t\\t\\tvertices[ offset     ] = x;\\n\\t\\t\\tvertices[ offset + 1 ] = - y;\\n\\n\\t\\t\\tnormals[ offset + 2 ] = 1;\\n\\n\\t\\t\\tuvs[ offset2     ] = ix / gridX;\\n\\t\\t\\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\\n\\n\\t\\t\\toffset += 3;\\n\\t\\t\\toffset2 += 2;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\toffset = 0;\\n\\n\\tvar indices = new Uint16Array( gridX * gridY * 6 );\\n\\n\\tfor ( var iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\tfor ( var ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\tvar a = ix + gridX1 * iy;\\n\\t\\t\\tvar b = ix + gridX1 * ( iy + 1 );\\n\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\tindices[ offset     ] = a;\\n\\t\\t\\tindices[ offset + 1 ] = b;\\n\\t\\t\\tindices[ offset + 2 ] = d;\\n\\n\\t\\t\\tindices[ offset + 3 ] = b;\\n\\t\\t\\tindices[ offset + 4 ] = c;\\n\\t\\t\\tindices[ offset + 5 ] = d;\\n\\n\\t\\t\\toffset += 6;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tthis.attributes[ 'index' ] = { array: indices, itemSize: 1 };\\n\\tthis.attributes[ 'position' ] = { array: vertices, itemSize: 3 };\\n\\tthis.attributes[ 'normal' ] = { array: normals, itemSize: 3 };\\n\\tthis.attributes[ 'uv' ] = { array: uvs, itemSize: 2 };\\n\\n};\\n\\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry3.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry3.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\\n */\\n\\nTHREE.PlaneGeometry3 = function ( width, height, widthSegments, heightSegments ) {\\n\\n\\tTHREE.Geometry3.call( this, ( widthSegments * heightSegments ) * 2 * 3 );\\n\\n\\tvar vertices = this.vertices;\\n\\tvar normals = this.normals;\\n\\tvar uvs = this.uvs;\\n\\n\\tthis.width = width;\\n\\tthis.height = height;\\n\\n\\tthis.widthSegments = widthSegments || 1;\\n\\tthis.heightSegments = heightSegments || 1;\\n\\n\\tvar widthHalf = width / 2;\\n\\tvar heightHalf = height / 2;\\n\\n\\tvar gridX = this.widthSegments;\\n\\tvar gridY = this.heightSegments;\\n\\n\\tvar segmentWidth = this.width / gridX;\\n\\tvar segmentHeight = this.height / gridY;\\n\\n\\tvar offset = 0;\\n\\n\\tfor ( var iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\tvar y1 = iy * segmentHeight - heightHalf;\\n\\t\\tvar y2 = ( iy + 1 ) * segmentHeight - heightHalf;\\n\\n\\t\\tfor ( var ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\tvar x1 = ix * segmentWidth - widthHalf;\\n\\t\\t\\tvar x2 = ( ix + 1 ) * segmentWidth - widthHalf;\\n\\n\\t\\t\\tvertices[ offset + 0 ][ 0 ] = x1;\\n\\t\\t\\tvertices[ offset + 0 ][ 1 ] = y1;\\n\\n\\t\\t\\tvertices[ offset + 1 ][ 0 ] = x2;\\n\\t\\t\\tvertices[ offset + 1 ][ 1 ] = y1;\\n\\n\\t\\t\\tvertices[ offset + 2 ][ 0 ] = x1;\\n\\t\\t\\tvertices[ offset + 2 ][ 1 ] = y2;\\n\\n\\t\\t\\tnormals[ offset + 0 ][ 2 ] = 1;\\n\\t\\t\\tnormals[ offset + 1 ][ 2 ] = 1;\\n\\t\\t\\tnormals[ offset + 2 ][ 2 ] = 1;\\n\\n\\t\\t\\tvertices[ offset + 3 ][ 0 ] = x2;\\n\\t\\t\\tvertices[ offset + 3 ][ 1 ] = y1;\\n\\n\\t\\t\\tvertices[ offset + 4 ][ 0 ] = x2;\\n\\t\\t\\tvertices[ offset + 4 ][ 1 ] = y2;\\n\\n\\t\\t\\tvertices[ offset + 5 ][ 0 ] = x1;\\n\\t\\t\\tvertices[ offset + 5 ][ 1 ] = y2;\\n\\n\\t\\t\\tnormals[ offset + 3 ][ 2 ] = 1;\\n\\t\\t\\tnormals[ offset + 4 ][ 2 ] = 1;\\n\\t\\t\\tnormals[ offset + 5 ][ 2 ] = 1;\\n\\n\\t\\t\\toffset += 6;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\\n\\nTHREE.PlaneGeometry3.prototype = Object.create( THREE.Geometry3.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry2Loader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry2Loader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n */\\r\\n\\r\\nTHREE.Geometry2Loader = function ( manager ) {\\r\\n\\r\\n\\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.Geometry2Loader.prototype = {\\r\\n\\r\\n\\tconstructor: THREE.Geometry2Loader,\\r\\n\\r\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\r\\n\\r\\n\\t\\tvar scope = this;\\r\\n\\r\\n\\t\\tvar loader = new THREE.XHRLoader();\\r\\n\\t\\tloader.setCrossOrigin( this.crossOrigin );\\r\\n\\t\\tloader.load( url, function ( text ) {\\r\\n\\r\\n\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\r\\n\\r\\n\\t\\t} );\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetCrossOrigin: function ( value ) {\\r\\n\\r\\n\\t\\tthis.crossOrigin = value;\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tparse: function ( json ) {\\r\\n\\r\\n\\t\\tvar geometry = new THREE.Geometry2( json.vertices.length / 3 );\\r\\n\\r\\n\\t\\tvar attributes = [ 'vertices', 'normals', 'uvs' ];\\r\\n\\t\\tvar boundingSphere = json.boundingSphere;\\r\\n\\r\\n\\t\\tfor ( var key in attributes ) {\\r\\n\\r\\n\\t\\t\\tvar attribute = attributes[ key ];\\r\\n\\t\\t\\tgeometry[ attribute ].set( json[ attribute ] );\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( boundingSphere !== undefined ) {\\r\\n\\r\\n\\t\\t\\tgeometry.boundingSphere = new THREE.Sphere(\\r\\n\\t\\t\\t\\tnew THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),\\r\\n\\t\\t\\t\\tboundingSphere.radius\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn geometry;\\r\\n\\r\\n\\t}\\r\\n\\r\\n};\\r\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/IndexedGeometry5.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/IndexedGeometry5.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.IndexedGeometry5 = function ( indices, size ) {\\n\\n\\tTHREE.BufferGeometry.call( this );\\n\\n\\tvar verticesBuffer = new Float32Array( size * 3 );\\n\\tvar normalsBuffer = new Float32Array( size * 3 );\\n\\tvar uvsBuffer = new Float32Array( size * 2 );\\n\\n\\tthis.indices = new Uint16Array( indices );\\n\\tthis.vertices = [];\\n\\tthis.normals = [];\\n\\tthis.uvs = [];\\n\\n\\tfor ( var i = 0; i < size; i ++ ) {\\n\\n\\t\\tthis.vertices.push( new THREE.TypedVector3( verticesBuffer, i * 3 ) );\\n\\t\\tthis.normals.push( new THREE.TypedVector3( normalsBuffer, i * 3 ) );\\n\\t\\tthis.uvs.push( new THREE.TypedVector2( uvsBuffer, i * 2 ) );\\n\\n\\t}\\n\\n\\tthis.attributes[ 'index' ] = { array: this.indices, itemSize: 1 };\\n\\tthis.attributes[ 'position' ] = { array: verticesBuffer, itemSize: 3 };\\n\\tthis.attributes[ 'normal' ] = { array: normalsBuffer, itemSize: 3 };\\n\\tthis.attributes[ 'uv' ] = { array: uvsBuffer, itemSize: 2 };\\n\\n};\\n\\nTHREE.IndexedGeometry5.prototype = Object.create( THREE.BufferGeometry.prototype );\\n\\nTHREE.TypedVector2 = function ( array, offset ) {\\n\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\t\\n};\\n\\nTHREE.TypedVector2.prototype = Object.create( THREE.Vector2.prototype );\\n\\nObject.defineProperties( THREE.TypedVector2.prototype, {\\n\\t'x': {\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'y': {\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t}\\n} );\\n\\nTHREE.TypedVector3 = function ( array, offset ) {\\n\\t\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\n};\\n\\nTHREE.TypedVector3.prototype = Object.create( THREE.Vector3.prototype );\\n\\nObject.defineProperties( THREE.TypedVector3.prototype, {\\n\\t'x': {\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'y': {\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t},\\n\\t'z': {\\n\\t\\tget: function () { return this.array[ this.offset + 2 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 2 ] = v; }\\n\\t}\\n} );\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry2.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry2.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.Geometry2 = function ( size ) {\\n\\n\\tTHREE.BufferGeometry.call( this );\\n\\n\\tthis.vertices = new THREE.Float32Attribute( size, 3 );\\n\\tthis.normals = new THREE.Float32Attribute( size, 3 );\\n\\tthis.uvs = new THREE.Float32Attribute( size, 2 );\\n\\n\\tthis.addAttribute( 'position', this.vertices );\\n\\tthis.addAttribute( 'normal', this.normals );\\n\\tthis.addAttribute( 'uv', this.uvs );\\n\\n};\\n\\nTHREE.Geometry2.prototype = Object.create( THREE.BufferGeometry.prototype );\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry6.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry6.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.PlaneGeometry6 = function ( width, height, widthSegments, heightSegments ) {\\n\\n\\tTHREE.PlaneBufferGeometry.call( this, width, height, widthSegments, heightSegments );\\n\\n\\tvar indices = this.attributes.index.array;\\n\\tvar vertices = this.attributes.position.array;\\n\\tvar normals = this.attributes.normal.array;\\n\\tvar uvs = this.attributes.uv.array;\\n\\n\\tthis.indices = indices;\\n\\tthis.vertices = [];\\n\\tthis.normals = [];\\n\\tthis.uvs = [];\\n\\n\\tfor ( var i = 0, l = vertices.length / 3; i < l; i ++ ) {\\n\\n\\t\\tthis.vertices.push( new THREE.TypedVector3( vertices, i * 3 ) );\\n\\t\\tthis.normals.push( new THREE.TypedVector3( normals, i * 3 ) );\\n\\t\\tthis.uvs.push( new THREE.TypedVector2( uvs, i * 2 ) );\\n\\n\\t}\\n\\n};\\n\\nTHREE.PlaneGeometry6.prototype = Object.create( THREE.PlaneBufferGeometry.prototype );\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry2.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry2.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\\n */\\n\\nTHREE.PlaneGeometry2 = function ( width, height, widthSegments, heightSegments ) {\\n\\n\\tTHREE.Geometry2.call( this, ( widthSegments * heightSegments ) * 2 * 3 );\\n\\n\\tvar vertices = this.vertices.array;\\n\\tvar normals = this.normals.array;\\n\\tvar uvs = this.uvs.array;\\n\\n\\tthis.width = width;\\n\\tthis.height = height;\\n\\n\\tthis.widthSegments = widthSegments || 1;\\n\\tthis.heightSegments = heightSegments || 1;\\n\\n\\tvar widthHalf = width / 2;\\n\\tvar heightHalf = height / 2;\\n\\n\\tvar gridX = this.widthSegments;\\n\\tvar gridY = this.heightSegments;\\n\\n\\tvar segmentWidth = this.width / gridX;\\n\\tvar segmentHeight = this.height / gridY;\\n\\n\\tvar offset = 0;\\n\\n\\tfor ( var iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\tvar y1 = iy * segmentHeight - heightHalf;\\n\\t\\tvar y2 = ( iy + 1 ) * segmentHeight - heightHalf;\\n\\n\\t\\tfor ( var ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\tvar x1 = ix * segmentWidth - widthHalf;\\n\\t\\t\\tvar x2 = ( ix + 1 ) * segmentWidth - widthHalf;\\n\\n\\t\\t\\tvertices[ offset + 0 ] = x1;\\n\\t\\t\\tvertices[ offset + 1 ] = y1;\\n\\n\\t\\t\\tvertices[ offset + 3 ] = x2;\\n\\t\\t\\tvertices[ offset + 4 ] = y1;\\n\\n\\t\\t\\tvertices[ offset + 6 ] = x1;\\n\\t\\t\\tvertices[ offset + 7 ] = y2;\\n\\n\\t\\t\\tnormals[ offset + 2 ] = 1;\\n\\t\\t\\tnormals[ offset + 5 ] = 1;\\n\\t\\t\\tnormals[ offset + 8 ] = 1;\\n\\n\\t\\t\\tvertices[ offset + 9 ] = x2;\\n\\t\\t\\tvertices[ offset + 10 ] = y1;\\n\\n\\t\\t\\tvertices[ offset + 12 ] = x2;\\n\\t\\t\\tvertices[ offset + 13 ] = y2;\\n\\n\\t\\t\\tvertices[ offset + 15 ] = x1;\\n\\t\\t\\tvertices[ offset + 16 ] = y2;\\n\\n\\t\\t\\tnormals[ offset + 11 ] = 1;\\n\\t\\t\\tnormals[ offset + 13 ] = 1;\\n\\t\\t\\tnormals[ offset + 17 ] = 1;\\n\\n\\t\\t\\toffset += 18;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\\n\\nTHREE.PlaneGeometry2.prototype = Object.create( THREE.Geometry2.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry5b.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry5b.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.Geometry5b = function ( bufferGeometry ) {\\n\\n\\tTHREE.BufferGeometry.call( this );\\n\\n\\tthis.attributes = bufferGeometry.attributes;\\n\\n\\tvar verticesBuffer = this.attributes.position.array;\\n\\tvar normalsBuffer = this.attributes.normal.array;\\n\\tvar uvsBuffer = this.attributes.uv.array;\\n\\n\\tthis.vertices = [];\\n\\tthis.normals = [];\\n\\tthis.uvs = [];\\n\\n\\tfor ( var i = 0, l = verticesBuffer.length / 3; i < l; i ++ ) {\\n\\n\\t\\tthis.vertices.push( new THREE.TypedVector3( verticesBuffer, i * 3 ) );\\n\\t\\tthis.normals.push( new THREE.TypedVector3( normalsBuffer, i * 3 ) );\\n\\t\\tthis.uvs.push( new THREE.TypedVector2( uvsBuffer, i * 2 ) );\\n\\n\\t}\\n\\n};\\n\\nTHREE.Geometry5b.prototype = Object.create( THREE.BufferGeometry.prototype );\\n\\nTHREE.TypedVector2 = function ( array, offset ) {\\n\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\t\\n};\\n\\nTHREE.TypedVector2.prototype = Object.create( THREE.Vector2.prototype );\\n\\nObject.defineProperties( THREE.TypedVector2.prototype, {\\n\\t'x': {\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'y': {\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t}\\n} );\\n\\nTHREE.TypedVector3 = function ( array, offset ) {\\n\\t\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\n};\\n\\nTHREE.TypedVector3.prototype = Object.create( THREE.Vector3.prototype );\\n\\nObject.defineProperties( THREE.TypedVector3.prototype, {\\n\\t'x': {\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'y': {\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t},\\n\\t'z': {\\n\\t\\tget: function () { return this.array[ this.offset + 2 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 2 ] = v; }\\n\\t}\\n} );\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/IndexedGeometry3.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/IndexedGeometry3.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.IndexedGeometry3 = function ( indices, size ) {\\n\\n\\tTHREE.BufferGeometry.call( this );\\n\\n\\tvar verticesBuffer = new ArrayBuffer( size * 3 * 4 );\\n\\tvar normalsBuffer = new ArrayBuffer( size * 3 * 4 );\\n\\tvar uvsBuffer = new ArrayBuffer( size * 2 * 4 );\\n\\n\\tthis.indices = new Uint16Array( indices );\\n\\tthis.vertices = [];\\n\\tthis.normals = [];\\n\\tthis.uvs = [];\\n\\n\\tfor ( var i = 0; i < size; i ++ ) {\\n\\n\\t\\tthis.vertices.push( new Float32Array( verticesBuffer, i * 3 * 4, 3 ) );\\n\\t\\tthis.normals.push( new Float32Array( normalsBuffer, i * 3 * 4, 3 ) );\\n\\t\\tthis.uvs.push( new Float32Array( uvsBuffer, i * 2 * 4, 2 ) );\\n\\n\\t}\\n\\n\\tthis.attributes[ 'index' ] = { array: this.indices, itemSize: 1 };\\n\\tthis.attributes[ 'position' ] = { array: new Float32Array( verticesBuffer, 0, size * 3 ), itemSize: 3 };\\n\\tthis.attributes[ 'normal' ] = { array: new Float32Array( normalsBuffer, 0, size * 3 ), itemSize: 3 };\\n\\tthis.attributes[ 'uv' ] = { array: new Float32Array( uvsBuffer, 0, size * 2 ), itemSize: 2 };\\n\\n};\\n\\nTHREE.Geometry3.prototype = Object.create( THREE.BufferGeometry.prototype );\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry2b.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry2b.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\\n */\\n\\nTHREE.PlaneGeometry2b = function ( width, height, widthSegments, heightSegments ) {\\n\\n\\tTHREE.Geometry2.call( this, ( widthSegments * heightSegments ) * 2 * 3 );\\n\\n\\tvar vertices = this.vertices;\\n\\tvar normals = this.normals;\\n\\tvar uvs = this.uvs;\\n\\n\\tthis.width = width;\\n\\tthis.height = height;\\n\\n\\tthis.widthSegments = widthSegments || 1;\\n\\tthis.heightSegments = heightSegments || 1;\\n\\n\\tvar widthHalf = width / 2;\\n\\tvar heightHalf = height / 2;\\n\\n\\tvar gridX = this.widthSegments;\\n\\tvar gridY = this.heightSegments;\\n\\n\\tvar segmentWidth = this.width / gridX;\\n\\tvar segmentHeight = this.height / gridY;\\n\\n\\tvar index = 0;\\n\\n\\tfor ( var iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\tvar y1 = iy * segmentHeight - heightHalf;\\n\\t\\tvar y2 = ( iy + 1 ) * segmentHeight - heightHalf;\\n\\n\\t\\tfor ( var ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\tvar x1 = ix * segmentWidth - widthHalf;\\n\\t\\t\\tvar x2 = ( ix + 1 ) * segmentWidth - widthHalf;\\n\\n\\t\\t\\tthis.vertices.setXY( index + 0,  x1, y1 );\\n\\t\\t\\tthis.vertices.setXY( index + 1,  x2, y1 );\\n\\t\\t\\tthis.vertices.setXY( index + 2,  x1, y2 );\\n\\n\\t\\t\\tthis.vertices.setXY( index + 3, x2, y1 );\\n\\t\\t\\tthis.vertices.setXY( index + 4, x2, y2 );\\n\\t\\t\\tthis.vertices.setXY( index + 5, x1, y2 );\\n\\n\\t\\t\\tthis.normals.setZ( index + 0, 1 );\\n\\t\\t\\tthis.normals.setZ( index + 1, 1 );\\n\\t\\t\\tthis.normals.setZ( index + 2, 1 );\\n\\n\\t\\t\\tthis.normals.setZ( index + 3, 1 );\\n\\t\\t\\tthis.normals.setZ( index + 4, 1 );\\n\\t\\t\\tthis.normals.setZ( index + 5, 1 );\\n\\n\\t\\t\\tindex += 6;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\\n\\nTHREE.PlaneGeometry2b.prototype = Object.create( THREE.Geometry2.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/BoxGeometry2.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/BoxGeometry2.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\\n */\\n\\nTHREE.BoxGeometry2 = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\n\\n\\tvar scope = this;\\n\\n\\tthis.width = width;\\n\\tthis.height = height;\\n\\tthis.depth = depth;\\n\\n\\tthis.widthSegments = widthSegments || 1;\\n\\tthis.heightSegments = heightSegments || 1;\\n\\tthis.depthSegments = depthSegments || 1;\\n\\n\\tvar width_half = this.width / 2;\\n\\tvar height_half = this.height / 2;\\n\\tvar depth_half = this.depth / 2;\\n\\n\\tvar vector = new THREE.Vector3();\\n\\n\\tvar vectors = [];\\n\\tvar vertices = [];\\n\\n\\tvar addVertex = function ( a, b, c ) {\\n\\n\\t\\tvertices.push( vectors[ a ], vectors[ a + 1 ], vectors[ a + 2 ] );\\n\\t\\tvertices.push( vectors[ b ], vectors[ b + 1 ], vectors[ b + 2 ] );\\n\\t\\tvertices.push( vectors[ c ], vectors[ c + 1 ], vectors[ c + 2 ] );\\n\\n\\t};\\n\\n\\tbuildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px\\n\\tbuildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx\\n\\tbuildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py\\n\\tbuildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny\\n\\tbuildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz\\n\\tbuildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz\\n\\n\\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\\n\\n\\t\\tvar w, ix, iy,\\n\\t\\tgridX = scope.widthSegments,\\n\\t\\tgridY = scope.heightSegments,\\n\\t\\twidth_half = width / 2,\\n\\t\\theight_half = height / 2,\\n\\t\\toffset = vectors.length;\\n\\n\\t\\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\\n\\n\\t\\t\\tw = 'z';\\n\\n\\t\\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\\n\\n\\t\\t\\tw = 'y';\\n\\t\\t\\tgridY = scope.depthSegments;\\n\\n\\t\\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\\n\\n\\t\\t\\tw = 'x';\\n\\t\\t\\tgridX = scope.depthSegments;\\n\\n\\t\\t}\\n\\n\\t\\tvar gridX1 = gridX + 1,\\n\\t\\tgridY1 = gridY + 1,\\n\\t\\tsegment_width = width / gridX,\\n\\t\\tsegment_height = height / gridY,\\n\\t\\tnormal = new THREE.Vector3();\\n\\n\\t\\tnormal[ w ] = depth > 0 ? 1 : - 1;\\n\\n\\t\\tfor ( iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\t\\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\\n\\t\\t\\t\\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\\n\\t\\t\\t\\tvector[ w ] = depth;\\n\\n\\t\\t\\t\\tvectors.push( vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfor ( iy = 0; iy < gridY; iy++ ) {\\n\\n\\t\\t\\tfor ( ix = 0; ix < gridX; ix++ ) {\\n\\n\\t\\t\\t\\tvar a = ix + gridX1 * iy;\\n\\t\\t\\t\\tvar b = ix + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\t\\taddVertex( a * 3 + offset, b * 3 + offset, d * 3 + offset );\\n\\t\\t\\t\\taddVertex( b * 3 + offset, c * 3 + offset, d * 3 + offset );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tTHREE.Geometry2.call( this, vertices.length / 3 );\\n\\n\\tthis.vertices.set( vertices );\\n\\n};\\n\\nTHREE.BoxGeometry2.prototype = Object.create( THREE.Geometry2.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry99.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry99.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.PlaneGeometry99 = function ( width, height, widthSegments, heightSegments ) {\\n\\n\\tTHREE.Geometry99.call( this );\\n\\n\\tthis.parameters = {\\n\\t\\twidth: width,\\n\\t\\theight: height,\\n\\t\\twidthSegments: widthSegments,\\n\\t\\theightSegments: heightSegments\\n\\t};\\n\\n\\tvar width_half = width / 2;\\n\\tvar height_half = height / 2;\\n\\n\\tvar gridX = widthSegments || 1;\\n\\tvar gridY = heightSegments || 1;\\n\\n\\tvar gridX1 = gridX + 1;\\n\\tvar gridY1 = gridY + 1;\\n\\n\\tvar segment_width = width / gridX;\\n\\tvar segment_height = height / gridY;\\n\\n\\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\\n\\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\\n\\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\\n\\n\\tvar offset = 0;\\n\\tvar offset2 = 0;\\n\\n\\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\tvar y = iy * segment_height - height_half;\\n\\n\\t\\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\tvar x = ix * segment_width - width_half;\\n\\n\\t\\t\\tvertices[ offset     ] = x;\\n\\t\\t\\tvertices[ offset + 1 ] = - y;\\n\\n\\t\\t\\tnormals[ offset + 2 ] = 1;\\n\\n\\t\\t\\tuvs[ offset2     ] = ix / gridX;\\n\\t\\t\\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\\n\\n\\t\\t\\toffset += 3;\\n\\t\\t\\toffset2 += 2;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\toffset = 0;\\n\\n\\tvar indices = new Uint16Array( gridX * gridY * 6 );\\n\\n\\tfor ( var iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\tfor ( var ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\tvar a = ix + gridX1 * iy;\\n\\t\\t\\tvar b = ix + gridX1 * ( iy + 1 );\\n\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\tindices[ offset     ] = a;\\n\\t\\t\\tindices[ offset + 1 ] = b;\\n\\t\\t\\tindices[ offset + 2 ] = d;\\n\\n\\t\\t\\tindices[ offset + 3 ] = b;\\n\\t\\t\\tindices[ offset + 4 ] = c;\\n\\t\\t\\tindices[ offset + 5 ] = d;\\n\\n\\t\\t\\toffset += 6;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tthis.attributes[ 'index' ] = { array: indices, itemSize: 1 };\\n\\tthis.attributes[ 'position' ] = { array: vertices, itemSize: 3 };\\n\\tthis.attributes[ 'normal' ] = { array: normals, itemSize: 3 };\\n\\tthis.attributes[ 'uv' ] = { array: uvs, itemSize: 2 };\\n\\n};\\n\\nTHREE.PlaneGeometry99.prototype = Object.create( THREE.Geometry99.prototype );\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/TypedGeometry.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/TypedGeometry.js\",\n            \"module-type\": \"library\",\n            \"text\": \"THREE.TypedVector2 = function ( array, offset ) {\\n\\n\\tthis.array = array;\\n\\tthis.offset = offset * 2;\\n\\n};\\n\\nTHREE.TypedVector2.prototype = {\\n\\n\\tconstructor: THREE.TypedVector3,\\n\\n\\tget x () {\\n\\n\\t\\treturn this.array[ this.offset ];\\n\\n\\t},\\n\\n\\tset x ( value ) {\\n\\n\\t\\tthis.array[ this.offset ] = value;\\n\\n\\t},\\n\\n\\tget y () {\\n\\n\\t\\treturn this.array[ this.offset + 1 ];\\n\\n\\t},\\n\\n\\tset y ( value ) {\\n\\n\\t\\tthis.array[ this.offset + 1 ] = value;\\n\\n\\t},\\n\\n\\tset: function ( x, y ) {\\n\\n\\t\\tthis.array[ this.offset ] = x;\\n\\t\\tthis.array[ this.offset + 1 ] = y;\\n\\t\\treturn this;\\n\\n\\t}\\n\\n};\\n\\nTHREE.TypedVector3 = function ( array, offset ) {\\n\\n\\tthis.array = array;\\n\\tthis.offset = offset * 3;\\n\\n};\\n\\nTHREE.TypedVector3.prototype = {\\n\\n\\tconstructor: THREE.TypedVector3,\\n\\n\\tget x () {\\n\\n\\t\\treturn this.array[ this.offset ];\\n\\n\\t},\\n\\n\\tset x ( value ) {\\n\\n\\t\\tthis.array[ this.offset ] = value;\\n\\n\\t},\\n\\n\\tget y () {\\n\\n\\t\\treturn this.array[ this.offset + 1 ];\\n\\n\\t},\\n\\n\\tset y ( value ) {\\n\\n\\t\\tthis.array[ this.offset + 1 ] = value;\\n\\n\\t},\\n\\n\\tget z () {\\n\\n\\t\\treturn this.array[ this.offset + 2 ];\\n\\n\\t},\\n\\n\\tset z ( value ) {\\n\\n\\t\\tthis.array[ this.offset + 2 ] = value;\\n\\n\\t},\\n\\n\\tset: function ( x, y, z ) {\\n\\n\\t\\tthis.array[ this.offset ] = x;\\n\\t\\tthis.array[ this.offset + 1 ] = y;\\n\\t\\tthis.array[ this.offset + 2 ] = z;\\n\\t\\treturn this;\\n\\n\\t},\\n\\n\\ttoString: function () {\\n\\n\\t\\treturn '[' + this.array[ this.offset ] + ',' + this.array[ this.offset + 1 ] + ',' + this.array[ this.offset + 2 ] + ']';\\n\\n\\t}\\n\\n};\\n\\nTHREE.TypedFace = function ( positions, normals, uvs, offset ) {\\n\\n\\tthis.positions = positions;\\n\\tthis.normals = normals;\\n\\tthis.uvs = uvs;\\n\\tthis.offset = offset * 3;\\n\\n};\\n\\nTHREE.TypedFace.prototype = {\\n\\n\\tconstructor: THREE.TypedFace,\\n\\n\\tvertex: function ( index ) {\\n\\n\\t\\treturn new THREE.TypedVector3( this.positions, this.offset + index );\\n\\n\\t},\\n\\n\\tnormal: function ( index ) {\\n\\n\\t\\treturn new THREE.TypedVector3( this.normals, this.offset + index );\\n\\n\\t},\\n\\n\\tuv: function ( index ) {\\n\\n\\t\\treturn new THREE.TypedVector2( this.uvs, this.offset + index );\\n\\n\\t}\\n\\n}\\n\\n\\nTHREE.TypedGeometry = function ( size ) {\\n\\n\\tthis.id = THREE.GeometryIdCount ++;\\n\\tthis.uuid = THREE.Math.generateUUID();\\n\\n\\tthis.name = '';\\n\\n\\tthis.positions = new Float32Array( size * 3 * 3 );\\n\\tthis.normals = new Float32Array( size * 3 * 3 );\\n\\tthis.uvs = new Float32Array( size * 3 * 2 );\\n\\n\\tthis.boundingBox = null;\\n\\tthis.boundingSphere = null;\\n\\n};\\n\\nTHREE.TypedGeometry.prototype = {\\n\\n\\tconstructor: THREE.TypedGeometry,\\n\\n\\tface: function ( index ) {\\n\\n\\t\\treturn new THREE.TypedFace( this.positions, this.normals, this.uvs, index );\\n\\n\\t},\\n\\n\\tdispose: function () {\\n\\n\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t}\\n\\n};\\n\\nTHREE.EventDispatcher.prototype.apply( THREE.TypedGeometry.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry3.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry3.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.Geometry3 = function ( size ) {\\n\\n\\tTHREE.BufferGeometry.call( this );\\n\\n\\tvar verticesBuffer = new ArrayBuffer( size * 3 * 4 );\\n\\tvar normalsBuffer = new ArrayBuffer( size * 3 * 4 );\\n\\tvar uvsBuffer = new ArrayBuffer( size * 2 * 4 );\\n\\n\\tthis.vertices = [];\\n\\tthis.normals = [];\\n\\tthis.uvs = [];\\n\\n\\tfor ( var i = 0; i < size; i ++ ) {\\n\\n\\t\\tthis.vertices.push( new Float32Array( verticesBuffer, i * 3 * 4, 3 ) );\\n\\t\\tthis.normals.push( new Float32Array( normalsBuffer, i * 3 * 4, 3 ) );\\n\\t\\tthis.uvs.push( new Float32Array( uvsBuffer, i * 2 * 4, 2 ) );\\n\\n\\t}\\n\\n\\tthis.attributes[ 'position' ] = { array: new Float32Array( verticesBuffer, 0, size * 3 ), itemSize: 3 };\\n\\tthis.attributes[ 'normal' ] = { array: new Float32Array( normalsBuffer, 0, size * 3 ), itemSize: 3 };\\n\\tthis.attributes[ 'uv' ] = { array: new Float32Array( uvsBuffer, 0, size * 2 ), itemSize: 2 };\\n\\n};\\n\\nTHREE.Geometry3.prototype = Object.create( THREE.BufferGeometry.prototype );\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry5.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry5.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\\n */\\n\\nTHREE.PlaneGeometry5 = function ( width, height, widthSegments, heightSegments ) {\\n\\n\\tTHREE.Geometry5.call( this, ( widthSegments * heightSegments ) * 2 * 3 );\\n\\n\\tvar vertices = this.vertices;\\n\\tvar normals = this.normals;\\n\\tvar uvs = this.uvs;\\n\\n\\tthis.width = width;\\n\\tthis.height = height;\\n\\n\\tthis.widthSegments = widthSegments || 1;\\n\\tthis.heightSegments = heightSegments || 1;\\n\\n\\tvar widthHalf = width / 2;\\n\\tvar heightHalf = height / 2;\\n\\n\\tvar gridX = this.widthSegments;\\n\\tvar gridY = this.heightSegments;\\n\\n\\tvar segmentWidth = this.width / gridX;\\n\\tvar segmentHeight = this.height / gridY;\\n\\n\\tvar offset = 0;\\n\\n\\tfor ( var iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\tvar y1 = iy * segmentHeight - heightHalf;\\n\\t\\tvar y2 = ( iy + 1 ) * segmentHeight - heightHalf;\\n\\n\\t\\tfor ( var ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\tvar x1 = ix * segmentWidth - widthHalf;\\n\\t\\t\\tvar x2 = ( ix + 1 ) * segmentWidth - widthHalf;\\n\\n\\t\\t\\tvertices[ offset + 0 ].set( x1, y1, 0 );\\n\\t\\t\\tvertices[ offset + 1 ].set( x2, y1, 0 );\\n\\t\\t\\tvertices[ offset + 2 ].set( x1, y2, 0 );\\n\\n\\t\\t\\tnormals[ offset + 0 ].z = 1;\\n\\t\\t\\tnormals[ offset + 1 ].z = 1;\\n\\t\\t\\tnormals[ offset + 2 ].z = 1;\\n\\n\\t\\t\\tvertices[ offset + 3 ].set( x2, y1, 0 );\\n\\t\\t\\tvertices[ offset + 4 ].set( x2, y2, 0 );\\n\\t\\t\\tvertices[ offset + 5 ].set( x1, y2, 0 );\\n\\n\\t\\t\\tnormals[ offset + 3 ].z = 1;\\n\\t\\t\\tnormals[ offset + 4 ].z = 1;\\n\\t\\t\\tnormals[ offset + 5 ].z = 1;\\n\\n\\t\\t\\toffset += 6;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\\n\\nTHREE.PlaneGeometry5.prototype = Object.create( THREE.Geometry5.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/PlaneGeometry.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\\n */\\n\\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\\n\\n\\tTHREE.Geometry.call( this );\\n\\n\\tthis.width = width;\\n\\tthis.height = height;\\n\\n\\tthis.widthSegments = widthSegments || 1;\\n\\tthis.heightSegments = heightSegments || 1;\\n\\n\\tvar ix, iz;\\n\\tvar width_half = width / 2;\\n\\tvar height_half = height / 2;\\n\\n\\tvar gridX = this.widthSegments;\\n\\tvar gridZ = this.heightSegments;\\n\\n\\tvar gridX1 = gridX + 1;\\n\\tvar gridZ1 = gridZ + 1;\\n\\n\\tvar segment_width = this.width / gridX;\\n\\tvar segment_height = this.height / gridZ;\\n\\n\\tvar normal = new THREE.Vector3( 0, 0, 1 );\\n\\n\\tfor ( iz = 0; iz < gridZ1; iz ++ ) {\\n\\n\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\tvar x = ix * segment_width - width_half;\\n\\t\\t\\tvar y = iz * segment_height - height_half;\\n\\n\\t\\t\\tthis.vertices.push( new THREE.Vector3( x, - y, 0 ) );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfor ( iz = 0; iz < gridZ; iz ++ ) {\\n\\n\\t\\tfor ( ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\tvar a = ix + gridX1 * iz;\\n\\t\\t\\tvar b = ix + gridX1 * ( iz + 1 );\\n\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iz + 1 );\\n\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iz;\\n\\n\\t\\t\\tvar uva = new THREE.Vector2( ix / gridX, 1 - iz / gridZ );\\n\\t\\t\\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ );\\n\\t\\t\\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ );\\n\\t\\t\\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ );\\n\\n\\t\\t\\tvar face = new THREE.Face3( a, b, d );\\n\\t\\t\\tface.normal.copy( normal );\\n\\t\\t\\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\\n\\n\\t\\t\\tthis.faces.push( face );\\n\\t\\t\\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\\n\\n\\t\\t\\tface = new THREE.Face3( b, c, d );\\n\\t\\t\\tface.normal.copy( normal );\\n\\t\\t\\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\\n\\n\\t\\t\\tthis.faces.push( face );\\n\\t\\t\\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\\n\\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry5.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/Geometry5.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.Geometry5 = function ( size ) {\\n\\n\\tTHREE.BufferGeometry.call( this );\\n\\n\\tvar verticesBuffer = new Float32Array( size * 3 );\\n\\tvar normalsBuffer = new Float32Array( size * 3 );\\n\\tvar uvsBuffer = new Float32Array( size * 2 );\\n\\n\\tthis.vertices = [];\\n\\tthis.normals = [];\\n\\tthis.uvs = [];\\n\\n\\tfor ( var i = 0; i < size; i ++ ) {\\n\\n\\t\\tthis.vertices.push( new THREE.TypedVector3( verticesBuffer, i * 3 ) );\\n\\t\\tthis.normals.push( new THREE.TypedVector3( normalsBuffer, i * 3 ) );\\n\\t\\tthis.uvs.push( new THREE.TypedVector2( uvsBuffer, i * 2 ) );\\n\\n\\t}\\n\\n\\tthis.attributes[ 'position' ] = { array: verticesBuffer, itemSize: 3 };\\n\\tthis.attributes[ 'normal' ] = { array: normalsBuffer, itemSize: 3 };\\n\\tthis.attributes[ 'uv' ] = { array: uvsBuffer, itemSize: 2 };\\n\\n};\\n\\nTHREE.Geometry5.prototype = Object.create( THREE.BufferGeometry.prototype );\\n\\nTHREE.TypedVector2 = function ( array, offset ) {\\n\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\t\\n};\\n\\nTHREE.TypedVector2.prototype = Object.create( THREE.Vector2.prototype );\\n\\nObject.defineProperties( THREE.TypedVector2.prototype, {\\n\\t'x': {\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'y': {\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t}\\n} );\\n\\nTHREE.TypedVector3 = function ( array, offset ) {\\n\\t\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\n};\\n\\nTHREE.TypedVector3.prototype = Object.create( THREE.Vector3.prototype );\\n\\nObject.defineProperties( THREE.TypedVector3.prototype, {\\n\\t'x': {\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'y': {\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t},\\n\\t'z': {\\n\\t\\tget: function () { return this.array[ this.offset + 2 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 2 ] = v; }\\n\\t}\\n} );\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/IndexedPlaneGeometry5.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Benchmark/IndexedPlaneGeometry5.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\\n */\\n\\nTHREE.IndexedPlaneGeometry5 = function ( width, height, widthSegments, heightSegments ) {\\n\\n\\tthis.width = width;\\n\\tthis.height = height;\\n\\n\\tthis.widthSegments = widthSegments || 1;\\n\\tthis.heightSegments = heightSegments || 1;\\n\\n\\tvar width_half = width / 2;\\n\\tvar height_half = height / 2;\\n\\n\\tvar gridX = this.widthSegments;\\n\\tvar gridY = this.heightSegments;\\n\\n\\tvar gridX1 = gridX + 1;\\n\\tvar gridY1 = gridY + 1;\\n\\n\\tvar segment_width = this.width / gridX;\\n\\tvar segment_height = this.height / gridY;\\n\\n\\tvar indices = gridX * gridY * 6;\\n\\tvar vertices = gridX1 * gridY1;\\n\\n\\tTHREE.IndexedGeometry5.call( this, indices, vertices );\\n\\n\\tvar offset = 0;\\n\\n\\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\tvar y = iy * segment_height - height_half;\\n\\n\\t\\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\tvar x = ix * segment_width - width_half;\\n\\n\\t\\t\\tthis.vertices[ offset ].x = x;\\n\\t\\t\\tthis.vertices[ offset ].y = - y;\\n\\n\\t\\t\\tthis.normals[ offset ].z = 1;\\n\\n\\t\\t\\tthis.uvs[ offset ].x = ix / gridX;\\n\\t\\t\\tthis.uvs[ offset ].y = iy / gridY;\\n\\n\\t\\t\\toffset ++;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tvar offset = 0;\\n\\n\\tfor ( var iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\tfor ( var ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\tvar a = ix + gridX1 * iy;\\n\\t\\t\\tvar b = ix + gridX1 * ( iy + 1 );\\n\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\tthis.indices[ offset     ] = a;\\n\\t\\t\\tthis.indices[ offset + 1 ] = b;\\n\\t\\t\\tthis.indices[ offset + 2 ] = d;\\n\\n\\t\\t\\tthis.indices[ offset + 3 ] = b;\\n\\t\\t\\tthis.indices[ offset + 4 ] = c;\\n\\t\\t\\tthis.indices[ offset + 5 ] = d;\\n\\n\\t\\t\\toffset += 6;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\\n\\nTHREE.IndexedPlaneGeometry5.prototype = Object.create( THREE.IndexedGeometry5.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/CircleTypedGeometry.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/CircleTypedGeometry.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author hughes\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.CircleTypedGeometry = function ( radius, segments, thetaStart, thetaLength ) {\\n\\n\\tthis.parameters = {\\n\\t\\tradius: radius,\\n\\t\\tsegments: segments,\\n\\t\\tthetaStart: thetaStart,\\n\\t\\tthetaLength: thetaLength\\n\\t};\\n\\n\\tradius = radius || 50;\\n\\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\\n\\n\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\n\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\n\\n\\t//\\n\\n\\tvar elements = segments + 2;\\n\\n\\tvar indices = new Uint16Array( segments * 3 );\\n\\tvar vertices = new Float32Array( elements * 3 );\\n\\tvar normals = new Float32Array( elements * 3 );\\n\\tvar uvs = new Float32Array( elements * 2 );\\n\\n\\t// center\\n\\n\\tnormals[ 2 ] = 1;\\n\\n\\tuvs[ 0 ] = 0.5;\\n\\tuvs[ 1 ] = 0.5;\\n\\n\\tvar offset = 0, offset2 = 2, offset3 = 3;\\n\\n\\tfor ( var i = 0; i <= segments; i ++ ) {\\n\\n\\t\\tvar segment = thetaStart + i / segments * thetaLength;\\n\\n\\t\\tvar x = radius * Math.cos( segment );\\n\\t\\tvar y = radius * Math.sin( segment );\\n\\n\\t\\tvertices[ offset3     ] = x;\\n\\t\\tvertices[ offset3 + 1 ] = y;\\n\\n\\t\\tnormals[ offset3 + 2 ] = 1;\\n\\n\\t\\tuvs[ offset2     ] = ( x / radius + 1 ) / 2;\\n\\t\\tuvs[ offset2 + 1 ] = ( y / radius + 1 ) / 2;\\n\\n\\t\\toffset2 += 2;\\n\\t\\toffset3 += 3;\\n\\n\\t\\t//\\n\\n\\t\\tindices[ offset     ] = 0;\\n\\t\\tindices[ offset + 1 ] = i + 1;\\n\\t\\tindices[ offset + 2 ] = i + 2;\\n\\n\\t\\toffset  += 3;\\n\\n\\t}\\n\\n\\tTHREE.IndexedTypedGeometry.call( this );\\n\\n\\tthis.setArrays( indices, vertices, normals, uvs );\\n\\n\\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\\n\\n};\\n\\nTHREE.CircleTypedGeometry.prototype = Object.create( THREE.IndexedTypedGeometry.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/ProxyVector2.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/ProxyVector2.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author jbaicoianu / http://baicoianu.com/\\n */\\n\\nTHREE.ProxyVector2 = function ( array, offset ) {\\n\\t\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\n};\\n\\nTHREE.ProxyVector2.prototype = Object.create( THREE.Vector2.prototype );\\n\\nObject.defineProperties( THREE.ProxyVector2.prototype, {\\n\\t'x': {\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'y': {\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t}\\n} );\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/ProxyFace3.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/ProxyFace3.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author jbaicoianu / http://baicoianu.com/\\n */\\n\\nTHREE.ProxyFace3 = function ( array, offset, vertexNormals, vertexColors, vertexTangents ) {\\n\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\tthis.vertexNormals = vertexNormals || [];\\n\\tthis.vertexColors = vertexColors || [];\\n\\tthis.vertexTangents = vertexTangents || [];\\n\\n\\tthis.normal = new THREE.MultiVector3( this.vertexNormals );\\n\\tthis.color = new THREE.MultiColor( this.vertexColors );\\n\\n\\t//THREE.Face3.call( this, array[offset], array[offset+1], array[offset+2] /*, normal, color, materialIndex */);\\n\\n}\\n\\nTHREE.ProxyFace3.prototype = Object.create( THREE.Face3.prototype );\\n\\nObject.defineProperties( THREE.ProxyFace3.prototype, {\\n\\t'a': {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'b': {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t},\\n\\t'c': {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function () { return this.array[ this.offset + 2 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 2 ] = v; }\\n\\t},\\n} );\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/MultiColor.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/MultiColor.js\",\n            \"module-type\": \"library\",\n            \"text\": \"// Allows updating of multiple THREE.Color objects with the same value\\n// Used for face.color -> face.vertexColor[] compatibility layer for non-indexed geometry\\n\\nTHREE.MultiColor = function(links) {\\n\\n\\tthis.links = links;\\n\\n}\\n\\nTHREE.MultiColor.prototype = Object.create( THREE.Color.prototype );\\n\\nTHREE.MultiColor.prototype.setAll = function(axis, value) {\\n\\n\\tfor (var i = 0, l = this.links.length; i < l; i++) {\\n\\n\\t\\tthis.links[i][axis] = value;\\n\\n\\t}\\n\\n}\\n\\n// Getters return value from the first linked color\\n// Setters set the same value for all linked colors\\nObject.defineProperties( THREE.MultiColor.prototype, {\\n\\t'r': {\\n\\t\\tget: function () { return (this.links[0] ? this.links[0].r : 0); },\\n\\t\\tset: function ( v ) { this.setAll('r', v); }\\n\\t},\\n\\t'g': {\\n\\t\\tget: function () { return (this.links[0] ? this.links[0].g : 0); },\\n\\t\\tset: function ( v ) { this.setAll('g', v); }\\n\\t},\\n\\t'b': {\\n\\t\\tget: function () { return (this.links[0] ? this.links[0].b : 0); },\\n\\t\\tset: function ( v ) { this.setAll('b', v); }\\n\\t}\\n} );\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/ProxyColor.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/ProxyColor.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author jbaicoianu / http://baicoianu.com/\\n */\\n\\nTHREE.ProxyColor = function ( array, offset ) {\\n\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\n}\\n\\nTHREE.ProxyColor.prototype = Object.create( THREE.Color.prototype );\\n\\nObject.defineProperties( THREE.ProxyColor.prototype, {\\n\\t'r': {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'g': {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t},\\n\\t'b': {\\n\\t\\tenumerable: true,\\t\\n\\t\\tget: function () { return this.array[ this.offset + 2 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 2 ] = v; }\\n\\t}\\n} );\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/MultiVector3.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/MultiVector3.js\",\n            \"module-type\": \"library\",\n            \"text\": \"// Allows updating of multiple THREE.Vector3 objects with the same value\\n// Used for face.normal -> face.vertexNormal[] compatibility layer for FlatShading\\n\\nTHREE.MultiVector3 = function(links) {\\n\\n\\tthis.links = links;\\n\\n}\\n\\nTHREE.MultiVector3.prototype = Object.create( THREE.Vector3.prototype );\\n\\nTHREE.MultiVector3.prototype.setAll = function(axis, value) {\\n\\n\\tfor (var i = 0, l = this.links.length; i < l; i++) {\\n\\n\\t\\tthis.links[i][axis] = value;\\n\\n\\t}\\n\\n}\\n\\n// Getters return value from the first linked vector\\n// Setters set the same value for all linked vectors\\nObject.defineProperties( THREE.MultiVector3.prototype, {\\n\\t'x': {\\n\\t\\tget: function () { return (this.links[0] ? this.links[0].x : 0); },\\n\\t\\tset: function ( v ) { this.setAll('x', v); }\\n\\t},\\n\\t'y': {\\n\\t\\tget: function () { return (this.links[0] ? this.links[0].y : 0); },\\n\\t\\tset: function ( v ) { this.setAll('y', v); }\\n\\t},\\n\\t'z': {\\n\\t\\tget: function () { return (this.links[0] ? this.links[0].z : 0); },\\n\\t\\tset: function ( v ) { this.setAll('z', v); }\\n\\t}\\n} );\\n\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/ProxyVector3.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/ProxyVector3.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author jbaicoianu / http://baicoianu.com/\\n */\\n\\nTHREE.ProxyVector3 = function ( array, offset ) {\\n\\t\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\n};\\n\\nTHREE.ProxyVector3.prototype = Object.create( THREE.Vector3.prototype );\\n\\nObject.defineProperties( THREE.ProxyVector3.prototype, {\\n\\t'x': {\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'y': {\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t},\\n\\t'z': {\\n\\t\\tget: function () { return this.array[ this.offset + 2 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 2 ] = v; }\\n\\t}\\n} );\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/ProxyVector4.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/Proxies/ProxyVector4.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author jbaicoianu / http://baicoianu.com/\\n */\\n\\nTHREE.ProxyVector4 = function ( array, offset ) {\\n\\t\\n\\tthis.array = array;\\n\\tthis.offset = offset;\\n\\n};\\n\\nTHREE.ProxyVector4.prototype = Object.create( THREE.Vector4.prototype );\\n\\nObject.defineProperties( THREE.ProxyVector4.prototype, {\\n\\t'x': {\\n\\t\\tget: function () { return this.array[ this.offset ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset ] = v; }\\n\\t},\\n\\t'y': {\\n\\t\\tget: function () { return this.array[ this.offset + 1 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 1 ] = v; }\\n\\t},\\n\\t'z': {\\n\\t\\tget: function () { return this.array[ this.offset + 2 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 2 ] = v; }\\n\\t},\\n\\t'w': {\\n\\t\\tget: function () { return this.array[ this.offset + 3 ]; },\\n\\t\\tset: function ( v ) { this.array[ this.offset + 3 ] = v; }\\n\\t}\\n} );\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Wip/GeometryEditor.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Wip/GeometryEditor.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.GeometryEditor = function ( geometry ) {\\n\\n\\tthis.geometry = geometry;\\n\\n};\\n\\nObject.defineProperties( THREE.GeometryEditor.prototype, {\\n\\tvertices: { \\n\\t\\tenumerable: true,\\n\\t\\tget: function() { return this.createVertexProxies(); }\\n\\t},\\n\\tnormals: {\\n\\t\\tenumerable: true,\\n\\t\\tget: function() { return this.createNormalProxies(); } \\n\\t},\\n\\tuvs: {\\n\\t\\tenumerable: true,\\n\\t\\tget: function() { return this.createUVProxies(); } \\n\\t}\\n} );\\n\\nTHREE.GeometryEditor.prototype.createVertexProxies = function () {\\n\\n\\tObject.defineProperty( this, 'vertices', { value: [], writable: true } );\\n\\n\\tvar attributes = this.geometry.attributes;\\n\\tvar length = attributes.position.array.length / 3;\\n\\n\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\tthis.vertices.push( new THREE.ProxyVector3( attributes.position.array, i * 3 ) );\\n\\n\\t}\\n\\n\\treturn this.vertices;\\n\\n};\\n\\nTHREE.GeometryEditor.prototype.createNormalProxies = function () {\\n\\n\\tObject.defineProperty( this, 'normals', { value: [], writable: true } );\\n\\n\\tvar attributes = this.geometry.attributes;\\n\\tvar length = attributes.position.array.length / 3;\\n\\n\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\tthis.normals.push( new THREE.ProxyVector3( attributes.normal.array, i * 3 ) );\\n\\n\\t}\\n\\n\\treturn this.normals;\\n\\n};\\n\\nTHREE.GeometryEditor.prototype.createUVProxies = function () {\\n\\n\\tObject.defineProperty( this, 'uvs', { value: [], writable: true } );\\n\\n\\tvar attributes = this.geometry.attributes;\\n\\tvar length = attributes.position.array.length / 3;\\n\\n\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\tthis.uvs.push( new THREE.ProxyVector2( attributes.uv.array, i * 2 ) );\\n\\n\\t}\\n\\n\\treturn this.uvs;\\n\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/ShaderGodRays.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/ShaderGodRays.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author huwb / http://huwbowles.com/\\n *\\n * God-rays (crepuscular rays)\\n *\\n * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\\n * Blurs a mask generated from the depth map along radial lines emanating from the light\\n * source. The blur repeatedly applies a blur filter of increasing support but constant\\n * sample count to produce a blur filter with large support.\\n *\\n * My implementation performs 3 passes, similar to the implementation from Sousa. I found\\n * just 6 samples per pass produced acceptible results. The blur is applied three times,\\n * with decreasing filter support. The result is equivalent to a single pass with\\n * 6*6*6 = 216 samples.\\n *\\n * References:\\n *\\n * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt\\n */\\n\\nTHREE.ShaderGodRays = {\\n\\n\\t/**\\n\\t * The god-ray generation shader.\\n\\t *\\n\\t * First pass:\\n\\t *\\n\\t * The input is the depth map. I found that the output from the\\n\\t * THREE.MeshDepthMaterial material was directly suitable without\\n\\t * requiring any treatment whatsoever.\\n\\t *\\n\\t * The depth map is blurred along radial lines towards the \\\"sun\\\". The\\n\\t * output is written to a temporary render target (I used a 1/4 sized\\n\\t * target).\\n\\t *\\n\\t * Pass two & three:\\n\\t *\\n\\t * The results of the previous pass are re-blurred, each time with a\\n\\t * decreased distance between samples.\\n\\t */\\n\\n\\t'godrays_generate': {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\ttInput: {\\n\\t\\t\\t\\ttype: \\\"t\\\",\\n\\t\\t\\t\\tvalue: null\\n\\t\\t\\t},\\n\\n\\t\\t\\tfStepSize: {\\n\\t\\t\\t\\ttype: \\\"f\\\",\\n\\t\\t\\t\\tvalue: 1.0\\n\\t\\t\\t},\\n\\n\\t\\t\\tvSunPositionScreenSpace: {\\n\\t\\t\\t\\ttype: \\\"v2\\\",\\n\\t\\t\\t\\tvalue: new THREE.Vector2( 0.5, 0.5 )\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\\"#define TAPS_PER_PASS 6.0\\\",\\n\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D tInput;\\\",\\n\\n\\t\\t\\t\\\"uniform vec2 vSunPositionScreenSpace;\\\",\\n\\t\\t\\t\\\"uniform float fStepSize;\\\", // filter step size\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t// delta from current pixel to \\\"sun\\\" position\\n\\n\\t\\t\\t\\t\\\"vec2 delta = vSunPositionScreenSpace - vUv;\\\",\\n\\t\\t\\t\\t\\\"float dist = length( delta );\\\",\\n\\n\\t\\t\\t\\t// Step vector (uv space)\\n\\n\\t\\t\\t\\t\\\"vec2 stepv = fStepSize * delta / dist;\\\",\\n\\n\\t\\t\\t\\t// Number of iterations between pixel and sun\\n\\n\\t\\t\\t\\t\\\"float iters = dist/fStepSize;\\\",\\n\\n\\t\\t\\t\\t\\\"vec2 uv = vUv.xy;\\\",\\n\\t\\t\\t\\t\\\"float col = 0.0;\\\",\\n\\n\\t\\t\\t\\t// This breaks ANGLE in Chrome 22\\n\\t\\t\\t\\t//\\t- see http://code.google.com/p/chromium/issues/detail?id=153105\\n\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\\n\\t\\t\\t\\t// so i've just left the loop\\n\\n\\t\\t\\t\\t\\\"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\\\",\\n\\n\\t\\t\\t\\t\\t// Accumulate samples, making sure we dont walk past the light source.\\n\\n\\t\\t\\t\\t\\t// The check for uv.y < 1 would not be necessary with \\\"border\\\" UV wrap\\n\\t\\t\\t\\t\\t// mode, with a black border colour. I don't think this is currently\\n\\t\\t\\t\\t\\t// exposed by three.js. As a result there might be artifacts when the\\n\\t\\t\\t\\t\\t// sun is to the left, right or bottom of screen as these cases are\\n\\t\\t\\t\\t\\t// not specifically handled.\\n\\n\\t\\t\\t\\t\\t\\\"col += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\\\",\\n\\t\\t\\t\\t\\t\\\"uv += stepv;\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\t\\t\\t\\t*/\\n\\n\\t\\t\\t\\t// Unrolling loop manually makes it work in ANGLE\\n\\n\\t\\t\\t\\t\\\"if ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\\\",\\n\\t\\t\\t\\t\\\"uv += stepv;\\\",\\n\\n\\t\\t\\t\\t\\\"if ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\\\",\\n\\t\\t\\t\\t\\\"uv += stepv;\\\",\\n\\n\\t\\t\\t\\t\\\"if ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\\\",\\n\\t\\t\\t\\t\\\"uv += stepv;\\\",\\n\\n\\t\\t\\t\\t\\\"if ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\\\",\\n\\t\\t\\t\\t\\\"uv += stepv;\\\",\\n\\n\\t\\t\\t\\t\\\"if ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\\\",\\n\\t\\t\\t\\t\\\"uv += stepv;\\\",\\n\\n\\t\\t\\t\\t\\\"if ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\\\",\\n\\t\\t\\t\\t\\\"uv += stepv;\\\",\\n\\n\\t\\t\\t\\t// Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\\n\\t\\t\\t\\t// objectionable artifacts, in particular near the sun position. The side\\n\\t\\t\\t\\t// effect is that the result is darker than it should be around the sun, as\\n\\t\\t\\t\\t// TAPS_PER_PASS is greater than the number of samples actually accumulated.\\n\\t\\t\\t\\t// When the result is inverted (in the shader 'godrays_combine', this produces\\n\\t\\t\\t\\t// a slight bright spot at the position of the sun, even when it is occluded.\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( col/TAPS_PER_PASS );\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor.a = 1.0;\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\t/**\\n\\t * Additively applies god rays from texture tGodRays to a background (tColors).\\n\\t * fGodRayIntensity attenuates the god rays.\\n\\t */\\n\\n\\t'godrays_combine': {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\ttColors: {\\n\\t\\t\\t\\ttype: \\\"t\\\",\\n\\t\\t\\t\\tvalue: null\\n\\t\\t\\t},\\n\\n\\t\\t\\ttGodRays: {\\n\\t\\t\\t\\ttype: \\\"t\\\",\\n\\t\\t\\t\\tvalue: null\\n\\t\\t\\t},\\n\\n\\t\\t\\tfGodRayIntensity: {\\n\\t\\t\\t\\ttype: \\\"f\\\",\\n\\t\\t\\t\\tvalue: 0.69\\n\\t\\t\\t},\\n\\n\\t\\t\\tvSunPositionScreenSpace: {\\n\\t\\t\\t\\ttype: \\\"v2\\\",\\n\\t\\t\\t\\tvalue: new THREE.Vector2( 0.5, 0.5 )\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D tColors;\\\",\\n\\t\\t\\t\\\"uniform sampler2D tGodRays;\\\",\\n\\n\\t\\t\\t\\\"uniform vec2 vSunPositionScreenSpace;\\\",\\n\\t\\t\\t\\\"uniform float fGodRayIntensity;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t// Since THREE.MeshDepthMaterial renders foreground objects white and background\\n\\t\\t\\t\\t// objects black, the god-rays will be white streaks. Therefore value is inverted\\n\\t\\t\\t\\t// before being combined with tColors\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor.a = 1.0;\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\n\\t/**\\n\\t * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\\n\\t * cheaper/faster/simpler to implement this as a simple sun sprite.\\n\\t */\\n\\n\\t'godrays_fake_sun': {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\tvSunPositionScreenSpace: {\\n\\t\\t\\t\\ttype: \\\"v2\\\",\\n\\t\\t\\t\\tvalue: new THREE.Vector2( 0.5, 0.5 )\\n\\t\\t\\t},\\n\\n\\t\\t\\tfAspect: {\\n\\t\\t\\t\\ttype: \\\"f\\\",\\n\\t\\t\\t\\tvalue: 1.0\\n\\t\\t\\t},\\n\\n\\t\\t\\tsunColor: {\\n\\t\\t\\t\\ttype: \\\"c\\\",\\n\\t\\t\\t\\tvalue: new THREE.Color( 0xffee00 )\\n\\t\\t\\t},\\n\\n\\t\\t\\tbgColor: {\\n\\t\\t\\t\\ttype: \\\"c\\\",\\n\\t\\t\\t\\tvalue: new THREE.Color( 0x000000 )\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vUv = uv;\\\",\\n\\t\\t\\t\\t\\\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\n\\t\\t\\t\\\"uniform vec2 vSunPositionScreenSpace;\\\",\\n\\t\\t\\t\\\"uniform float fAspect;\\\",\\n\\n\\t\\t\\t\\\"uniform vec3 sunColor;\\\",\\n\\t\\t\\t\\\"uniform vec3 bgColor;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vec2 diff = vUv - vSunPositionScreenSpace;\\\",\\n\\n\\t\\t\\t\\t// Correct for aspect ratio\\n\\n\\t\\t\\t\\t\\\"diff.x *= fAspect;\\\",\\n\\n\\t\\t\\t\\t\\\"float prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\\\",\\n\\t\\t\\t\\t\\\"prop = 0.35 * pow( 1.0 - prop, 3.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor.xyz = mix( sunColor, bgColor, 1.0 - prop );\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor.w = 1.0;\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/CurveExtras.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/CurveExtras.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/*\\n * A bunch of parametric curves\\n * @author zz85\\n *\\n * Formulas collected from various sources\\n *\\thttp://mathworld.wolfram.com/HeartCurve.html\\n *\\thttp://mathdl.maa.org/images/upload_library/23/stemkoski/knots/page6.html\\n *\\thttp://en.wikipedia.org/wiki/Viviani%27s_curve\\n *\\thttp://mathdl.maa.org/images/upload_library/23/stemkoski/knots/page4.html\\n *\\thttp://www.mi.sanu.ac.rs/vismath/taylorapril2011/Taylor.pdf\\n *\\thttp://prideout.net/blog/?p=44\\n */\\n\\n// Lets define some curves\\nTHREE.Curves = {};\\n\\n\\n THREE.Curves.GrannyKnot = THREE.Curve.create( function(){},\\n\\n\\t function(t) {\\n\\t    t = 2 * Math.PI * t;\\n\\n\\t    var x = -0.22 * Math.cos(t) - 1.28 * Math.sin(t) - 0.44 * Math.cos(3 * t) - 0.78 * Math.sin(3 * t);\\n\\t    var y = -0.1 * Math.cos(2 * t) - 0.27 * Math.sin(2 * t) + 0.38 * Math.cos(4 * t) + 0.46 * Math.sin(4 * t);\\n\\t    var z = 0.7 * Math.cos(3 * t) - 0.4 * Math.sin(3 * t);\\n\\t    return new THREE.Vector3(x, y, z).multiplyScalar(20);\\n\\t}\\n);\\n\\nTHREE.Curves.HeartCurve = THREE.Curve.create(\\n\\nfunction(s) {\\n\\n\\tthis.scale = (s === undefined) ? 5 : s;\\n\\n},\\n\\nfunction(t) {\\n\\n\\tt *= 2 * Math.PI;\\n\\n\\tvar tx = 16 * Math.pow(Math.sin(t), 3);\\n\\tvar ty = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t), tz = 0;\\n\\n\\treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);\\n\\n}\\n\\n);\\n\\n\\n\\n// Viviani's Curve\\nTHREE.Curves.VivianiCurve = THREE.Curve.create(\\n\\n\\tfunction(radius) {\\n\\n\\t\\tthis.radius = radius;\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tt = t * 4 * Math.PI; // Normalized to 0..1\\n\\t\\tvar a = this.radius / 2;\\n\\t\\tvar tx = a * (1 + Math.cos(t)),\\n\\t\\t\\tty = a * Math.sin(t),\\n\\t\\t\\ttz = 2 * a * Math.sin(t / 2);\\n\\n\\t\\treturn new THREE.Vector3(tx, ty, tz);\\n\\n\\t}\\n\\n);\\n\\n\\nTHREE.Curves.KnotCurve = THREE.Curve.create(\\n\\n\\tfunction() {\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tt *= 2 * Math.PI;\\n\\n\\t\\tvar R = 10;\\n\\t\\tvar s = 50;\\n\\t\\tvar tx = s * Math.sin(t),\\n\\t\\t\\tty = Math.cos(t) * (R + s * Math.cos(t)),\\n\\t\\t\\ttz = Math.sin(t) * (R + s * Math.cos(t));\\n\\n\\t\\treturn new THREE.Vector3(tx, ty, tz);\\n\\n\\t}\\n\\n);\\n\\nTHREE.Curves.HelixCurve = THREE.Curve.create(\\n\\n\\tfunction() {\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tvar a = 30; // radius\\n\\t\\tvar b = 150; //height\\n\\t\\tvar t2 = 2 * Math.PI * t * b / 30;\\n\\t\\tvar tx = Math.cos(t2) * a,\\n\\t\\t\\tty = Math.sin(t2) * a,\\n\\t\\t\\ttz = b * t;\\n\\n\\t\\treturn new THREE.Vector3(tx, ty, tz);\\n\\n\\t}\\n\\n);\\n\\nTHREE.Curves.TrefoilKnot = THREE.Curve.create(\\n\\n\\tfunction(s) {\\n\\n\\t\\tthis.scale = (s === undefined) ? 10 : s;\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tt *= Math.PI * 2;\\n\\t\\tvar tx = (2 + Math.cos(3 * t)) * Math.cos(2 * t),\\n\\t\\t\\tty = (2 + Math.cos(3 * t)) * Math.sin(2 * t),\\n\\t\\t\\ttz = Math.sin(3 * t);\\n\\n\\t\\treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);\\n\\n\\t}\\n\\n);\\n\\nTHREE.Curves.TorusKnot = THREE.Curve.create(\\n\\n\\tfunction(s) {\\n\\n\\t\\tthis.scale = (s === undefined) ? 10 : s;\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tvar p = 3,\\n\\t\\t\\tq = 4;\\n\\t\\tt *= Math.PI * 2;\\n\\t\\tvar tx = (2 + Math.cos(q * t)) * Math.cos(p * t),\\n\\t\\t\\tty = (2 + Math.cos(q * t)) * Math.sin(p * t),\\n\\t\\t\\ttz = Math.sin(q * t);\\n\\n\\t\\treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);\\n\\n\\t}\\n\\n);\\n\\n\\nTHREE.Curves.CinquefoilKnot = THREE.Curve.create(\\n\\n\\tfunction(s) {\\n\\n\\t\\tthis.scale = (s === undefined) ? 10 : s;\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tvar p = 2,\\n\\t\\t\\tq = 5;\\n\\t\\tt *= Math.PI * 2;\\n\\t\\tvar tx = (2 + Math.cos(q * t)) * Math.cos(p * t),\\n\\t\\t\\tty = (2 + Math.cos(q * t)) * Math.sin(p * t),\\n\\t\\t\\ttz = Math.sin(q * t);\\n\\n\\t\\treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);\\n\\n\\t}\\n\\n);\\n\\n\\nTHREE.Curves.TrefoilPolynomialKnot = THREE.Curve.create(\\n\\n\\tfunction(s) {\\n\\n\\t\\tthis.scale = (s === undefined) ? 10 : s;\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tt = t * 4 - 2;\\n\\t\\tvar tx = Math.pow(t, 3) - 3 * t,\\n\\t\\t\\tty = Math.pow(t, 4) - 4 * t * t,\\n\\t\\t\\ttz = 1 / 5 * Math.pow(t, 5) - 2 * t;\\n\\n\\t\\treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);\\n\\n\\t}\\n\\n);\\n\\n// var scaleTo = function(x, y) {\\n//   var r = y - x;\\n//   return function(t) {\\n//     t * r + x;\\n//   };\\n// }\\nvar scaleTo = function(x, y, t) {\\n\\n\\t\\tvar r = y - x;\\n\\t\\treturn t * r + x;\\n\\n\\t}\\n\\nTHREE.Curves.FigureEightPolynomialKnot = THREE.Curve.create(\\n\\n\\tfunction(s) {\\n\\n\\t\\tthis.scale = (s === undefined) ? 1 : s;\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tt = scaleTo(-4, 4, t);\\n\\t\\tvar tx = 2 / 5 * t * (t * t - 7) * (t * t - 10),\\n\\t\\t\\tty = Math.pow(t, 4) - 13 * t * t,\\n\\t\\t\\ttz = 1 / 10 * t * (t * t - 4) * (t * t - 9) * (t * t - 12);\\n\\n\\t\\treturn new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);\\n\\n\\t}\\n\\n);\\n\\nTHREE.Curves.DecoratedTorusKnot4a = THREE.Curve.create(\\n\\n\\tfunction(s) {\\n\\n\\t\\tthis.scale = (s === undefined) ? 40 : s;\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tt *= Math.PI * 2;\\n\\t\\tvar\\n\\t\\tx = Math.cos(2 * t) * (1 + 0.6 * (Math.cos(5 * t) + 0.75 * Math.cos(10 * t))),\\n\\t\\t\\ty = Math.sin(2 * t) * (1 + 0.6 * (Math.cos(5 * t) + 0.75 * Math.cos(10 * t))),\\n\\t\\t\\tz = 0.35 * Math.sin(5 * t);\\n\\n\\t\\treturn new THREE.Vector3(x, y, z).multiplyScalar(this.scale);\\n\\n\\t}\\n\\n);\\n\\n\\nTHREE.Curves.DecoratedTorusKnot4b = THREE.Curve.create(\\n\\n\\tfunction(s) {\\n\\n\\t\\tthis.scale = (s === undefined) ? 40 : s;\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\t\\tvar fi = t * Math.PI * 2;\\n\\t\\tvar x = Math.cos(2 * fi) * (1 + 0.45 * Math.cos(3 * fi) + 0.4 * Math.cos(9 * fi)),\\n\\t\\t\\ty = Math.sin(2 * fi) * (1 + 0.45 * Math.cos(3 * fi) + 0.4 * Math.cos(9 * fi)),\\n\\t\\t\\tz = 0.2 * Math.sin(9 * fi);\\n\\n\\t\\treturn new THREE.Vector3(x, y, z).multiplyScalar(this.scale);\\n\\n\\t}\\n\\n);\\n\\n\\nTHREE.Curves.DecoratedTorusKnot5a = THREE.Curve.create(\\n\\n\\tfunction(s) {\\n\\n\\t\\tthis.scale = (s === undefined) ? 40 : s;\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tvar fi = t * Math.PI * 2;\\n\\t\\tvar x = Math.cos(3 * fi) * (1 + 0.3 * Math.cos(5 * fi) + 0.5 * Math.cos(10 * fi)),\\n\\t\\t\\ty = Math.sin(3 * fi) * (1 + 0.3 * Math.cos(5 * fi) + 0.5 * Math.cos(10 * fi)),\\n\\t\\t\\tz = 0.2 * Math.sin(20 * fi);\\n\\n\\t\\treturn new THREE.Vector3(x, y, z).multiplyScalar(this.scale);\\n\\n\\t}\\n\\n);\\n\\nTHREE.Curves.DecoratedTorusKnot5c = THREE.Curve.create(\\n\\n\\tfunction(s) {\\n\\n\\t\\tthis.scale = (s === undefined) ? 40 : s;\\n\\n\\t},\\n\\n\\tfunction(t) {\\n\\n\\t\\tvar fi = t * Math.PI * 2;\\n\\t\\tvar x = Math.cos(4 * fi) * (1 + 0.5 * (Math.cos(5 * fi) + 0.4 * Math.cos(20 * fi))),\\n\\t\\t\\ty = Math.sin(4 * fi) * (1 + 0.5 * (Math.cos(5 * fi) + 0.4 * Math.cos(20 * fi))),\\n\\t\\t\\tz = 0.35 * Math.sin(15 * fi);\\n\\n\\t\\treturn new THREE.Vector3(x, y, z).multiplyScalar(this.scale);\\n\\n\\t}\\n\\n);\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/UCSCharacter.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/UCSCharacter.js\",\n            \"module-type\": \"library\",\n            \"text\": \"THREE.UCSCharacter = function() {\\n\\n\\tvar scope = this;\\n\\t\\n\\tvar mesh;\\n\\n\\tthis.scale = 1;\\n\\n\\tthis.root = new THREE.Object3D();\\n\\t\\n\\tthis.numSkins;\\n\\tthis.numMorphs;\\n\\t\\n\\tthis.skins = [];\\n\\tthis.materials = [];\\n\\tthis.morphs = [];\\n\\n\\tthis.onLoadComplete = function () {};\\n\\t\\n\\tthis.loadCounter = 0;\\n\\n\\tthis.loadParts = function ( config ) {\\n\\t\\t\\n\\t\\tthis.numSkins = config.skins.length;\\n\\t\\tthis.numMorphs = config.morphs.length;\\n\\t\\t\\n\\t\\t// Character geometry + number of skins\\n\\t\\tthis.loadCounter = 1 + config.skins.length;\\n\\t\\t\\n\\t\\t// SKINS\\n\\t\\tthis.skins = loadTextures( config.baseUrl + \\\"skins/\\\", config.skins );\\n\\t\\tthis.materials = createMaterials( this.skins );\\n\\t\\t\\n\\t\\t// MORPHS\\n\\t\\tthis.morphs = config.morphs;\\n\\t\\t\\n\\t\\t// CHARACTER\\n\\t\\tvar loader = new THREE.JSONLoader();\\n\\t\\tconsole.log( config.baseUrl + config.character );\\n\\t\\tloader.load( config.baseUrl + config.character, function( geometry ) {\\n\\t\\t\\tgeometry.computeBoundingBox();\\n\\t\\t\\tgeometry.computeVertexNormals();\\n\\n\\t\\t\\t//THREE.AnimationHandler.add( geometry.animation );\\n\\n\\t\\t\\tmesh = new THREE.SkinnedMesh( geometry, new THREE.MeshFaceMaterial() );\\n\\t\\t\\tscope.root.add( mesh );\\n\\t\\t\\t\\n\\t\\t\\tvar bb = geometry.boundingBox;\\n\\t\\t\\tscope.root.scale.set( config.s, config.s, config.s );\\n\\t\\t\\tscope.root.position.set( config.x, config.y - bb.min.y * config.s, config.z );\\n\\n\\t\\t\\tmesh.castShadow = true;\\n\\t\\t\\tmesh.receiveShadow = true;\\n\\n\\t\\t\\tanimation = new THREE.Animation( mesh, geometry.animation );\\n\\t\\t\\tanimation.play();\\n\\t\\t\\t\\n\\t\\t\\tscope.setSkin(0);\\n\\t\\t\\t\\n\\t\\t\\tscope.checkLoadComplete();\\n\\t\\t} );\\n\\n\\t};\\n\\t\\n\\tthis.setSkin = function( index ) {\\n\\t\\tif ( mesh && scope.materials ) {\\n\\t\\t\\tmesh.material = scope.materials[ index ];\\n\\t\\t}\\n\\t};\\n\\t\\n\\tthis.updateMorphs = function( influences ) {\\n\\t\\tif ( mesh ) {\\n\\t\\t\\tfor ( var i = 0; i < scope.numMorphs; i ++ ) {\\n\\t\\t\\t\\tmesh.morphTargetInfluences[ i ] = influences[ scope.morphs[ i ] ] / 100;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction loadTextures( baseUrl, textureUrls ) {\\n\\t\\tvar mapping = new THREE.UVMapping();\\n\\t\\tvar textures = [];\\n\\n\\t\\tfor ( var i = 0; i < textureUrls.length; i ++ ) {\\n\\n\\t\\t\\ttextures[ i ] = THREE.ImageUtils.loadTexture( baseUrl + textureUrls[ i ], mapping, scope.checkLoadComplete );\\n\\t\\t\\ttextures[ i ].name = textureUrls[ i ];\\n\\n\\t\\t}\\n\\n\\t\\treturn textures;\\n\\t};\\n\\n\\tfunction createMaterials( skins ) {\\n\\t\\tvar materials = [];\\n\\t\\t\\n\\t\\tfor ( var i = 0; i < skins.length; i ++ ) {\\n\\n\\t\\t\\tmaterials[ i ] = new THREE.MeshLambertMaterial( {\\n\\t\\t\\t\\tcolor: 0xeeeeee,\\n\\t\\t\\t\\tspecular: 10.0,\\n\\t\\t\\t\\tmap: skins[ i ],\\n\\t\\t\\t\\tskinning: true,\\n\\t\\t\\t\\tmorphTargets: true,\\n\\t\\t\\t\\twrapAround: true\\n\\t\\t\\t} );\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn materials;\\n\\t}\\n\\n\\tthis.checkLoadComplete = function () {\\n\\n\\t\\tscope.loadCounter -= 1;\\n\\n\\t\\tif ( scope.loadCounter === 0 ) {\\n\\n\\t\\t\\tscope.onLoadComplete();\\n\\n\\t\\t}\\n\\n\\t}\\n\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/ShaderDeferred.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/ShaderDeferred.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n * @author MPanknin / http://www.redplant.de/\\n * @author benaadams / http://blog.illyriad.co.uk/\\n *\\n */\\n\\n\\nTHREE.DeferredShaderChunk = {\\n\\n\\t// decode float to vec3\\n\\n\\tunpackFloat: [\\n\\n\\t\\t\\\"vec3 float_to_vec3( float data ) {\\\",\\n\\n\\t\\t\\t\\\"vec3 uncompressed;\\\",\\n\\t\\t\\t\\\"uncompressed.x = fract( data );\\\",\\n\\t\\t\\t\\\"float zInt = floor( data / 255.0 );\\\",\\n\\t\\t\\t\\\"uncompressed.z = fract( zInt / 255.0 );\\\",\\n\\t\\t\\t\\\"uncompressed.y = fract( floor( data - ( zInt * 255.0 ) ) / 255.0 );\\\",\\n\\t\\t\\t\\\"return uncompressed;\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tcomputeVertexPositionVS: [\\n\\n\\t\\t\\\"vec2 texCoord = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\\\",\\n\\n\\t\\t\\\"vec4 normalDepth = texture2D( samplerNormalDepth, texCoord );\\\",\\n\\t\\t\\\"float z = normalDepth.w;\\\",\\n\\n\\t\\t\\\"if ( z == 0.0 ) discard;\\\",\\n\\n\\t\\t\\\"vec2 xy = texCoord * 2.0 - 1.0;\\\",\\n\\n\\t\\t\\\"vec4 vertexPositionProjected = vec4( xy, z, 1.0 );\\\",\\n\\t\\t\\\"vec4 vertexPositionVS = matProjInverse * vertexPositionProjected;\\\",\\n\\t\\t\\\"vertexPositionVS.xyz /= vertexPositionVS.w;\\\",\\n\\t\\t\\\"vertexPositionVS.w = 1.0;\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tcomputeNormal: [\\n\\n\\t\\t\\\"vec3 normal = normalDepth.xyz * 2.0 - 1.0;\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tunpackColorMap: [\\n\\n\\t\\t\\\"vec4 colorMap = texture2D( samplerColor, texCoord );\\\",\\n\\n\\t\\t\\\"vec3 albedo = float_to_vec3( abs( colorMap.x ) );\\\",\\n\\t\\t\\\"vec3 specularColor = float_to_vec3( abs( colorMap.y ) );\\\",\\n\\t\\t\\\"float shininess = abs( colorMap.z );\\\",\\n\\t\\t\\\"float wrapAround = sign( colorMap.z );\\\",\\n\\t\\t\\\"float additiveSpecular = sign( colorMap.y );\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tcomputeDiffuse: [\\n\\n\\t\\t\\\"float dotProduct = dot( normal, lightVector );\\\",\\n\\t\\t\\\"float diffuseFull = max( dotProduct, 0.0 );\\\",\\n\\n\\t\\t\\\"vec3 diffuse;\\\",\\n\\n\\t\\t\\\"if ( wrapAround < 0.0 ) {\\\",\\n\\n\\t\\t\\t// wrap around lighting\\n\\n\\t\\t\\t\\\"float diffuseHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\\",\\n\\n\\t\\t\\t\\\"const vec3 wrapRGB = vec3( 1.0, 1.0, 1.0 );\\\",\\n\\t\\t\\t\\\"diffuse = mix( vec3( diffuseFull ), vec3( diffuseHalf ), wrapRGB );\\\",\\n\\n\\t\\t\\\"} else {\\\",\\n\\n\\t\\t\\t// simple lighting\\n\\n\\t\\t\\t\\\"diffuse = vec3( diffuseFull );\\\",\\n\\n\\t\\t\\\"}\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tcomputeSpecular: [\\n\\n\\t\\t\\\"vec3 halfVector = normalize( lightVector - normalize( vertexPositionVS.xyz ) );\\\",\\n\\t\\t\\\"float dotNormalHalf = max( dot( normal, halfVector ), 0.0 );\\\",\\n\\n\\t\\t// simple specular\\n\\n\\t\\t//\\\"vec3 specular = specularColor * max( pow( dotNormalHalf, shininess ), 0.0 ) * diffuse;\\\",\\n\\n\\t\\t// physically based specular\\n\\n\\t\\t\\\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\\\",\\n\\n\\t\\t\\\"vec3 schlick = specularColor + vec3( 1.0 - specularColor ) * pow( 1.0 - dot( lightVector, halfVector ), 5.0 );\\\",\\n\\t\\t\\\"vec3 specular = schlick * max( pow( dotNormalHalf, shininess ), 0.0 ) * diffuse * specularNormalization;\\\"\\n\\n\\t].join(\\\"\\\\n\\\"),\\n\\n\\tcombine: [\\n\\n\\t\\t\\\"vec3 light = lightIntensity * lightColor;\\\",\\n\\t\\t\\\"gl_FragColor = vec4( light * ( albedo * diffuse + specular ), attenuation );\\\"\\n\\n\\t].join(\\\"\\\\n\\\")\\n\\n};\\n\\nTHREE.ShaderDeferred = {\\n\\n\\t\\\"color\\\" : {\\n\\n\\t\\tuniforms: THREE.UniformsUtils.merge( [\\n\\n\\t\\t\\tTHREE.UniformsLib[ \\\"common\\\" ],\\n\\t\\t\\tTHREE.UniformsLib[ \\\"fog\\\" ],\\n\\t\\t\\tTHREE.UniformsLib[ \\\"shadowmap\\\" ],\\n\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\\"emissive\\\" :  { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\t\\t\\\"specular\\\" :  { type: \\\"c\\\", value: new THREE.Color( 0x111111 ) },\\n\\t\\t\\t\\t\\\"shininess\\\":  { type: \\\"f\\\", value: 30 },\\n\\t\\t\\t\\t\\\"wrapAround\\\": \\t\\t{ type: \\\"f\\\", value: 1 },\\n\\t\\t\\t\\t\\\"additiveSpecular\\\": { type: \\\"f\\\", value: 1 },\\n\\n\\t\\t\\t\\t\\\"samplerNormalDepth\\\": { type: \\\"t\\\", value: null },\\n\\t\\t\\t\\t\\\"viewWidth\\\": \\t\\t{ type: \\\"f\\\", value: 800 },\\n\\t\\t\\t\\t\\\"viewHeight\\\": \\t\\t{ type: \\\"f\\\", value: 600 }\\n\\t\\t\\t}\\n\\n\\t\\t] ),\\n\\n\\t\\tfragmentShader : [\\n\\n\\t\\t\\t\\\"uniform vec3 diffuse;\\\",\\n\\t\\t\\t\\\"uniform vec3 specular;\\\",\\n\\t\\t\\t\\\"uniform vec3 emissive;\\\",\\n\\t\\t\\t\\\"uniform float shininess;\\\",\\n\\t\\t\\t\\\"uniform float wrapAround;\\\",\\n\\t\\t\\t\\\"uniform float additiveSpecular;\\\",\\n\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"color_pars_fragment\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"map_pars_fragment\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"lightmap_pars_fragment\\\" ],\\n\\n\\t\\t\\t\\\"#ifdef USE_ENVMAP\\\",\\n\\n\\t\\t\\t\\t\\\"varying vec3 vWorldPosition;\\\",\\n\\n\\t\\t\\t\\t\\\"uniform float reflectivity;\\\",\\n\\t\\t\\t\\t\\\"uniform samplerCube envMap;\\\",\\n\\t\\t\\t\\t\\\"uniform float flipEnvMap;\\\",\\n\\t\\t\\t\\t\\\"uniform int combine;\\\",\\n\\n\\t\\t\\t\\t\\\"uniform bool useRefract;\\\",\\n\\t\\t\\t\\t\\\"uniform float refractionRatio;\\\",\\n\\n\\t\\t\\t\\t\\\"uniform sampler2D samplerNormalDepth;\\\",\\n\\t\\t\\t\\t\\\"uniform float viewHeight;\\\",\\n\\t\\t\\t\\t\\\"uniform float viewWidth;\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"fog_pars_fragment\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_pars_fragment\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"specularmap_pars_fragment\\\" ],\\n\\n\\t\\t\\t\\\"const float unit = 255.0/256.0;\\\",\\n\\n\\t\\t\\t\\\"float vec3_to_float( vec3 data ) {\\\",\\n\\n\\t\\t\\t\\t\\\"highp float compressed = fract( data.x * unit ) + floor( data.y * unit * 255.0 ) + floor( data.z * unit * 255.0 ) * 255.0;\\\",\\n\\t\\t\\t\\t\\\"return compressed;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"const float opacity = 1.0;\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( diffuse, opacity );\\\",\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"map_fragment\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"alphatest_fragment\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"specularmap_fragment\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"lightmap_fragment\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"color_fragment\\\" ],\\n\\n\\t\\t\\t\\t\\\"#ifdef USE_ENVMAP\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec2 texCoord = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\\\",\\n\\t\\t\\t\\t\\t\\\"vec4 normalDepth = texture2D( samplerNormalDepth, texCoord );\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 normal = normalDepth.xyz * 2.0 - 1.0;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 reflectVec;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"if ( useRefract ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"reflectVec = refract( cameraToVertex, normal, refractionRatio );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"} else { \\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"reflectVec = reflect( cameraToVertex, normal );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#ifdef DOUBLE_SIDED\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#else\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#ifdef GAMMA_INPUT\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"cubeColor.xyz *= cubeColor.xyz;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\t\\\"if ( combine == 1 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"} else if ( combine == 2 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"} else {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_fragment\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"fog_fragment\\\" ],\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\t\\\"const float compressionScale = 0.999;\\\",\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\t\\\"vec3 diffuseMapColor;\\\",\\n\\n\\t\\t\\t\\t\\\"#ifdef USE_MAP\\\",\\n\\n\\t\\t\\t\\t\\t\\\"diffuseMapColor = texelColor.xyz;\\\",\\n\\n\\t\\t\\t\\t\\\"#else\\\",\\n\\n\\t\\t\\t\\t\\t\\\"diffuseMapColor = vec3( 1.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t// diffuse color\\n\\n\\t\\t\\t\\t\\\"gl_FragColor.x = vec3_to_float( compressionScale * gl_FragColor.xyz );\\\",\\n\\n\\t\\t\\t\\t// specular color\\n\\n\\t\\t\\t\\t\\\"if ( additiveSpecular < 0.0 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor.y = vec3_to_float( compressionScale * specular );\\\",\\n\\n\\t\\t\\t\\t\\\"} else {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor.y = vec3_to_float( compressionScale * specular * diffuseMapColor );\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor.y *= additiveSpecular;\\\",\\n\\n\\t\\t\\t\\t// shininess\\n\\n\\t\\t\\t\\t\\\"gl_FragColor.z = wrapAround * shininess;\\\",\\n\\n\\t\\t\\t\\t// emissive color\\n\\n\\t\\t\\t\\t\\\"#ifdef USE_COLOR\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor.w = vec3_to_float( compressionScale * emissive * diffuseMapColor * vColor );\\\",\\n\\n\\t\\t\\t\\t\\\"#else\\\",\\n\\n\\t\\t\\t\\t\\t\\\"gl_FragColor.w = vec3_to_float( compressionScale * emissive * diffuseMapColor );\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader : [\\n\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"map_pars_vertex\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"lightmap_pars_vertex\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"color_pars_vertex\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"morphtarget_pars_vertex\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"skinning_pars_vertex\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_pars_vertex\\\" ],\\n\\n\\t\\t\\t\\\"#ifdef USE_ENVMAP\\\",\\n\\n\\t\\t\\t\\t\\\"varying vec3 vWorldPosition;\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"map_vertex\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"lightmap_vertex\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"color_vertex\\\" ],\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"skinbase_vertex\\\" ],\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"morphtarget_vertex\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"skinning_vertex\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"default_vertex\\\" ],\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"worldpos_vertex\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"shadowmap_vertex\\\" ],\\n\\n\\t\\t\\t\\t\\\"#ifdef USE_ENVMAP\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vWorldPosition = worldPosition.xyz;\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\t\\\"normalDepth\\\" : {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\tbumpMap: \\t  { type: \\\"t\\\", value: null },\\n\\t\\t\\tbumpScale:\\t  { type: \\\"f\\\", value: 1 },\\n\\t\\t\\toffsetRepeat: { type: \\\"v4\\\", value: new THREE.Vector4( 0, 0, 1, 1 ) }\\n\\n\\t\\t},\\n\\n\\t\\tfragmentShader : [\\n\\n\\t\\t\\t\\\"#ifdef USE_BUMPMAP\\\",\\n\\n\\t\\t\\t\\t\\\"#extension GL_OES_standard_derivatives : enable\\\\n\\\",\\n\\n\\t\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\t\\t\\t\\t\\\"varying vec3 vViewPosition;\\\",\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"bumpmap_pars_fragment\\\" ],\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"varying vec3 normalView;\\\",\\n\\t\\t\\t\\\"varying vec4 clipPos;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 normal = normalize( normalView );\\\",\\n\\n\\t\\t\\t\\t\\\"#ifdef USE_BUMPMAP\\\",\\n\\n\\t\\t\\t\\t\\t\\\"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor.xyz = normal * 0.5 + 0.5;\\\",\\n\\t\\t\\t\\t\\\"gl_FragColor.w = clipPos.z / clipPos.w;\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader : [\\n\\n\\t\\t\\t\\\"varying vec3 normalView;\\\",\\n\\t\\t\\t\\\"varying vec4 clipPos;\\\",\\n\\n\\t\\t\\t\\\"#ifdef USE_BUMPMAP\\\",\\n\\n\\t\\t\\t\\t\\\"varying vec2 vUv;\\\",\\n\\t\\t\\t\\t\\\"varying vec3 vViewPosition;\\\",\\n\\n\\t\\t\\t\\t\\\"uniform vec4 offsetRepeat;\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"morphtarget_pars_vertex\\\" ],\\n\\t\\t\\tTHREE.ShaderChunk[ \\\"skinning_pars_vertex\\\" ],\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"morphnormal_vertex\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"skinbase_vertex\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"skinnormal_vertex\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"defaultnormal_vertex\\\" ],\\n\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"morphtarget_vertex\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"skinning_vertex\\\" ],\\n\\t\\t\\t\\tTHREE.ShaderChunk[ \\\"default_vertex\\\" ],\\n\\n\\t\\t\\t\\t\\\"normalView = normalize( normalMatrix * objectNormal );\\\",\\n\\n\\t\\t\\t\\t\\\"#ifdef USE_BUMPMAP\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\\",\\n\\t\\t\\t\\t\\t\\\"vViewPosition = -mvPosition.xyz;\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"clipPos = gl_Position;\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\t\\\"composite\\\" : {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\tsamplerLight: \\t{ type: \\\"t\\\", value: null },\\n\\t\\t\\tbrightness:\\t\\t{ type: \\\"f\\\", value: 1 }\\n\\n\\t\\t},\\n\\n\\t\\tfragmentShader : [\\n\\n\\t\\t\\t\\\"varying vec2 texCoord;\\\",\\n\\t\\t\\t\\\"uniform sampler2D samplerLight;\\\",\\n\\t\\t\\t\\\"uniform float brightness;\\\",\\n\\n\\t\\t\\t// tonemapping operators\\n\\t\\t\\t// based on John Hable's HLSL snippets\\n\\t\\t\\t// from http://filmicgames.com/archives/75\\n\\n\\t\\t\\t\\\"#ifdef TONEMAP_UNCHARTED\\\",\\n\\n\\t\\t\\t\\t\\\"const float A = 0.15;\\\",\\n\\t\\t\\t\\t\\\"const float B = 0.50;\\\",\\n\\t\\t\\t\\t\\\"const float C = 0.10;\\\",\\n\\t\\t\\t\\t\\\"const float D = 0.20;\\\",\\n\\t\\t\\t\\t\\\"const float E = 0.02;\\\",\\n\\t\\t\\t\\t\\\"const float F = 0.30;\\\",\\n\\t\\t\\t\\t\\\"const float W = 11.2;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 Uncharted2Tonemap( vec3 x ) {\\\",\\n\\n\\t\\t\\t\\t   \\\"return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 inColor = texture2D( samplerLight, texCoord ).xyz;\\\",\\n\\t\\t\\t\\t\\\"inColor *= brightness;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 outColor;\\\",\\n\\n\\t\\t\\t\\t\\\"#if defined( TONEMAP_SIMPLE )\\\",\\n\\n\\t\\t\\t\\t\\t\\\"outColor = sqrt( inColor );\\\",\\n\\n\\t\\t\\t\\t\\\"#elif defined( TONEMAP_LINEAR )\\\",\\n\\n\\t\\t\\t\\t\\t// simple linear to gamma conversion\\n\\n\\t\\t\\t\\t\\t\\\"outColor = pow( inColor, vec3( 1.0 / 2.2 ) );\\\",\\n\\n\\t\\t\\t\\t\\\"#elif defined( TONEMAP_REINHARD )\\\",\\n\\n\\t\\t\\t\\t\\t// Reinhard operator\\n\\n\\t\\t\\t\\t\\t\\\"inColor = inColor / ( 1.0 + inColor );\\\",\\n\\t\\t\\t\\t\\t\\\"outColor = pow( inColor, vec3( 1.0 / 2.2 ) );\\\",\\n\\n\\t\\t\\t\\t\\\"#elif defined( TONEMAP_FILMIC )\\\",\\n\\n\\t\\t\\t\\t\\t// filmic operator by Jim Hejl and Richard Burgess-Dawson\\n\\n\\t\\t\\t\\t\\t\\\"vec3 x = max( vec3( 0.0 ), inColor - 0.004 );\\\",\\n\\t\\t\\t\\t\\t\\\"outColor = ( x * ( 6.2 * x + 0.5 ) ) / ( x * ( 6.2 * x + 1.7 ) + 0.06 );\\\",\\n\\n\\t\\t\\t\\t\\\"#elif defined( TONEMAP_UNCHARTED )\\\",\\n\\n\\t\\t\\t\\t\\t// tonemapping operator from Uncharted 2 by John Hable\\n\\n\\t\\t\\t\\t\\t\\\"float ExposureBias = 2.0;\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 curr = Uncharted2Tonemap( ExposureBias * inColor );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 whiteScale = vec3( 1.0 ) / Uncharted2Tonemap( vec3( W ) );\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 color = curr * whiteScale;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"outColor = pow( color, vec3( 1.0 / 2.2 ) );\\\",\\n\\n\\t\\t\\t\\t\\\"#else\\\",\\n\\n\\t\\t\\t\\t\\t\\\"outColor = inColor;\\\",\\n\\n\\t\\t\\t\\t\\\"#endif\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( outColor, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader : [\\n\\n\\t\\t\\t\\\"varying vec2 texCoord;\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vec4 pos = vec4( sign( position.xy ), 0.0, 1.0 );\\\",\\n\\t\\t\\t\\t\\\"texCoord = pos.xy * vec2( 0.5 ) + 0.5;\\\",\\n\\t\\t\\t\\t\\\"gl_Position = pos;\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\t\\\"pointLight\\\" : {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\tsamplerNormalDepth: { type: \\\"t\\\", value: null },\\n\\t\\t\\tsamplerColor: \\t\\t{ type: \\\"t\\\", value: null },\\n\\t\\t\\tmatProjInverse: { type: \\\"m4\\\", value: new THREE.Matrix4() },\\n\\t\\t\\tviewWidth: \\t\\t{ type: \\\"f\\\", value: 800 },\\n\\t\\t\\tviewHeight: \\t{ type: \\\"f\\\", value: 600 },\\n\\n\\t\\t\\tlightPositionVS:{ type: \\\"v3\\\", value: new THREE.Vector3( 0, 0, 0 ) },\\n\\t\\t\\tlightColor: \\t{ type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\tlightIntensity: { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\tlightRadius: \\t{ type: \\\"f\\\", value: 1.0 }\\n\\n\\t\\t},\\n\\n\\t\\tfragmentShader : [\\n\\n\\t\\t\\t\\\"uniform sampler2D samplerColor;\\\",\\n\\t\\t\\t\\\"uniform sampler2D samplerNormalDepth;\\\",\\n\\n\\t\\t\\t\\\"uniform float lightRadius;\\\",\\n\\t\\t\\t\\\"uniform float lightIntensity;\\\",\\n\\t\\t\\t\\\"uniform float viewHeight;\\\",\\n\\t\\t\\t\\\"uniform float viewWidth;\\\",\\n\\n\\t\\t\\t\\\"uniform vec3 lightColor;\\\",\\n\\t\\t\\t\\\"uniform vec3 lightPositionVS;\\\",\\n\\n\\t\\t\\t\\\"uniform mat4 matProjInverse;\\\",\\n\\n\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackFloat\\\" ],\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeVertexPositionVS\\\" ],\\n\\n\\t\\t\\t\\t// bail out early when pixel outside of light sphere\\n\\n\\t\\t\\t\\t\\\"vec3 lightVector = lightPositionVS - vertexPositionVS.xyz;\\\",\\n\\t\\t\\t\\t\\\"float distance = length( lightVector );\\\",\\n\\n\\t\\t\\t\\t\\\"if ( distance > lightRadius ) discard;\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeNormal\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackColorMap\\\" ],\\n\\n\\t\\t\\t\\t// compute light\\n\\n\\t\\t\\t\\t\\\"lightVector = normalize( lightVector );\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeDiffuse\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeSpecular\\\" ],\\n\\n\\t\\t\\t\\t// combine\\n\\n\\t\\t\\t\\t\\\"float cutoff = 0.3;\\\",\\n\\t\\t\\t\\t\\\"float denom = distance / lightRadius + 1.0;\\\",\\n\\t\\t\\t\\t\\\"float attenuation = 1.0 / ( denom * denom );\\\",\\n\\t\\t\\t\\t\\\"attenuation = ( attenuation - cutoff ) / ( 1.0 - cutoff );\\\",\\n\\t\\t\\t\\t\\\"attenuation = max( attenuation, 0.0 );\\\",\\n\\t\\t\\t\\t\\\"attenuation *= attenuation;\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"combine\\\" ],\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader : [\\n\\n\\t\\t\\t\\\"void main() { \\\",\\n\\n\\t\\t\\t\\t// sphere proxy needs real position\\n\\n\\t\\t\\t\\t\\\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\",\\n\\t\\t\\t\\t\\\"gl_Position = projectionMatrix * mvPosition;\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\t\\\"spotLight\\\" : {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\tsamplerNormalDepth: { type: \\\"t\\\", value: null },\\n\\t\\t\\tsamplerColor: \\t\\t{ type: \\\"t\\\", value: null },\\n\\t\\t\\tmatProjInverse: { type: \\\"m4\\\", value: new THREE.Matrix4() },\\n\\t\\t\\tviewWidth: \\t\\t{ type: \\\"f\\\", value: 800 },\\n\\t\\t\\tviewHeight: \\t{ type: \\\"f\\\", value: 600 },\\n\\n\\t\\t\\tlightPositionVS :{ type: \\\"v3\\\", value: new THREE.Vector3( 0, 1, 0 ) },\\n\\t\\t\\tlightDirectionVS:{ type: \\\"v3\\\", value: new THREE.Vector3( 0, 1, 0 ) },\\n\\t\\t\\tlightColor: \\t{ type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\tlightIntensity: { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\tlightDistance: \\t{ type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\tlightAngle: \\t{ type: \\\"f\\\", value: 1.0 }\\n\\n\\t\\t},\\n\\n\\t\\tfragmentShader : [\\n\\n\\t\\t\\t\\\"uniform vec3 lightPositionVS;\\\",\\n\\t\\t\\t\\\"uniform vec3 lightDirectionVS;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D samplerColor;\\\",\\n\\t\\t\\t\\\"uniform sampler2D samplerNormalDepth;\\\",\\n\\n\\t\\t\\t\\\"uniform float viewHeight;\\\",\\n\\t\\t\\t\\\"uniform float viewWidth;\\\",\\n\\n\\t\\t\\t\\\"uniform float lightAngle;\\\",\\n\\t\\t\\t\\\"uniform float lightIntensity;\\\",\\n\\t\\t\\t\\\"uniform vec3 lightColor;\\\",\\n\\n\\t\\t\\t\\\"uniform mat4 matProjInverse;\\\",\\n\\n\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackFloat\\\" ],\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeVertexPositionVS\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeNormal\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackColorMap\\\" ],\\n\\n\\t\\t\\t\\t// compute light\\n\\n\\t\\t\\t\\t\\\"vec3 lightVector = normalize( lightPositionVS.xyz - vertexPositionVS.xyz );\\\",\\n\\n\\t\\t\\t\\t\\\"float rho = dot( lightDirectionVS, lightVector );\\\",\\n\\t\\t\\t\\t\\\"float rhoMax = cos( lightAngle * 0.5 );\\\",\\n\\n\\t\\t\\t\\t\\\"if ( rho <= rhoMax ) discard;\\\",\\n\\n\\t\\t\\t\\t\\\"float theta = rhoMax + 0.0001;\\\",\\n\\t\\t\\t\\t\\\"float phi = rhoMax + 0.05;\\\",\\n\\t\\t\\t\\t\\\"float falloff = 4.0;\\\",\\n\\n\\t\\t\\t\\t\\\"float spot = 0.0;\\\",\\n\\n\\t\\t\\t\\t\\\"if ( rho >= phi ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"spot = 1.0;\\\",\\n\\n\\t\\t\\t\\t\\\"} else if ( rho <= theta ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"spot = 0.0;\\\",\\n\\n\\t\\t\\t\\t\\\"} else { \\\",\\n\\n\\t\\t\\t\\t\\t\\\"spot = pow( ( rho - theta ) / ( phi - theta ), falloff );\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeDiffuse\\\" ],\\n\\n\\t\\t\\t\\t\\\"diffuse *= spot;\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeSpecular\\\" ],\\n\\n\\t\\t\\t\\t// combine\\n\\n\\t\\t\\t\\t\\\"const float attenuation = 1.0;\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"combine\\\" ],\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader : [\\n\\n\\t\\t\\t\\\"void main() { \\\",\\n\\n\\t\\t\\t\\t// full screen quad proxy\\n\\n\\t\\t\\t\\t\\\"gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\t\\\"directionalLight\\\" : {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\tsamplerNormalDepth: { type: \\\"t\\\", value: null },\\n\\t\\t\\tsamplerColor: \\t\\t{ type: \\\"t\\\", value: null },\\n\\t\\t\\tmatProjInverse: { type: \\\"m4\\\", value: new THREE.Matrix4() },\\n\\t\\t\\tviewWidth: \\t\\t{ type: \\\"f\\\", value: 800 },\\n\\t\\t\\tviewHeight: \\t{ type: \\\"f\\\", value: 600 },\\n\\n\\t\\t\\tlightDirectionVS: { type: \\\"v3\\\", value: new THREE.Vector3( 0, 1, 0 ) },\\n\\t\\t\\tlightColor: \\t{ type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\tlightIntensity: { type: \\\"f\\\", value: 1.0 }\\n\\n\\t\\t},\\n\\n\\t\\tfragmentShader : [\\n\\n\\t\\t\\t\\\"uniform sampler2D samplerColor;\\\",\\n\\t\\t\\t\\\"uniform sampler2D samplerNormalDepth;\\\",\\n\\n\\t\\t\\t\\\"uniform float lightRadius;\\\",\\n\\t\\t\\t\\\"uniform float lightIntensity;\\\",\\n\\t\\t\\t\\\"uniform float viewHeight;\\\",\\n\\t\\t\\t\\\"uniform float viewWidth;\\\",\\n\\n\\t\\t\\t\\\"uniform vec3 lightColor;\\\",\\n\\t\\t\\t\\\"uniform vec3 lightDirectionVS;\\\",\\n\\n\\t\\t\\t\\\"uniform mat4 matProjInverse;\\\",\\n\\n\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackFloat\\\" ],\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeVertexPositionVS\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeNormal\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackColorMap\\\" ],\\n\\n\\t\\t\\t\\t// compute light\\n\\n\\t\\t\\t\\t\\\"vec3 lightVector = lightDirectionVS;\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeDiffuse\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeSpecular\\\" ],\\n\\n\\t\\t\\t\\t// combine\\n\\n\\t\\t\\t\\t\\\"const float attenuation = 1.0;\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"combine\\\" ],\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader : [\\n\\n\\t\\t\\t\\\"void main() { \\\",\\n\\n\\t\\t\\t\\t// full screen quad proxy\\n\\n\\t\\t\\t\\t\\\"gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\t\\\"hemisphereLight\\\" : {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\tsamplerNormalDepth: { type: \\\"t\\\", value: null },\\n\\t\\t\\tsamplerColor: \\t\\t{ type: \\\"t\\\", value: null },\\n\\t\\t\\tmatProjInverse: { type: \\\"m4\\\", value: new THREE.Matrix4() },\\n\\t\\t\\tviewWidth: \\t\\t{ type: \\\"f\\\", value: 800 },\\n\\t\\t\\tviewHeight: \\t{ type: \\\"f\\\", value: 600 },\\n\\n\\t\\t\\tlightDirectionVS: { type: \\\"v3\\\", value: new THREE.Vector3( 0, 1, 0 ) },\\n\\t\\t\\tlightColorSky: \\t  { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\tlightColorGround: { type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\tlightIntensity:   { type: \\\"f\\\", value: 1.0 }\\n\\n\\t\\t},\\n\\n\\t\\tfragmentShader : [\\n\\n\\t\\t\\t\\\"uniform sampler2D samplerColor;\\\",\\n\\t\\t\\t\\\"uniform sampler2D samplerNormalDepth;\\\",\\n\\n\\t\\t\\t\\\"uniform float lightRadius;\\\",\\n\\t\\t\\t\\\"uniform float lightIntensity;\\\",\\n\\t\\t\\t\\\"uniform float viewHeight;\\\",\\n\\t\\t\\t\\\"uniform float viewWidth;\\\",\\n\\n\\t\\t\\t\\\"uniform vec3 lightColorSky;\\\",\\n\\t\\t\\t\\\"uniform vec3 lightColorGround;\\\",\\n\\t\\t\\t\\\"uniform vec3 lightDirectionVS;\\\",\\n\\n\\t\\t\\t\\\"uniform mat4 matProjInverse;\\\",\\n\\n\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackFloat\\\" ],\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeVertexPositionVS\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeNormal\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackColorMap\\\" ],\\n\\n\\t\\t\\t\\t// compute light\\n\\n\\t\\t\\t\\t\\\"vec3 lightVector = lightDirectionVS;\\\",\\n\\n\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\t\\\"float dotProduct = dot( normal, lightVector );\\\",\\n\\t\\t\\t\\t\\\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 hemiColor = mix( lightColorGround, lightColorSky, hemiDiffuseWeight );\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 diffuse = hemiColor;\\\",\\n\\n\\t\\t\\t\\t// specular (sky light)\\n\\n\\t\\t\\t\\t\\\"vec3 hemiHalfVectorSky = normalize( lightVector - vertexPositionVS.xyz );\\\",\\n\\t\\t\\t\\t\\\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\\",\\n\\t\\t\\t\\t\\\"float hemiSpecularWeightSky = max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t// specular (ground light)\\n\\n\\t\\t\\t\\t\\\"vec3 lVectorGround = -lightVector;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 hemiHalfVectorGround = normalize( lVectorGround - vertexPositionVS.xyz );\\\",\\n\\t\\t\\t\\t\\\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\\",\\n\\t\\t\\t\\t\\\"float hemiSpecularWeightGround = max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\\"float dotProductGround = dot( normal, lVectorGround );\\\",\\n\\n\\t\\t\\t\\t\\\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 schlickSky = specularColor + vec3( 1.0 - specularColor ) * pow( 1.0 - dot( lightVector, hemiHalfVectorSky ), 5.0 );\\\",\\n\\t\\t\\t\\t\\\"vec3 schlickGround = specularColor + vec3( 1.0 - specularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\\\",\\n\\t\\t\\t\\t\\\"vec3 specular = hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\\",\\n\\n\\t\\t\\t\\t// combine\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( lightIntensity * ( albedo * diffuse + specular ), 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader : [\\n\\n\\t\\t\\t\\\"void main() { \\\",\\n\\n\\t\\t\\t\\t// full screen quad proxy\\n\\n\\t\\t\\t\\t\\\"gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\t\\\"areaLight\\\" : {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\tsamplerNormalDepth: { type: \\\"t\\\", value: null },\\n\\t\\t\\tsamplerColor: \\t\\t{ type: \\\"t\\\", value: null },\\n\\t\\t\\tmatProjInverse: { type: \\\"m4\\\", value: new THREE.Matrix4() },\\n\\t\\t\\tviewWidth: \\t\\t{ type: \\\"f\\\", value: 800 },\\n\\t\\t\\tviewHeight: \\t{ type: \\\"f\\\", value: 600 },\\n\\n\\t\\t\\tlightPositionVS: { type: \\\"v3\\\", value: new THREE.Vector3( 0, 1, 0 ) },\\n\\t\\t\\tlightNormalVS: \\t { type: \\\"v3\\\", value: new THREE.Vector3( 0, -1, 0 ) },\\n\\t\\t\\tlightRightVS:  \\t { type: \\\"v3\\\", value: new THREE.Vector3( 1, 0, 0 ) },\\n\\t\\t\\tlightUpVS:  \\t { type: \\\"v3\\\", value: new THREE.Vector3( 1, 0, 0 ) },\\n\\n\\t\\t\\tlightColor: \\t{ type: \\\"c\\\", value: new THREE.Color( 0x000000 ) },\\n\\t\\t\\tlightIntensity: { type: \\\"f\\\", value: 1.0 },\\n\\n\\t\\t\\tlightWidth:  { type: \\\"f\\\", value: 1.0 },\\n\\t\\t\\tlightHeight: { type: \\\"f\\\", value: 1.0 },\\n\\n\\t\\t\\tconstantAttenuation:  { type: \\\"f\\\", value: 1.5 },\\n\\t\\t\\tlinearAttenuation:    { type: \\\"f\\\", value: 0.5 },\\n\\t\\t\\tquadraticAttenuation: { type: \\\"f\\\", value: 0.1 }\\n\\n\\t\\t},\\n\\n\\t\\tfragmentShader : [\\n\\n\\t\\t\\t\\\"uniform vec3 lightPositionVS;\\\",\\n\\t\\t\\t\\\"uniform vec3 lightNormalVS;\\\",\\n\\t\\t\\t\\\"uniform vec3 lightRightVS;\\\",\\n\\t\\t\\t\\\"uniform vec3 lightUpVS;\\\",\\n\\n\\t\\t\\t\\\"uniform sampler2D samplerColor;\\\",\\n\\t\\t\\t\\\"uniform sampler2D samplerNormalDepth;\\\",\\n\\n\\t\\t\\t\\\"uniform float lightWidth;\\\",\\n\\t\\t\\t\\\"uniform float lightHeight;\\\",\\n\\n\\t\\t\\t\\\"uniform float constantAttenuation;\\\",\\n\\t\\t\\t\\\"uniform float linearAttenuation;\\\",\\n\\t\\t\\t\\\"uniform float quadraticAttenuation;\\\",\\n\\n\\t\\t\\t\\\"uniform float lightIntensity;\\\",\\n\\t\\t\\t\\\"uniform vec3 lightColor;\\\",\\n\\n\\t\\t\\t\\\"uniform float viewHeight;\\\",\\n\\t\\t\\t\\\"uniform float viewWidth;\\\",\\n\\n\\t\\t\\t\\\"uniform mat4 matProjInverse;\\\",\\n\\n\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackFloat\\\" ],\\n\\n\\t\\t\\t\\\"vec3 projectOnPlane( vec3 point, vec3 planeCenter, vec3 planeNorm ) {\\\",\\n\\n\\t\\t\\t\\t\\\"return point - dot( point - planeCenter, planeNorm ) * planeNorm;\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"bool sideOfPlane( vec3 point, vec3 planeCenter, vec3 planeNorm ) {\\\",\\n\\n\\t\\t\\t\\t\\\"return ( dot( point - planeCenter, planeNorm ) >= 0.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"vec3 linePlaneIntersect( vec3 lp, vec3 lv, vec3 pc, vec3 pn ) {\\\",\\n\\n\\t\\t\\t\\t\\\"return lp + lv * ( dot( pn, pc - lp ) / dot( pn, lv ) );\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"float calculateAttenuation( float dist ) {\\\",\\n\\n\\t\\t\\t\\t\\\"return ( 1.0 / ( constantAttenuation + linearAttenuation * dist + quadraticAttenuation * dist * dist ) );\\\",\\n\\n\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeVertexPositionVS\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"computeNormal\\\" ],\\n\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackColorMap\\\" ],\\n\\n\\t\\t\\t\\t\\\"float w = lightWidth;\\\",\\n\\t\\t\\t\\t\\\"float h = lightHeight;\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 proj = projectOnPlane( vertexPositionVS.xyz, lightPositionVS, lightNormalVS );\\\",\\n\\t\\t\\t\\t\\\"vec3 dir = proj - lightPositionVS;\\\",\\n\\n\\t\\t\\t\\t\\\"vec2 diagonal = vec2( dot( dir, lightRightVS ), dot( dir, lightUpVS ) );\\\",\\n\\t\\t\\t\\t\\\"vec2 nearest2D = vec2( clamp( diagonal.x, -w, w ), clamp( diagonal.y, -h, h ) );\\\",\\n\\t\\t\\t\\t\\\"vec3 nearestPointInside = vec3( lightPositionVS ) + ( lightRightVS * nearest2D.x + lightUpVS * nearest2D.y );\\\",\\n\\n\\t\\t\\t\\t\\\"vec3 lightDir = normalize( nearestPointInside - vertexPositionVS.xyz );\\\",\\n\\t\\t\\t\\t\\\"float NdotL = max( dot( lightNormalVS, -lightDir ), 0.0 );\\\",\\n\\t\\t\\t\\t\\\"float NdotL2 = max( dot( normal, lightDir ), 0.0 );\\\",\\n\\n\\t\\t\\t\\t//\\\"if ( NdotL2 * NdotL > 0.0 && sideOfPlane( vertexPositionVS.xyz, lightPositionVS, lightNormalVS ) ) {\\\",\\n\\t\\t\\t\\t\\\"if ( NdotL2 * NdotL > 0.0 ) {\\\",\\n\\n\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\t\\t\\\"vec3 diffuse = vec3( sqrt( NdotL * NdotL2 ) );\\\",\\n\\n\\t\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\t\\t\\\"vec3 specular = vec3( 0.0 );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"vec3 R = reflect( normalize( -vertexPositionVS.xyz ), normal );\\\",\\n\\t\\t\\t\\t\\t\\\"vec3 E = linePlaneIntersect( vertexPositionVS.xyz, R, vec3( lightPositionVS ), lightNormalVS );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"float specAngle = dot( R, lightNormalVS );\\\",\\n\\n\\t\\t\\t\\t\\t\\\"if ( specAngle > 0.0 ) {\\\",\\n\\n\\t\\t\\t\\t\\t\\t\\\"vec3 dirSpec = E - vec3( lightPositionVS );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"vec2 dirSpec2D = vec2( dot( dirSpec, lightRightVS ), dot( dirSpec, lightUpVS ) );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"vec2 nearestSpec2D = vec2( clamp( dirSpec2D.x, -w, w ), clamp( dirSpec2D.y, -h, h ) );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"float specFactor = 1.0 - clamp( length( nearestSpec2D - dirSpec2D ) * 0.05 * shininess, 0.0, 1.0 );\\\",\\n\\t\\t\\t\\t\\t\\t\\\"specular = specularColor * specFactor * specAngle * diffuse;\\\",\\n\\n\\t\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\t\\t// combine\\n\\n\\t\\t\\t\\t\\t\\\"float dist = distance( vertexPositionVS.xyz, nearestPointInside );\\\",\\n\\t\\t\\t\\t\\t\\\"float attenuation = calculateAttenuation( dist );\\\",\\n\\n\\t\\t\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"combine\\\" ],\\n\\n\\t\\t\\t\\t\\\"} else {\\\",\\n\\n\\t\\t\\t\\t\\t\\\"discard;\\\",\\n\\n\\t\\t\\t\\t\\\"}\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader : [\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t// full screen quad proxy\\n\\n\\t\\t\\t\\t\\\"gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t},\\n\\n\\t\\\"emissiveLight\\\" : {\\n\\n\\t\\tuniforms: {\\n\\n\\t\\t\\tsamplerColor: \\t{ type: \\\"t\\\", value: null },\\n\\t\\t\\tviewWidth: \\t\\t{ type: \\\"f\\\", value: 800 },\\n\\t\\t\\tviewHeight: \\t{ type: \\\"f\\\", value: 600 },\\n\\n\\t\\t},\\n\\n\\t\\tfragmentShader : [\\n\\n\\t\\t\\t\\\"uniform sampler2D samplerColor;\\\",\\n\\n\\t\\t\\t\\\"uniform float viewHeight;\\\",\\n\\t\\t\\t\\\"uniform float viewWidth;\\\",\\n\\n\\t\\t\\tTHREE.DeferredShaderChunk[ \\\"unpackFloat\\\" ],\\n\\n\\t\\t\\t\\\"void main() {\\\",\\n\\n\\t\\t\\t\\t\\\"vec2 texCoord = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\\\",\\n\\n\\t\\t\\t\\t\\\"vec4 colorMap = texture2D( samplerColor, texCoord );\\\",\\n\\t\\t\\t\\t\\\"vec3 emissiveColor = float_to_vec3( abs( colorMap.w ) );\\\",\\n\\n\\t\\t\\t\\t\\\"gl_FragColor = vec4( emissiveColor, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\"),\\n\\n\\t\\tvertexShader : [\\n\\n\\t\\t\\t\\\"void main() { \\\",\\n\\n\\t\\t\\t\\t// full screen quad proxy\\n\\n\\t\\t\\t\\t\\\"gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\\\",\\n\\n\\t\\t\\t\\\"}\\\"\\n\\n\\t\\t].join(\\\"\\\\n\\\")\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js-plus/icon\": {\n            \"created\": \"20150122113649353\",\n            \"modified\": \"20150122113650949\",\n            \"title\": \"$:/plugins/rboue/Three.js-plus/icon\",\n            \"type\": \"image/png\",\n            \"text\": \"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABmJLR0QA/wD/AP+gvaeTAAAACXBI\\nWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wMRCAYZvJsQjgAAABl0RVh0Q29tbWVudABDcmVhdGVk\\nIHdpdGggR0lNUFeBDhcAABHaSURBVHja7Z15VJNX3se/N7IoWElQgwiEVUBZBJdSSweFEZdaWjew\\nIrZqO9O302l9562n9cx5zxydMzOnp6eli+2r09KilipuoxVKlUarUOqGBRcUiBKIiQjGLEAggZD7\\n/kHTwRGyB7I837845Fnuc3+f53eX53d/l1BK4UqilOLBgwdob2+HQqGAQqGAUqmEWq2GUDMxPFWe\\n22To/CrOvohw7wfCsWPHgs1mw8/PD2w2GwEBAfD39wchxKXqizg7ACqVCiKRCCKRCGKxGMHtm+36\\nQGLuRyQ4OBihoaEICQmBr68vA8BISqfTQSQSQSAQoPJ2j9E32t4Sct4jUVFRiIqKAo/HA4vFYgCw\\nh1tvampCXV0dvOtyHbrAvfH7SVxcHMLDw52iuXBoANra2nDp0iV4XnveKdupvoRiMnfuXAQEBDAA\\nmOVWhUKcO3cOE1t+7xI9VFnY52TevHkICwtjADDk5uvr61FRUYEw2ZuuNTT5RS0T80laWhpiYmIc\\npnlwCAAaGxvxww8/uKzhhwIhPT0d06ZNc28A7ty5gxMnToAn/ZNbGP6R55/8IVmyZAmCg4PdC4De\\n3l6cOnUKrNpstzT8I5p1hGRkZMDT09P1ARAIBGg6nMwYfghF5VwhkZGRrgmAWq1GSUkJJtzayBjf\\ngLpjvyLLli2Dl5fXiNxvRKat2trasL3wdD5jfOPyqV9P//blifD79++7hgeoqalB+4nfMIa3QAFL\\nfyRJSUnOCQClFHw+H7rqFYzxrZBnynGSnp5ut3kDuzQBWq0WBw4cYIxvA/VdeJYePHgQWq3WOQDQ\\naDQoKioCR/gyY3wbid30Ev3666+h0WgcG4DOzk78vfBkeGDrHxnj21hT7r5G/154Mryzs9MxAVAq\\nlTh6dOfPo/193pWVKs9t+kdRZX5HR4djdQK7urpQtWMK89aPJAyv3yPjx48ffQ+gVqvxbtHpcMYk\\nI6t3i06Hq9Xq0fUAWq0WRUVFYNr80dG9qZ+SdevWwcPDY+Q9gE6nw6FDhxjjj3LH8PDhw7DmJbbY\\nA5SXl4NeXskY3wHkmXKcZGRkjJwHqKmpYYzvQOq78Cytr68fGQDa29uZuX0HVMvROdSSOQKzAOjr\\n68MHR6rzmep2TB04cAD9/f326wOUlZVhzJUc5u13YLHmHCWZmZm29wDNzc2M8Z1AuuoV9M6dO7YF\\noLe3Fw374xnjO4l2fXslT6fT2a4J4PP56L+0nAFgBNXs/z6ZPn06OBwOfHx80N/fD5VKBbFYDK/r\\na43awi+dT5544gnrAWhvb0fNFxEuZ3wx9yPC5XIxbtw4AAMBLDKZDOyml0b1WaW8f5KFCxciICBg\\n2HJQSnH16lVyryzVYFlTXhUTNpttHQB79+5FgOQPLgFA57TdJD4+HhEREdRQ0KVUKs2pr68/pKpc\\nMqLPHZR1nsTHm97UarVafPPNN2R844tDnqOM/JLk5ORYDsDt27dx6+BMpzd+R1QhycjIeHvixInv\\nmNWh0ulQU1NDpOXz7V4HcevrSXBwsNn3+SX0jgwXfRWz9joxtCaRZejCe76vc/qvfNwllSQ7O5ua\\na3wAYLFYmD17Nn3qjTa0Bn5it8V8kdm1FhkfAAghWLhwIe2K3jNk+U6dOmWZB6irq4P4eIpTv/0z\\nN94iU6bYJk6BUopTp04RW3eGe6YXkeXLl9O+vj6cPHmSnD17Fh0dHQgMDMTSpUuRkmKaDdRqNc5+\\nMGnI32Jz60hoaKh5AOzatQvh8i1OC0DyS03+XC5XZuvrlpaWElvmK0h5VUxqa2vxyiuvoLGx8ZHr\\nLly4kBQUFCA0NNToPX/88UcyVL9FyvsnWbdunekA3Lp1C7cPJTmt8X9ZYmWX8ut0OhQVFRFbdIxl\\nYZ8THx8frF69mhqK+p00aVLOhQsXDkVEGB6N9fT0oOLDyUP+NiPvJgkJCTGtD3D+/Hnn9fuzjjxk\\n/I6ODpSXl5Pdu3eTvXv3kjNnzhBrImlYLBZWrVplE7i4XC42bNhw21jIt1QqPfjCCy8Y/e4/btw4\\nSAI+HrIvUFVVZVonUCaTYfKd/3Lat3/+/IEee01NDVmxYgXhcrlYvHgx3bhxI33xxRdpeno65XK5\\n2LRpExEKhRZ17Hx9feHz1HdWdwq1F5+jCoUiwpRjq6qqKJ/PN3rPwMDAIf/PEb5M5XK5cQCqq6ud\\n9uUf++S3xNvbG9u3bydz5syhx44do0PF0nd2dqKwsJBOnz6d7tmzxyJDmto5M6StB6eZde+ysjKj\\nxzz22GPD/nb58mXDAPT39zt1oMfcuXOxZcsWsm3bNmrKXLhGo8HGjRvpzp07zYbAy8sLZPa/rPIC\\nYrE425zjm5ubjR5jKD6w/9LyR+rlIQAEAoHTvv13p+wgx44dQ35+vlkAU0qxefNmev78ebONGRsb\\na1WZvb29D5lzvI+Pj9FjjAWF3Lp1a3gA6urqnBYAHo+HLVu2WHRuX18fXn/9dbODKy2dvNHL3BxB\\niYmJxkcWMsMj3xs3bgwNgFarxXBzys4g7cXnaGtrq8Xlr66uNtsLsFgstAfvtLgZ2Lroksnl9fLy\\nwpo1awzXgVZr9GPWuJt5dHDU0K8ACIVCOLM+PZdhda+8pKTE7HOMfW0zprS0NJPK/dZbb5GwsDBq\\nxL2bdK3BfQmWK7T/ANDQ0GD1NSxpAr29va2655tvvomEhASDhsvJySHbtm2jxiaoLl48/rMp9xxs\\n618B4PQc6XJmAGQyWba115BKpSNebu+6XFpWVobt27eT4ODgh0CYOXMmKSwsJMXFxXTMmDEGr3Pp\\n0iUSIPlrsin3PCvU5T8EgFKpREfjAafOe+7n53fI2mtwOByzz+np6bG67J+V/hy+detW2tLSQhsb\\nG0l1dTWRSCSktraWbtiwgRrLDiIUConi9G9N7k8sUOT8Sb/CmAUMJGx0dg03A2aOwsPDLfE8Vt83\\nVZ7b9LcvT0R0dHQ0TZs2jc6ePZtOnTrVJINeuXKFNBYnmN35FYvFrgXA/z5dY/UIJisry6zjKaWY\\neu91m4ycUuW5TRd2BkfU1taaFKepUqnw7bffGg0LG04ikejfANy9e9fpAajgFK83NA1qTJGRkSQ9\\nPd2symxtbbV5kEjbd0/RP+/67oPKykoilUpzBg/Zent70dTUREpLS8mPHwfA4+oai+FrbW0FABCd\\nTofydx5zmaDPJX9WWXTewYMHSXa2ealry8vLiTNPnS/a2klYQ30hclbR5MNk6dKlZr+Vr732mtnG\\nV6lUTr9AVqlUgjUaQx97idSsprt378amTZtMgoDFYuGdd94hO3bsMNuQFRUVTr99mFQqhUt5AGAg\\n8KGgoADFxcUkLCxsWCMlJSURPp9P3n77bWpuEkaZTPaZK2Q6l8vl8FAoFC4FgE/9elpd/QNZs2YN\\nzc7Oxrlz50hFRQXu3r0LFosFHo+HzMxMJCYmWmRAjUaD0tKCuQEuUFcKhQIeSqUSfnAtyfjpVDK1\\ngQQFBdHU1FSamppqmz4GpSgpKSEBkr+6RKdZqVSC1d3dDVfU9b0xtL6+3mbttEajwb59+8hjgg0u\\nM2JSqVRgCdST8uCiajk6h/70009W50JUKBRNe/bsIZNEr7jUGsmenh6QE//wdflVv21Bf6mZM+eZ\\nWdOnTzerw9fV1YUzZ84QZ9230KSRkzsAoJeY+xFJTk5GdHQ0HS7LJqUUYrGYXL9+3S32NHIrAAZr\\nQvQa1e2e9PH67/mUUiiVSrfbwcxtAWA0IBZTBQwAjBgAGDEAMHJPAKo4+yKYanBPCTnvEVbEWJmQ\\nqQr3lI+PD1imrDdj5MIAWLuyhZHzis1mMwAwADAAuDcAkydPZmrCTcXlchkP4M6aMGECWIQQiLkf\\nEaY63Et3p+wgwC8zgcHBwUyNuJn0NmcBA+lVGLmX9EkjGQ/AADCQW66CU7yeqRb3kJDzHvH19f03\\nAAAwP8KriKka91BUVNSvf3sM/qfgMlM55qot6P+Iv78//Pz84OHhAS8vL3h7e4PFGni3ent7odVq\\nodFooNFoIJPJIJfLRzX2cEgAeDweBIw9DUoZ+SUJDQ0Fj8cDl8vV5+2x0JC/Q3d3N8RiMWlpaUFL\\nSwtC7v/3iEAxOGv4Q4smjh07hnE385gg0UHSJR0iCQkJVieFNEUajQY3b94k165dA1f8ql3up4nb\\nR5599tmhARAIBGg6nOz2AFRwitfnzY8siomJoXpXPtLq6urCuXPnht0LyGL3P7CXwtAA9Pf3g/+u\\nn1sDELjsJ5KQkGD2knF7qbOzE2fOnCGm7BVoijLf7iCDoX4I7zFjxsDj8W/cclr43tRPyW82tyMx\\nMdFhjK8fomdlZdHQFdVWF8rriRLynx7tEf+WnJzsdsaXhX1O8vLyqCNHR8XGxtL4FxqsgiApKemR\\n/z0CgL+/P+ThBW7jBSZEr1GtXr3aaCZOR1BQUBANee6iRbZRRHxBhkqEOWQPx5Q9Z11FPlFvjPf0\\n9HSa8s6YMYO2TMw3G4Inn3xyyP8PCUBYWBiEnPfcwgtER0dTJyyzWceLJn0w5I5hwwIAAOnp6W7h\\nAcaOHet0ZdZveG2qDNlyWABiYmLcIlBEKpXOcbYy379/3+RjWwM/IYOnfk0GAAAWLFjg8h7g8lBb\\naTmwenp6YE7Gkvnz5xv83SAAkZGRLj8iIDWrqUgkcopnpJSirKzM5LJ2x35FjGVANzrPuXjxYpf3\\nAje/nkElEglxdOOfPHmSmLOv06JFi4weYxQADoeDMXOPuXxf4PreGFpbW+uQz9nT04P9+/cTUrPa\\nZOP7pfN/DfqwCgB9L9IdIobavnuK/mXX8YgbN244BAgajQZ8Pp9UfDgZE1t+b7Lx70z+kKSkpJjW\\nBJqaQ6+5uRkN++Pd5kPR/ZBdZNasWYiOjqaGduO0h+RyOf/atWuZPVVPW1Tfw+0UbhUAAMDn89F/\\nabnbfS1Uz/iaxMTEgMfj2eV7AaUU7e3tRCgUoq6uDsHtmy2u43GpZSQtLc30TrA5APT396OgoABh\\nsjfd9pNxBad4/bxgFHG5XLDZbLDZbA6bzZZ5eXmZZOiuri4oFAqiUCggl8shkUjg3/w7m9Rne/BO\\nkpeXB3O+ZpqdRrW9vR01X0QwUUMGAInwbCvy8vICpRRqtRqhD/5nROrryT+2EnO3zbEoj25DQwOa\\n/zWbgcCBFJtbR0JDQ80+z6J4p5iYGKu3TmdkO3mmHLfI+BYDAACZmZnQxO1jIBjtoWLcPmLNhzuL\\nASCEICsrC4qILxgIRknKyC9JVlYWrAlhsyrklRCCVatW/brUmNHI6e6UHWTlypWwNn7R6phnDw8P\\n5Obmuk0AiSOo2f99kpubC1tMUNkk6N3b2xtr165FW9Bfahjz2Fdn2Ac/WLt2rdXb1ls1DBxOarUa\\n+/fvt9l+uoweVmvgJ+T555+3aRSTTQEABmYLjxw5Ar/bmxgIbKiOqEKycuVK2Dp62eYAAANTnqWl\\npbDVahZ3V19CMVm2bBnssWDFLgDoITh9+jS0F59jILBCXk+UkAULFsBeq5XsBoBeLS0tqN8Xx0Bg\\ngeJfaCBBQUF2vYfdAQCA7u5uHD16FK6275699CD0M7J8+XKMxFK1EQFA3yRcvHgRitO/ZSAwIHbG\\nKfL4449jpBaojhgAeonFYpSWliJcvoUBYZCa/d8nzzzzDOzt8kcdAL03uHr1Ku6VpTIQAJjydBVJ\\nTEzEaCxLHxUA9Orq6sL3338Pn/r1bglCd+xXZNGiRTAletclAdBLIBDg7NmzI5YkabTVMjGfZGRk\\nwNCSLbcCQC+hUIjKykoESP5AXdXwaWlpAwE1DpKFxKEA0EsikaCyshIc4csuAYIs7HMyb948hIWF\\nOVzZHBIAvTo7O3H16lV0VSx2ShDGp50kM2fOxHA7lTMAmDFqaGpqQl1dHbzrch26wL3x+0lcXBzC\\nw8PhSMmmnBqAwdLpdBCJRBAIBKi83ROeKs9tGtV+C+c9EhUVhaioKPB4PIxWXkG3AeA/pVKpIBKJ\\nIBKJIJFIENT2hl0fSBLwMQkKCkJoaChCQkJGdQjHADCMOjo6IJVKoVQqoVAooFAo0N3dDZVKZXSR\\nRsvEfOLr6wsfHx/9yh+w2WxMmjQJ5i66cAb9P0ino5gBTAIlAAAAAElFTkSuQmCC\\n\"\n        },\n        \"$:/plugins/rboue/Three.js-plus/license\": {\n            \"title\": \"$:/plugins/rboue/Three.js-plus/license\",\n            \"text\": \"!Plugin license\\nCopyright (C) 2015 RenÃ© BouÃ© (rboue) &lt;rboue01 (at) gmail (dot) com&gt;<br>\\nAll rights reserved.\\n\\nThis program is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation, either version 3 of the License, or\\n(at your option) any later version.\\n\\nThis program is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n!Three.js r69 license\\nThe Three.js r69 LICENSE file is as follows :\\n\\n```\\nThe MIT License\\n\\nCopyright &copy; 2010-2014 three.js authors\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n```\"\n        },\n        \"$:/plugins/rboue/Three.js-plus/readme\": {\n            \"title\": \"$:/plugins/rboue/Three.js-plus/readme\",\n            \"text\": \"Three.js r69 extras for ~TiddlyWiki (needs Three.js plugin).\"\n        }\n    }\n}","author":"rboue","bag":"default","core-version":">=5.1.1","dependents":"","description":"Three.js extras","list":"readme license","plugin-type":"plugin","revision":"0","title":"$:/plugins/rboue/Three.js-plus","version":"1.0.0","name":"Three.js-plus"}