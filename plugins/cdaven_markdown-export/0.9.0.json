{"title":"$:/plugins/cdaven/markdown-export","description":"Markdown export of tiddlers","author":"cdaven","version":"0.9.0","core-version":">=5.3.0","source":"https://github.com/cdaven/tiddlywiki-stuff/tree/main/markdown-export","plugin-type":"plugin","list":"readme details license","dependents":"","type":"application/json","text":"{\"tiddlers\":{\"$:/plugins/cdaven/markdown-export/archive.js\":{\"title\":\"$:/plugins/cdaven/markdown-export/archive.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/cdaven/markdown-export/archive.js\\r\\ntype: application/javascript\\r\\nmodule-type: library\\r\\n\\\\*/\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.ZipArchive = void 0;\\r\\nclass ZipArchive {\\r\\n    constructor(title) {\\r\\n        this.title = title;\\r\\n        this.archive = null;\\r\\n        const JSZip = desire(\\\"$:/plugins/tiddlywiki/jszip/jszip.js\\\");\\r\\n        if (JSZip !== undefined) {\\r\\n            this.archive = new JSZip();\\r\\n        }\\r\\n    }\\r\\n    isEnabled() {\\r\\n        return this.archive != null;\\r\\n    }\\r\\n    /** Load archive from a tiddler */\\r\\n    load() {\\r\\n        if (!this.isEnabled()) {\\r\\n            console.error(\\\"JSZip plugin probably missing\\\");\\r\\n            return;\\r\\n        }\\r\\n        const tiddler = $tw.wiki.getTiddler(this.title);\\r\\n        if (tiddler && tiddler.fields.type === \\\"application/zip\\\") {\\r\\n            try {\\r\\n                this.archive.load(tiddler.fields.text, { base64: true });\\r\\n            }\\r\\n            catch (e) {\\r\\n                console.error(\\\"JSZip error: \\\" + e);\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            console.warn(\\\"Missing tiddler or wrong type: \\\", this.title);\\r\\n        }\\r\\n    }\\r\\n    /** Save archive to a tiddler */\\r\\n    save() {\\r\\n        if (!this.isEnabled()) {\\r\\n            console.error(\\\"JSZip plugin probably missing\\\");\\r\\n            return;\\r\\n        }\\r\\n        $tw.wiki.addTiddler({\\r\\n            title: this.title,\\r\\n            type: \\\"application/zip\\\",\\r\\n            text: this.toBase64()\\r\\n        });\\r\\n    }\\r\\n    /** Add file to archive */\\r\\n    addFile(filename, contents) {\\r\\n        if (!this.isEnabled()) {\\r\\n            console.error(\\\"JSZip plugin probably missing\\\");\\r\\n            return;\\r\\n        }\\r\\n        this.archive.file(filename, contents);\\r\\n    }\\r\\n    /** Render archive with Base64-encoding */\\r\\n    toBase64() {\\r\\n        return this.archive.generate({ type: \\\"base64\\\" });\\r\\n    }\\r\\n}\\r\\nexports.ZipArchive = ZipArchive;\\r\\n/** Like require, but doesn't throw errors when module is missing */\\r\\nfunction desire(moduleName) {\\r\\n    return $tw.modules.titles[moduleName] ? require(moduleName) : undefined;\\r\\n}\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/cdaven/markdown-export/core.js\":{\"title\":\"$:/plugins/cdaven/markdown-export/core.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/cdaven/markdown-export/core.js\\r\\ntype: application/javascript\\r\\nmodule-type: library\\r\\n\\\\*/\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/cdaven/markdown-export/details\":{\"title\":\"$:/plugins/cdaven/markdown-export/details\",\"created\":\"20221113100340267\",\"text\":\"!! Markdown Flavour\\n\\nThere are quite a few different Markdown specifications, and I have settled on [[Pandoc Markdown|https://pandoc.org/MANUAL.html#pandocs-markdown]], for two reasons:\\n\\n# Pandoc Markdown is quite capable, with a lot of extensions. All of these extensions will not work in every Markdown renderer, but most will.\\r\\n# [[Pandoc|https://pandoc.org]] itself is a great way to convert from (Pandoc) Markdown to other document formats, such as Word or PDF.\\n\\n!!! Further conversion with Pandoc\\n\\nYou can convert a Markdown file to Word with this simple Pandoc command:\\n\\n```\\r\\npandoc -o output.docx input.md\\r\\n```\\n\\nSimply change \\\".docx\\\" to \\\".html\\\" or \\\".pdf\\\" to convert to other formats, or use [[the --to switch|https://pandoc.org/MANUAL.html#option--to]].\\n\\nYou can also convert this Pandoc Markdown file to ~CommonMark or ~GitHub-Flavored Markdown like this:\\n\\n```\\r\\npandoc -o common.md --to commonmark input.md\\r\\npandoc -o github.md --to gfm input.md\\r\\n```\\n\\n!! Export Targets\\n\\nThe different export targets mostly differ in how they generate frontmatter (page properties), links and filenames.\\n\\n!! Some caveats\\n\\nSince ~TiddlyWiki is very expressive -- and has a multitude of plugins -- export plugins such as this probably cannot support all possible variations.\\n\\nConverting to Markdown requires a bunch of compromises, and will therefore be \\\"opinionated\\\". This is how //I// want my Markdown to look.\\n\\n!! Encoding\\n\\nThe Markdown file will be encoded with UTF-8 and Linux/Mac newlines (still works on Windows!). This should work on most platforms and with most third party applications.\\n\\n!! System Requirements\\n\\nThe plugin uses relatively modern Javascript (\\\"ES2015\\\") that doesn't work in Internet Explorer. Most modern browsers //should// work.\"},\"$:/plugins/cdaven/markdown-export/download-saver.js\":{\"title\":\"$:/plugins/cdaven/markdown-export/download-saver.js\",\"created\":\"20241228202045496\",\"module-type\":\"saver\",\"type\":\"application/javascript\",\"text\":\"(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar DownloadSaver2 = function(wiki) {};\\n\\nDownloadSaver2.prototype.save = function(text,method,callback,options) {\\n\\toptions = options || {};\\n\\t// Get the current filename\\n\\tvar filename = options.variables.filename;\\n\\tif(!filename) {\\n\\t\\tvar p = document.location.pathname.lastIndexOf(\\\"/\\\");\\n\\t\\tif(p !== -1) {\\n\\t\\t\\t// We decode the pathname because document.location is URL encoded by the browser\\n\\t\\t\\tfilename = $tw.utils.decodeURIComponentSafe(document.location.pathname.substr(p+1));\\n\\t\\t}\\n\\t}\\n\\tif(!filename) {\\n\\t\\tfilename = \\\"tiddlywiki.html\\\";\\n\\t}\\n\\t// Set up the link\\n\\tvar link = document.createElement(\\\"a\\\");\\n\\tvar mimeType = this.getMimeType(filename);\\n\\tif(Blob !== undefined && mimeType.startsWith(\\\"text/\\\")) {\\n\\t\\tvar blob = new Blob([text], {type: mimeType});\\n\\t\\tlink.setAttribute(\\\"href\\\", URL.createObjectURL(blob));\\n\\t} else {\\n\\t\\tlink.setAttribute(\\\"href\\\",\\\"data:\\\"+mimeType+\\\",\\\" + encodeURIComponent(text));\\n\\t}\\n\\tlink.setAttribute(\\\"download\\\",filename);\\n\\tdocument.body.appendChild(link);\\n\\tlink.click();\\n\\tdocument.body.removeChild(link);\\n\\t// Callback that we succeeded\\n\\tcallback(null);\\n\\treturn true;\\n};\\n\\n/*\\nInformation about this saver\\n*/\\nDownloadSaver2.prototype.info = {\\n\\tname: \\\"download2\\\",\\n\\tcapabilities: [\\\"download\\\"],\\n\\tpriority: 101\\n};\\n\\nDownloadSaver2.prototype.getMimeType = function(filename) {\\n\\tif (filename.endsWith(\\\".zip\\\")) {\\n\\t\\treturn \\\"application/zip;base64\\\";\\n\\t}\\n\\telse {\\n\\t\\treturn \\\"text/html\\\";\\n\\t}\\n};\\n\\n/*\\nStatic method that returns true if this saver is capable of working\\n*/\\nexports.canSave = function(wiki) {\\n\\treturn document.createElement(\\\"a\\\").download !== undefined;\\n};\\n\\n/*\\nCreate an instance of this saver\\n*/\\nexports.create = function(wiki) {\\n\\treturn new DownloadSaver2(wiki);\\n};\\n\\n})();\\n\"},\"$:/plugins/cdaven/markdown-export/exportNote\":{\"title\":\"$:/plugins/cdaven/markdown-export/exportNote\",\"created\":\"20220602113244086\",\"description\":\"A note that will be added as a comment to exported Markdown files\",\"modified\":\"20220602113609303\",\"tags\":\"\",\"text\":\"Exported from TiddlyWiki at <<now>>\"},\"$:/plugins/cdaven/markdown-export/exporttarget\":{\"title\":\"$:/plugins/cdaven/markdown-export/exporttarget\",\"created\":\"20241230085243526\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"pandoc\"},\"$:/plugins/cdaven/markdown-export/icon\":{\"title\":\"$:/plugins/cdaven/markdown-export/icon\",\"created\":\"20240502135950835\",\"modified\":\"20240503190926146\",\"tags\":\"\",\"text\":\"\\\\parameters (size:\\\"22pt\\\")\\n<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=<<size>> height=<<size>> viewBox=\\\"0 0 208 128\\\"><path d=\\\"M30 98V30h20l20 25 20-25h20v68H90V59L70 84 50 59v39zm125 0l-30-33h20V30h20v35h20z\\\"/></svg>\"},\"$:/plugins/cdaven/markdown-export/license\":{\"title\":\"$:/plugins/cdaven/markdown-export/license\",\"created\":\"20220513163358248\",\"modified\":\"20220513163418690\",\"tags\":\"\",\"text\":\"Copyright 2022-2024 Christian Dav√©n and contributors\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \\\"Software\\\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\"},\"$:/plugins/cdaven/markdown-export/markdown-export.js\":{\"title\":\"$:/plugins/cdaven/markdown-export/markdown-export.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/cdaven/markdown-export/markdown-export.js\\r\\ntype: application/javascript\\r\\nmodule-type: macro\\r\\n\\\\*/\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.run = exports.params = exports.name = void 0;\\r\\nconst render_helpers_js_1 = require(\\\"./render-helpers.js\\\");\\r\\nconst render_js_1 = require(\\\"./render.js\\\");\\r\\nconst zip_archive_js_1 = require(\\\"./zip-archive.js\\\");\\r\\nexports.name = \\\"markdown-export\\\";\\r\\nexports.params = [\\r\\n    {\\r\\n        name: \\\"filter\\\",\\r\\n        default: \\\"\\\"\\r\\n    },\\r\\n    {\\r\\n        name: \\\"note\\\",\\r\\n        default: \\\"\\\"\\r\\n    },\\r\\n    {\\r\\n        name: \\\"version\\\",\\r\\n        default: \\\"\\\"\\r\\n    },\\r\\n    {\\r\\n        name: \\\"extension\\\",\\r\\n        default: \\\".md\\\"\\r\\n    },\\r\\n];\\r\\n/** LaTeX page break, recognized by Pandoc */\\r\\nconst pageBreak = \\\"\\\\n\\\\n\\\\\\\\newpage\\\\n\\\\n\\\";\\r\\n/** Title of temporary zip tiddler */\\r\\nconst tempZipTiddler = \\\"$:/temp/cdaven/markdown.zip\\\";\\r\\n/** The macro entrypoint */\\r\\nfunction run(filter = \\\"\\\", note = \\\"\\\", version = \\\"\\\", extension = \\\".md\\\") {\\r\\n    console.log(`Running Markdown Export ${version} with filter ${filter} and extension ${extension}`);\\r\\n    if (!filter) {\\r\\n        console.warn(\\\"No filter specified, exiting\\\");\\r\\n        return \\\"\\\";\\r\\n    }\\r\\n    const createArchive = extension == \\\".zip\\\";\\r\\n    const exportTarget = (0, render_helpers_js_1.getExportTarget)();\\r\\n    const twRenderer = new render_js_1.TiddlyWikiRenderer($tw);\\r\\n    const renderer = new render_js_1.MarkdownRenderer(twRenderer, exportTarget);\\r\\n    let markdownTiddlers = [];\\r\\n    for (const title of $tw.wiki.filterTiddlers(filter)) {\\r\\n        let markdownTiddler = null;\\r\\n        try {\\r\\n            markdownTiddler = renderer.renderTiddler(title);\\r\\n        }\\r\\n        catch (err) {\\r\\n            console.error(err);\\r\\n        }\\r\\n        if (markdownTiddler) {\\r\\n            markdownTiddlers.push({\\r\\n                title: title,\\r\\n                text: markdownTiddler.trim()\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n    if (createArchive) {\\r\\n        let zipArchive = new zip_archive_js_1.ZipArchive(tempZipTiddler);\\r\\n        if (!zipArchive.isEnabled()) {\\r\\n            console.error(\\\"JSZip plugin is required for generating zip archives\\\");\\r\\n            return \\\"\\\";\\r\\n        }\\r\\n        for (const mdTiddler of markdownTiddlers) {\\r\\n            zipArchive.addFile((0, render_helpers_js_1.titleToFilename)(mdTiddler.title, exportTarget) + \\\".md\\\", mdTiddler.text);\\r\\n        }\\r\\n        return zipArchive.toBase64();\\r\\n    }\\r\\n    else {\\r\\n        return markdownTiddlers.map(t => t.text).join(pageBreak);\\r\\n    }\\r\\n}\\r\\nexports.run = run;\\r\\n;\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/cdaven/markdown-export/md-tiddler.js\":{\"title\":\"$:/plugins/cdaven/markdown-export/md-tiddler.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/cdaven/markdown-export/md-tiddler.js\\r\\ntype: application/javascript\\r\\nmodule-type: macro\\r\\n\\r\\nMacro to output a single tiddler to Markdown, e.g. for use with a template, possibly from the command line.\\r\\n\\\\*/\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.run = exports.params = exports.name = void 0;\\r\\nconst render_helpers_js_1 = require(\\\"./render-helpers.js\\\");\\r\\nconst render_js_1 = require(\\\"./render.js\\\");\\r\\nexports.name = \\\"mdtiddler\\\";\\r\\nexports.params = [\\r\\n    {\\r\\n        name: \\\"title\\\",\\r\\n        default: \\\"\\\"\\r\\n    },\\r\\n];\\r\\n/** The macro entrypoint */\\r\\nfunction run(title = \\\"\\\") {\\r\\n    title = title || this.getVariable(\\\"currentTiddler\\\");\\r\\n    if (!title) {\\r\\n        console.warn(\\\"No title specified, exiting\\\");\\r\\n        return \\\"\\\";\\r\\n    }\\r\\n    if (title === \\\"$:/plugins/cdaven/markdown-export/md-tiddler\\\") {\\r\\n        // TODO: This avoids a Javascript error, but there should be a better solution\\r\\n        console.warn(\\\"Shouldn't render itself...?\\\");\\r\\n        return \\\"\\\";\\r\\n    }\\r\\n    const exportTarget = (0, render_helpers_js_1.getExportTarget)();\\r\\n    const twRenderer = new render_js_1.TiddlyWikiRenderer($tw);\\r\\n    const renderer = new render_js_1.MarkdownRenderer(twRenderer, exportTarget);\\r\\n    return renderer.renderTiddler(title) || \\\"\\\";\\r\\n}\\r\\nexports.run = run;\\r\\n;\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/cdaven/markdown-export/md-tiddler\":{\"title\":\"$:/plugins/cdaven/markdown-export/md-tiddler\",\"created\":\"20220606063844580\",\"text\":\"<!--\\n\\nThis template is used for saving tiddlers as Markdown\\n\\n--><$text text=<<mdtiddler>>/>\"},\"$:/plugins/cdaven/markdown-export/MenuItem\":{\"title\":\"$:/plugins/cdaven/markdown-export/MenuItem\",\"created\":\"20220421104331124\",\"description\":\"Markdown\",\"extension\":\".md\",\"modified\":\"20240502192724034\",\"tags\":\"$:/tags/Exporter\",\"text\":\"<$transclude $variable=\\\"markdown-export\\\" filter=<<exportFilter>> note={{$:/plugins/cdaven/markdown-export/exportNote}} version={{$:/plugins/cdaven/markdown-export!!version}} $output=\\\"text/raw\\\"/>\"},\"$:/plugins/cdaven/markdown-export/MenuItemZip\":{\"title\":\"$:/plugins/cdaven/markdown-export/MenuItemZip\",\"created\":\"20220421104331124\",\"description\":\"Markdown (.zip archive)\",\"extension\":\".zip\",\"modified\":\"20240502192724034\",\"tags\":\"$:/tags/Exporter\",\"text\":\"<$transclude $variable=\\\"markdown-export\\\" filter=<<exportFilter>> note={{$:/plugins/cdaven/markdown-export/exportNote}} version={{$:/plugins/cdaven/markdown-export!!version}} extension=\\\".zip\\\" $output=\\\"text/raw\\\"/>\"},\"$:/plugins/cdaven/markdown-export/readme\":{\"title\":\"$:/plugins/cdaven/markdown-export/readme\",\"created\":\"20220513163340267\",\"modified\":\"20240504050636805\",\"text\":\"This is a plugin for ~TiddlyWiki that lets you export tiddlers to Markdown, either in the web browser or on the command line.\\n\\n<style type=\\\"text/css\\\">\\nh3 svg, p svg {\\n    height: 1rem;\\n    padding: 0;\\n}\\n</style>\\n\\n!! In the browser (or similar graphical user interfaces)\\n\\n!!! Markdown button\\n\\nClick the \\\"Markdown\\\" button ({{$:/plugins/cdaven/markdown-export/icon}}) on any tiddler and pick between copying the tiddler's contents as Markdown to the clipboard, open a temporary tiddler with the Markdown code, or download the tiddler as a Markdown file.\\n\\nHide or move this button here: [[$:/core/ui/ControlPanel/Toolbars]]\\n\\n!!! Export tiddlers button\\n\\nClick the \\\"Export tiddler\\\" button ({{$:/core/images/export-button}}) or menu item on the tiddler to export, and select \\\"Markdown\\\". A Markdown file will be generated and downloaded.\\n\\nYou can also use the \\\"Export tiddlers\\\" button from [[$:/AdvancedSearch]] in the \\\"Filter\\\" tab, to export many tiddlers to one big Markdown file.\\n\\nIf you export multiple tiddlers, it is recommended to select \\\"Markdown (.zip archive)\\\", since each tiddler will then be saved to its own Markdown file in the zip archive.\\n\\n!! On the command line\\n\\nUse the [[TiddlyWiki command installable via npm|https://www.npmjs.com/package/tiddlywiki]] and type something like this:\\n\\n```sh\\ntiddlywiki <folder> --render <tiddler> '[encodeuricomponent[]addsuffix[.md]]' 'text/plain' '$:/plugins/cdaven/markdown-export/md-tiddler'\\n```\\n\\n!! Exporting to Different Targets\\n\\nFrom version 0.9, you can export to different \\\"targets\\\" to get slightly different results.\\n\\nThe default target is `pandoc`, which is how the plugin has always worked until now.\\n\\nYou can also select `obsidian` or `logseq`.\\n\\nSet the export target by editing [[$:/plugins/cdaven/markdown-export/exporttarget]].\\n\\n!! Homepage\\n\\nThis plugin's homepage is at https://cdaven.github.io/tiddlywiki/\\n\\n!! Source Code\\n\\nThe source code is available at https://github.com/cdaven/tiddlywiki-stuff/tree/main/markdown-export -- this is where you can report issues or request features.\"},\"$:/plugins/cdaven/markdown-export/render-helpers.js\":{\"title\":\"$:/plugins/cdaven/markdown-export/render-helpers.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/cdaven/markdown-export/render-helpers.js\\r\\ntype: application/javascript\\r\\nmodule-type: library\\r\\n\\\\*/\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.getExportTarget = exports.titleToFilename = exports.latex_htmldecode = exports.formatLogseqPropertyValue = exports.formatYamlPropertyValue = exports.formatDate = exports.isOnlyNodeInBlock = exports.isTWDate = exports.isDomNode = exports.isTextNode = exports.trimEnd = exports.btoa = exports.Node = void 0;\\r\\n/* Polyfill browser stuff when run from Node.js */\\r\\nexports.Node = globalThis.Node || {\\r\\n    ELEMENT_NODE: 1,\\r\\n    TEXT_NODE: 3,\\r\\n};\\r\\n/* Polyfill browser stuff when run from Node.js */\\r\\nexports.btoa = globalThis.btoa || function (data) {\\r\\n    const ascii = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\\r\\n    let len = data.length - 1, i = -1, b64 = '';\\r\\n    while (i < len) {\\r\\n        const code = data.charCodeAt(++i) << 16 | data.charCodeAt(++i) << 8 | data.charCodeAt(++i);\\r\\n        b64 += ascii[(code >>> 18) & 63] + ascii[(code >>> 12) & 63] + ascii[(code >>> 6) & 63] + ascii[code & 63];\\r\\n    }\\r\\n    const pads = data.length % 3;\\r\\n    if (pads > 0) {\\r\\n        b64 = b64.slice(0, pads - 3);\\r\\n        while (b64.length % 4 !== 0) {\\r\\n            b64 += '=';\\r\\n        }\\r\\n    }\\r\\n    return b64;\\r\\n};\\r\\nfunction trimEnd(s) {\\r\\n    return s.replace(/\\\\s+$/, \\\"\\\");\\r\\n}\\r\\nexports.trimEnd = trimEnd;\\r\\nfunction isTextNode(node) {\\r\\n    if (node.nodeType === exports.Node.TEXT_NODE)\\r\\n        return true;\\r\\n    else if (typeof node.nodeType === \\\"undefined\\\")\\r\\n        return node.hasOwnProperty(\\\"textContent\\\");\\r\\n    else\\r\\n        return false;\\r\\n}\\r\\nexports.isTextNode = isTextNode;\\r\\nfunction isDomNode(node) {\\r\\n    if (node.nodeType === exports.Node.ELEMENT_NODE)\\r\\n        return true;\\r\\n    else if (typeof node.nodeType === \\\"undefined\\\")\\r\\n        return node.hasOwnProperty(\\\"children\\\");\\r\\n    else\\r\\n        return false;\\r\\n}\\r\\nexports.isDomNode = isDomNode;\\r\\nfunction isTWDate(value) {\\r\\n    return value\\r\\n        && (typeof value[\\\"toISOString\\\"] === \\\"function\\\"\\r\\n            || datePatternTW.test(value));\\r\\n}\\r\\nexports.isTWDate = isTWDate;\\r\\n/** Check if the node is the only node in the paragraph or block */\\r\\nfunction isOnlyNodeInBlock(node) {\\r\\n    return node.parentNode\\r\\n        && (node.parentNode.tag == \\\"p\\\" || node.parentNode.tag == \\\"div\\\")\\r\\n        && node.parentNode.children.length == 1;\\r\\n}\\r\\nexports.isOnlyNodeInBlock = isOnlyNodeInBlock;\\r\\n/** TW date format (spaces added for clarity): [UTC] YYYY 0MM 0DD 0hh 0mm 0ss 0XXX */\\r\\nconst datePatternTW = /^(\\\\d{4})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{3})$/;\\r\\nfunction formatDate(fieldValue) {\\r\\n    let isoString = \\\"\\\";\\r\\n    if (typeof fieldValue[\\\"toISOString\\\"] === \\\"function\\\") {\\r\\n        isoString = fieldValue.toISOString();\\r\\n    }\\r\\n    else if (datePatternTW.test(fieldValue)) {\\r\\n        const parsedDate = new Date($tw.utils.parseDate(fieldValue));\\r\\n        isoString = parsedDate.toISOString();\\r\\n    }\\r\\n    else {\\r\\n        console.error(`${fieldValue} is not a valid date`);\\r\\n        return null;\\r\\n    }\\r\\n    // Remove \\\".123Z\\\" suffix (milliseconds and UTC marker),\\r\\n    // so that it matches Obsidian's \\\"date & time\\\" type.\\r\\n    return isoString.substring(0, isoString.lastIndexOf(\\\".\\\"));\\r\\n}\\r\\nexports.formatDate = formatDate;\\r\\n/** Format property values for the YAML frontmatter */\\r\\nfunction formatYamlPropertyValue(fieldValue, enableNumbers = true) {\\r\\n    if (isTWDate(fieldValue)) {\\r\\n        return formatDate(fieldValue);\\r\\n    }\\r\\n    else if (enableNumbers && !isNaN(parseFloat(fieldValue)) && isFinite(fieldValue)) {\\r\\n        return fieldValue.toString();\\r\\n    }\\r\\n    else {\\r\\n        return '\\\"' +\\r\\n            fieldValue.toString()\\r\\n                // Remove newlines\\r\\n                .replace(/[\\\\r\\\\n]+/g, \\\" \\\")\\r\\n                // Escape backslashes\\r\\n                .replace(/\\\\\\\\/g, \\\"\\\\\\\\\\\\\\\\\\\")\\r\\n                // Escape double quotes\\r\\n                .replace(/\\\"/g, '\\\\\\\\\\\"')\\r\\n            + '\\\"';\\r\\n    }\\r\\n}\\r\\nexports.formatYamlPropertyValue = formatYamlPropertyValue;\\r\\n/** Format property values for the Logseq frontmatter */\\r\\nfunction formatLogseqPropertyValue(fieldValue, enableNumbers = true) {\\r\\n    if (isTWDate(fieldValue)) {\\r\\n        return formatDate(fieldValue);\\r\\n    }\\r\\n    else if (enableNumbers && !isNaN(parseFloat(fieldValue)) && isFinite(fieldValue)) {\\r\\n        return fieldValue.toString();\\r\\n    }\\r\\n    else {\\r\\n        // Remove newlines\\r\\n        return fieldValue.toString().replace(/[\\\\r\\\\n]+/g, \\\" \\\");\\r\\n    }\\r\\n}\\r\\nexports.formatLogseqPropertyValue = formatLogseqPropertyValue;\\r\\n/** Decode HTML special entities <, >, & that can be used in LaTeX math */\\r\\nfunction latex_htmldecode(s) {\\r\\n    return s.replace(/&lt;|&gt;|&amp;/g, match => ({\\r\\n        \\\"&lt;\\\": \\\"<\\\",\\r\\n        \\\"&gt;\\\": \\\">\\\",\\r\\n        \\\"&amp;\\\": \\\"&\\\"\\r\\n    }[match]));\\r\\n}\\r\\nexports.latex_htmldecode = latex_htmldecode;\\r\\n/** Escape special characters in title so it can be used as a filename */\\r\\nfunction titleToFilename(title, exportTarget) {\\r\\n    let filename = title;\\r\\n    if (filename[0] == \\\".\\\") {\\r\\n        // Escape leading dot in filename √† la Logseq\\r\\n        // Seems like a good enough default in all cases\\r\\n        filename = \\\"%2E\\\" + filename.substring(1);\\r\\n    }\\r\\n    if (exportTarget == \\\"logseq\\\") {\\r\\n        // Escape triple underscores (corresponds to / in Logseq)\\r\\n        filename = filename.replace(\\\"___\\\", \\\"%5F%5F%5F\\\");\\r\\n        if (filename[filename.length - 1] == \\\".\\\") {\\r\\n            // Escape trailing dot in filename (don't know why Logseq does this)\\r\\n            filename = filename.substring(0, filename.length - 1) + \\\".___\\\";\\r\\n        }\\r\\n        return filename.replace(/<|>|:|\\\\*|\\\\?|\\\\||\\\\\\\\|\\\\/|\\\"|#/g, match => ({\\r\\n            \\\"<\\\": \\\"%3C\\\",\\r\\n            \\\">\\\": \\\"%3E\\\",\\r\\n            \\\":\\\": \\\"%3A\\\",\\r\\n            \\\"*\\\": \\\"%2A\\\",\\r\\n            \\\"?\\\": \\\"%3F\\\",\\r\\n            \\\"|\\\": \\\"%7C\\\",\\r\\n            \\\"\\\\\\\\\\\": \\\"%5C\\\",\\r\\n            \\\"\\\\\\\"\\\": \\\"%22\\\",\\r\\n            \\\"#\\\": \\\"%23\\\",\\r\\n            // Forward slash is used to create a hierarchy,\\r\\n            // but all files are still in the same folder\\r\\n            \\\"/\\\": \\\"___\\\",\\r\\n        }[match]));\\r\\n    }\\r\\n    else {\\r\\n        // Obsidian accepts some \\\"special characters\\\" in wikilinks,\\r\\n        // that are also accepted by the operating systems. Forward\\r\\n        // slashes are retained, so that we can create a folder structure\\r\\n        // in a zip archive. I believe Pandoc and Obsidian could be\\r\\n        // handled with the same logic here.\\r\\n        return filename.replace(/<|>|:|\\\\*|\\\\?|\\\\||\\\\\\\\|\\\"|#/g, match => ({\\r\\n            \\\"<\\\": \\\"%3C\\\",\\r\\n            \\\">\\\": \\\"%3E\\\",\\r\\n            \\\":\\\": \\\"%3A\\\",\\r\\n            \\\"*\\\": \\\"%2A\\\",\\r\\n            \\\"?\\\": \\\"%3F\\\",\\r\\n            \\\"|\\\": \\\"%7C\\\",\\r\\n            \\\"\\\\\\\\\\\": \\\"%5C\\\",\\r\\n            \\\"\\\\\\\"\\\": \\\"%22\\\",\\r\\n            \\\"#\\\": \\\"%23\\\",\\r\\n            // Keep forward slashes to create a folder structure\\r\\n        }[match]));\\r\\n    }\\r\\n}\\r\\nexports.titleToFilename = titleToFilename;\\r\\nconst validExportTargets = [\\\"pandoc\\\", \\\"obsidian\\\", \\\"logseq\\\"];\\r\\nconst defaultExportTarget = \\\"pandoc\\\";\\r\\nfunction isValidExportTarget(value) {\\r\\n    return validExportTargets.indexOf(value) !== -1;\\r\\n}\\r\\nfunction getSetting(title, defaultValue) {\\r\\n    const tiddler = $tw.wiki.getTiddler(title);\\r\\n    if (tiddler) {\\r\\n        return tiddler.fields.text || defaultValue;\\r\\n    }\\r\\n    else {\\r\\n        return defaultValue;\\r\\n    }\\r\\n}\\r\\nfunction getExportTarget() {\\r\\n    const value = getSetting(\\\"$:/plugins/cdaven/markdown-export/exporttarget\\\", defaultExportTarget).toLowerCase();\\r\\n    return isValidExportTarget(value) ? value : defaultExportTarget;\\r\\n}\\r\\nexports.getExportTarget = getExportTarget;\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/cdaven/markdown-export/render-rules.js\":{\"title\":\"$:/plugins/cdaven/markdown-export/render-rules.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/cdaven/markdown-export/render-rules.js\\r\\ntype: application/javascript\\r\\nmodule-type: library\\r\\n\\\\*/\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.getAnchorRule = exports.getMetaRule = exports.getDefaultRules = void 0;\\r\\nconst render_helpers_1 = require(\\\"./render-helpers\\\");\\r\\n/** Get rules for rendering a TiddlyWiki widget tree consisting of HTML-ish elements/nodes */\\r\\nfunction getDefaultRules(renderer) {\\r\\n    let rules = {\\r\\n        \\\"p\\\": (node, im) => {\\r\\n            var _a;\\r\\n            if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.tag) === \\\"li\\\") {\\r\\n                const newlines = renderer.isLastChild(node)\\r\\n                    ? \\\"\\\\n\\\" // End with one newline for the last child\\r\\n                    : \\\"\\\\n\\\\n\\\"; // End with two newlines between paragraphs\\r\\n                if (node.parentNode.children[0] == node) {\\r\\n                    // The first <p> inside a <li> is rendered as inline text\\r\\n                    return `${im.trim()}${newlines}`;\\r\\n                }\\r\\n                else {\\r\\n                    // Subsequent <p> inside a <li> is rendered with indentation\\r\\n                    return `    ${im.trim()}${newlines}`;\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                // Add newlines after paragraphs\\r\\n                return `${im.trim()}\\\\n\\\\n`;\\r\\n            }\\r\\n        },\\r\\n        \\\"em\\\": (_, im) => `*${im}*`,\\r\\n        \\\"strong\\\": (_, im) => `**${im}**`,\\r\\n        \\\"u\\\": (_, im) => `<u>${im}</u>`,\\r\\n        \\\"strike\\\": (_, im) => `~~${im}~~`,\\r\\n        // Force line-break\\r\\n        \\\"br\\\": (node) => {\\r\\n            const nextNode = renderer.getNextNode(node);\\r\\n            if (nextNode == null || ((0, render_helpers_1.isTextNode)(nextNode) && nextNode.textContent === \\\"\\\\n\\\")) {\\r\\n                // If the next line is blank, shouldn't end with a \\\\\\r\\n                return \\\"\\\\n\\\";\\r\\n            }\\r\\n            else {\\r\\n                return \\\"\\\\\\\\\\\\n\\\";\\r\\n            }\\r\\n        },\\r\\n        \\\"hr\\\": () => `---\\\\n\\\\n`,\\r\\n        \\\"label\\\": (_, im) => im,\\r\\n        // Pandoc 3.0 supports highlighted text using ==, if you specify --from markdown+mark\\r\\n        \\\"mark\\\": (_, im) => `==${im}==`,\\r\\n        \\\"span\\\": (node, im) => {\\r\\n            const katexStart = '<annotation encoding=\\\"application/x-tex\\\">';\\r\\n            if (node.rawHTML && node.rawHTML.indexOf(katexStart) !== -1) {\\r\\n                let mathEq = node.rawHTML.substring(node.rawHTML.indexOf(katexStart) + katexStart.length);\\r\\n                // The raw HTML is encoded here, but we need to decode at least LaTeX-specific characters such as <, >, &\\r\\n                mathEq = (0, render_helpers_1.latex_htmldecode)(mathEq.substring(0, mathEq.indexOf('</annotation>')));\\r\\n                if ((0, render_helpers_1.isOnlyNodeInBlock)(node) || (mathEq.startsWith(\\\"\\\\n\\\") && mathEq.endsWith(\\\"\\\\n\\\"))) {\\r\\n                    // As a block equation\\r\\n                    return `$$${(0, render_helpers_1.trimEnd)(mathEq)}\\\\n$$\\\\n\\\\n`;\\r\\n                }\\r\\n                else {\\r\\n                    // As an inline equation\\r\\n                    return `$${mathEq}$`;\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                return im;\\r\\n            }\\r\\n        },\\r\\n        \\\"sub\\\": (_, im) => `~${im.replace(/ /g, \\\"\\\\\\\\ \\\")}~`,\\r\\n        \\\"sup\\\": (_, im) => `^${im.replace(/ /g, \\\"\\\\\\\\ \\\")}^`,\\r\\n        \\\"h1\\\": (_, im) => `# ${im}\\\\n\\\\n`,\\r\\n        \\\"h2\\\": (_, im) => `## ${im}\\\\n\\\\n`,\\r\\n        \\\"h3\\\": (_, im) => `### ${im}\\\\n\\\\n`,\\r\\n        \\\"h4\\\": (_, im) => `#### ${im}\\\\n\\\\n`,\\r\\n        // Definition lists\\r\\n        \\\"dl\\\": (_, im) => `${im.trim()}\\\\n\\\\n`,\\r\\n        \\\"dt\\\": (_, im) => `${im}\\\\n`,\\r\\n        \\\"dd\\\": (_, im) => ` ~ ${im}\\\\n\\\\n`,\\r\\n        // Code blocks\\r\\n        \\\"pre\\\": (node, im) => {\\r\\n            if (node.children.every(child => (0, render_helpers_1.isDomNode)(child) && child.tag === \\\"code\\\")) {\\r\\n                // <pre> with nested <code> elements, just pass through\\r\\n                return im;\\r\\n            }\\r\\n            else {\\r\\n                // <pre> without nested <code>\\r\\n                return `\\\\`\\\\`\\\\`\\\\n${im.trim()}\\\\n\\\\`\\\\`\\\\`\\\\n\\\\n`;\\r\\n            }\\r\\n        },\\r\\n        \\\"code\\\": (node, im) => {\\r\\n            var _a, _b, _c;\\r\\n            if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.tag) === \\\"pre\\\") {\\r\\n                // <code> nested inside <pre>\\r\\n                // The Highlight plugin puts the language in the \\\"class\\\" attribute\\r\\n                let classRx = (_c = (_b = node.attributes) === null || _b === void 0 ? void 0 : _b.class) === null || _c === void 0 ? void 0 : _c.match(/^(.+) hljs$/);\\r\\n                if (classRx) {\\r\\n                    const lang = classRx[1];\\r\\n                    return `\\\\`\\\\`\\\\`${lang}\\\\n${im.trim()}\\\\n\\\\`\\\\`\\\\`\\\\n\\\\n`;\\r\\n                }\\r\\n                else {\\r\\n                    return `\\\\`\\\\`\\\\`\\\\n${im.trim()}\\\\n\\\\`\\\\`\\\\`\\\\n\\\\n`;\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                // As inline code\\r\\n                return `\\\\`${im}\\\\``;\\r\\n            }\\r\\n        },\\r\\n        \\\"blockquote\\\": (node, im) => {\\r\\n            var _a;\\r\\n            let indentation = \\\"\\\";\\r\\n            if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.tag) === \\\"li\\\") {\\r\\n                indentation = \\\"    \\\";\\r\\n            }\\r\\n            // Insert \\\"> \\\" at the beginning of each line\\r\\n            const prefix = `${indentation}> `;\\r\\n            return `${prefix}${im.trim().replace(/\\\\n/g, `\\\\n${prefix}`)}\\\\n\\\\n`;\\r\\n        },\\r\\n        \\\"cite\\\": (_, im) => {\\r\\n            return `<cite>${im}</cite>`;\\r\\n        },\\r\\n        // Lists\\r\\n        \\\"ul\\\": (node, im) => {\\r\\n            var _a;\\r\\n            if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.tag) === \\\"li\\\") {\\r\\n                // Nested list, should not end with double newlines\\r\\n                return `\\\\n${im}`;\\r\\n            }\\r\\n            else {\\r\\n                return `${im.trim()}\\\\n\\\\n`;\\r\\n            }\\r\\n        },\\r\\n        \\\"li\\\": (node, im) => {\\r\\n            let curNode = node.parentNode;\\r\\n            if (curNode == null) {\\r\\n                console.error(\\\"Found <li> without parent\\\");\\r\\n                return null;\\r\\n            }\\r\\n            const listType = curNode.tag === \\\"ul\\\" ? \\\"*\\\" : \\\"1.\\\";\\r\\n            const listTags = [\\\"ul\\\", \\\"ol\\\", \\\"li\\\"];\\r\\n            let depth = -1;\\r\\n            // Traverse up the path to count nesting levels\\r\\n            while (curNode && listTags.indexOf(curNode.tag) !== -1) {\\r\\n                if (curNode.tag !== \\\"li\\\") {\\r\\n                    depth++;\\r\\n                }\\r\\n                curNode = curNode.parentNode;\\r\\n            }\\r\\n            const indent = \\\"    \\\".repeat(depth);\\r\\n            return `${indent}${listType} ${im.trim()}\\\\n`;\\r\\n        },\\r\\n        \\\"input\\\": (node) => {\\r\\n            var _a, _b;\\r\\n            if (((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.type) === \\\"checkbox\\\") {\\r\\n                if ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.checked) {\\r\\n                    return \\\"[x]\\\";\\r\\n                }\\r\\n                else {\\r\\n                    return \\\"[ ]\\\";\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                console.warn(\\\"Unsupported input node type\\\", node);\\r\\n                return null;\\r\\n            }\\r\\n        },\\r\\n        \\\"img\\\": (node) => {\\r\\n            var _a, _b;\\r\\n            // TODO: If in zip archive mode, and the image is \\\"local\\\",\\r\\n            // create a Markdown image link instead of inlining\\r\\n            let caption = ((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.title) || \\\"\\\";\\r\\n            let src = ((_b = node.attributes) === null || _b === void 0 ? void 0 : _b.src) || \\\"\\\";\\r\\n            const svgPrefix = \\\"data:image/svg+xml,\\\";\\r\\n            if (src.startsWith(svgPrefix)) {\\r\\n                // SVGs should also be Base64-encoded for compatibility\\r\\n                src = svgPrefix.replace(\\\"svg+xml,\\\", \\\"svg+xml;base64,\\\") +\\r\\n                    (0, render_helpers_1.btoa)(decodeURIComponent(src.substring(svgPrefix.length)));\\r\\n            }\\r\\n            return `![${caption}](${src})`;\\r\\n        },\\r\\n        \\\"i\\\": (node, im) => {\\r\\n            var _a;\\r\\n            if ((_a = node.attributes) === null || _a === void 0 ? void 0 : _a.class) {\\r\\n                const classes = node.attributes.class.split(\\\" \\\");\\r\\n                if (im.trim().length === 0 && classes.some(c => c.startsWith(\\\"fa-\\\"))) {\\r\\n                    // Lazily render all FontAwesome icons as a replacement character\\r\\n                    return \\\"ÔøΩ\\\";\\r\\n                }\\r\\n            }\\r\\n            return null;\\r\\n        },\\r\\n        // Tables\\r\\n        \\\"table\\\": (node) => {\\r\\n            let tbody = null;\\r\\n            for (const child of node.children) {\\r\\n                if ((0, render_helpers_1.isDomNode)(child) && child.tag === \\\"tbody\\\") {\\r\\n                    tbody = child;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            if (tbody == null) {\\r\\n                return null;\\r\\n            }\\r\\n            let thead = null;\\r\\n            for (const child of node.children) {\\r\\n                if ((0, render_helpers_1.isDomNode)(child) && child.tag === \\\"thead\\\") {\\r\\n                    thead = child;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            const justifyLeft = (s, w) => {\\r\\n                const sLen = (s === null || s === void 0 ? void 0 : s.length) || 0;\\r\\n                return s + ' '.repeat(w - sLen);\\r\\n            };\\r\\n            const justifyRight = (s, w) => {\\r\\n                const sLen = (s === null || s === void 0 ? void 0 : s.length) || 0;\\r\\n                return ' '.repeat(w - sLen) + s;\\r\\n            };\\r\\n            const center = (s, w) => {\\r\\n                const sLen = (s === null || s === void 0 ? void 0 : s.length) || 0;\\r\\n                const spacesLeft = Math.ceil((w - sLen) / 2);\\r\\n                const spacesRight = w - sLen - spacesLeft;\\r\\n                return ' '.repeat(spacesLeft) + s + ' '.repeat(spacesRight);\\r\\n            };\\r\\n            let grid = [];\\r\\n            if (thead != null) {\\r\\n                for (const row of thead.children) {\\r\\n                    if ((0, render_helpers_1.isDomNode)(row) && row.tag === \\\"tr\\\") {\\r\\n                        let cellsInCurrentRow = [];\\r\\n                        for (const cell of row.children) {\\r\\n                            if ((0, render_helpers_1.isDomNode)(cell)) {\\r\\n                                cellsInCurrentRow.push({\\r\\n                                    innerMarkup: renderer.renderNode(cell),\\r\\n                                    header: cell.tag === \\\"th\\\",\\r\\n                                    align: cell.attributes.align,\\r\\n                                });\\r\\n                            }\\r\\n                        }\\r\\n                        grid.push(cellsInCurrentRow);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            for (const row of tbody.children) {\\r\\n                if ((0, render_helpers_1.isDomNode)(row) && row.tag === \\\"tr\\\") {\\r\\n                    let cellsInCurrentRow = [];\\r\\n                    for (const cell of row.children) {\\r\\n                        if ((0, render_helpers_1.isDomNode)(cell)) {\\r\\n                            cellsInCurrentRow.push({\\r\\n                                innerMarkup: renderer.renderNode(cell),\\r\\n                                header: cell.tag === \\\"th\\\",\\r\\n                                align: cell.attributes.align,\\r\\n                            });\\r\\n                        }\\r\\n                    }\\r\\n                    if (cellsInCurrentRow.length > 0) {\\r\\n                        grid.push(cellsInCurrentRow);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            let columnWidths = [];\\r\\n            for (let i = 0; i < grid[0].length; i++) {\\r\\n                // Check max length of each column's inner markup\\r\\n                columnWidths.push(Math.max(...grid.map(row => { var _a; return ((_a = row[i].innerMarkup) === null || _a === void 0 ? void 0 : _a.length) || 0; })));\\r\\n            }\\r\\n            let tableMarkup = [];\\r\\n            let isFirstRow = true;\\r\\n            for (const row of grid) {\\r\\n                let rowMarkup = [];\\r\\n                for (const column in row) {\\r\\n                    const cell = row[column];\\r\\n                    const innerMarkup = cell.innerMarkup;\\r\\n                    const columnWidth = columnWidths[column];\\r\\n                    if (cell.align === \\\"center\\\") {\\r\\n                        rowMarkup.push(center(innerMarkup, columnWidth));\\r\\n                    }\\r\\n                    else if (cell.align === \\\"right\\\") {\\r\\n                        rowMarkup.push(justifyRight(innerMarkup, columnWidth));\\r\\n                    }\\r\\n                    else {\\r\\n                        rowMarkup.push(justifyLeft(innerMarkup, columnWidth));\\r\\n                    }\\r\\n                }\\r\\n                tableMarkup.push(\\\"| \\\" + rowMarkup.join(\\\" | \\\") + \\\" |\\\");\\r\\n                if (isFirstRow) {\\r\\n                    // Markdown requires the first row to be a header row\\r\\n                    let rowMarkup = [];\\r\\n                    for (const column in row) {\\r\\n                        const columnWidth = columnWidths[column];\\r\\n                        rowMarkup.push(\\\"-\\\".repeat(columnWidth));\\r\\n                    }\\r\\n                    tableMarkup.push(\\\"|-\\\" + rowMarkup.join(\\\"-|-\\\") + \\\"-|\\\");\\r\\n                    isFirstRow = false;\\r\\n                }\\r\\n            }\\r\\n            return tableMarkup.join(\\\"\\\\n\\\") + \\\"\\\\n\\\\n\\\";\\r\\n        },\\r\\n        // The <tr> tag is handled by the <table> rule\\r\\n        \\\"tr\\\": () => null,\\r\\n        \\\"td\\\": (_, im) => im,\\r\\n        \\\"th\\\": (_, im) => im,\\r\\n        // Generic block element rule\\r\\n        \\\"block\\\": (node, im) => {\\r\\n            if (im.trim().length > 0) {\\r\\n                return `<${node.tag}>${im.trim()}</${node.tag}>\\\\n`;\\r\\n            }\\r\\n            else {\\r\\n                return null;\\r\\n            }\\r\\n        },\\r\\n        // Wildcard rule, catching all other inline elements\\r\\n        \\\"*\\\": (node, im) => {\\r\\n            if (im.trim().length > 0) {\\r\\n                return `<${node.tag}>${im.trim()}</${node.tag}>`;\\r\\n            }\\r\\n            else {\\r\\n                return null;\\r\\n            }\\r\\n        },\\r\\n    };\\r\\n    // Inherit identical rules\\r\\n    rules[\\\"div\\\"] = rules[\\\"p\\\"];\\r\\n    rules[\\\"ol\\\"] = rules[\\\"ul\\\"];\\r\\n    // Generic block elements\\r\\n    rules[\\\"address\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"article\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"aside\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"details\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"dialog\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"fieldset\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"figcaption\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"figure\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"footer\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"form\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"header\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"hgroup\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"main\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"nav\\\"] = rules[\\\"block\\\"];\\r\\n    rules[\\\"section\\\"] = rules[\\\"block\\\"];\\r\\n    return rules;\\r\\n}\\r\\nexports.getDefaultRules = getDefaultRules;\\r\\n/** Get \\\"meta\\\" rule for rendering frontmatter */\\r\\nfunction getMetaRule(renderer, exportTarget) {\\r\\n    return (node, im) => {\\r\\n        const fields = node.attributes;\\r\\n        const metadata = {\\r\\n            title: fields.title,\\r\\n            author: fields.author,\\r\\n            date: fields.modified || fields.created,\\r\\n            abstract: fields.description,\\r\\n            tags: fields.tags,\\r\\n            other: {},\\r\\n        };\\r\\n        for (const field in fields) {\\r\\n            if ([\\\"text\\\", \\\"title\\\", \\\"author\\\", \\\"modified\\\", \\\"description\\\", \\\"tags\\\", \\\"type\\\"].indexOf(field) !== -1)\\r\\n                // Ignore full text and the fields already taken care of, plus \\\"type\\\"\\r\\n                continue;\\r\\n            metadata.other[field] = fields[field];\\r\\n        }\\r\\n        let frontMatter = \\\"\\\";\\r\\n        if (exportTarget == \\\"logseq\\\") {\\r\\n            // Logseq uses its own syntax: https://docs.logseq.com/#/page/properties\\r\\n            let properties = [];\\r\\n            if (metadata.title) {\\r\\n                properties.push(`title:: ${metadata.title}`);\\r\\n            }\\r\\n            if (metadata.author) {\\r\\n                properties.push(`author:: ${metadata.author}`);\\r\\n            }\\r\\n            if (metadata.date) {\\r\\n                properties.push(`date:: ${(0, render_helpers_1.formatDate)(metadata.date)}`);\\r\\n            }\\r\\n            if (metadata.abstract) {\\r\\n                properties.push(`abstract:: ${(0, render_helpers_1.formatLogseqPropertyValue)(metadata.abstract)}`);\\r\\n            }\\r\\n            if (metadata.tags && metadata.tags.length > 0) {\\r\\n                properties.push(`tags:: ${metadata.tags.join(', ')}`);\\r\\n            }\\r\\n            for (const field in metadata.other) {\\r\\n                // Remove all illegal characters from field/property names\\r\\n                const fieldName = field.trim().replace(/\\\\s+/g, \\\"-\\\").replace(/[^a-z0-9.*+!?$%&=<>_-]/gi, \\\"\\\");\\r\\n                if (fieldName.length > 0) {\\r\\n                    properties.push(`${fieldName}:: ${(0, render_helpers_1.formatLogseqPropertyValue)(metadata.other[field])}`);\\r\\n                }\\r\\n            }\\r\\n            frontMatter = `${properties.join(\\\"\\\\n\\\")}\\\\n\\\\n`;\\r\\n        }\\r\\n        else {\\r\\n            // Both Obsidian and Pandoc accepts YAML, but values need not be quoted\\r\\n            let properties = [];\\r\\n            if (metadata.title) {\\r\\n                properties.push(`title: ${(0, render_helpers_1.formatYamlPropertyValue)(metadata.title)}`);\\r\\n            }\\r\\n            if (metadata.author) {\\r\\n                properties.push(`author: ${(0, render_helpers_1.formatYamlPropertyValue)(metadata.author)}`);\\r\\n            }\\r\\n            if (metadata.date) {\\r\\n                properties.push(`date: ${(0, render_helpers_1.formatDate)(metadata.date)}`);\\r\\n            }\\r\\n            if (metadata.abstract) {\\r\\n                properties.push(`abstract: ${(0, render_helpers_1.formatYamlPropertyValue)(metadata.abstract)}`);\\r\\n            }\\r\\n            if (metadata.tags && metadata.tags.length > 0) {\\r\\n                const tags = metadata.tags.map((t) => (0, render_helpers_1.formatYamlPropertyValue)(t, false));\\r\\n                if (exportTarget == \\\"pandoc\\\") {\\r\\n                    // Pandoc expects this in a \\\"keywords\\\" property\\r\\n                    properties.push(`keywords: [${tags.join(', ')}]`);\\r\\n                }\\r\\n                else {\\r\\n                    // Obsidian expects this in a \\\"tags\\\" property\\r\\n                    properties.push(`tags: [${tags.join(', ')}]`);\\r\\n                }\\r\\n            }\\r\\n            for (const field in metadata.other) {\\r\\n                const fieldName = field.trim().replace(/\\\\s+/g, \\\"-\\\").replace(/[\\\\:]+$/, \\\"\\\");\\r\\n                if (fieldName.length) {\\r\\n                    properties.push(`${fieldName}: ${(0, render_helpers_1.formatYamlPropertyValue)(metadata.other[field])}`);\\r\\n                }\\r\\n            }\\r\\n            frontMatter = `---\\\\n${properties.join(\\\"\\\\n\\\")}\\\\n---\\\\n\\\\n`;\\r\\n        }\\r\\n        if (exportTarget == \\\"pandoc\\\") {\\r\\n            // Add h1 header (Logseq and Obsidian already shows the filename/title as header)\\r\\n            frontMatter += `# ${metadata.title}\\\\n\\\\n`;\\r\\n        }\\r\\n        return frontMatter;\\r\\n    };\\r\\n}\\r\\nexports.getMetaRule = getMetaRule;\\r\\n/** Get \\\"a\\\" (anchor) rule for rendering links */\\r\\nfunction getAnchorRule(renderer, exportTarget) {\\r\\n    return (node, im) => {\\r\\n        var _a;\\r\\n        const href = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.href;\\r\\n        if (href === null || href === void 0 ? void 0 : href.startsWith(\\\"#\\\")) {\\r\\n            // Remove leading # character and decode html entities √† la TiddlyWiki\\r\\n            const target = decodeURIComponent(href.substring(1));\\r\\n            const alias = im;\\r\\n            if (exportTarget == \\\"pandoc\\\") {\\r\\n                // Use the common Markdown link syntax to a different file\\r\\n                return `[${alias}](${(0, render_helpers_1.titleToFilename)(target, exportTarget)}.md)`;\\r\\n            }\\r\\n            else if (exportTarget == \\\"logseq\\\") {\\r\\n                // Logseq links should include special characters that will be escaped\\r\\n                // before looking up the corresponding filename\\r\\n                if (target == alias) {\\r\\n                    return `[[${target}]]`;\\r\\n                }\\r\\n                else {\\r\\n                    // Logseq alias syntax\\r\\n                    return `[${alias}]([[${target}]])`;\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (target == alias) {\\r\\n                    return `[[${(0, render_helpers_1.titleToFilename)(target, exportTarget)}]]`;\\r\\n                }\\r\\n                else {\\r\\n                    // Obsidian and Zettlr alias syntax\\r\\n                    return `[[${(0, render_helpers_1.titleToFilename)(target, exportTarget)}|${alias}]]`;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (im && im != href) {\\r\\n            return `[${im}](${href})`;\\r\\n        }\\r\\n        else {\\r\\n            return `<${href}>`;\\r\\n        }\\r\\n    };\\r\\n}\\r\\nexports.getAnchorRule = getAnchorRule;\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/cdaven/markdown-export/render.js\":{\"title\":\"$:/plugins/cdaven/markdown-export/render.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/cdaven/markdown-export/render.js\\r\\ntype: application/javascript\\r\\nmodule-type: library\\r\\n\\\\*/\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.MarkdownRenderer = exports.TiddlyWikiRenderer = void 0;\\r\\nconst render_helpers_js_1 = require(\\\"./render-helpers.js\\\");\\r\\nconst render_rules_js_1 = require(\\\"./render-rules.js\\\");\\r\\n// TODO: Look at/think about https://tiddlywiki.com/static/Creating%2520a%2520custom%2520export%2520format.html\\r\\nclass TiddlyWikiRenderer {\\r\\n    constructor(tw) {\\r\\n        this.tw = tw;\\r\\n        // Imports built-in macros and custom macros in the tiddler, including the $:/tags/Macro/View tag\\r\\n        const macroImport = \\\"[[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]] [all[shadows+tiddlers]tag[$:/tags/Macro/View]!has[draft.of]]\\\";\\r\\n        this.widgetOptions = {\\r\\n            document: $tw.fakeDocument,\\r\\n            mode: \\\"block\\\",\\r\\n            importVariables: macroImport,\\r\\n            recursionMarker: \\\"yes\\\",\\r\\n            variables: {\\r\\n                currentTiddler: null\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n    /** Let TiddlyWiki parse the tiddler text and build a widget tree */\\r\\n    renderWidgetTree(title) {\\r\\n        this.widgetOptions.variables.currentTiddler = title;\\r\\n        const widgetNode = this.tw.wiki.makeTranscludeWidget(title, this.widgetOptions);\\r\\n        const container = this.tw.fakeDocument.createElement(\\\"div\\\");\\r\\n        widgetNode.render(container, null);\\r\\n        // Get the first-level nodes in the tree\\r\\n        return container.children[0].children;\\r\\n    }\\r\\n    /** \\\"Wikify\\\" a WikiText string */\\r\\n    wikifyText(text) {\\r\\n        return this.tw.wiki.renderText(\\\"text/plain\\\", \\\"text/vnd.tiddlywiki\\\", text);\\r\\n    }\\r\\n    /** Get tiddler fields */\\r\\n    getFields(title) {\\r\\n        const tiddler = this.tw.wiki.getTiddler(title);\\r\\n        if (tiddler == null) {\\r\\n            console.warn(\\\"Found no such tiddler\\\", title);\\r\\n            return null;\\r\\n        }\\r\\n        // Clone tiddler fields\\r\\n        return Object.assign({}, tiddler.fields);\\r\\n    }\\r\\n}\\r\\nexports.TiddlyWikiRenderer = TiddlyWikiRenderer;\\r\\nclass MarkdownRenderer {\\r\\n    constructor(tw, target) {\\r\\n        this.tw = tw;\\r\\n        this.tw = tw;\\r\\n        this.rules = (0, render_rules_js_1.getDefaultRules)(this);\\r\\n        this.rules[\\\"meta\\\"] = (0, render_rules_js_1.getMetaRule)(this, target);\\r\\n        this.rules[\\\"a\\\"] = (0, render_rules_js_1.getAnchorRule)(this, target);\\r\\n    }\\r\\n    renderTiddler(title) {\\r\\n        if (this.rules == null) {\\r\\n            console.warn(\\\"Cannot render tiddler without rules\\\");\\r\\n            return null;\\r\\n        }\\r\\n        const nodes = this.tw.renderWidgetTree(title);\\r\\n        this.tiddlerFields = this.tw.getFields(title);\\r\\n        if (this.tiddlerFields == null) {\\r\\n            console.warn(`Tiddler [[${title}]] doesn't seem to exist`);\\r\\n            return null;\\r\\n        }\\r\\n        let renderedNodes = \\\"\\\";\\r\\n        for (const node of nodes) {\\r\\n            const nodeMarkup = this.renderNode(node);\\r\\n            if (nodeMarkup != null) {\\r\\n                renderedNodes += nodeMarkup;\\r\\n            }\\r\\n        }\\r\\n        // Prepend meta node last, in case attributes have changed during rendering\\r\\n        const metaNode = {\\r\\n            tag: \\\"meta\\\",\\r\\n            nodeType: render_helpers_js_1.Node.ELEMENT_NODE,\\r\\n            attributes: this.tiddlerFields,\\r\\n            children: []\\r\\n        };\\r\\n        let markup = this.renderNode(metaNode) + renderedNodes;\\r\\n        return markup.replace(/\\\\n\\\\n\\\\n+/g, \\\"\\\\n\\\\n\\\").trim() + \\\"\\\\n\\\";\\r\\n    }\\r\\n    /** Get raw text from node */\\r\\n    getNodeText(node) {\\r\\n        if ((0, render_helpers_js_1.isTextNode)(node)) {\\r\\n            return node.textContent || \\\"\\\";\\r\\n        }\\r\\n        else if ((0, render_helpers_js_1.isDomNode)(node)) {\\r\\n            return node.children.map(child => this.getNodeText(child)).join(\\\" \\\");\\r\\n        }\\r\\n        else {\\r\\n            return null;\\r\\n        }\\r\\n    }\\r\\n    /** Render specified node to Markdown */\\r\\n    renderNode(node) {\\r\\n        if ((0, render_helpers_js_1.isTextNode)(node)) {\\r\\n            return node.textContent || \\\"\\\";\\r\\n        }\\r\\n        else if ((0, render_helpers_js_1.isDomNode)(node)) {\\r\\n            // Render markup from children depth-first\\r\\n            const innerMarkup = node.children.map(child => this.renderNode(child)).join(\\\"\\\");\\r\\n            return this.executeRule(node, innerMarkup);\\r\\n        }\\r\\n        else {\\r\\n            console.error(\\\"Unknown type of node\\\", node);\\r\\n            throw new Error(\\\"Unknown type of node\\\");\\r\\n        }\\r\\n    }\\r\\n    /** Get next sibling of specified node */\\r\\n    getNextNode(node) {\\r\\n        if (node.parentNode == null) {\\r\\n            return null;\\r\\n        }\\r\\n        let isNext = false;\\r\\n        for (const n of node.parentNode.children) {\\r\\n            if (isNext) {\\r\\n                return n;\\r\\n            }\\r\\n            else if (n === node) {\\r\\n                isNext = true;\\r\\n            }\\r\\n        }\\r\\n        return null;\\r\\n    }\\r\\n    isFirstChild(node) {\\r\\n        if (node.parentNode == null) {\\r\\n            // Define all root elements as the first and last children\\r\\n            return true;\\r\\n        }\\r\\n        return node == node.parentNode.children[0];\\r\\n    }\\r\\n    isLastChild(node) {\\r\\n        if (node.parentNode == null) {\\r\\n            // Define all root elements as the first and last children\\r\\n            return true;\\r\\n        }\\r\\n        return node == node.parentNode.children[node.parentNode.children.length - 1];\\r\\n    }\\r\\n    setRule(tag, renderer) {\\r\\n        this.rules[tag] = renderer;\\r\\n    }\\r\\n    executeRule(node, innerMarkup) {\\r\\n        if (node.tag in this.rules) {\\r\\n            return this.rules[node.tag](node, innerMarkup);\\r\\n        }\\r\\n        else {\\r\\n            // Use wildcard rule when tag doesn't have its own rule\\r\\n            return this.rules[\\\"*\\\"](node, innerMarkup);\\r\\n        }\\r\\n    }\\r\\n}\\r\\nexports.MarkdownRenderer = MarkdownRenderer;\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/cdaven/markdown-export/ToolbarButton\":{\"title\":\"$:/plugins/cdaven/markdown-export/ToolbarButton\",\"caption\":\"{{$:/plugins/cdaven/markdown-export/icon}} Markdown\",\"created\":\"20240503085745301\",\"description\":\"Convert tiddler to Markdown and copy, edit or download\",\"modified\":\"20240503093746830\",\"tags\":\"$:/tags/ViewToolbar\",\"text\":\"\\\\define markdownCopyButton()\\n<$button class=\\\"tc-btn-invisible\\\">\\n<$wikify name=\\\"markdownSource\\\" text=\\\"\\\"\\\"<$transclude $variable=\\\"markdown-export\\\" filter=`[[$(currentTiddler)$]]` note={{$:/plugins/cdaven/markdown-export/exportNote}} version={{$:/plugins/cdaven/markdown-export!!version}} $output=\\\"text/raw\\\"/>\\\"\\\"\\\">\\n<$action-sendmessage $message=\\\"tm-copy-to-clipboard\\\" $param=<<markdownSource>> />\\n</$wikify>\\n\\n<span class=\\\"tc-btn-text\\\">Copy as Markdown</span>\\n</$button>\\n\\\\end\\n\\n\\\\define markdownEditButton()\\n<$button class=\\\"tc-btn-invisible\\\">\\n<$wikify name=\\\"markdownSource\\\" text=\\\"\\\"\\\"<$transclude $variable=\\\"markdown-export\\\" filter=`[[$(currentTiddler)$]]` note={{$:/plugins/cdaven/markdown-export/exportNote}} version={{$:/plugins/cdaven/markdown-export!!version}} $output=\\\"text/raw\\\"/>\\\"\\\"\\\">\\n<$action-sendmessage $message=\\\"tm-new-tiddler\\\" title=`$:/temp/$(currentTiddler)$.md` text=<<markdownSource>> type=\\\"text/markdown\\\" />\\n</$wikify>\\n\\n<span class=\\\"tc-btn-text\\\">Edit as Markdown</span>\\n</$button>\\n\\\\end\\n\\n\\\\define markdownDownloadButton()\\n<$button class=\\\"tc-btn-invisible\\\">\\n<$action-sendmessage\\n   $message=\\\"tm-download-file\\\"\\n   $param=\\\"$:/plugins/cdaven/markdown-export/MenuItem\\\"\\n   exportFilter=`[[$(currentTiddler)$]]`\\n   filename=`$(currentTiddler)$.md` />\\n\\n<span class=\\\"tc-btn-text\\\">Download as Markdown</span>\\n</$button>\\n\\\\end\\n\\n\\\\define markdownMainButton()\\n<span class=\\\"tc-popup-keep\\\"><$button popup=<<qualify \\\"$:/state/popup/cdaven/markdown\\\">> class=<<tv-config-toolbar-class>> tooltip=\\\"Markdown\\\">\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/plugins/cdaven/markdown-export/icon}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">Markdown</span>\\n</$list>\\n</$button></span>\\n<$reveal state=<<qualify \\\"$:/state/popup/cdaven/markdown\\\">> type=\\\"popup\\\" position=\\\"below\\\" animate=\\\"yes\\\">\\n<div class=\\\"tc-drop-down\\\">\\n<<markdownCopyButton>>\\n<<markdownEditButton>>\\n<<markdownDownloadButton>>\\n</div>\\n</$reveal>\\n\\\\end\\n\\n<<markdownMainButton>>\"},\"$:/plugins/cdaven/markdown-export/zip-archive.js\":{\"title\":\"$:/plugins/cdaven/markdown-export/zip-archive.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/cdaven/markdown-export/zip-archive.js\\r\\ntype: application/javascript\\r\\nmodule-type: library\\r\\n\\\\*/\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.ZipArchive = void 0;\\r\\nclass ZipArchive {\\r\\n    constructor(title) {\\r\\n        this.title = title;\\r\\n        this.archive = null;\\r\\n        const JSZip = desire(\\\"$:/plugins/tiddlywiki/jszip/jszip.js\\\");\\r\\n        if (JSZip !== undefined) {\\r\\n            this.archive = new JSZip();\\r\\n        }\\r\\n    }\\r\\n    isEnabled() {\\r\\n        return this.archive != null;\\r\\n    }\\r\\n    /** Load archive from a tiddler */\\r\\n    load() {\\r\\n        if (!this.isEnabled()) {\\r\\n            console.error(\\\"JSZip plugin probably missing\\\");\\r\\n            return;\\r\\n        }\\r\\n        const tiddler = $tw.wiki.getTiddler(this.title);\\r\\n        if (tiddler && tiddler.fields.type === \\\"application/zip\\\") {\\r\\n            try {\\r\\n                this.archive.load(tiddler.fields.text, { base64: true });\\r\\n            }\\r\\n            catch (e) {\\r\\n                console.error(\\\"JSZip error: \\\" + e);\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            console.warn(\\\"Missing tiddler or wrong type: \\\", this.title);\\r\\n        }\\r\\n    }\\r\\n    /** Save archive to a tiddler */\\r\\n    save() {\\r\\n        if (!this.isEnabled()) {\\r\\n            console.error(\\\"JSZip plugin probably missing\\\");\\r\\n            return;\\r\\n        }\\r\\n        $tw.wiki.addTiddler({\\r\\n            title: this.title,\\r\\n            type: \\\"application/zip\\\",\\r\\n            text: this.toBase64()\\r\\n        });\\r\\n    }\\r\\n    /** Add file to archive */\\r\\n    addFile(filename, contents) {\\r\\n        if (!this.isEnabled()) {\\r\\n            console.error(\\\"JSZip plugin probably missing\\\");\\r\\n            return;\\r\\n        }\\r\\n        this.archive.file(filename, contents);\\r\\n    }\\r\\n    /** Render archive with Base64-encoding */\\r\\n    toBase64() {\\r\\n        return this.archive.generate({ type: \\\"base64\\\" });\\r\\n    }\\r\\n}\\r\\nexports.ZipArchive = ZipArchive;\\r\\n/** Like require, but doesn't throw errors when module is missing */\\r\\nfunction desire(moduleName) {\\r\\n    return $tw.modules.titles[moduleName] ? require(moduleName) : undefined;\\r\\n}\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"}}}","name":"markdown-export ÂØºÂá∫Markdown"}