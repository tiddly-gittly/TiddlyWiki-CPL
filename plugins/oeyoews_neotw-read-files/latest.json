{"title":"$:/plugins/oeyoews/neotw-read-files","description":"扩展TiddlyWiki读取目录","author":"oeyoews","version":"0.0.1","core-version":">=5.3.0","type":"application/json","plugin-type":"plugin","name":"Neotw Read Files","dependents":"","stability":"STABILITY_3_LEGACY","list":"readme","text":"{\"tiddlers\":{\"$:/plugins/oeyoews/neotw-read-files/readme\":{\"title\":\"$:/plugins/oeyoews/neotw-read-files/readme\",\"text\":\"* 导入的图片不会被删除, 需要手动在files 文件夹里面手动删除\\n* 此插件是关于 tiddlywiki 的路由实验性插件，其中的  ImportToExternalFile  是在 saqimtiaz 的插件基础上修改而来的 (仅仅适用于 tiddlywiki-starter-kit 的用例场景)\\n\\n* https://groups.google.com/g/tiddlywiki/c/T0MP1Adzzk0\\n* https://saqimtiaz.github.io/sq-tw/temp/import-to-external-file.html\"},\"$:/config/sq/OverwriteBinaryFiles\":{\"title\":\"$:/config/sq/OverwriteBinaryFiles\",\"text\":\"yes\"},\"$:/config/sq/SaveAsExternalFile\":{\"title\":\"$:/config/sq/SaveAsExternalFile\",\"text\":\"yes\"},\"$:/plugins/oeyoews/neotw-read-files/routes/get-file.js\":{\"title\":\"$:/plugins/oeyoews/neotw-read-files/routes/get-file.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/oeyoews/neotw-read-files/routes/get-file.js\\ntype: application/javascript\\nmodule-type: route\\n\\nneotw-read-files GET /images/:filepath\\n由 https://github.com/Jermolene/TiddlyWiki5/blob/ceee20fd5970e1b75c2117d2522c998a6c5054f3/core/modules/server/routes/get-file.js 改写\\n\\nhttps://github.com/Jermolene/TiddlyWiki5/discussions/7964\\n\\n\\\\*/\\n(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict';\\n\\n  exports.method = 'GET';\\n\\n  // exports.path = /^\\\\/static\\\\/(.+)$/;\\n  const customPath =\\n    $tw.wiki.getTiddlerText(\\n      '$:/plugins/oeyoews/neotw-read-files/custom-path',\\n    ) || 'static';\\n  exports.path = new RegExp(`^/${customPath}/(.+)`);\\n\\n  exports.handler = function (request, response, state) {\\n    var path = require('path'),\\n      fs = require('fs'),\\n      suppliedFilename = $tw.utils.decodeURIComponentSafe(state.params[0]),\\n      baseFilename = path.resolve(state.boot.wikiPath, customPath),\\n      filename = path.resolve(baseFilename, suppliedFilename),\\n      extension = path.extname(filename);\\n\\n    // Check that the filename is inside the wiki files folder\\n    if (path.relative(baseFilename, filename).indexOf('..') !== 0) {\\n      // Send the file\\n      fs.readFile(filename, function (err, content) {\\n        var status,\\n          content,\\n          type = 'text/plain';\\n        if (err) {\\n          console.log(\\n            'Error accessing file ' + filename + ': ' + err.toString(),\\n          );\\n          status = 404;\\n          content = \\\"File '\\\" + suppliedFilename + \\\"' not found\\\";\\n        } else {\\n          status = 200;\\n          content = content;\\n          type = $tw.config.fileExtensionInfo[extension]\\n            ? $tw.config.fileExtensionInfo[extension].type\\n            : 'application/octet-stream';\\n        }\\n        state.sendResponse(status, { 'Content-Type': type }, content);\\n      });\\n    } else {\\n      state.sendResponse(\\n        404,\\n        { 'Content-Type': 'text/plain' },\\n        \\\"File '\\\" + suppliedFilename + \\\"' not found\\\",\\n      );\\n    }\\n  };\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"route\"},\"$:/plugins/sq/ImportToExternalFile/server-route-upload.js\":{\"title\":\"$:/plugins/sq/ImportToExternalFile/server-route-upload.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/sq/ImportToExternalFile/server-route-upload.js\\ntype: application/javascript\\nmodule-type: route\\n\\nPOST /^\\\\/api\\\\/upload/\\n\\nUpload media\\n\\n\\\\*/\\n(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict';\\n\\n  exports.method = 'POST';\\n\\n  exports.path = new RegExp('^/api/upload');\\n  exports.bodyFormat = 'stream';\\n\\n  const fs = require('fs');\\n  const path = require('path');\\n\\n  exports.handler = function (request, response, state) {\\n    let body = '';\\n\\n    request.on('data', function (chunk) {\\n      body += chunk;\\n      // We limit the size of an upload to 10mb for now.\\n      if (body.length > 10e6) {\\n        response.writeHead(413, { 'Content-Type': 'text/plain' }).end();\\n        request.connection.destroy();\\n      }\\n    });\\n\\n    request.on('end', function () {\\n      try {\\n        let bodyData = JSON.parse(body);\\n\\n        const filesPath = path.resolve($tw.boot.wikiTiddlersPath, './files');\\n\\n        //config option overwrite existing?\\n\\n        /*\\n            var xfilepath = $tw.utils.generateTiddlerFilepath(bodyData.tiddler.fields.title,{\\n                directory: filesPath\\n            });\\n            //var ext = path.extname(originalpath);\\n            //xfilepath = xfilepath.substring(0,xfilepath.length - ext.length);\\n\\n\\n            // 1) try to increment filename before extension.\\n            // 2) don't encode / in file path so can specify a subdir\\n            xfilepath = path.join(filesPath, bodyData.tiddler.fields.title); //with this tiddler titles like images/filename work but only if directory exists\\n            console.log(xfilepath);\\n\\t\\t\\t*/\\n        var xfilepath = generateBinaryFilePath(bodyData.tiddler.fields.title);\\n        $tw.utils.createDirectory(filesPath);\\n        const buf = Buffer.from(bodyData.tiddler.fields.text, 'base64');\\n        //const filename = path.join(filesPath, bodyData.tiddler.fields.title);\\n        const filename = xfilepath;\\n        fs.writeFile(path.join(xfilepath), buf, function (error) {\\n          if (error) {\\n            console.log(error);\\n            throw error;\\n          } else {\\n            console.log('文件已保存' + filename);\\n            response.setHeader('Content-Type', 'application/json');\\n            response.end(\\n              JSON.stringify({\\n                success: 'saved ' + bodyData.tiddler.fields.title,\\n                status: 200,\\n                //\\\"_canonical_uri\\\":\\t \\\"files/\\\" + bodyData.tiddler.fields.title,\\n                _canonical_uri: path.relative(\\n                  path.resolve($tw.boot.wikiTiddlersPath, '..'),\\n                  xfilepath,\\n                ),\\n                tiddler: bodyData.tiddler.fields.title,\\n              }),\\n            );\\n            //state.wiki.addTiddler(bodyData.tiddler.fields,{_canonical_uri : bodyData.tiddler.fields.title, text:\\\"\\\"},state.wiki.getModificationFields());\\n            //return true;\\n          }\\n        });\\n      } catch (e) {\\n        console.log('Error parsing or writing uploaded file', e, { level: 2 });\\n        response.writeHead(400);\\n        response.end();\\n      }\\n    });\\n  };\\n\\n  var generateBinaryFilePath = function (title, options) {\\n    // 由于这是使用的是includewiki 的形式， 不支持files文件夹, 所以需要双层上级目录路径,\\n    const filesDirPath = path.resolve(\\n      $tw.boot.wikiTiddlersPath,\\n      '../../files/',\\n    );\\n    // console.log(filesDirPath);\\n    // Remove any forward or backward slashes so we don't create directories\\n    var filepath = title.replace(/\\\\/|\\\\\\\\/g, '_');\\n    // Replace any Windows control codes\\n    filepath = filepath.replace(\\n      /^(con|prn|aux|nul|com[0-9]|lpt[0-9])$/i,\\n      '_$1_',\\n    );\\n    // Replace any leading spaces with the same number of underscores\\n    filepath = filepath.replace(/^ +/, function (u) {\\n      return u.replace(/ /g, '_');\\n    });\\n    //If the path does not start with \\\".\\\" or \\\"..\\\" && a path seperator, then\\n    if (!/^\\\\.{1,2}[/\\\\\\\\]/g.test(filepath)) {\\n      // Don't let the filename start with any dots because such files are invisible on *nix\\n      filepath = filepath.replace(/^\\\\.+/g, function (u) {\\n        return u.replace(/\\\\./g, '_');\\n      });\\n    }\\n    // Replace any Unicode control codes\\n    filepath = filepath.replace(/[\\\\x00-\\\\x1f\\\\x80-\\\\x9f]/g, '_');\\n    // Replace any characters that can't be used in cross-platform filenames\\n    filepath = $tw.utils.transliterate(\\n      filepath.replace(/<|>|~|\\\\:|\\\\\\\"|\\\\||\\\\?|\\\\*|\\\\^/g, '_'),\\n    );\\n    var extension = path.extname(title);\\n    //remove extension from filepath\\n    filepath = filepath.substring(0, filepath.length - extension.length);\\n    // Replace any dots or spaces at the end of the extension with the same number of underscores\\n    extension = extension.replace(/[\\\\. ]+$/, function (u) {\\n      return u.replace(/[\\\\. ]/g, '_');\\n    });\\n    // Truncate the extension if it is too long\\n    if (extension.length > 32) {\\n      extension = extension.substr(0, 32);\\n    }\\n    // Truncate the filename if it is too long\\n    if (filepath.length > 200) {\\n      filepath = filepath.substr(0, 200);\\n    }\\n    // If the resulting filename is blank (eg because the title is just punctuation)\\n    if (!filepath || /^_+$/g.test(filepath)) {\\n      // ...then just use the character codes of the title\\n      filepath = '';\\n      $tw.utils.each(title.split(''), function (char) {\\n        if (filepath) {\\n          filepath += '-';\\n        }\\n        filepath += char.charCodeAt(0).toString();\\n      });\\n    }\\n\\n    var overwrite =\\n      $tw.wiki.getTextReference(\\n        '!!text',\\n        'yes',\\n        '$:/config/sq/OverwriteBinaryFiles',\\n      ) === 'yes'\\n        ? true\\n        : false;\\n    if (overwrite) {\\n      return path.resolve(filesDirPath, filepath + extension);\\n    }\\n\\n    var fullPath,\\n      count = 0;\\n    do {\\n      fullPath = path.resolve(\\n        filesDirPath,\\n        filepath + (count ? '_' + count : '') + extension,\\n      );\\n      count++;\\n    } while (fs.existsSync(fullPath));\\n    return fullPath;\\n  };\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"route\"},\"$:/plugins/sq/ImportToExternalFile/startup.js\":{\"title\":\"$:/plugins/sq/ImportToExternalFile/startup.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/sq/ImportToExternalFile/startup.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nThis adds a hook for the \\\"th-importing-tiddler\\\"\\n\\n\\\\*/\\n(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  'use strict';\\n\\n  // Export name and synchronous status\\n  exports.name = 'sq-server-images';\\n  exports.platforms = ['browser'];\\n  exports.after = ['render'];\\n  exports.synchronous = true;\\n\\n  exports.startup = function () {\\n    function updateProgress(e) {\\n      // TODO make this work in different browsers\\n      /*\\n\\t\\tif (e.lengthComputable) {\\n\\t\\tvar percentComplete = e.loaded/e.total*100;\\n\\t\\t} else {\\n\\t\\tvar percentComplete = -1;\\n\\t\\t}\\n\\t\\tconsole.log(percentComplete);\\n\\t\\t*/\\n    }\\n    function transferComplete(e) {\\n      // console.log('Complete!!', e);\\n    }\\n    function transferFailed(e) {\\n      console.log('Failed!');\\n    }\\n    function transferCanceled(e) {\\n      console.log('Cancelled!');\\n    }\\n    // Add the hook to the wiki in the browser\\n    $tw.hooks.addHook('th-importing-tiddler', function (tiddler) {\\n      var saveAsExternal =\\n        $tw.wiki.getTextReference(\\n          '!!text',\\n          'yes',\\n          '$:/config/sq/SaveAsExternalFile',\\n        ) === 'yes'\\n          ? true\\n          : false;\\n      if (!saveAsExternal) {\\n        return tiddler;\\n      }\\n\\n      // Figure out if the thing being imported is something that should be\\n      // saved on the server.\\n      var mediaTypes = [\\n        'image/gif',\\n        'image/x-icon',\\n        'image/jpeg',\\n        'image/jpeg',\\n        'image/png',\\n        'image/svg+xml',\\n        'application/pdf',\\n        'application/zip',\\n        'application/font-woff',\\n        'application/x-font-ttf',\\n        'audio/ogg',\\n        'video/mp4',\\n        'audio/mp3',\\n        'audio/mp4',\\n      ];\\n      if (\\n        mediaTypes.indexOf(tiddler.fields.type) > -1 &&\\n        !tiddler.fields._canonical_uri\\n      ) {\\n        // Check if this is set up to use HTTP post or websockets to save the\\n        // image on the server.\\n        let request = new XMLHttpRequest();\\n        request.upload.addEventListener('progress', updateProgress);\\n        request.upload.addEventListener('load', transferComplete);\\n        request.upload.addEventListener('error', transferFailed);\\n        request.upload.addEventListener('abort', transferCanceled);\\n\\n        request.onreadystatechange = function () {\\n          if (this.readyState == 4 && this.status == 200) {\\n            console.info(this.response);\\n            var json = null;\\n            try {\\n              json = JSON.parse(this.response);\\n            } catch (e) {}\\n            if (json) {\\n              let tiddler = $tw.wiki.getTiddler(json.tiddler);\\n\\n              // HACK: remove extra dot path\\n              let _canonical_uri = json._canonical_uri;\\n              if (json._canonical_uri.startsWith('..')) {\\n                _canonical_uri = _canonical_uri.replace('..', '.');\\n              }\\n              $tw.wiki.addTiddler(\\n                new $tw.Tiddler(tiddler, {\\n                  _canonical_uri,\\n                  text: '',\\n                }),\\n              );\\n            }\\n          }\\n        };\\n\\n        let uploadURL = '/api/upload';\\n        request.open('POST', uploadURL, true);\\n\\n        var thing = {\\n          tiddler: tiddler,\\n        };\\n        //\\trequest.upload.addEventListener('load', transferComplete);\\n        request.setRequestHeader('X-Requested-With', 'TiddlyWiki');\\n        request.send(JSON.stringify(thing));\\n\\n        // Change the tiddler fields and stuff\\n        var fields = {};\\n        var uri = '/files/' + tiddler.fields.title;\\n        //Use tw.utils.generateTiddlerFilePath //remove / etc from title\\n        //https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/utils/filesystem.js#L321\\n        fields.title = tiddler.fields.title;\\n        fields.type = tiddler.fields.type;\\n        fields._canonical_uri = uri;\\n        //return new $tw.Tiddler(fields);\\n        return tiddler;\\n      } else {\\n        return tiddler;\\n      }\\n    });\\n  };\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"startup\"},\"$:/core/ui/ViewTemplate/import-external-files\":{\"title\":\"$:/core/ui/ViewTemplate/import-external-files\",\"tags\":\"$:/tags/ViewTemplate\",\"list-after\":\"$:/core/ui/ViewTemplate/import\",\"text\":\"<$list filter=\\\"[all[current]field:plugin-type[import]]\\\" variable=\\\"null\\\">\\n\\n<$checkbox tiddler=\\\"$:/config/sq/SaveAsExternalFile\\\" field=\\\"text\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"yes\\\"> Import binary files as external attachments</$checkbox>\\n\\n<$list filter=\\\"[{$:/config/sq/SaveAsExternalFile}match[yes]]\\\" variable=\\\"null\\\">\\n<$checkbox tiddler=\\\"$:/config/sq/OverwriteBinaryFiles\\\" field=\\\"text\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"yes\\\"> Overwrite binary files with the same name</$checkbox>\\n</$list>\\n\\n</$list>\"}}}"}