{"title":"$:/plugins/EvidentlyCube/AutoComplete","name":"Auto Complete","version":"1.0.19","core-version":">=5.2.3","description":"Enable easy tiddler name completion in various contexts","author":"Maurycy Zarzycki","source":"https://github.com/EvidentlyCube/TW5-AutoComplete","plugin-type":"plugin","list":"readme license history","dependents":"","type":"application/json","text":"{\"tiddlers\":{\"$:/plugins/EvidentlyCube/Common/Settings\":{\"title\":\"$:/plugins/EvidentlyCube/Common/Settings\",\"tags\":\"$:/tags/ControlPanel\",\"caption\":\"Evidently Cube\",\"text\":\"\\\\whitespace trim\\n! Evidently Cube plugins Settings\\n\\nBelow are settings for all Evidently Cube plugins.\\n\\n<$macrocall\\n\\t$name=\\\"tabs\\\"\\n\\ttabsList=\\\"[all[shadows+tiddlers]tag[$:/tags/EvidentlyCube/SettingsTab]!is[draft]sort[]]\\\"\\n\\tdefault={{{ [all[shadows+tiddlers]tag[$:/tags/EvidentlyCube/SettingsTab]!is[draft]sort[]limit[1]] }}}/>\\n\\n\"},\"$:/plugins/EvidentlyCube/AutoComplete/history\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/history\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"* ''1.0.19'':\\n** Registered triggers in the settings now display without any accidental parsing\\n** Fix extraneous offset when using a theme that has left-top offsets/margins\\n* ''1.0.18'':\\n** Fixed RSOD in TW 5.3.0+ caused by new API not being supported\\n** Fixed RSOD when earlier keyup causes the focus to be changed -- can be triggered by setting `sidebar-search` shortcut to the same key as manually triggering auto complete.\\n* ''1.0.17'' -- Variable `editedTiddler` can now be used in //Suggestion Filter// and //Display Filter//\\n* ''1.0.16'' -- The two `<p>` tags that were wrapping around the auto complete window have been reduced to a single `<p>` tag.\\n* ''1.0.15'':\\n** ''Code Mirror integration:'' No longer throws an exception when triggering completion in non-codemirror input when codemirror editor is opened\\n** ''Code Mirror integration:'' Completion opens at the correct position even when window is scrolled\\n** ''Code Mirror integration:'' No longer throws an exception when selecting an option with mouse in non-codemirror input when codemirror editor is opened\\n* ''1.0.14'':\\n** Fixed a bug where navigating through auto completion would still trigger TW's keyboard widgets eg. navigating auto completion in sidebar search would also change selected search result\\n** The list of suggestion can now be scrolled down using the keyboard.\\n* ''1.0.13'' -- Added caption to triggers to improve how they are displayed in the settings\\n* ''1.0.12'' -- Various small fixes and tweaks to problems introduced between 1.0.9 and 1.0.11.\\n* ''1.0.11'' -- This plugin now takes preference over `codemirror-autocomplete` and will prevent the code mirror Auto Complete from opening at the same time as this\\n* ''1.0.10'' -- No longer crashes when using together with a Twitter plugin or any other plugin which delays the execution of the `startup` module\\n* ''1.0.9'' -- Using mouse for Auto Complete now works in tiddlers opened in a separate window\\n* ''1.0.8'' -- Auto Complete now works gracefully with `codemirror-closebrackets` plugin\\n* ''1.0.7'' -- Auto Complete now only opens in the window in which it was invoked when using Side Editor plugin or just opening a tiddler in a new window\\n* ''1.0.6'':\\n** If you use Auto Complete in a text area that is scrolled, Auto Complete window will now be correctly positioned.\\n** If you use framed editor but the main window was scrolled, Auto Complete window will now be correctly positioned\\n** Fixed incorrect placeholder for description field\\n** Changed the default trigger slightly\\n* ''1.0.5'' -- Auto Complete now also opens in tiddlers opened in a new window\\n* ''1.0.4'' -- Added `Transform Filter` option to triggers which allows transforming the suggestion before it is inserted (eg to insert a field value instead)\\n* ''1.0.3'' -- Added compatibility with Streams - this plugin's Enter takes priority over Streams's Enter\\n* ''1.0.2'' -- Upped version because issue\\n* ''1.0.1'' -- Added `z-index` to CSS so the completion always (tries to) appear at the top\\n* ''1.0.0'' -- Initial release\"},\"$:/plugins/EvidentlyCube/AutoComplete/icon\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/icon\",\"text\":\"iVBORw0KGgoAAAANSUhEUgAAACMAAAAjCAYAAAAe2bNZAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAELklEQVRYhc2X309bZRjHP+/hnNIC2nXt5hYjrJHR8cOR1CiRBBISk6FGE2JK1JtdmEi4IPPKkOwf2D9g8ErTW27UC4WYGJRVL7xAN2DJ4hjMDRI2VmiRdqenPa8Xb1fa0gIt0PhNTs573vd9nvdznve3kFJK/ifSnyeSySRzc3OkUqmaNe5wOAgGg7hcrl2YZDJJf38/fr8fj8dTsVMpJaZp4nQ6K7Lb3NxkeXmZ2dlZBSSllJFIRIZCIWnbtqxGa2trcmxsrGI727ZlKBSSkUhESimlDpBKpfB4PFiWxfXr14nH4wV/cOXKFVZXV1lYWKClpYWOjg6mpqYA0DSNnp4e7ty5U3FEhRB4PJ7c0MiNGSkluq4zNDSEaZoFRn6/n7a2Nrq6unC73fh8Ptxud86hYRgVg+S3+1w6gNfrZXFxEcuy6O3tPZST5ubmXHp7e5uRkZGKQUzTZHFxEa/XC4DIdh83btxgenr6SH9ZqSzLYnBwkPHxcYQQCgZUuJLJJOl0umYwuq7jcrkQQqhvANu2CYfDTE5OYllWzWAMw2B4eJirV6+iaZqCmZ+fJxwOMzExgcPhqBlMKpVidHSUYDBId3e3golGowQCAdrb28nYkCnaIAwNbLk3vxIZGqQlIEHXINszBAIBotEokDe1AVIZ+Pwn2Cqc2XxwER7G4c/16mE+6YQfl+BZGq69Ad0v7a1TAOOogy/fUfT5EiKbdYTICAHvte6mS6kAxpZwL5oNZ5E8TjDTkMhONpeu4GN5URTAhVOqrBzQftoD88sD2C6xcQfPweYzWN5S3y+/AL4GuJXXdboGH3eWhzlIBWa6Bp8FK3Pwtr+6hg+EsSX8/kh1R76EgOIjmBDwqgce70C8aMDn12n1QLO7CpiMDb89LO+8WIYGC0/gUbx0uRBqXFUMs7IFP9yDgPdwhgBPk3C+ST3ltJGA7+6WL1/ZKgHz8wr8+i1cPgvObO5yDLwueLFoUZbA3afQ4laDdX0HHsSpauqnV2C8GCZjQx0w3AHuepU3tQTtPrhQIszh2/D+RTjtgj/W4JvbykfFyrPJwbT7oO8y/B3dLTzToMK8kdjro/MM3N9Sjybg0+4qQICbkRIwfc3w1bvwNAFpG5ocanYlspu4Uwe3Uy1sx6mR70vAgIL4+pZa9PpeUe+/1hVAmxc+6lBr0UmpAMbQ4Iu3Cit8eOnkGt8XJiPh5j9q995Pr52F+5uwU+Icdq5JzcgjwwA8ScC/B1wqL3khmoSN5N6ypiOczQpg6gSE2g9neNhVtWqYjJ09ABWFXwh4/Tz4Tx0/QFkYiRoLxd0kBLSePlmQHIxhGMRiMeqE5Nqbx72S7K9YLJa7qwkppUwkEgwMDFBfX09jY2PNQHZ2djBNk5mZGRoaGnYvcZZlsbS0VNN7k67rtLa2FkamZq0foP8APw/vuJS94F4AAAAASUVORK5CYII=\",\"type\":\"image/png\"},\"$:/plugins/EvidentlyCube/AutoComplete/license\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/license\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"This plugin is licensed under the MIT license.\\n\\nCopyright 2022 Maurycy Zarzycki\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \\\"Software\\\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\"},\"$:/plugins/EvidentlyCube/AutoComplete/readme\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/readme\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"[[Github|https://github.com/EvidentlyCube/TW5-PluginShowcase/tree/main/plugins/EvidentlyCube/TW5-AutoComplete]]\\n\\n----\\n\\n! Features\\n\\nA versatile and easy to use auto completion for TiddlyWiki:\\n\\n* Auto complete anything you want:\\n** Tiddler titles\\n** Field values\\n** Any filter result\\n* Define your own triggers\\n** Customize the filter which retrieves the suggestions\\n** Customize template used for inserting the selected suggestion\\n** Customize how the suggestions are displayed in the completion window\\n** Control auto-triggering separately for inputs and text areas\\n* Clear interface for editing the triggers\\n* Manually open auto complete with customizable keyboard shortcut\\n\\n!! Plugin compatibility\\n\\n * Official [[Code Mirror|https://tiddlywiki.com/plugins/tiddlywiki/codemirror/]] plugin\\n * [[Streams|https://saqimtiaz.github.io/streams/]] by saqimtiaz\\n\\n! How to use\\n\\n* After installing head to the Control Panel and open the tab ''Evidently Cube''\\n* Create a new trigger using the button\\n** It will be filled with sensible defaults\\n** Customize the trigger to your heart's content\\n* At any time press <kbd>Ctrl+Space</kbd> right in front of a defined trigger to open the completion window manually\\n** Or use a different keyboard shortcut you defined\"},\"$:/plugins/EvidentlyCube/AutoComplete/Config\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/Config\",\"rows\":\"8\"},\"$:/config/shortcuts/EC-AutoComplete\":{\"title\":\"$:/config/shortcuts/EC-AutoComplete\",\"text\":\"ctrl+space\"},\"$:/config/ShortcutInfo/EC-AutoComplete\":{\"title\":\"$:/config/ShortcutInfo/EC-AutoComplete\",\"text\":\"Triggers completion of Auto Complete plugin\\n\"},\"$:/plugins/EvidentlyCube/AutoComplete/completion-api.js\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/completion-api.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/AutoComplete/completion-api.js\\ntype: application/javascript\\nmodule-type: library\\n\\nAPI for the modal\\n\\n\\\\*/\\n(function () {\\n\\n\\tconst DATA_TIDDLER_NAME = \\\"$:/temp/AutoComplete/completion-data\\\";\\n\\n\\t/*jslint node: true, browser: true */\\n\\t/*global $tw: false */\\n\\t\\\"use strict\\\";\\n\\n\\tvar OPTIONS_TIDDLERS = [\\n\\t\\t'$:/config/shortcuts/EC-AutoComplete',\\n\\t\\t'$:/config/shortcuts-linux/EC-AutoComplete',\\n\\t\\t'$:/config/shortcuts-not-linux/EC-AutoComplete',\\n\\t\\t'$:/config/shortcuts-mac/EC-AutoComplete',\\n\\t\\t'$:/config/shortcuts-not-mac/EC-AutoComplete',\\n\\t\\t'$:/config/shortcuts-windows/EC-AutoComplete',\\n\\t\\t'$:/config/shortcuts-not-windows/EC-AutoComplete',\\n\\t];\\n\\n\\tfunction EC_AutoComplete() {\\n\\t\\tthis.isActive = false;\\n\\t\\tthis.activeState = {\\n\\t\\t\\ttrigger: null,\\n\\t\\t\\tlastQuery: null,\\n\\t\\t\\tselectedResult: -1,\\n\\t\\t\\tresults: [],\\n\\t\\t\\toptions: {}\\n\\t\\t}\\n\\t\\tthis.options = {\\n\\t\\t\\ttriggers: [],\\n\\t\\t\\ttriggerTiddlers: []\\n\\t\\t}\\n\\n\\t\\tthis._loadOptions();\\n\\t\\tthis._updateTriggerList(this._getTriggerTiddlerList());\\n\\n\\t\\tdocument.addEventListener('keydown', this._handleGlobalKeydownCapture.bind(this), true);\\n\\t\\t$tw.wiki.addEventListener(\\\"change\\\", this._handleChange.bind(this));\\n\\t};\\n\\n\\tEC_AutoComplete.prototype._handleGlobalKeydownCapture = function (event) {\\n\\t\\tif (this.isActive && event.key === \\\"Escape\\\") {\\n\\t\\t\\tthis.finishCompletion();\\n\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t}\\n\\t};\\n\\n\\tEC_AutoComplete.prototype.getMatchingTrigger = function (lastCharacter, inputType, getFragmentCallback) {\\n\\t\\tvar ignoreType = lastCharacter === null || lastCharacter === \\\"\\\";\\n\\n\\t\\tfor (let i = 0; i < this.options.triggers.length; i++) {\\n\\t\\t\\tvar triggerData = this.options.triggers[i];\\n\\n\\t\\t\\tif (!ignoreType && !triggerData.autoTriggerInput && inputType === 'INPUT') {\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t} else if (!ignoreType && !triggerData.autoTriggerTextArea && inputType === 'TEXTAREA') {\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t} else if (lastCharacter && triggerData.triggerLastCharacter !== lastCharacter) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst fragment = getFragmentCallback(triggerData.trigger.length);\\n\\t\\t\\tif (fragment !== triggerData.trigger) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn triggerData;\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\\n\\n\\tEC_AutoComplete.prototype.startCompletion = function (trigger, position, options) {\\n\\t\\tthis.isActive = true;\\n\\t\\tthis.activeState.trigger = trigger;\\n\\t\\tthis.activeState.lastQuery = null;\\n\\t\\tthis.activeState.selectedResult = 0;\\n\\t\\tthis.activeState.results = [];\\n\\t\\tthis.activeState.options = options || {};\\n\\n\\t\\tthis.updateQuery(\\\"\\\");\\n\\n\\t\\tfixDoubledMargins(position);\\n\\n\\t\\tconst newStyle = `left: ${position.left.toFixed(4)}px; top: ${position.top.toFixed(4)}px`;\\n\\n\\t\\t$tw.wiki.setText(DATA_TIDDLER_NAME, 'show', null, \\\"1\\\");\\n\\t\\t$tw.wiki.setText(DATA_TIDDLER_NAME, 'style', null, newStyle);\\n\\t\\t$tw.wiki.setText(DATA_TIDDLER_NAME, 'display-filter', null, trigger.displayFilter);\\n\\t\\t$tw.wiki.setText(DATA_TIDDLER_NAME, 'edited-tiddler', null, options.editedTiddler || '');\\n\\t\\tif (typeof options.windowID !== \\\"undefined\\\") {\\n\\t\\t\\t$tw.wiki.setText(DATA_TIDDLER_NAME, 'show-window', null, options.windowID);\\n\\t\\t} else {\\n\\t\\t\\t$tw.wiki.setText(DATA_TIDDLER_NAME, 'show-window', null, \\\"-1\\\");\\n\\t\\t}\\n\\t};\\n\\n\\tEC_AutoComplete.prototype.finishCompletion = function () {\\n\\t\\tif (this.activeState.options.onFinish) {\\n\\t\\t\\tthis.activeState.options.onFinish();\\n\\t\\t}\\n\\n\\t\\tthis.isActive = false;\\n\\t\\tthis.activeState.trigger = null;\\n\\t\\tthis.activeState.lastQuery = null;\\n\\t\\tthis.activeState.selectedResult = -1;\\n\\t\\tthis.activeState.results = [];\\n\\n\\t\\t$tw.wiki.setText(DATA_TIDDLER_NAME, 'show', null, \\\"0\\\");\\n\\t};\\n\\n\\tEC_AutoComplete.prototype.updateQuery = function (query) {\\n\\t\\tif (query === this.activeState.lastQuery) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.activeState.lastQuery = query;\\n\\t\\tthis.activeState.selectedResult = 0;\\n\\n\\t\\tconst results = $tw.wiki.filterTiddlers(this.activeState.trigger.filter, getVariableFauxWidget({\\n\\t\\t\\teditedTiddler: this.activeState.options.editedTiddler || '',\\n\\t\\t\\tquery\\n\\t\\t}));\\n\\n\\t\\tthis.activeState.results = results;\\n\\t\\t$tw.wiki.setText(DATA_TIDDLER_NAME, 'list', null, this.activeState.results);\\n\\t\\t$tw.wiki.setText(DATA_TIDDLER_NAME, 'index', null, 1);\\n\\t};\\n\\n\\tEC_AutoComplete.prototype.changeSelection = function (delta) {\\n\\t\\tthis.activeState.selectedResult += delta\\n\\n\\t\\tif (this.activeState.selectedResult < 0) {\\n\\t\\t\\tthis.activeState.selectedResult = this.activeState.results.length - 1;\\n\\t\\t} else if (this.activeState.selectedResult >= this.activeState.results.length) {\\n\\t\\t\\tthis.activeState.selectedResult = 0;\\n\\t\\t}\\n\\n\\t\\t$tw.wiki.setText(DATA_TIDDLER_NAME, 'index', null, this.activeState.selectedResult + 1);\\n\\t};\\n\\n\\tEC_AutoComplete.prototype.getCompletedTemplate = function (option) {\\n\\t\\tconst withReplacedOption = this.activeState.trigger.insertTemplate.replace(/\\\\$option\\\\$/g, option);\\n\\t\\tconst caretTokenIndex = withReplacedOption.indexOf(\\\"$caret$\\\");\\n\\t\\tconst withRemovedCaret = withReplacedOption.replace(/\\\\$caret\\\\$/g, '');\\n\\t\\treturn {\\n\\t\\t\\ttext: withRemovedCaret,\\n\\t\\t\\tcaretIndex: caretTokenIndex !== -1\\n\\t\\t\\t\\t? caretTokenIndex\\n\\t\\t\\t\\t: withRemovedCaret.length\\n\\t\\t};\\n\\t}\\n\\n\\tEC_AutoComplete.prototype.getSelected = function () {\\n\\t\\tconst selectedResult = this.activeState.results[this.activeState.selectedResult] || \\\"\\\";\\n\\n\\t\\treturn selectedResult\\n\\t\\t\\t? $tw.wiki.filterTiddlers(this.activeState.trigger.transformFilter, getVariableFauxWidget({ currentTiddler: selectedResult }))\\n\\t\\t\\t: \\\"\\\";\\n\\t};\\n\\n\\tEC_AutoComplete.prototype.setSelectionByValue = function (value) {\\n\\t\\tconst index = this.activeState.results.indexOf(value);\\n\\n\\t\\tif (index !== -1) {\\n\\t\\t\\tthis.activeState.selectedResult = index;\\n\\t\\t}\\n\\t}\\n\\n\\tEC_AutoComplete.prototype.getClicked = function (event) {\\n\\t\\tif (event.target && event.target.classList.contains('ec_ac-link')) {\\n\\t\\t\\treturn event.target.innerText;\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t};\\n\\n\\tEC_AutoComplete.prototype.isManualTrigger = function (event) {\\n\\t\\treturn $tw.keyboardManager.checkKeyDescriptors(event, this.options.manualTriggerKeyInfo);\\n\\t}\\n\\n\\tEC_AutoComplete.prototype._handleChange = function (changedTiddlers) {\\n\\t\\tif ($tw.utils.hopArray(changedTiddlers, OPTIONS_TIDDLERS)) {\\n\\t\\t\\tthis._loadOptions();\\n\\t\\t}\\n\\n\\t\\tconst newTriggerTiddlerList = this._getTriggerTiddlerList();\\n\\n\\t\\tif (\\n\\t\\t\\t$tw.utils.hopArray(changedTiddlers, newTriggerTiddlerList)\\n\\t\\t\\t|| $tw.utils.hopArray(changedTiddlers, this.options.triggerTiddlers)\\n\\t\\t) {\\n\\t\\t\\tthis._updateTriggerList(newTriggerTiddlerList);\\n\\t\\t}\\n\\t};\\n\\n\\tEC_AutoComplete.prototype._loadOptions = function () {\\n\\t\\tthis.options.manualTriggerKeyInfo = $tw.keyboardManager.parseKeyDescriptors('((EC-AutoComplete))', { wiki: this.wiki });\\n\\t}\\n\\n\\tEC_AutoComplete.prototype._getTriggerTiddlerList = function () {\\n\\t\\treturn $tw.wiki.getTiddlersWithTag(\\\"$:/tags/EC/AutoComplete/Trigger\\\");\\n\\t};\\n\\n\\tEC_AutoComplete.prototype._updateTriggerList = function (tiddlerList) {\\n\\t\\tthis.options.triggers = [];\\n\\t\\tthis.options.triggerTiddlers = tiddlerList;\\n\\n\\t\\tfor (var i = 0; i < tiddlerList.length; i++) {\\n\\t\\t\\tvar title = tiddlerList[i],\\n\\t\\t\\t\\ttiddlerFields = $tw.wiki.getTiddler(title).fields,\\n\\t\\t\\t\\ttrigger = tiddlerFields.trigger,\\n\\t\\t\\t\\tfilter = tiddlerFields.filter,\\n\\t\\t\\t\\tinsertTemplate = tiddlerFields.template;\\n\\n\\t\\t\\tif (!filter || !insertTemplate || !trigger) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.options.triggers.push({\\n\\t\\t\\t\\tfilter: tiddlerFields.filter,\\n\\t\\t\\t\\tdisplayFilter: tiddlerFields['display-filter'],\\n\\t\\t\\t\\ttransformFilter: tiddlerFields['transform-filter'] || \\\"[<currentTiddler>]\\\",\\n\\t\\t\\t\\ttrigger: trigger,\\n\\t\\t\\t\\ttriggerLastCharacter: trigger.charAt(trigger.length - 1),\\n\\t\\t\\t\\tinsertTemplate: insertTemplate,\\n\\t\\t\\t\\tautoTriggerInput: String(tiddlerFields['auto-trigger-input']) === '1',\\n\\t\\t\\t\\tautoTriggerTextArea: String(tiddlerFields['auto-trigger-textarea']) === '1',\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * ISSUE: if the used theme has margins or left/top applied to any of the parents\\n\\t * that contain the Autocomplete window and the input AND also has a parent with `position: relative`\\n\\t * then the provided caret position will be offset by those margins/lefts/tops\\n\\t * and once again will be applied because of the fact the Autocomplete widget lives\\n\\t * under the same parents - effectively applying those offsets twice.\\n\\t *\\n\\t * This fixes it by subtracting one set of offsets.\\n\\t */\\n\\tfunction fixDoubledMargins(caretPosition) {\\n\\t\\tlet acContainer = document.querySelector('.ec_ac-completion');\\n\\n\\t\\tif (!acContainer) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// The assumption is if we set the absolute position to (0,0) then whatever\\n\\t\\t// the global in-page position is will be the value of a single set\\n\\t\\t// of offsets, exactly what we need to subtract\\n\\t\\tconst oldDisplay = acContainer.style.display;\\n\\t\\tacContainer.style.display = \\\"block\\\";\\n\\t\\tacContainer.style.left = \\\"0px\\\";\\n\\t\\tacContainer.style.top = \\\"0px\\\";\\n\\n\\t\\tconst position = acContainer.getBoundingClientRect();\\n\\n\\t\\tcaretPosition.left -= position.left;\\n\\t\\tcaretPosition.top -= position.top;\\n\\n\\t\\tacContainer.style.display = oldDisplay;\\n\\t}\\n\\n\\tfunction getVariableFauxWidget(keyValues) {\\n\\t\\tif ($tw.rootWidget.makeFakeWidgetWithVariables) {\\n\\t\\t\\treturn $tw.rootWidget.makeFakeWidgetWithVariables(keyValues);\\n\\t\\t}\\n\\n\\t\\t// Backwards compatibility for pre 5.3.0 versions\\n\\t\\treturn {\\n\\t\\t\\tgetVariable: function (name) {\\n\\t\\t\\t\\tif (typeof keyValues[name] !== 'undefined') {\\n\\t\\t\\t\\t\\treturn keyValues[name];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn \\\"\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\texports.EC_AutoComplete = EC_AutoComplete;\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/EvidentlyCube/AutoComplete/completion-window.js\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/completion-window.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/AutoComplete/completion-window.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nAdds support for auto complete in tiddlers opened in a new window\\n\\\\*/\\n\\n(function () {\\n\\n\\t/*jslint node: false, browser: true */\\n\\t/*global $tw: false */\\n\\t\\\"use strict\\\";\\n\\n\\t// Export name and synchronous status\\n\\texports.name = \\\"evidentlycube-tiddlercompletion-window\\\";\\n\\texports.platforms = [\\\"browser\\\"];\\n\\texports.after = [\\\"windows\\\"];\\n\\texports.synchronous = true;\\n\\n\\texports.startup = function () {\\n\\t\\tconst innerListener = $tw.rootWidget.eventListeners['tm-open-window'];\\n\\t\\t$tw.rootWidget.addEventListener(\\\"tm-open-window\\\", function (event) {\\n\\t\\t\\tinnerListener(event);\\n\\n\\t\\t\\tvar title = event.param || event.tiddlerTitle;\\n\\t\\t\\tvar paramObject = event.paramObject || {};\\n\\t\\t\\tvar windowID = paramObject.windowID || title;\\n\\n\\t\\t\\tconst window = $tw.windows[windowID];\\n\\t\\t\\tconst parser = $tw.wiki.parseTiddler(\\\"$:/plugins/EvidentlyCube/AutoComplete/window\\\");\\n\\t\\t\\tconst widgetNode = $tw.wiki.makeWidget(parser, {\\n\\t\\t\\t\\tdocument: window.document,\\n\\t\\t\\t\\tparentWidget: $tw.rootWidget,\\n\\t\\t\\t\\tvariables: {\\n\\t\\t\\t\\t\\t'tv-window-id': windowID\\n\\t\\t\\t\\t }\\n\\t\\t\\t});\\n\\t\\t\\tconst refreshHandler = function (changes) {\\n\\t\\t\\t\\twidgetNode.refresh(changes);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Used to prevent auto complete opening in all windows\\n\\t\\t\\twindow.document._ecAcWindowID = windowID;\\n\\t\\t\\t$tw.wiki.addEventListener(\\\"change\\\", refreshHandler);\\n\\t\\t\\twindow.addEventListener(\\\"beforeunload\\\", function (event) {\\n\\t\\t\\t\\t$tw.wiki.removeEventListener(\\\"change\\\", refreshHandler);\\n\\t\\t\\t}, false);\\n\\n\\t\\t\\twidgetNode.render(window.document.body, window.document.body.firstChild);\\n\\t\\t});\\n\\t};\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"startup\"},\"$:/plugins/EvidentlyCube/AutoComplete/completion.js\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/completion.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/AutoComplete/completion.js\\ntype: application/javascript\\nmodule-type: startup\\n\\nHooks the module\\n\\\\*/\\n\\n(function () {\\n\\n\\t/*jslint node: false, browser: true */\\n\\t/*global $tw: false */\\n\\t\\\"use strict\\\";\\n\\n\\t// Export name and synchronous status\\n\\texports.name = \\\"evidentlycube-tiddlercompletion\\\";\\n\\texports.platforms = [\\\"browser\\\"];\\n\\texports.after = [\\\"startup\\\"];\\n\\texports.before = [\\\"render\\\"];\\n\\texports.synchronous = true;\\n\\n\\texports.startup = function () {\\n\\t\\tif ($tw.node) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tconst monkeypatch = {\\n\\t\\t\\tsequence: function(originalMethod, newMethod) {\\n\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\tconst result = originalMethod.apply(this, arguments);\\n\\n\\t\\t\\t\\t\\tnewMethod.apply(this, arguments);\\n\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tpreventable: function(originalMethod, newMethod) {\\n\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\tif (newMethod.apply(this, arguments) !== false) {\\n\\t\\t\\t\\t\\t\\treturn originalMethod.apply(this, arguments);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tconst EC_AutoComplete = require('$:/plugins/EvidentlyCube/AutoComplete/completion-api.js').EC_AutoComplete;\\n\\t\\tconst completionApi = new EC_AutoComplete();\\n\\n\\t\\trequire('$:/plugins/EvidentlyCube/AutoComplete/integration-core.js').patch(completionApi, monkeypatch);\\n\\t\\ttry {\\n\\t\\t\\trequire('$:/plugins/EvidentlyCube/AutoComplete/integration-codemirror.js').patch(completionApi, monkeypatch);\\n\\t\\t} catch (e) {\\n\\t\\t\\t// Silently ignore if Code Mirror is not installed\\n\\t\\t}\\n\\n\\t};\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"startup\"},\"$:/plugins/EvidentlyCube/AutoComplete/integration-codemirror.js\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/integration-codemirror.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/AutoComplete/integration-codemirror.js\\ntype: application/javascript\\nmodule-type: library\\n\\nAutocompletion integration for Simple text editor\\n\\n\\\\*/\\n(function () {\\n\\n\\texports.patch = function(completionAPI, monkeypatch) {\\n\\t\\tvar editCodeMirrorWidget = require('$:/plugins/tiddlywiki/codemirror/edit-codemirror.js')['edit-codemirror'];\\n\\n\\t\\tvar selectionStart = -1;\\n\\t\\tvar activeCm = null;\\n\\t\\tvar activeDocument = null;\\n\\t\\tvar triggerLength = -1;\\n\\n\\t\\teditCodeMirrorWidget.prototype.render = monkeypatch.sequence(editCodeMirrorWidget.prototype.render, widgetRender);\\n\\n\\t\\tfunction widgetRender() {\\n\\t\\t\\tthis.engine.cm.on('keydown', handleKeydown.bind(this));\\n\\t\\t\\tthis.engine.cm.on('blur', handleBlur.bind(this));\\n\\t\\t\\tthis.engine.cm.on('change', handleEngineInput.bind(this));\\n\\t\\t\\tthis.engine.cm.on('cursorActivity', handleCursorActivity.bind(this));\\n\\t\\t}\\n\\n\\t\\tfunction handleKeydown(cm, event) {\\n\\t\\t\\tif (completionAPI.isActive) {\\n\\t\\t\\t\\tswitch(event.key) {\\n\\t\\t\\t\\t\\tcase \\\"ArrowUp\\\":\\n\\t\\t\\t\\t\\tcase \\\"ArrowDown\\\":\\n\\t\\t\\t\\t\\t\\tcompletionAPI.changeSelection(event.key === \\\"ArrowUp\\\" ? -1 : 1);\\n\\t\\t\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase \\\"Enter\\\":\\n\\t\\t\\t\\t\\t\\tconst option = completionAPI.getSelected();\\n\\n\\t\\t\\t\\t\\t\\tif (option) {\\n\\t\\t\\t\\t\\t\\t\\tinsertSelection(option);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tcompletionAPI.finishCompletion();\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tif (completionAPI.isManualTrigger(event)) {\\n\\t\\t\\t\\t\\t\\t\\t// Prevent codemirror-autocomplete from triggering while this one is visible\\n\\t\\t\\t\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if (completionAPI.isManualTrigger(event)) {\\n\\t\\t\\t\\tvar triggerData = completionAPI.getMatchingTrigger(\\\"\\\", \\\"\\\", function (length) {\\n\\t\\t\\t\\t\\tconst caret = cm.getCursor();\\n\\t\\t\\t\\t\\tconst start = {\\n\\t\\t\\t\\t\\t\\tline: caret.line,\\n\\t\\t\\t\\t\\t\\tch: Math.max(0, caret.ch - length)\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\treturn cm.getRange(start, caret);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tif (triggerData) {\\n\\t\\t\\t\\t\\tstartCompletion(triggerData, cm, { editedTiddler: this.editTitle });\\n\\t\\t\\t\\t\\t// Prevent codemirror-autocomplete from triggering\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction startCompletion(triggerData, cm, options) {\\n\\t\\t\\tactiveCm = cm;\\n\\t\\t\\tactiveDocument = cm.getInputField().ownerDocument;\\n\\n\\t\\t\\tactiveDocument.addEventListener('mousedown', handleDocumentMouseDownCapture, true);\\n\\n\\t\\t\\ttriggerLength = triggerData.trigger.length;\\n\\t\\t\\tselectionStart = cm.getCursor();\\n\\t\\t\\tcompletionAPI.startCompletion(triggerData, getCaretCoordinates(cm, selectionStart), {\\n\\t\\t\\t\\tonFinish: handleFinishCompletion,\\n\\t\\t\\t\\twindowID: cm.getInputField().ownerDocument._ecAcWindowID,\\n\\t\\t\\t\\teditedTiddler: options.editedTiddler || ''\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tfunction handleDocumentMouseDownCapture(event) {\\n\\t\\t\\tconst target = event.target;\\n\\t\\t\\tif (\\n\\t\\t\\t\\t!completionAPI.isActive\\n\\t\\t\\t\\t|| !activeCm\\n\\t\\t\\t\\t|| !target\\n\\t\\t\\t\\t|| !target.classList.contains('ec_ac-link')\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst value = target.getAttribute('data-value');\\n\\n\\t\\t\\tcompletionAPI.setSelectionByValue(value);\\n\\t\\t\\tinsertSelection(completionAPI.getSelected());\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t}\\n\\n\\t\\tfunction handleFinishCompletion() {\\n\\t\\t\\tactiveDocument.removeEventListener('keydown', handleDocumentMouseDownCapture, true);\\n\\n\\t\\t\\tactiveCm = null;\\n\\t\\t\\tactiveDocument = null;\\n\\t\\t}\\n\\n\\t\\tfunction handleEngineInput(cm, operation) {\\n\\t\\t\\tconst data = getOperationData(cm, operation);\\n\\n\\t\\t\\tif (!completionAPI.isActive && data !== null && data !== \\\"\\\") {\\n\\t\\t\\t\\tselectionStart = cm.getCursor();\\n\\n\\t\\t\\t\\tvar triggerData = completionAPI.getMatchingTrigger(data, \\\"TEXTAREA\\\", function (length) {\\n\\t\\t\\t\\t\\tconst caret = cm.getCursor();\\n\\t\\t\\t\\t\\tconst start = {\\n\\t\\t\\t\\t\\t\\tline: caret.line,\\n\\t\\t\\t\\t\\t\\tch: Math.max(0, caret.ch - length)\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\treturn cm.getRange(start, caret);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tif (triggerData) {\\n\\t\\t\\t\\t\\tactiveCm = cm;\\n\\t\\t\\t\\t\\tstartCompletion(triggerData, cm, { editedTiddler: this.editTitle });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction getOperationData(cm, operation) {\\n\\t\\t\\tif (!operation || !operation.text || operation.text.length !== 1 || operation.origin !== \\\"+input\\\") {\\n\\t\\t\\t\\treturn \\\"\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst inputText = operation.text[0];\\n\\n\\t\\t\\tconst autoCloseBracketsConf = cm.getOption('autoCloseBrackets');\\n\\t\\t\\tif (autoCloseBracketsConf) {\\n\\t\\t\\t\\t// Special handling if autoCloseBrackets plugin is enabled\\n\\t\\t\\t\\tconst pairs = autoCloseBracketsConf.pairs || \\\"()[]{}''\\\\\\\"\\\\\\\"\\\";\\n\\t\\t\\t\\tconst index = pairs.indexOf(inputText);\\n\\n\\t\\t\\t\\t// If a configured pair was input then let's act as if only the first character was inserted\\n\\t\\t\\t\\tif (index !== -1 && index % 2 === 0) {\\n\\t\\t\\t\\t\\treturn inputText.substring(0, 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn inputText;\\n\\t\\t}\\n\\n\\t\\tfunction handleBlur() {\\n\\t\\t\\tif (completionAPI.isActive) {\\n\\t\\t\\t\\tcompletionAPI.finishCompletion();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction handleCursorActivity(cm) {\\n\\t\\t\\tif (!completionAPI.isActive || !cm.hasFocus()) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tconst cursor = cm.getCursor();\\n\\n\\t\\t\\tif (cursor.line < selectionStart.line || cursor.ch < selectionStart.ch) {\\n\\t\\t\\t\\tcompletionAPI.finishCompletion();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcompletionAPI.updateQuery(cm.getRange(selectionStart, cursor));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction insertSelection(value) {\\n\\t\\t\\tconst completed = completionAPI.getCompletedTemplate(value);\\n\\t\\t\\tconst sliceStart = {\\n\\t\\t\\t\\tline: selectionStart.line,\\n\\t\\t\\t\\tch: selectionStart.ch - triggerLength\\n\\t\\t\\t};\\n\\t\\t\\tconst sliceEnd = activeCm.getCursor();\\n\\n\\t\\t\\tactiveCm.replaceRange(completed.text, sliceStart, sliceEnd);\\n\\t\\t\\tactiveCm.setCursor({\\n\\t\\t\\t\\tline: selectionStart.line,\\n\\t\\t\\t\\tch: selectionStart.ch - triggerLength + completed.caretIndex\\n\\t\\t\\t});\\n\\t\\t\\tcompletionAPI.finishCompletion();\\n\\t\\t}\\n\\n\\t\\tfunction getCaretCoordinates(cm, caretPos) {\\n\\t\\t\\tconst coords = cm.charCoords(caretPos);\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tleft: coords.left,\\n\\t\\t\\t\\ttop: coords.bottom\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/EvidentlyCube/AutoComplete/integration-core.js\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/integration-core.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/AutoComplete/integration-core.js\\ntype: application/javascript\\nmodule-type: library\\n\\nAutocompletion integration for Simple text editor\\n\\n\\\\*/\\n(function () {\\n\\n\\texports.patch = function (completionAPI, monkeypatch) {\\n\\t\\tvar editTextWidget = require('$:/core/modules/widgets/edit-text.js')['edit-text'];\\n\\t\\tvar simpleEngine = require('$:/core/modules/editor/engines/simple.js').SimpleEngine;\\n\\t\\tvar framedEngine = require('$:/core/modules/editor/engines/framed.js').FramedEngine;\\n\\t\\tvar getBaseCaretCoordinates = require('$:/plugins/EvidentlyCube/AutoComplete/textarea-caret-position.js').getCaretCoordinates;\\n\\n\\t\\tvar selectionStart = -1;\\n\\t\\tvar activeDom = null;\\n\\t\\tvar activeDocument_keyHook = null;\\n\\t\\tvar activeDocument_mouseHook = null;\\n\\t\\tvar triggerLength = -1;\\n\\n\\t\\t// Needed to be able to detect main TW window in the mechanism that prevents\\n\\t\\t// Auto Complete from opening in multiple windows\\n\\t\\tdocument._ecAcWindowID = \\\"\\\";\\n\\n\\t\\teditTextWidget.prototype.render = monkeypatch.sequence(editTextWidget.prototype.render, widgetRender);\\n\\t\\teditTextWidget.prototype.handleKeydownEvent = monkeypatch.preventable(editTextWidget.prototype.handleKeydownEvent, handleWidgetKeydown);\\n\\t\\tsimpleEngine.prototype.handleInputEvent = monkeypatch.preventable(simpleEngine.prototype.handleInputEvent, handleEngineInput);\\n\\t\\tframedEngine.prototype.handleInputEvent = monkeypatch.preventable(framedEngine.prototype.handleInputEvent, handleEngineInput);\\n\\n\\t\\tfunction widgetRender() {\\n\\t\\t\\tthis.engine.domNode.addEventListener('blur', handleBlur);\\n\\t\\t\\tthis.engine.domNode.addEventListener('keyup', handleKeyup);\\n\\n\\t\\t\\t// We need to be able to detect this even for inputs\\n\\t\\t\\tif (!this.editShowToolbar) {\\n\\t\\t\\t\\t$tw.utils.addEventListeners(this.engine.domNode, [\\n\\t\\t\\t\\t\\t{ name: 'keydown', handlerObject: this, handlerMethod: 'handleKeydownEvent' }\\n\\t\\t\\t\\t]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction handleWidgetKeydown(event) {\\n\\t\\t\\tif (completionAPI.isActive) {\\n\\t\\t\\t\\tswitch (event.key) {\\n\\t\\t\\t\\t\\tcase \\\"ArrowUp\\\":\\n\\t\\t\\t\\t\\tcase \\\"ArrowDown\\\":\\n\\t\\t\\t\\t\\t\\tcompletionAPI.changeSelection(event.key === \\\"ArrowUp\\\" ? -1 : 1);\\n\\t\\t\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if (completionAPI.isManualTrigger(event)) {\\n\\t\\t\\t\\tvar triggerData = completionAPI.getMatchingTrigger(\\\"\\\", event.target.tagName, function (length) {\\n\\t\\t\\t\\t\\treturn event.target.value.substr(event.target.selectionStart - length, length);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tif (triggerData) {\\n\\t\\t\\t\\t\\tstartCompletion(triggerData, event.target, this.editTitle);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction startCompletion(triggerData, dom, editedTiddler) {\\n\\t\\t\\t// Special handling to avoid confirm to close draft when editing in framed editor\\n\\t\\t\\tactiveDocument_keyHook = dom.ownerDocument;\\n\\t\\t\\tactiveDocument_mouseHook = activeDocument_keyHook.defaultView.top.document;\\n\\n\\t\\t\\t// Iframed editor compatibility: Prevent escape from asking to close the tiddler if completion is active\\n\\t\\t\\t// Streams Plugin compatibility: Handle enter on root to circumvent new stream being created\\n\\t\\t\\tactiveDocument_keyHook.addEventListener('keydown', handleDocumentKeydownCapture, true);\\n\\t\\t\\tactiveDocument_mouseHook.addEventListener('mousedown', handleDocumentMouseDownCapture, true);\\n\\n\\t\\t\\tactiveDom = dom;\\n\\t\\t\\ttriggerLength = triggerData.trigger.length;\\n\\t\\t\\tselectionStart = dom.selectionStart;\\n\\t\\t\\tcompletionAPI.startCompletion(triggerData, getCaretCoordinates(dom, selectionStart), {\\n\\t\\t\\t\\tonFinish: handleFinishCompletion,\\n\\t\\t\\t\\twindowID: dom.ownerDocument.defaultView.top.document._ecAcWindowID,\\n\\t\\t\\t\\teditedTiddler: editedTiddler\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tfunction handleFinishCompletion() {\\n\\t\\t\\tactiveDocument_keyHook.removeEventListener('keydown', handleDocumentKeydownCapture, true);\\n\\t\\t\\tactiveDocument_mouseHook.removeEventListener('mousedown', handleDocumentMouseDownCapture, true);\\n\\n\\t\\t\\tactiveDom = null;\\n\\t\\t\\tactiveDocument_keyHook = null;\\n\\t\\t\\tactiveDocument_mouseHook = null;\\n\\t\\t}\\n\\n\\t\\tfunction handleDocumentMouseDownCapture(event) {\\n\\t\\t\\tconst target = event.target;\\n\\t\\t\\tif (!completionAPI.isActive || !target || !target.classList.contains('ec_ac-link')) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst value = target.getAttribute('data-value');\\n\\n\\t\\t\\tcompletionAPI.setSelectionByValue(value);\\n\\t\\t\\tinsertSelection(completionAPI.getSelected());\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t}\\n\\n\\t\\tfunction handleDocumentKeydownCapture(event) {\\n\\t\\t\\tif (!completionAPI.isActive) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tswitch (event.key) {\\n\\t\\t\\t\\tcase 'Escape':\\n\\t\\t\\t\\t\\tcompletionAPI.finishCompletion();\\n\\t\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t\\t\\tevent.preventDefault()\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'Enter':\\n\\t\\t\\t\\t\\tif (!event.ctrlKey && !event.shiftKey && !event.altKey) {\\n\\t\\t\\t\\t\\t\\tconst option = completionAPI.getSelected();\\n\\n\\t\\t\\t\\t\\t\\tif (option) {\\n\\t\\t\\t\\t\\t\\t\\tinsertSelection(option);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tcompletionAPI.finishCompletion();\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction handleEngineInput(event) {\\n\\t\\t\\tif (!completionAPI.isActive && event.data !== null && event.data !== \\\"\\\") {\\n\\t\\t\\t\\tvar triggerData = completionAPI.getMatchingTrigger(event.data, event.target.tagName, function (length) {\\n\\t\\t\\t\\t\\treturn event.target.value.substr(event.target.selectionStart - length, length);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tif (triggerData) {\\n\\t\\t\\t\\t\\tactiveDom = event.target;\\n\\t\\t\\t\\t\\tstartCompletion(triggerData, event.target, this.widget.editTitle);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction handleBlur(event) {\\n\\t\\t\\tif (completionAPI.isActive) {\\n\\t\\t\\t\\tcompletionAPI.finishCompletion();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction handleKeyup(event) {\\n\\t\\t\\tif (!completionAPI.isActive) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t} else if (!activeDom) {\\n\\t\\t\\t\\tcompletionAPI.finishCompletion();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (activeDom.selectionStart < selectionStart) {\\n\\t\\t\\t\\tcompletionAPI.finishCompletion();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcompletionAPI.updateQuery(activeDom.value.substring(selectionStart, activeDom.selectionStart));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction insertSelection(value) {\\n\\t\\t\\tconst completed = completionAPI.getCompletedTemplate(value);\\n\\t\\t\\tconst sliceStart = selectionStart - triggerLength;\\n\\t\\t\\tconst sliceEnd = activeDom.selectionStart;\\n\\n\\t\\t\\tif (activeDom.getRootNode().execCommand) {\\n\\t\\t\\t\\tactiveDom.selectionStart = sliceStart;\\n\\t\\t\\t\\tactiveDom.selectionEnd = sliceEnd;\\n\\t\\t\\t\\tactiveDom.getRootNode().execCommand(\\\"insertText\\\", false, completed.text);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tactiveDom.value = activeDom.value.substr(0, sliceStart)\\n\\t\\t\\t\\t\\t+ completed.text\\n\\t\\t\\t\\t\\t+ activeDom.value.substr(sliceEnd);\\n\\t\\t\\t}\\n\\n\\t\\t\\tactiveDom.selectionStart = activeDom.selectionEnd = selectionStart - triggerLength + completed.caretIndex;\\n\\t\\t\\tcompletionAPI.finishCompletion();\\n\\t\\t}\\n\\n\\t\\tfunction getCaretCoordinates() {\\n\\t\\t\\tconst baseCoords = activeDom.getBoundingClientRect();\\n\\t\\t\\tconst domDocument = activeDom.getRootNode();\\n\\t\\t\\tconst domWindow = domDocument.defaultView;\\n\\t\\t\\tconst caretCoords = getBaseCaretCoordinates(activeDom, selectionStart);\\n\\t\\t\\tconst domScroll = { left: -activeDom.scrollLeft, top: -activeDom.scrollTop };\\n\\t\\t\\tconst containingIframe = getContainingIframe(activeDom);\\n\\t\\t\\tconst iframeCoords = getIframeOffset(containingIframe);\\n\\t\\t\\tconst parentWindowCoords = containingIframe\\n\\t\\t\\t\\t? { left: containingIframe.ownerDocument.defaultView.scrollX, top: containingIframe.ownerDocument.defaultView.scrollY }\\n\\t\\t\\t\\t: { left: 0, top: 0 };\\n\\n\\t\\t\\tconst totalCoords = sumCoords([baseCoords, caretCoords, iframeCoords, parentWindowCoords, domScroll]);\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tleft: totalCoords.left + domWindow.scrollX,\\n\\t\\t\\t\\ttop: totalCoords.top + domWindow.scrollY + caretCoords.height\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction sumCoords(coords) {\\n\\t\\t\\tconst totalCoords = { left: 0, top: 0 };\\n\\t\\t\\tfor (const coord of coords) {\\n\\t\\t\\t\\ttotalCoords.left += coord.left;\\n\\t\\t\\t\\ttotalCoords.top += coord.top;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn totalCoords;\\n\\t\\t}\\n\\n\\t\\tfunction getContainingIframe(dom) {\\n\\t\\t\\tconst root = dom.getRootNode();\\n\\n\\t\\t\\tif (root !== document) {\\n\\t\\t\\t\\tconst parentDocument = root.defaultView.parent.document;\\n\\t\\t\\t\\tconst iframes = parentDocument.querySelectorAll('iframe');\\n\\t\\t\\t\\tfor (var i = 0; i < iframes.length; i++) {\\n\\t\\t\\t\\t\\tconst iframe = iframes[i];\\n\\n\\t\\t\\t\\t\\tif (iframe.contentDocument !== root) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn iframe;;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tfunction getIframeOffset(containingIframe) {\\n\\t\\t\\treturn containingIframe\\n\\t\\t\\t\\t? containingIframe.getBoundingClientRect()\\n\\t\\t\\t\\t: { top: 0, left: 0 };\\n\\t\\t}\\n\\t}\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/EvidentlyCube/AutoComplete/Settings\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/Settings\",\"tags\":\"$:/tags/EvidentlyCube/SettingsTab\",\"caption\":\"Auto Complete\",\"text\":\"\\\\define action-new-trigger()\\n<$action-createtiddler\\n\\t$basetitle={{{ [all[shadows+tiddlers]tag[$:/tags/EC/AutoComplete/Trigger]!is[draft]count[]add[1]addprefix[$:/EvidentlyCube/Trigger/]] }}}\\n\\ttags=\\\"$:/tags/EC/AutoComplete/Trigger\\\"\\n\\tcaption={{{ [all[shadows+tiddlers]tag[$:/tags/EC/AutoComplete/Trigger]!is[draft]count[]add[1]addprefix[Unnamed trigger ]] }}}\\n\\ttrigger=\\\"[[\\\"\\n\\tfilter=\\\"[all[tiddlers]!is[system]!is[draft]search:title<query>]\\\"\\n\\tdisplay-filter=\\\"[<currentTiddler>]\\\"\\n\\ttemplate=\\\"[[$option$]]$caret$\\\"\\n\\tauto-trigger-textarea=\\\"1\\\"\\n>\\n\\t<$action-navigate $to=<<createTiddler-title>> scroll=\\\"yes\\\"/>\\n</$action-createtiddler>\\n\\\\end\\n\\n\\\\define action-open-keyboard-shortcuts()\\n<$action-setfield $tiddler=\\\"$:/state/tab-1749438307\\\" text=\\\"$:/core/ui/ControlPanel/KeyboardShortcuts\\\" />\\n\\\\end\\n\\n\\\\define comp-open-keyboard-shortcuts()\\n<$button\\n\\ttag=\\\"a\\\"\\n\\tclass=\\\"tc-tiddlylink tc-tiddlylink-resolves ec_ac-pointer\\\"\\n\\tactions=<<action-open-keyboard-shortcuts>>\\n>Keyboard Shortcuts</$button>\\n\\n\\\\end\\n\\nConfiguration for the [[Auto Complete|$:/plugins/EvidentlyCube/AutoComplete]] plugin.\\n\\n! Registered Triggers\\n\\n<ul>\\n\\t<$list filter=\\\"[all[shadows+tiddlers]tag[$:/tags/EC/AutoComplete/Trigger]!is[draft]sortan[title]sortan[caption]]\\\">\\n\\t\\t<li><$link to=<<currentTiddler>>><$view field=\\\"caption\\\"><$view field=\\\"title\\\"/></$view></$link> (Trigger <code><$text text={{!!trigger}} /></code>)</li>\\n\\t</$list>\\n\\t<li><$button actions=<<action-new-trigger>>>Create a new trigger</$button></li>\\n</ul>\\n\\n! Config\\n\\n<table>\\n<colgroup>\\n\\t<col width=\\\"60%\\\"/>\\n</colgroup>\\n<tbody>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Displayed results''<br/>\\n\\t\\t//Maximum number of results to display in the auto complete window, must be between 1 and 99//\\n\\t</td>\\n\\t<td>\\n\\t\\t<$edit-text tiddler=\\\"$:/plugins/EvidentlyCube/AutoComplete/Config\\\" field=\\\"rows\\\" default=\\\"8\\\"/>\\n\\t\\t<$list filter=\\\"\\\"\\\"\\n\\t\\t\\t[{$:/plugins/EvidentlyCube/AutoComplete/Config!!rows}floor[]compare:number:lt[1]]\\n\\t\\t\\t[{$:/plugins/EvidentlyCube/AutoComplete/Config!!rows}floor[]compare:number:gt[99]]\\n\\t\\t\\t+[count[]!match[0]]\\n\\t\\t\\\"\\\"\\\">\\n\\t\\t\\t<div class=\\\"tc-error\\\">Must be a number between 1 and 99</div>\\n\\t\\t</$list>\\n\\t</td>\\n</tr>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Keyboard Shortcut''<br/>\\n\\t\\t//Use this keyboard shortcut right in front of a trigger to manually open the completion window; can be changed in <<comp-open-keyboard-shortcuts>>tab//\\n\\t</td>\\n\\t<td>\\n\\t<$list filter=\\\"$:/config/shortcuts/ $:/config/shortcuts-mac/ $:/config/shortcuts-not-mac/ $:/config/shortcuts-linux/ $:/config/shortcuts-not-linux/ $:/config/shortcuts-windows/ $:/config/shortcuts-not-windows/\\\">\\n\\t\\t<$macrocall $name=\\\"displayshortcuts\\\" $output=\\\"text/html\\\" shortcuts={{{ [<currentTiddler>addsuffix[EC-AutoComplete]get[text]] }}} prefix=\\\"<kbd>\\\" separator=\\\"</kbd> <kbd>\\\" suffix=\\\"</kbd>\\\"/>\\n\\t</$list>\\n\\t</td>\\n</tr>\\n</tbody>\\n</table>\\n\\n\"},\"$:/plugins/EvidentlyCube/AutoComplete/template-cascade\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/template-cascade\",\"tags\":\"$:/tags/ViewTemplateBodyFilter\",\"list-after\":\"$:/config/ViewTemplateBodyFilters/system\",\"text\":\"[tag[$:/tags/EC/AutoComplete/Trigger]then[$:/plugins/EvidentlyCube/AutoComplete/template]]\"},\"$:/plugins/EvidentlyCube/AutoComplete/template\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/template\",\"text\":\"\\\\define must-be-defined(field name)\\n<$list filter=\\\"[{!!$field$}match[]]\\\">\\n\\t<span class=\\\"tc-error\\\">\\n\\t\\t$name$ must be defined\\n\\t</span>\\n</$list>\\n\\\\end\\n\\n\\\\define must-be-valid-filter(field)\\n<$let\\n\\tbase-filter={{!!$field$}}\\n\\tsuffix=\\\" +[limit[1]]\\\"\\n\\tfilter={{{ [<base-filter>addsuffix<suffix>] }}}\\n>\\n<$list filter=<<filter>>>\\n\\t<$list filter={{{ [<currentTiddler>prefix[Filter error]] }}}>\\n\\t\\t<span class=\\\"tc-error\\\">\\n\\t\\t\\t<$text text=<<currentTiddler>>/>\\n\\t\\t</span>\\n\\t</$list>\\n</$list>\\n</$let>\\n\\\\end\\n\\n<div class=\\\"ec_ac-options\\\">\\n<h1>Auto complete trigger</h1>\\n\\n<p>This tiddler defines a trigger for Auto Complete plugin.</p>\\n\\n<table>\\n<colgroup>\\n\\t<col width=\\\"50%\\\"/>\\n</colgroup>\\n<tbody>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Caption:''<br/>\\n\\t\\t<p class=\\\"ec_ac-muted\\\">\\n\\t\\t\\tOptional caption displayed in the Control Panel instead of the tiddler name\\n\\t\\t</p>\\n\\t</td>\\n\\t<td><$edit-text class=\\\"ec-tc-disabled\\\" field=\\\"caption\\\" default=\\\"\\\" placeholder=\\\"Caption...\\\"/></td>\\n</tr>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Description:''<br/>\\n\\t\\t<p class=\\\"ec_ac-muted\\\">\\n\\t\\t\\tA description of this trigger to make it easier to keep things clean.\\n\\t\\t</p>\\n\\t</td>\\n\\t<td><$edit-text class=\\\"ec-tc-disabled\\\" field=\\\"text\\\" default=\\\"\\\" placeholder=\\\"Description for this trigger...\\\"/></td>\\n</tr>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Trigger:''<br/>\\n\\t\\t<p class=\\\"ec_ac-muted\\\">\\n\\t\\t\\tDefines the text which will trigger auto completion.<br/>\\n\\t\\t\\tFor example `[[` will cause the auto completion to appear after you type `[[` in any text field.\\n\\t\\t</p>\\n\\t</td>\\n\\t<td>\\n\\t\\t<$edit-text class=\\\"ec-tc-disabled\\\" field=\\\"trigger\\\" placeholder=\\\"Trigger...\\\"/>\\n\\t\\t<$list filter=\\\"[all[shadows+tiddlers]tag[$:/tags/EC/AutoComplete/Trigger]field:trigger{!!trigger}] -[<currentTiddler>] +[limit[1]]\\\">\\n\\t\\t\\t<span class=\\\"tc-error\\\">\\n\\t\\t\\t\\tTrigger already used in: <<currentTiddler>>\\n\\t\\t\\t</span>\\n\\t\\t</$list>\\n\\t\\t<<must-be-defined \\\"trigger\\\" \\\"Trigger\\\">>\\n\\t</td>\\n</tr>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Suggestion Filter:''<br/>\\n\\t\\t<p class=\\\"ec_ac-muted\\\">\\n\\t\\t\\tThis filter generates the list of options that will be displayed in the auto completion.<br/>\\n\\t\\t\\tUse variable `query` to inject the typed text.<br/>\\n\\t\\t\\tVariable `<editedTiddler>` contains the name of the tiddler that is being modified by the widget that triggered auto completion.\\n\\t\\t</p>\\n\\t</td>\\n\\t<td>\\n\\t\\t<$edit-text class=\\\"ec-tc-disabled\\\" tag=\\\"textarea\\\" field=\\\"filter\\\" placeholder=\\\"Filter...\\\"/>\\n\\t\\t<<must-be-valid-filter \\\"filter\\\">>\\n\\t\\t<<must-be-defined \\\"filter\\\" \\\"Filter\\\">>\\n\\t</td>\\n</tr>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Display Filter:''<br/>\\n\\t\\t<p class=\\\"ec_ac-muted\\\">\\n\\t\\t\\tAdvanced feature!<br/>\\n\\t\\t\\tTransforms how the suggestion will be displayed in auto complete window.<br/>\\n\\t\\t\\t`<currentTiddler>` contains the suggestion being displayed.<br/>\\n\\t\\t\\tVariable `<editedTiddler>` contains the name of the tiddler that is being modified by the widget that triggered auto completion.\\n\\t\\t</p>\\n\\t</td>\\n\\t<td>\\n\\t\\t<$edit-text class=\\\"ec-tc-disabled\\\" tag=\\\"textarea\\\" field=\\\"display-filter\\\" placeholder=\\\"Display filter...\\\"/>\\n\\t\\t<<must-be-valid-filter \\\"display-filter\\\">>\\n\\t\\t<<must-be-defined \\\"display-filter\\\" \\\"Display filter\\\">>\\n\\t</td>\\n</tr>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Transform Filter:''<br/>\\n\\t\\t<p class=\\\"ec_ac-muted\\\">\\n\\t\\t\\tAdvanced feature!<br/>\\n\\t\\t\\tTransform the selected suggestion before it's inserted.<br/>\\n\\t\\t\\tIt's useful when you want to insert tiddler's text or data indexes.<br/>\\n\\t\\t\\t`<currentTiddler>` contains the suggestion selected.\\n\\t\\t</p>\\n\\t</td>\\n\\t<td>\\n\\t\\t<$edit-text class=\\\"ec-tc-disabled\\\" tag=\\\"textarea\\\" field=\\\"transform-filter\\\" placeholder=\\\"[<currentTiddler>]\\\"/>\\n\\t\\t<<must-be-valid-filter \\\"transform-filter\\\">>\\n\\t</td>\\n</tr>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Template:''<br/>\\n\\t\\t<p class=\\\"ec_ac-muted\\\">\\n\\t\\t\\tA template that is inserted when you select an option from auto completion.<br/>\\n\\t\\t\\t`$option$` will be replaced by the selected option. <br/>\\n\\t\\t\\t`$caret$` will put the caret on that position after insertion.\\n\\t\\t</p>\\n\\t</td>\\n\\t<td>\\n\\t\\t<$edit-text class=\\\"ec-tc-disabled\\\" field=\\\"template\\\" placeholder=\\\"Template...\\\"/>\\n\\t\\t<<must-be-defined \\\"template\\\" \\\"Template\\\">>\\n\\t</td>\\n</tr>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Auto trigger on Inputs:''<br/>\\n\\t\\t<p class=\\\"ec_ac-muted\\\">\\n\\t\\t\\tIf checked auto completion will automatically open as soon as you type the ''trigger'' in a single-line text input.<br/>\\n\\t\\t\\tOtherwise you need to open it manually with a keyboard shortcut.\\n\\t\\t</p>\\n\\t</td>\\n\\t<td>\\n\\t\\t<$checkbox field=\\\"auto-trigger-input\\\" checked=\\\"1\\\">&nbsp;Auto trigger on Inputs</$checkbox>\\n\\t</td>\\n</tr>\\n<tr>\\n\\t<td align=\\\"center\\\">\\n\\t\\t''Auto trigger on Text Areas:''<br/>\\n\\t\\t<p class=\\\"ec_ac-muted\\\">\\n\\t\\t\\tIf checked auto completion will automatically open as soon as you type the ''trigger'' in a multi-line text input.<br/>\\n\\t\\t\\tOtherwise you need to open it manually with a keyboard shortcut.\\n\\t\\t</p>\\n\\t</td>\\n\\t<td>\\n\\t\\t<$checkbox field=\\\"auto-trigger-textarea\\\" checked=\\\"1\\\">&nbsp;Auto trigger on Text Areas</$checkbox>\\n\\t</td>\\n</tr>\\n</tbody>\\n</table>\\n\\n<h1>Test the filter</h1>\\n\\n<$let\\n\\ttemp=<<qualify \\\"$:/temp/completion-test\\\">>\\n\\trows={{{ [{$:/plugins/EvidentlyCube/AutoComplete/Config!!rows}floor[]!match[0]else[8]min[99]max[1]] }}}\\n\\tdefault-transform-filter=\\\"[<currentTiddler>]\\\"\\n\\tfilter-suffix=\\\" +[limit<rows>]\\\"\\n\\tdisplay-filter={{!!display-filter}}\\n\\ttransform-filter={{{ [{!!transform-filter}!match[]else<default-transform-filter>] }}}\\n\\tfilter={{{ [{!!filter}addsuffix<filter-suffix>] }}}\\n>\\n\\t''Query:'' <$edit-text tag=\\\"input\\\" class=\\\"ec-tc-disabled\\\" tiddler=<<temp>> field=\\\"query\\\" default=\\\"\\\" placeholder=\\\"Test...\\\"/>\\n\\n\\t<p class=\\\"ec_ac-muted\\\">Only the first <<rows>> results will be displayed.</p>\\n\\n\\t<table>\\n\\t<thead>\\n\\t<tr>\\n\\t\\t<th>Suggestion</th>\\n\\t\\t<th>Displays as</th>\\n\\t\\t<th>After insertion</th>\\n\\t</tr>\\n\\t</thead>\\n\\t<tbody>\\n\\t<$let\\n\\t\\tquery={{{ [<temp>get[query]] }}}\\n\\t\\teditedTiddler=<<temp>>\\n\\t>\\n\\t\\t<$list filter=<<filter>> emptyMessage=\\\"\\\"\\\"<tr><td colspan=\\\"3\\\" class=\\\"ec_ac-muted\\\">No results</td></tr>\\\"\\\"\\\">\\n\\t\\t\\t<tr>\\n\\t\\t\\t\\t<td><$text text={{{ [<currentTiddler>] }}} /></td>\\n\\t\\t\\t\\t<td><$text text={{{ [<currentTiddler>subfilter<display-filter>] }}} /></td>\\n\\t\\t\\t\\t<td><$text text={{{ [<currentTiddler>subfilter<transform-filter>] }}} /></td>\\n\\t\\t\\t</tr>\\n\\t\\t</$list>\\n\\t</$let>\\n\\t</tbody>\\n\\t</table>\\n</$let>\\n</div>\\n\"},\"$:/plugins/EvidentlyCube/AutoComplete/Style\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/Style\",\"tags\":\"$:/tags/Stylesheet\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\".ec_ac-muted {\\n\\tcolor: <<colour foreground>>;\\n\\topacity: 0.75;\\n\\tfont-style: italic;\\n}\\n\\n.ec_ac-completion {\\n\\tposition: absolute;\\n\\tbackground: <<colour modal-background>>;\\n\\tborder: 2px solid <<colour modal-border>>;\\n\\tpadding: 2em 1em;\\n\\tbox-shadow: 2px 2px 10px rgba(0, 0, 0, 0.5);\\n\\tz-index: 100000;\\n\\tmin-width: 250px;\\n}\\n\\n.ec_ac-dots-top {\\n\\tpointer-events: none;\\n\\tuser-select: none;\\n\\tposition: absolute;\\n\\tfont-size: 2em;\\n\\ttext-align: center;\\n\\ttop: 0;\\n\\tleft: 0;\\n\\tright: 0;\\n}\\n.ec_ac-dots-bottom {\\n\\tpointer-events: none;\\n\\tuser-select: none;\\n\\tposition: absolute;\\n\\tfont-size: 2em;\\n\\ttext-align: center;\\n\\tbottom: 0.5em;\\n\\tleft: 0;\\n\\tright: 0;\\n}\\n.ec_ac-completion li {\\n\\tlist-style: none;\\n}\\n.ec_ac-completion .label {\\n\\tcolor: <<colour muted-foreground>>;\\n}\\n.ec_ac-completion .ec_ac-link {\\n\\tcolor: <<colour tiddler-link-foreground>>;\\n\\tcursor: pointer;\\n}\\n.ec_ac-completion .ec_ac-link.selected,\\n.ec_ac-completion .ec_ac-link:hover\\n{\\n\\tbackground-color: <<colour tiddler-link-foreground>>;\\n\\tcolor: <<colour background>>;\\n}\\n\\n.ec_ac-options table {\\n\\twidth: 100%;\\n}\\n\\n.ec_ac-options p {\\n\\tmargin-top: 0;\\n\\tmargin-bottom: 0;\\n}\\n.ec_ac-options input:not([type=\\\"checkbox\\\"]),\\n.ec_ac-options textarea {\\n\\tdisplay: block;\\n\\twidth: 100%;\\n\\tmargin-top: 7px;\\n\\tmargin-bottom: 7px;\\n}\\n\\n.ec_ac-options .tc-error a {\\n\\tcolor: white;\\n\\ttext-decoration: underline;\\n}\\n\\n.ec_ac-pointer {\\n\\tcursor: pointer;\\n}\"},\"$:/plugins/EvidentlyCube/AutoComplete/textarea-caret-position.js\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/textarea-caret-position.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/AutoComplete/textarea-caret-position.js\\ntype: application/javascript\\nmodule-type: library\\n\\nComputes pixel-position of the caret\\n\\nTaken from: https://github.com/koddsson/textarea-caret-position\\nThe MIT License (MIT)\\n\\nCopyright (c) 2015 Jonathan Ong me@jongleberry.com\\n\\\\*/\\n\\n(function(){\\n// We'll copy the properties below into the mirror div.\\n// Note that some browsers, such as Firefox, do not concatenate properties\\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\\n// so we have to list every single property explicitly.\\nconst properties = [\\n\\t'direction', // RTL support\\n\\t'boxSizing',\\n\\t'width', // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\\n\\t'height',\\n\\t'overflowX',\\n\\t'overflowY', // copy the scrollbar for IE\\n\\n\\t'borderTopWidth',\\n\\t'borderRightWidth',\\n\\t'borderBottomWidth',\\n\\t'borderLeftWidth',\\n\\t'borderStyle',\\n\\n\\t'paddingTop',\\n\\t'paddingRight',\\n\\t'paddingBottom',\\n\\t'paddingLeft',\\n\\n\\t// https://developer.mozilla.org/en-US/docs/Web/CSS/font\\n\\t'fontStyle',\\n\\t'fontVariant',\\n\\t'fontWeight',\\n\\t'fontStretch',\\n\\t'fontSize',\\n\\t'fontSizeAdjust',\\n\\t'lineHeight',\\n\\t'fontFamily',\\n\\n\\t'textAlign',\\n\\t'textTransform',\\n\\t'textIndent',\\n\\t'textDecoration', // might not make a difference, but better be safe\\n\\n\\t'letterSpacing',\\n\\t'wordSpacing',\\n\\n\\t'tabSize',\\n\\t'MozTabSize'\\n]\\n\\nconst isBrowser = typeof window !== 'undefined'\\nconst isFirefox = isBrowser && window.mozInnerScreenX != null\\n\\nexports.getCaretCoordinates = function (element, position, options) {\\n\\tconst debug = (options && options.debug) || false\\n\\tif (debug) {\\n\\t\\tconst el = document.querySelector('#input-textarea-caret-position-mirror-div')\\n\\t\\tif (el) el.parentNode.removeChild(el)\\n\\t}\\n\\n\\t// The mirror div will replicate the textarea's style\\n\\tconst div = document.createElement('div')\\n\\tdiv.id = 'input-textarea-caret-position-mirror-div'\\n\\tdocument.body.appendChild(div)\\n\\n\\tconst style = div.style\\n\\tconst computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle // currentStyle for IE < 9\\n\\tconst isInput = element.nodeName === 'INPUT'\\n\\n\\t// Default textarea styles\\n\\tstyle.whiteSpace = 'pre-wrap'\\n\\tif (!isInput) style.wordWrap = 'break-word' // only for textarea-s\\n\\n\\t// Position off-screen\\n\\tstyle.position = 'absolute' // required to return coordinates properly\\n\\tif (!debug) style.visibility = 'hidden' // not 'display: none' because we want rendering\\n\\n\\t// Transfer the element's properties to the div\\n\\tfor (const prop of properties) {\\n\\t\\tif (isInput && prop === 'lineHeight') {\\n\\t\\t\\t// Special case for <input>s because text is rendered centered and line height may be != height\\n\\t\\t\\tif (computed.boxSizing === 'border-box') {\\n\\t\\t\\t\\tconst height = parseInt(computed.height)\\n\\t\\t\\t\\tconst outerHeight =\\n\\t\\t\\t\\t\\tparseInt(computed.paddingTop) +\\n\\t\\t\\t\\t\\tparseInt(computed.paddingBottom) +\\n\\t\\t\\t\\t\\tparseInt(computed.borderTopWidth) +\\n\\t\\t\\t\\t\\tparseInt(computed.borderBottomWidth)\\n\\t\\t\\t\\tconst targetHeight = outerHeight + parseInt(computed.lineHeight)\\n\\t\\t\\t\\tif (height > targetHeight) {\\n\\t\\t\\t\\t\\tstyle.lineHeight = `${height - outerHeight}px`\\n\\t\\t\\t\\t} else if (height === targetHeight) {\\n\\t\\t\\t\\t\\tstyle.lineHeight = computed.lineHeight\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstyle.lineHeight = 0\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstyle.lineHeight = computed.height\\n\\t\\t\\t}\\n\\t\\t} else if (!isInput && prop === 'width' && computed.boxSizing === 'border-box') {\\n\\t\\t\\t// With box-sizing: border-box we need to offset the size slightly inwards.  This small difference can compound\\n\\t\\t\\t// greatly in long textareas with lots of wrapping, leading to very innacurate results if not accounted for.\\n\\t\\t\\t// Firefox will return computed styles in floats, like `0.9px`, while chromium might return `1px` for the same element.\\n\\t\\t\\t// Either way we use `parseFloat` to turn `0.9px` into `0.9` and `1px` into `1`\\n\\t\\t\\tlet totalBorderWidth = parseFloat(computed.borderLeftWidth) + parseFloat(computed.borderRightWidth)\\n\\t\\t\\t// When a vertical scrollbar is present it shrinks the content. We need to account for this by using clientWidth\\n\\t\\t\\t// instead of width in everything but Firefox. When we do that we also have to account for the border width.\\n\\t\\t\\tlet width = isFirefox ? parseFloat(computed[prop]) - totalBorderWidth : element.clientWidth + totalBorderWidth\\n\\t\\t\\tstyle[prop] = `${width}px`\\n\\t\\t} else {\\n\\t\\t\\tstyle[prop] = computed[prop]\\n\\t\\t}\\n\\t}\\n\\n\\tif (isFirefox) {\\n\\t\\t// Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\\n\\t\\tif (element.scrollHeight > parseInt(computed.height)) style.overflowY = 'scroll'\\n\\t} else {\\n\\t\\tstyle.overflow = 'hidden' // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\\n\\t}\\n\\n\\tdiv.textContent = element.value.substring(0, position)\\n\\t// The second special handling for input type=\\\"text\\\" vs textarea:\\n\\t// spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\\n\\tif (isInput) div.textContent = div.textContent.replace(/\\\\s/g, '\\\\u00a0')\\n\\n\\tconst span = document.createElement('span')\\n\\t// Wrapping must be replicated *exactly*, including when a long word gets\\n\\t// onto the next line, with whitespace at the end of the line before (#7).\\n\\t// The  *only* reliable way to do that is to copy the *entire* rest of the\\n\\t// textarea's content into the <span> created at the caret position.\\n\\t// For inputs, just '.' would be enough, but no need to bother.\\n\\tspan.textContent = element.value.substring(position) || '.' // || because a completely empty faux span doesn't render at all\\n\\tdiv.appendChild(span)\\n\\n\\tconst coordinates = {\\n\\t\\ttop: span.offsetTop + parseInt(computed['borderTopWidth']),\\n\\t\\tleft: span.offsetLeft + parseInt(computed['borderLeftWidth']),\\n\\t\\theight: parseInt(computed['lineHeight'])\\n\\t}\\n\\n\\tif (debug) {\\n\\t\\tspan.style.backgroundColor = '#aaa'\\n\\t} else {\\n\\t\\tdocument.body.removeChild(div)\\n\\t}\\n\\n\\treturn coordinates\\n}\\n})();\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/EvidentlyCube/AutoComplete/window\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/window\",\"tags\":\"$:/tags/PageTemplate\",\"text\":\"\\\\whitespace trim\\n<$let\\n\\twindow-id={{{ [<tw-window-id>else[]] }}}\\n\\tcount={{{ [list[$:/temp/AutoComplete/completion-data]count[]] }}}\\n\\tbase-limit={{$:/plugins/EvidentlyCube/AutoComplete/Config!!rows}}\\n\\tlimit={{{ [<base-limit>add[1]compare:number:eq<count>else<base-limit>] }}}\\n\\thalf-limit={{{ [<limit>divide[2]ceil[]] }}}\\n\\tmax-offset={{{ [<count>subtract<limit>] }}}\\n\\tselected={{$:/temp/AutoComplete/completion-data!!index}}\\n\\toffset={{{ [<selected>subtract<half-limit>min<max-offset>max[0]] }}}\\n\\teditedTiddler={{$:/temp/AutoComplete/completion-data!!edited-tiddler}}\\n>\\n\\n<$list filter=\\\"\\\"\\\"\\n[{$:/temp/AutoComplete/completion-data!!show}]\\n=[{$:/temp/AutoComplete/completion-data!!show-window}match<tv-window-id>then[1]]\\n=[{$:/temp/AutoComplete/completion-data!!show-window}match[-1]then[1]]\\n+[match[1]count[]match[2]]\\n\\\"\\\"\\\"\\nemptyMessage=\\\"\\\"\\\"\\n<ul class=\\\"ec_ac-completion\\\" style=\\\"display: none\\\"></ul>\\n\\\"\\\"\\\"\\nvariable=\\\"ignore\\\"\\n>\\n\\n<ul class=\\\"ec_ac-completion\\\" style={{$:/temp/AutoComplete/completion-data!!style}}>\\n\\t<$list filter=\\\"[<offset>compare:number:gt[0]]\\\">\\n\\t\\t<li class=\\\"ec_ac-dots-top\\\">...</li>\\n\\t</$list>\\n\\t<$list\\n\\t\\tfilter=\\\"[list[$:/temp/AutoComplete/completion-data]rest<offset>first<limit>]\\\"\\n\\t\\tcounter=\\\"index\\\"\\n\\t\\temptyMessage=\\\"\\\"\\\"<li class=\\\"label\\\">No results</li>\\\"\\\"\\\"\\n\\t>\\n\\t\\t<$list filter=\\\"[<index>add<offset>match<selected>]\\\" variable=\\\"_\\\" emptyMessage=\\\"\\\"\\\"\\n\\t\\t\\t<li class=\\\"ec_ac-link\\\" data-value=<<currentTiddler>>>\\n\\t\\t\\t\\t<$text text={{{ [<currentTiddler>subfilter{$:/temp/AutoComplete/completion-data!!display-filter}] }}} />\\n\\t\\t\\t</li>\\n\\t\\t\\\"\\\"\\\">\\n\\t\\t\\t<li class=\\\"ec_ac-link selected\\\" data-value=<<currentTiddler>>>\\n\\t\\t\\t\\t<$text text={{{ [<currentTiddler>subfilter{$:/temp/AutoComplete/completion-data!!display-filter}] }}} />\\n\\t\\t\\t</li>\\n\\t\\t</$list>\\n\\t</$list>\\n\\t<$list filter=\\\"[<offset>compare:number:lt<max-offset>]\\\">\\n\\t\\t<li class=\\\"ec_ac-dots-bottom\\\">...</li>\\n\\t</$list>\\n</ul>\\n</$list>\\n</$let>\"}}}"}