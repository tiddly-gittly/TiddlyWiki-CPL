{"type":"application/json","text":"{\n    \"tiddlers\": {\n        \"$:/plugins/rboue/Three.js/Lib/three-min.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/three-min.js\",\n            \"module-type\": \"library\",\n            \"text\": \"(function(){\\nvar THREE={REVISION:\\\"68\\\"};TiddlyWiki||\\\"object\\\"!==typeof module||(module.exports=THREE);THREE.CullFaceNone=0;THREE.CullFaceBack=1;THREE.CullFaceFront=2;THREE.CullFaceFrontBack=3;THREE.FrontFaceDirectionCW=0;THREE.FrontFaceDirectionCCW=1;THREE.BasicShadowMap=0;THREE.PCFShadowMap=1;THREE.PCFSoftShadowMap=2;THREE.FrontSide=0;THREE.BackSide=1;THREE.DoubleSide=2;THREE.NoShading=0;THREE.FlatShading=1;THREE.SmoothShading=2;THREE.NoColors=0;THREE.FaceColors=1;THREE.VertexColors=2;THREE.NoBlending=0;\\nTHREE.NormalBlending=1;THREE.AdditiveBlending=2;THREE.SubtractiveBlending=3;THREE.MultiplyBlending=4;THREE.CustomBlending=5;THREE.AddEquation=100;THREE.SubtractEquation=101;THREE.ReverseSubtractEquation=102;THREE.ZeroFactor=200;THREE.OneFactor=201;THREE.SrcColorFactor=202;THREE.OneMinusSrcColorFactor=203;THREE.SrcAlphaFactor=204;THREE.OneMinusSrcAlphaFactor=205;THREE.DstAlphaFactor=206;THREE.OneMinusDstAlphaFactor=207;THREE.DstColorFactor=208;THREE.OneMinusDstColorFactor=209;\\nTHREE.SrcAlphaSaturateFactor=210;THREE.MultiplyOperation=0;THREE.MixOperation=1;THREE.AddOperation=2;THREE.UVMapping=function(){};THREE.CubeReflectionMapping=function(){};THREE.CubeRefractionMapping=function(){};THREE.SphericalReflectionMapping=function(){};THREE.SphericalRefractionMapping=function(){};THREE.RepeatWrapping=1E3;THREE.ClampToEdgeWrapping=1001;THREE.MirroredRepeatWrapping=1002;THREE.NearestFilter=1003;THREE.NearestMipMapNearestFilter=1004;THREE.NearestMipMapLinearFilter=1005;\\nTHREE.LinearFilter=1006;THREE.LinearMipMapNearestFilter=1007;THREE.LinearMipMapLinearFilter=1008;THREE.UnsignedByteType=1009;THREE.ByteType=1010;THREE.ShortType=1011;THREE.UnsignedShortType=1012;THREE.IntType=1013;THREE.UnsignedIntType=1014;THREE.FloatType=1015;THREE.UnsignedShort4444Type=1016;THREE.UnsignedShort5551Type=1017;THREE.UnsignedShort565Type=1018;THREE.AlphaFormat=1019;THREE.RGBFormat=1020;THREE.RGBAFormat=1021;THREE.LuminanceFormat=1022;THREE.LuminanceAlphaFormat=1023;\\nTHREE.RGB_S3TC_DXT1_Format=2001;THREE.RGBA_S3TC_DXT1_Format=2002;THREE.RGBA_S3TC_DXT3_Format=2003;THREE.RGBA_S3TC_DXT5_Format=2004;THREE.Color=function(a){return 3===arguments.length?this.setRGB(arguments[0],arguments[1],arguments[2]):this.set(a)};\\nTHREE.Color.prototype={constructor:THREE.Color,r:1,g:1,b:1,set:function(a){a instanceof THREE.Color?this.copy(a):\\\"number\\\"===typeof a?this.setHex(a):\\\"string\\\"===typeof a&&this.setStyle(a);return this},setHex:function(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSL:function(a,b,c){if(0===b)this.r=this.g=this.b=c;else{var d=function(a,b,c){0>c&&(c+=1);1<c&&--c;return c<1/6?a+6*(b-a)*c:\\n.5>c?b:c<2/3?a+6*(b-a)*(2/3-c):a};b=.5>=c?c*(1+b):c+b-c*b;c=2*c-b;this.r=d(c,b,a+1/3);this.g=d(c,b,a);this.b=d(c,b,a-1/3)}return this},setStyle:function(a){if(/^rgb\\\\((\\\\d+), ?(\\\\d+), ?(\\\\d+)\\\\)$/i.test(a))return a=/^rgb\\\\((\\\\d+), ?(\\\\d+), ?(\\\\d+)\\\\)$/i.exec(a),this.r=Math.min(255,parseInt(a[1],10))/255,this.g=Math.min(255,parseInt(a[2],10))/255,this.b=Math.min(255,parseInt(a[3],10))/255,this;if(/^rgb\\\\((\\\\d+)\\\\%, ?(\\\\d+)\\\\%, ?(\\\\d+)\\\\%\\\\)$/i.test(a))return a=/^rgb\\\\((\\\\d+)\\\\%, ?(\\\\d+)\\\\%, ?(\\\\d+)\\\\%\\\\)$/i.exec(a),this.r=\\nMath.min(100,parseInt(a[1],10))/100,this.g=Math.min(100,parseInt(a[2],10))/100,this.b=Math.min(100,parseInt(a[3],10))/100,this;if(/^\\\\#([0-9a-f]{6})$/i.test(a))return a=/^\\\\#([0-9a-f]{6})$/i.exec(a),this.setHex(parseInt(a[1],16)),this;if(/^\\\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))return a=/^\\\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a),this.setHex(parseInt(a[1]+a[1]+a[2]+a[2]+a[3]+a[3],16)),this;if(/^(\\\\w+)$/i.test(a))return this.setHex(THREE.ColorKeywords[a]),this},copy:function(a){this.r=a.r;this.g=\\na.g;this.b=a.b;return this},copyGammaToLinear:function(a){this.r=a.r*a.r;this.g=a.g*a.g;this.b=a.b*a.b;return this},copyLinearToGamma:function(a){this.r=Math.sqrt(a.r);this.g=Math.sqrt(a.g);this.b=Math.sqrt(a.b);return this},convertGammaToLinear:function(){var a=this.r,b=this.g,c=this.b;this.r=a*a;this.g=b*b;this.b=c*c;return this},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this},getHex:function(){return 255*this.r<<16^255*this.g<<\\n8^255*this.b<<0},getHexString:function(){return(\\\"000000\\\"+this.getHex().toString(16)).slice(-6)},getHSL:function(a){a=a||{h:0,s:0,l:0};var b=this.r,c=this.g,d=this.b,e=Math.max(b,c,d),f=Math.min(b,c,d),g,h=(f+e)/2;if(f===e)f=g=0;else{var k=e-f,f=.5>=h?k/(e+f):k/(2-e-f);switch(e){case b:g=(c-d)/k+(c<d?6:0);break;case c:g=(d-b)/k+2;break;case d:g=(b-c)/k+4}g/=6}a.h=g;a.s=f;a.l=h;return a},getStyle:function(){return\\\"rgb(\\\"+(255*this.r|0)+\\\",\\\"+(255*this.g|0)+\\\",\\\"+(255*this.b|0)+\\\")\\\"},offsetHSL:function(a,\\nb,c){var d=this.getHSL();d.h+=a;d.s+=b;d.l+=c;this.setHSL(d.h,d.s,d.l);return this},add:function(a){this.r+=a.r;this.g+=a.g;this.b+=a.b;return this},addColors:function(a,b){this.r=a.r+b.r;this.g=a.g+b.g;this.b=a.b+b.b;return this},addScalar:function(a){this.r+=a;this.g+=a;this.b+=a;return this},multiply:function(a){this.r*=a.r;this.g*=a.g;this.b*=a.b;return this},multiplyScalar:function(a){this.r*=a;this.g*=a;this.b*=a;return this},lerp:function(a,b){this.r+=(a.r-this.r)*b;this.g+=(a.g-this.g)*b;\\nthis.b+=(a.b-this.b)*b;return this},equals:function(a){return a.r===this.r&&a.g===this.g&&a.b===this.b},fromArray:function(a){this.r=a[0];this.g=a[1];this.b=a[2];return this},toArray:function(){return[this.r,this.g,this.b]},clone:function(){return(new THREE.Color).setRGB(this.r,this.g,this.b)}};\\nTHREE.ColorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,\\ndarkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,\\ngrey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,\\nlime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,\\npalegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,\\ntomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};THREE.Quaternion=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1};\\nTHREE.Quaternion.prototype={constructor:THREE.Quaternion,_x:0,_y:0,_z:0,_w:0,get x(){return this._x},set x(a){this._x=a;this.onChangeCallback()},get y(){return this._y},set y(a){this._y=a;this.onChangeCallback()},get z(){return this._z},set z(a){this._z=a;this.onChangeCallback()},get w(){return this._w},set w(a){this._w=a;this.onChangeCallback()},set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;this.onChangeCallback();return this},copy:function(a){this._x=a.x;this._y=a.y;this._z=a.z;\\nthis._w=a.w;this.onChangeCallback();return this},setFromEuler:function(a,b){if(!1===a instanceof THREE.Euler)throw Error(\\\"THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.\\\");var c=Math.cos(a._x/2),d=Math.cos(a._y/2),e=Math.cos(a._z/2),f=Math.sin(a._x/2),g=Math.sin(a._y/2),h=Math.sin(a._z/2);\\\"XYZ\\\"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e-f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):\\\"YXZ\\\"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e-f*d*h,this._z=\\nc*d*h-f*g*e,this._w=c*d*e+f*g*h):\\\"ZXY\\\"===a.order?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):\\\"ZYX\\\"===a.order?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e+f*g*h):\\\"YZX\\\"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e-f*g*h):\\\"XZY\\\"===a.order&&(this._x=f*d*e-c*g*h,this._y=c*g*e-f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e+f*g*h);if(!1!==b)this.onChangeCallback();return this},setFromAxisAngle:function(a,\\nb){var c=b/2,d=Math.sin(c);this._x=a.x*d;this._y=a.y*d;this._z=a.z*d;this._w=Math.cos(c);this.onChangeCallback();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0];a=b[4];var d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],k=b[6],b=b[10],l=c+f+b;0<l?(c=.5/Math.sqrt(l+1),this._w=.25/c,this._x=(k-g)*c,this._y=(d-h)*c,this._z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(k-g)/c,this._x=.25*c,this._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y=\\n.25*c,this._z=(g+k)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+k)/c,this._z=.25*c);this.onChangeCallback();return this},setFromUnitVectors:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector3);b=c.dot(d)+1;1E-6>b?(b=0,Math.abs(c.x)>Math.abs(c.z)?a.set(-c.y,c.x,0):a.set(0,-c.z,c.y)):a.crossVectors(c,d);this._x=a.x;this._y=a.y;this._z=a.z;this._w=b;this.normalize();return this}}(),inverse:function(){this.conjugate().normalize();return this},conjugate:function(){this._x*=\\n-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this},dot:function(a){return this._x*a._x+this._y*a._y+this._z*a._z+this._w*a._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a=this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);this.onChangeCallback();return this},\\nmultiply:function(a,b){return void 0!==b?(console.warn(\\\"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\\\"),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z,f=a._w,g=b._x,h=b._y,k=b._z,l=b._w;this._x=c*l+f*g+d*k-e*h;this._y=d*l+f*h+e*g-c*k;this._z=e*l+f*k+c*h-d*g;this._w=f*l-c*g-d*h-e*k;this.onChangeCallback();return this},multiplyVector3:function(a){console.warn(\\\"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.\\\");\\nreturn a.applyQuaternion(this)},slerp:function(a,b){var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=-a._z,g=-g):this.copy(a);if(1<=g)return this._w=f,this._x=c,this._y=d,this._z=e,this;var h=Math.acos(g),k=Math.sqrt(1-g*g);if(.001>Math.abs(k))return this._w=.5*(f+this._w),this._x=.5*(c+this._x),this._y=.5*(d+this._y),this._z=.5*(e+this._z),this;g=Math.sin((1-b)*h)/k;h=Math.sin(b*h)/k;this._w=f*g+this._w*h;this._x=c*g+\\nthis._x*h;this._y=d*g+this._y*h;this._z=e*g+this._z*h;this.onChangeCallback();return this},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._w===this._w},fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];this._w=a[3];this.onChangeCallback();return this},toArray:function(){return[this._x,this._y,this._z,this._w]},onChange:function(a){this.onChangeCallback=a;return this},onChangeCallback:function(){},clone:function(){return new THREE.Quaternion(this._x,this._y,\\nthis._z,this._w)}};THREE.Quaternion.slerp=function(a,b,c,d){return c.copy(a).slerp(b,d)};THREE.Vector2=function(a,b){this.x=a||0;this.y=b||0};\\nTHREE.Vector2.prototype={constructor:THREE.Vector2,set:function(a,b){this.x=a;this.y=b;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error(\\\"index is out of range: \\\"+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw Error(\\\"index is out of range: \\\"+a);}},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,\\nb){if(void 0!==b)return console.warn(\\\"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\\\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},sub:function(a,b){if(void 0!==b)return console.warn(\\\"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\\\"),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;return this},\\nsubVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiply:function(a){this.x*=a.x;this.y*=a.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divide:function(a){this.x/=a.x;this.y/=a.y;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a):this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);return this},clamp:function(a,\\nb){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector2,b=new THREE.Vector2);a.set(c,c);b.set(d,d);return this.clamp(a,b)}}(),floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this},\\nroundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);return this},negate:function(){this.x=-this.x;this.y=-this.y;return this},dot:function(a){return this.x*a.x+this.y*a.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},normalize:function(){return this.divideScalar(this.length())},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=\\nthis.x-a.x;a=this.y-a.y;return b*b+a*a},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a){this.x=a[0];this.y=a[1];return this},toArray:function(){return[this.x,this.y]},clone:function(){return new THREE.Vector2(this.x,this.y)}};THREE.Vector3=function(a,b,c){this.x=a||0;this.y=b||0;this.z=c||0};\\nTHREE.Vector3.prototype={constructor:THREE.Vector3,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw Error(\\\"index is out of range: \\\"+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error(\\\"index is out of range: \\\"+\\na);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){if(void 0!==b)return console.warn(\\\"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\\\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},sub:function(a,b){if(void 0!==b)return console.warn(\\\"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\\\"),\\nthis.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this},multiply:function(a,b){if(void 0!==b)return console.warn(\\\"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\\\"),this.multiplyVectors(a,b);this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;return this},multiplyVectors:function(a,b){this.x=a.x*b.x;this.y=\\na.y*b.y;this.z=a.z*b.z;return this},applyEuler:function(){var a;return function(b){!1===b instanceof THREE.Euler&&console.error(\\\"THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.\\\");void 0===a&&(a=new THREE.Quaternion);this.applyQuaternion(a.setFromEuler(b));return this}}(),applyAxisAngle:function(){var a;return function(b,c){void 0===a&&(a=new THREE.Quaternion);this.applyQuaternion(a.setFromAxisAngle(b,c));return this}}(),applyMatrix3:function(a){var b=this.x,\\nc=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[3]*c+a[6]*d;this.y=a[1]*b+a[4]*c+a[7]*d;this.z=a[2]*b+a[5]*c+a[8]*d;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12];this.y=a[1]*b+a[5]*c+a[9]*d+a[13];this.z=a[2]*b+a[6]*c+a[10]*d+a[14];return this},applyProjection:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;var e=1/(a[3]*b+a[7]*c+a[11]*d+a[15]);this.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e;this.y=(a[1]*b+a[5]*c+a[9]*d+a[13])*e;this.z=\\n(a[2]*b+a[6]*c+a[10]*d+a[14])*e;return this},applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,g=a.z;a=a.w;var h=a*b+f*d-g*c,k=a*c+g*b-e*d,l=a*d+e*c-f*b,b=-e*b-f*c-g*d;this.x=h*a+b*-e+k*-g-l*-f;this.y=k*a+b*-f+l*-e-h*-g;this.z=l*a+b*-g+h*-f-k*-e;return this},transformDirection:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d;this.y=a[1]*b+a[5]*c+a[9]*d;this.z=a[2]*b+a[6]*c+a[10]*d;this.normalize();return this},divide:function(a){this.x/=a.x;\\nthis.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a):this.z=this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);this.z<a.z&&(this.z=a.z);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=\\nb.z);return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector3,b=new THREE.Vector3);a.set(c,c,c);b.set(d,d,d);return this.clamp(a,b)}}(),floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this},roundToZero:function(){this.x=\\n0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);return this},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+\\nMath.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},cross:function(a,b){if(void 0!==b)return console.warn(\\\"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\\\"),this.crossVectors(a,b);var c=this.x,d=this.y,e=this.z;this.x=d*a.z-e*a.y;this.y=\\ne*a.x-c*a.z;this.z=c*a.y-d*a.x;return this},crossVectors:function(a,b){var c=a.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;this.x=d*h-e*g;this.y=e*f-c*h;this.z=c*g-d*f;return this},projectOnVector:function(){var a,b;return function(c){void 0===a&&(a=new THREE.Vector3);a.copy(c).normalize();b=this.dot(a);return this.copy(a).multiplyScalar(b)}}(),projectOnPlane:function(){var a;return function(b){void 0===a&&(a=new THREE.Vector3);a.copy(this).projectOnVector(b);return this.sub(a)}}(),reflect:function(){var a;return function(b){void 0===\\na&&(a=new THREE.Vector3);return this.sub(a.copy(b).multiplyScalar(2*this.dot(b)))}}(),angleTo:function(a){a=this.dot(a)/(this.length()*a.length());return Math.acos(THREE.Math.clamp(a,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y;a=this.z-a.z;return b*b+c*c+a*a},setEulerFromRotationMatrix:function(a,b){console.error(\\\"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.\\\")},\\nsetEulerFromQuaternion:function(a,b){console.error(\\\"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.\\\")},getPositionFromMatrix:function(a){console.warn(\\\"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().\\\");return this.setFromMatrixPosition(a)},getScaleFromMatrix:function(a){console.warn(\\\"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().\\\");return this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,\\nb){console.warn(\\\"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().\\\");return this.setFromMatrixColumn(a,b)},setFromMatrixPosition:function(a){this.x=a.elements[12];this.y=a.elements[13];this.z=a.elements[14];return this},setFromMatrixScale:function(a){var b=this.set(a.elements[0],a.elements[1],a.elements[2]).length(),c=this.set(a.elements[4],a.elements[5],a.elements[6]).length();a=this.set(a.elements[8],a.elements[9],a.elements[10]).length();this.x=b;this.y=c;this.z=\\na;return this},setFromMatrixColumn:function(a,b){var c=4*a,d=b.elements;this.x=d[c];this.y=d[c+1];this.z=d[c+2];return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];return this},toArray:function(){return[this.x,this.y,this.z]},clone:function(){return new THREE.Vector3(this.x,this.y,this.z)}};THREE.Vector4=function(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1};\\nTHREE.Vector4.prototype={constructor:THREE.Vector4,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setW:function(a){this.w=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;case 3:this.w=b;break;default:throw Error(\\\"index is out of range: \\\"+a);}},getComponent:function(a){switch(a){case 0:return this.x;\\ncase 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error(\\\"index is out of range: \\\"+a);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){if(void 0!==b)return console.warn(\\\"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\\\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;this.w+=a;return this},\\naddVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},sub:function(a,b){if(void 0!==b)return console.warn(\\\"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\\\"),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;this.w*=a;return this},applyMatrix4:function(a){var b=\\nthis.x,c=this.y,d=this.z,e=this.w;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e;this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e;this.z=a[2]*b+a[6]*c+a[10]*d+a[14]*e;this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a,this.w*=a):(this.z=this.y=this.x=0,this.w=1);return this},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):(this.x=a.x/b,this.y=a.y/b,this.z=a.z/b);return this},\\nsetAxisAngleFromRotationMatrix:function(a){var b,c,d;a=a.elements;var e=a[0];d=a[4];var f=a[8],g=a[1],h=a[5],k=a[9];c=a[2];b=a[6];var l=a[10];if(.01>Math.abs(d-g)&&.01>Math.abs(f-c)&&.01>Math.abs(k-b)){if(.1>Math.abs(d+g)&&.1>Math.abs(f+c)&&.1>Math.abs(k+b)&&.1>Math.abs(e+h+l-3))return this.set(1,0,0,0),this;a=Math.PI;e=(e+1)/2;h=(h+1)/2;l=(l+1)/2;d=(d+g)/4;f=(f+c)/4;k=(k+b)/4;e>h&&e>l?.01>e?(b=0,d=c=.707106781):(b=Math.sqrt(e),c=d/b,d=f/b):h>l?.01>h?(b=.707106781,c=0,d=.707106781):(c=Math.sqrt(h),\\nb=d/c,d=k/c):.01>l?(c=b=.707106781,d=0):(d=Math.sqrt(l),b=f/d,c=k/d);this.set(b,c,d,a);return this}a=Math.sqrt((b-k)*(b-k)+(f-c)*(f-c)+(g-d)*(g-d));.001>Math.abs(a)&&(a=1);this.x=(b-k)/a;this.y=(f-c)/a;this.z=(g-d)/a;this.w=Math.acos((e+h+l-1)/2);return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);this.w>a.w&&(this.w=a.w);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);this.z<a.z&&(this.z=a.z);this.w<a.w&&(this.w=a.w);\\nreturn this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z);this.w<a.w?this.w=a.w:this.w>b.w&&(this.w=b.w);return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector4,b=new THREE.Vector4);a.set(c,c,c,c);b.set(d,d,d,d);return this.clamp(a,b)}}(),floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);\\nreturn this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);this.w=0>this.w?Math.ceil(this.w):Math.floor(this.w);\\nreturn this},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length())},\\nsetLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;this.w+=(a.w-this.w)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&a.w===this.w},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];this.w=a[3];return this},toArray:function(){return[this.x,this.y,this.z,this.w]},clone:function(){return new THREE.Vector4(this.x,this.y,this.z,\\nthis.w)}};THREE.Euler=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._order=d||THREE.Euler.DefaultOrder};THREE.Euler.RotationOrders=\\\"XYZ YZX ZXY XZY YXZ ZYX\\\".split(\\\" \\\");THREE.Euler.DefaultOrder=\\\"XYZ\\\";\\nTHREE.Euler.prototype={constructor:THREE.Euler,_x:0,_y:0,_z:0,_order:THREE.Euler.DefaultOrder,get x(){return this._x},set x(a){this._x=a;this.onChangeCallback()},get y(){return this._y},set y(a){this._y=a;this.onChangeCallback()},get z(){return this._z},set z(a){this._z=a;this.onChangeCallback()},get order(){return this._order},set order(a){this._order=a;this.onChangeCallback()},set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._order=d||this._order;this.onChangeCallback();return this},copy:function(a){this._x=\\na._x;this._y=a._y;this._z=a._z;this._order=a._order;this.onChangeCallback();return this},setFromRotationMatrix:function(a,b){var c=THREE.Math.clamp,d=a.elements,e=d[0],f=d[4],g=d[8],h=d[1],k=d[5],l=d[9],n=d[2],q=d[6],d=d[10];b=b||this._order;\\\"XYZ\\\"===b?(this._y=Math.asin(c(g,-1,1)),.99999>Math.abs(g)?(this._x=Math.atan2(-l,d),this._z=Math.atan2(-f,e)):(this._x=Math.atan2(q,k),this._z=0)):\\\"YXZ\\\"===b?(this._x=Math.asin(-c(l,-1,1)),.99999>Math.abs(l)?(this._y=Math.atan2(g,d),this._z=Math.atan2(h,k)):(this._y=\\nMath.atan2(-n,e),this._z=0)):\\\"ZXY\\\"===b?(this._x=Math.asin(c(q,-1,1)),.99999>Math.abs(q)?(this._y=Math.atan2(-n,d),this._z=Math.atan2(-f,k)):(this._y=0,this._z=Math.atan2(h,e))):\\\"ZYX\\\"===b?(this._y=Math.asin(-c(n,-1,1)),.99999>Math.abs(n)?(this._x=Math.atan2(q,d),this._z=Math.atan2(h,e)):(this._x=0,this._z=Math.atan2(-f,k))):\\\"YZX\\\"===b?(this._z=Math.asin(c(h,-1,1)),.99999>Math.abs(h)?(this._x=Math.atan2(-l,k),this._y=Math.atan2(-n,e)):(this._x=0,this._y=Math.atan2(g,d))):\\\"XZY\\\"===b?(this._z=Math.asin(-c(f,\\n-1,1)),.99999>Math.abs(f)?(this._x=Math.atan2(q,k),this._y=Math.atan2(g,e)):(this._x=Math.atan2(-l,d),this._y=0)):console.warn(\\\"THREE.Euler: .setFromRotationMatrix() given unsupported order: \\\"+b);this._order=b;this.onChangeCallback();return this},setFromQuaternion:function(a,b,c){var d=THREE.Math.clamp,e=a.x*a.x,f=a.y*a.y,g=a.z*a.z,h=a.w*a.w;b=b||this._order;\\\"XYZ\\\"===b?(this._x=Math.atan2(2*(a.x*a.w-a.y*a.z),h-e-f+g),this._y=Math.asin(d(2*(a.x*a.z+a.y*a.w),-1,1)),this._z=Math.atan2(2*(a.z*a.w-a.x*\\na.y),h+e-f-g)):\\\"YXZ\\\"===b?(this._x=Math.asin(d(2*(a.x*a.w-a.y*a.z),-1,1)),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),h-e-f+g),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),h-e+f-g)):\\\"ZXY\\\"===b?(this._x=Math.asin(d(2*(a.x*a.w+a.y*a.z),-1,1)),this._y=Math.atan2(2*(a.y*a.w-a.z*a.x),h-e-f+g),this._z=Math.atan2(2*(a.z*a.w-a.x*a.y),h-e+f-g)):\\\"ZYX\\\"===b?(this._x=Math.atan2(2*(a.x*a.w+a.z*a.y),h-e-f+g),this._y=Math.asin(d(2*(a.y*a.w-a.x*a.z),-1,1)),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),h+e-f-g)):\\\"YZX\\\"===b?(this._x=Math.atan2(2*\\n(a.x*a.w-a.z*a.y),h-e+f-g),this._y=Math.atan2(2*(a.y*a.w-a.x*a.z),h+e-f-g),this._z=Math.asin(d(2*(a.x*a.y+a.z*a.w),-1,1))):\\\"XZY\\\"===b?(this._x=Math.atan2(2*(a.x*a.w+a.y*a.z),h-e+f-g),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),h+e-f-g),this._z=Math.asin(d(2*(a.z*a.w-a.x*a.y),-1,1))):console.warn(\\\"THREE.Euler: .setFromQuaternion() given unsupported order: \\\"+b);this._order=b;if(!1!==c)this.onChangeCallback();return this},reorder:function(){var a=new THREE.Quaternion;return function(b){a.setFromEuler(this);\\nthis.setFromQuaternion(a,b)}}(),equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order},fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];void 0!==a[3]&&(this._order=a[3]);this.onChangeCallback();return this},toArray:function(){return[this._x,this._y,this._z,this._order]},onChange:function(a){this.onChangeCallback=a;return this},onChangeCallback:function(){},clone:function(){return new THREE.Euler(this._x,this._y,this._z,this._order)}};\\nTHREE.Line3=function(a,b){this.start=void 0!==a?a:new THREE.Vector3;this.end=void 0!==b?b:new THREE.Vector3};\\nTHREE.Line3.prototype={constructor:THREE.Line3,set:function(a,b){this.start.copy(a);this.end.copy(b);return this},copy:function(a){this.start.copy(a.start);this.end.copy(a.end);return this},center:function(a){return(a||new THREE.Vector3).addVectors(this.start,this.end).multiplyScalar(.5)},delta:function(a){return(a||new THREE.Vector3).subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(a,\\nb){var c=b||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},closestPointToPointParameter:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d){a.subVectors(c,this.start);b.subVectors(this.end,this.start);var e=b.dot(b),e=b.dot(a)/e;d&&(e=THREE.Math.clamp(e,0,1));return e}}(),closestPointToPoint:function(a,b,c){a=this.closestPointToPointParameter(a,b);c=c||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},applyMatrix4:function(a){this.start.applyMatrix4(a);\\nthis.end.applyMatrix4(a);return this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)},clone:function(){return(new THREE.Line3).copy(this)}};THREE.Box2=function(a,b){this.min=void 0!==a?a:new THREE.Vector2(Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector2(-Infinity,-Infinity)};\\nTHREE.Box2.prototype={constructor:THREE.Box2,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new THREE.Vector2;return function(b,c){var d=a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=\\nthis.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},center:function(a){return(a||new THREE.Vector2).addVectors(this.min,this.max).multiplyScalar(.5)},size:function(a){return(a||new THREE.Vector2).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);\\nthis.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector2).set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>\\nthis.max.y?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector2).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector2;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&\\na.max.equals(this.max)},clone:function(){return(new THREE.Box2).copy(this)}};THREE.Box3=function(a,b){this.min=void 0!==a?a:new THREE.Vector3(Infinity,Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector3(-Infinity,-Infinity,-Infinity)};\\nTHREE.Box3.prototype={constructor:THREE.Box3,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new THREE.Vector3;return function(b,c){var d=a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),setFromObject:function(){var a=new THREE.Vector3;return function(b){var c=this;b.updateMatrixWorld(!0);\\nthis.makeEmpty();b.traverse(function(b){if(void 0!==b.geometry&&void 0!==b.geometry.vertices)for(var e=b.geometry.vertices,f=0,g=e.length;f<g;f++)a.copy(e[f]),a.applyMatrix4(b.matrixWorld),c.expandByPoint(a)});return this}}(),copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},\\ncenter:function(a){return(a||new THREE.Vector3).addVectors(this.min,this.max).multiplyScalar(.5)},size:function(a){return(a||new THREE.Vector3).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<\\nthis.min.z||a.z>this.max.z?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&a.max.z<=this.max.z?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector3).set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<\\nthis.min.z||a.min.z>this.max.z?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector3).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),getBoundingSphere:function(){var a=new THREE.Vector3;return function(b){b=b||new THREE.Sphere;b.center=this.center();b.radius=.5*this.size(a).length();return b}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);\\nthis.max.max(a.max);return this},applyMatrix4:function(){var a=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];return function(b){a[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(b);a[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(b);a[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(b);a[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(b);a[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(b);\\na[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(b);a[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(b);a[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(b);this.makeEmpty();this.setFromPoints(a);return this}}(),translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)},clone:function(){return(new THREE.Box3).copy(this)}};\\nTHREE.Matrix3=function(a,b,c,d,e,f,g,h,k){var l=this.elements=new Float32Array(9);l[0]=void 0!==a?a:1;l[3]=b||0;l[6]=c||0;l[1]=d||0;l[4]=void 0!==e?e:1;l[7]=f||0;l[2]=g||0;l[5]=h||0;l[8]=void 0!==k?k:1};\\nTHREE.Matrix3.prototype={constructor:THREE.Matrix3,set:function(a,b,c,d,e,f,g,h,k){var l=this.elements;l[0]=a;l[3]=b;l[6]=c;l[1]=d;l[4]=e;l[7]=f;l[2]=g;l[5]=h;l[8]=k;return this},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this},copy:function(a){a=a.elements;this.set(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8]);return this},multiplyVector3:function(a){console.warn(\\\"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.\\\");return a.applyMatrix3(this)},\\nmultiplyVector3Array:function(a){console.warn(\\\"THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.\\\");return this.applyToVector3Array(a)},applyToVector3Array:function(){var a=new THREE.Vector3;return function(b,c,d){void 0===c&&(c=0);void 0===d&&(d=b.length);for(var e=0;e<d;e+=3,c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyMatrix3(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[3]*=a;b[6]*=\\na;b[1]*=a;b[4]*=a;b[7]*=a;b[2]*=a;b[5]*=a;b[8]*=a;return this},determinant:function(){var a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],k=a[7],a=a[8];return b*f*a-b*g*k-c*e*a+c*g*h+d*e*k-d*f*h},getInverse:function(a,b){var c=a.elements,d=this.elements;d[0]=c[10]*c[5]-c[6]*c[9];d[1]=-c[10]*c[1]+c[2]*c[9];d[2]=c[6]*c[1]-c[2]*c[5];d[3]=-c[10]*c[4]+c[6]*c[8];d[4]=c[10]*c[0]-c[2]*c[8];d[5]=-c[6]*c[0]+c[2]*c[4];d[6]=c[9]*c[4]-c[5]*c[8];d[7]=-c[9]*c[0]+c[1]*c[8];d[8]=c[5]*c[0]-c[1]*c[4];\\nc=c[0]*d[0]+c[1]*d[3]+c[2]*d[6];if(0===c){if(b)throw Error(\\\"Matrix3.getInverse(): can't invert matrix, determinant is 0\\\");console.warn(\\\"Matrix3.getInverse(): can't invert matrix, determinant is 0\\\");this.identity();return this}this.multiplyScalar(1/c);return this},transpose:function(){var a,b=this.elements;a=b[1];b[1]=b[3];b[3]=a;a=b[2];b[2]=b[6];b[6]=a;a=b[5];b[5]=b[7];b[7]=a;return this},flattenToArrayOffset:function(a,b){var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];\\na[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];return a},getNormalMatrix:function(a){this.getInverse(a).transpose();return this},transposeIntoArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]]},clone:function(){var a=this.elements;return new THREE.Matrix3(a[0],a[3],\\na[6],a[1],a[4],a[7],a[2],a[5],a[8])}};THREE.Matrix4=function(a,b,c,d,e,f,g,h,k,l,n,q,r,t,s,p){var v=this.elements=new Float32Array(16);v[0]=void 0!==a?a:1;v[4]=b||0;v[8]=c||0;v[12]=d||0;v[1]=e||0;v[5]=void 0!==f?f:1;v[9]=g||0;v[13]=h||0;v[2]=k||0;v[6]=l||0;v[10]=void 0!==n?n:1;v[14]=q||0;v[3]=r||0;v[7]=t||0;v[11]=s||0;v[15]=void 0!==p?p:1};\\nTHREE.Matrix4.prototype={constructor:THREE.Matrix4,set:function(a,b,c,d,e,f,g,h,k,l,n,q,r,t,s,p){var v=this.elements;v[0]=a;v[4]=b;v[8]=c;v[12]=d;v[1]=e;v[5]=f;v[9]=g;v[13]=h;v[2]=k;v[6]=l;v[10]=n;v[14]=q;v[3]=r;v[7]=t;v[11]=s;v[15]=p;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},copy:function(a){this.elements.set(a.elements);return this},extractPosition:function(a){console.warn(\\\"THREEMatrix4: .extractPosition() has been renamed to .copyPosition().\\\");return this.copyPosition(a)},\\ncopyPosition:function(a){var b=this.elements;a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractRotation:function(){var a=new THREE.Vector3;return function(b){var c=this.elements;b=b.elements;var d=1/a.set(b[0],b[1],b[2]).length(),e=1/a.set(b[4],b[5],b[6]).length(),f=1/a.set(b[8],b[9],b[10]).length();c[0]=b[0]*d;c[1]=b[1]*d;c[2]=b[2]*d;c[4]=b[4]*e;c[5]=b[5]*e;c[6]=b[6]*e;c[8]=b[8]*f;c[9]=b[9]*f;c[10]=b[10]*f;return this}}(),makeRotationFromEuler:function(a){!1===a instanceof THREE.Euler&&\\nconsole.error(\\\"THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\\\");var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c),c=Math.sin(c),g=Math.cos(d),d=Math.sin(d),h=Math.cos(e),e=Math.sin(e);if(\\\"XYZ\\\"===a.order){a=f*h;var k=f*e,l=c*h,n=c*e;b[0]=g*h;b[4]=-g*e;b[8]=d;b[1]=k+l*d;b[5]=a-n*d;b[9]=-c*g;b[2]=n-a*d;b[6]=l+k*d;b[10]=f*g}else\\\"YXZ\\\"===a.order?(a=g*h,k=g*e,l=d*h,n=d*e,b[0]=a+n*c,b[4]=l*c-k,b[8]=f*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=k*c-l,b[6]=n+a*c,\\nb[10]=f*g):\\\"ZXY\\\"===a.order?(a=g*h,k=g*e,l=d*h,n=d*e,b[0]=a-n*c,b[4]=-f*e,b[8]=l+k*c,b[1]=k+l*c,b[5]=f*h,b[9]=n-a*c,b[2]=-f*d,b[6]=c,b[10]=f*g):\\\"ZYX\\\"===a.order?(a=f*h,k=f*e,l=c*h,n=c*e,b[0]=g*h,b[4]=l*d-k,b[8]=a*d+n,b[1]=g*e,b[5]=n*d+a,b[9]=k*d-l,b[2]=-d,b[6]=c*g,b[10]=f*g):\\\"YZX\\\"===a.order?(a=f*g,k=f*d,l=c*g,n=c*d,b[0]=g*h,b[4]=n-a*e,b[8]=l*e+k,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=k*e+l,b[10]=a-n*e):\\\"XZY\\\"===a.order&&(a=f*g,k=f*d,l=c*g,n=c*d,b[0]=g*h,b[4]=-e,b[8]=d*h,b[1]=a*e+n,b[5]=f*h,b[9]=k*\\ne-l,b[2]=l*e-k,b[6]=c*h,b[10]=n*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},setRotationFromQuaternion:function(a){console.warn(\\\"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().\\\");return this.makeRotationFromQuaternion(a)},makeRotationFromQuaternion:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w,g=c+c,h=d+d,k=e+e;a=c*g;var l=c*h,c=c*k,n=d*h,d=d*k,e=e*k,g=f*g,h=f*h,f=f*k;b[0]=1-(n+e);b[4]=l-f;b[8]=c+h;b[1]=l+f;b[5]=1-\\n(a+e);b[9]=d-g;b[2]=c-h;b[6]=d+g;b[10]=1-(a+n);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},lookAt:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f){var g=this.elements;c.subVectors(d,e).normalize();0===c.length()&&(c.z=1);a.crossVectors(f,c).normalize();0===a.length()&&(c.x+=1E-4,a.crossVectors(f,c).normalize());b.crossVectors(c,a);g[0]=a.x;g[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;g[6]=b.z;g[10]=c.z;return this}}(),\\nmultiply:function(a,b){return void 0!==b?(console.warn(\\\"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\\\"),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements,e=this.elements,f=c[0],g=c[4],h=c[8],k=c[12],l=c[1],n=c[5],q=c[9],r=c[13],t=c[2],s=c[6],p=c[10],v=c[14],w=c[3],u=c[7],D=c[11],c=c[15],A=d[0],x=d[4],C=d[8],I=d[12],z=d[1],y=d[5],K=d[9],N=d[13],ba=d[2],P=d[6],O=d[10],J=d[14],E=d[3],\\nQ=d[7],L=d[11],d=d[15];e[0]=f*A+g*z+h*ba+k*E;e[4]=f*x+g*y+h*P+k*Q;e[8]=f*C+g*K+h*O+k*L;e[12]=f*I+g*N+h*J+k*d;e[1]=l*A+n*z+q*ba+r*E;e[5]=l*x+n*y+q*P+r*Q;e[9]=l*C+n*K+q*O+r*L;e[13]=l*I+n*N+q*J+r*d;e[2]=t*A+s*z+p*ba+v*E;e[6]=t*x+s*y+p*P+v*Q;e[10]=t*C+s*K+p*O+v*L;e[14]=t*I+s*N+p*J+v*d;e[3]=w*A+u*z+D*ba+c*E;e[7]=w*x+u*y+D*P+c*Q;e[11]=w*C+u*K+D*O+c*L;e[15]=w*I+u*N+D*J+c*d;return this},multiplyToArray:function(a,b,c){var d=this.elements;this.multiplyMatrices(a,b);c[0]=d[0];c[1]=d[1];c[2]=d[2];c[3]=d[3];\\nc[4]=d[4];c[5]=d[5];c[6]=d[6];c[7]=d[7];c[8]=d[8];c[9]=d[9];c[10]=d[10];c[11]=d[11];c[12]=d[12];c[13]=d[13];c[14]=d[14];c[15]=d[15];return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},multiplyVector3:function(a){console.warn(\\\"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.\\\");\\nreturn a.applyProjection(this)},multiplyVector4:function(a){console.warn(\\\"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.\\\");return a.applyMatrix4(this)},multiplyVector3Array:function(a){console.warn(\\\"THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.\\\");return this.applyToVector3Array(a)},applyToVector3Array:function(){var a=new THREE.Vector3;return function(b,c,d){void 0===c&&(c=0);void 0===d&&(d=\\nb.length);for(var e=0;e<d;e+=3,c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyMatrix4(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),rotateAxis:function(a){console.warn(\\\"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.\\\");a.transformDirection(this)},crossVector:function(a){console.warn(\\\"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.\\\");return a.applyMatrix4(this)},determinant:function(){var a=this.elements,b=\\na[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],k=a[13],l=a[2],n=a[6],q=a[10],r=a[14];return a[3]*(+e*h*n-d*k*n-e*g*q+c*k*q+d*g*r-c*h*r)+a[7]*(+b*h*r-b*k*q+e*f*q-d*f*r+d*k*l-e*h*l)+a[11]*(+b*k*n-b*g*r-e*f*n+c*f*r+e*g*l-c*k*l)+a[15]*(-d*g*l-b*h*n+b*g*q+d*f*n-c*f*q+c*h*l)},transpose:function(){var a=this.elements,b;b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=a[11];a[11]=a[14];a[14]=b;return this},flattenToArrayOffset:function(a,\\nb){var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a},getPosition:function(){var a=new THREE.Vector3;return function(){console.warn(\\\"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.\\\");var b=this.elements;return a.set(b[12],b[13],b[14])}}(),setPosition:function(a){var b=\\nthis.elements;b[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getInverse:function(a,b){var c=this.elements,d=a.elements,e=d[0],f=d[4],g=d[8],h=d[12],k=d[1],l=d[5],n=d[9],q=d[13],r=d[2],t=d[6],s=d[10],p=d[14],v=d[3],w=d[7],u=d[11],d=d[15];c[0]=n*p*w-q*s*w+q*t*u-l*p*u-n*t*d+l*s*d;c[4]=h*s*w-g*p*w-h*t*u+f*p*u+g*t*d-f*s*d;c[8]=g*q*w-h*n*w+h*l*u-f*q*u-g*l*d+f*n*d;c[12]=h*n*t-g*q*t-h*l*s+f*q*s+g*l*p-f*n*p;c[1]=q*s*v-n*p*v-q*r*u+k*p*u+n*r*d-k*s*d;c[5]=g*p*v-h*s*v+h*r*u-e*p*u-g*r*d+e*s*d;c[9]=h*n*v-g*q*v-h*k*\\nu+e*q*u+g*k*d-e*n*d;c[13]=g*q*r-h*n*r+h*k*s-e*q*s-g*k*p+e*n*p;c[2]=l*p*v-q*t*v+q*r*w-k*p*w-l*r*d+k*t*d;c[6]=h*t*v-f*p*v-h*r*w+e*p*w+f*r*d-e*t*d;c[10]=f*q*v-h*l*v+h*k*w-e*q*w-f*k*d+e*l*d;c[14]=h*l*r-f*q*r-h*k*t+e*q*t+f*k*p-e*l*p;c[3]=n*t*v-l*s*v-n*r*w+k*s*w+l*r*u-k*t*u;c[7]=f*s*v-g*t*v+g*r*w-e*s*w-f*r*u+e*t*u;c[11]=g*l*v-f*n*v-g*k*w+e*n*w+f*k*u-e*l*u;c[15]=f*n*r-g*l*r+g*k*t-e*n*t-f*k*s+e*l*s;c=e*c[0]+k*c[4]+r*c[8]+v*c[12];if(0==c){if(b)throw Error(\\\"Matrix4.getInverse(): can't invert matrix, determinant is 0\\\");\\nconsole.warn(\\\"Matrix4.getInverse(): can't invert matrix, determinant is 0\\\");this.identity();return this}this.multiplyScalar(1/c);return this},translate:function(a){console.warn(\\\"THREE.Matrix4: .translate() has been removed.\\\")},rotateX:function(a){console.warn(\\\"THREE.Matrix4: .rotateX() has been removed.\\\")},rotateY:function(a){console.warn(\\\"THREE.Matrix4: .rotateY() has been removed.\\\")},rotateZ:function(a){console.warn(\\\"THREE.Matrix4: .rotateZ() has been removed.\\\")},rotateByAxis:function(a,b){console.warn(\\\"THREE.Matrix4: .rotateByAxis() has been removed.\\\")},\\nscale:function(a){var b=this.elements,c=a.x,d=a.y;a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],Math.max(a[4]*a[4]+a[5]*a[5]+a[6]*a[6],a[8]*a[8]+a[9]*a[9]+a[10]*a[10])))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(1,\\n0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);return this},makeRotationY:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=Math.cos(b),d=Math.sin(b),e=1-c,f=a.x,g=a.y,h=a.z,k=e*f,l=e*g;this.set(k*f+c,k*g-d*h,k*h+d*g,0,k*g+d*h,l*g+c,l*h-d*f,0,k*h-d*g,l*h+d*f,e*h*h+c,0,0,0,0,1);return this},makeScale:function(a,b,c){this.set(a,\\n0,0,0,0,b,0,0,0,0,c,0,0,0,0,1);return this},compose:function(a,b,c){this.makeRotationFromQuaternion(b);this.scale(c);this.setPosition(a);return this},decompose:function(){var a=new THREE.Vector3,b=new THREE.Matrix4;return function(c,d,e){var f=this.elements,g=a.set(f[0],f[1],f[2]).length(),h=a.set(f[4],f[5],f[6]).length(),k=a.set(f[8],f[9],f[10]).length();0>this.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.elements.set(this.elements);c=1/g;var f=1/h,l=1/k;b.elements[0]*=c;b.elements[1]*=\\nc;b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=l;b.elements[9]*=l;b.elements[10]*=l;d.setFromRotationMatrix(b);e.x=g;e.y=h;e.z=k;return this}}(),makeFrustum:function(a,b,c,d,e,f){var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(d-c);g[9]=(d+c)/(d-c);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makePerspective:function(a,b,c,d){a=c*Math.tan(THREE.Math.degToRad(.5*a));\\nvar e=-a;return this.makeFrustum(e*b,a*b,e,a,c,d)},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=b-a,k=c-d,l=f-e;g[0]=2/h;g[4]=0;g[8]=0;g[12]=-((b+a)/h);g[1]=0;g[5]=2/k;g[9]=0;g[13]=-((c+d)/k);g[2]=0;g[6]=0;g[10]=-2/l;g[14]=-((f+e)/l);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]]},clone:function(){var a=\\nthis.elements;return new THREE.Matrix4(a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15])}};THREE.Ray=function(a,b){this.origin=void 0!==a?a:new THREE.Vector3;this.direction=void 0!==b?b:new THREE.Vector3};\\nTHREE.Ray.prototype={constructor:THREE.Ray,set:function(a,b){this.origin.copy(a);this.direction.copy(b);return this},copy:function(a){this.origin.copy(a.origin);this.direction.copy(a.direction);return this},at:function(a,b){return(b||new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)},recast:function(){var a=new THREE.Vector3;return function(b){this.origin.copy(this.at(b,a));return this}}(),closestPointToPoint:function(a,b){var c=b||new THREE.Vector3;c.subVectors(a,this.origin);\\nvar d=c.dot(this.direction);return 0>d?c.copy(this.origin):c.copy(this.direction).multiplyScalar(d).add(this.origin)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){var c=a.subVectors(b,this.origin).dot(this.direction);if(0>c)return this.origin.distanceTo(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);return a.distanceTo(b)}}(),distanceSqToSegment:function(a,b,c,d){var e=a.clone().add(b).multiplyScalar(.5),f=b.clone().sub(a).normalize(),g=.5*a.distanceTo(b),h=\\nthis.origin.clone().sub(e);a=-this.direction.dot(f);b=h.dot(this.direction);var k=-h.dot(f),l=h.lengthSq(),n=Math.abs(1-a*a),q,r;0<=n?(h=a*k-b,q=a*b-k,r=g*n,0<=h?q>=-r?q<=r?(g=1/n,h*=g,q*=g,a=h*(h+a*q+2*b)+q*(a*h+q+2*k)+l):(q=g,h=Math.max(0,-(a*q+b)),a=-h*h+q*(q+2*k)+l):(q=-g,h=Math.max(0,-(a*q+b)),a=-h*h+q*(q+2*k)+l):q<=-r?(h=Math.max(0,-(-a*g+b)),q=0<h?-g:Math.min(Math.max(-g,-k),g),a=-h*h+q*(q+2*k)+l):q<=r?(h=0,q=Math.min(Math.max(-g,-k),g),a=q*(q+2*k)+l):(h=Math.max(0,-(a*g+b)),q=0<h?g:Math.min(Math.max(-g,\\n-k),g),a=-h*h+q*(q+2*k)+l)):(q=0<a?-g:g,h=Math.max(0,-(a*q+b)),a=-h*h+q*(q+2*k)+l);c&&c.copy(this.direction.clone().multiplyScalar(h).add(this.origin));d&&d.copy(f.clone().multiplyScalar(q).add(e));return a},isIntersectionSphere:function(a){return this.distanceToPoint(a.center)<=a.radius},intersectSphere:function(){var a=new THREE.Vector3;return function(b,c){a.subVectors(b.center,this.origin);var d=a.dot(this.direction),e=a.dot(a)-d*d,f=b.radius*b.radius;if(e>f)return null;f=Math.sqrt(f-e);e=d-f;\\nd+=f;return 0>e&&0>d?null:0>e?this.at(d,c):this.at(e,c)}}(),isIntersectionPlane:function(a){var b=a.distanceToPoint(this.origin);return 0===b||0>a.normal.dot(this.direction)*b?!0:!1},distanceToPlane:function(a){var b=a.normal.dot(this.direction);if(0==b)return 0==a.distanceToPoint(this.origin)?0:null;a=-(this.origin.dot(a.normal)+a.constant)/b;return 0<=a?a:null},intersectPlane:function(a,b){var c=this.distanceToPlane(a);return null===c?null:this.at(c,b)},isIntersectionBox:function(){var a=new THREE.Vector3;\\nreturn function(b){return null!==this.intersectBox(b,a)}}(),intersectBox:function(a,b){var c,d,e,f,g;d=1/this.direction.x;f=1/this.direction.y;g=1/this.direction.z;var h=this.origin;0<=d?(c=(a.min.x-h.x)*d,d*=a.max.x-h.x):(c=(a.max.x-h.x)*d,d*=a.min.x-h.x);0<=f?(e=(a.min.y-h.y)*f,f*=a.max.y-h.y):(e=(a.max.y-h.y)*f,f*=a.min.y-h.y);if(c>f||e>d)return null;if(e>c||c!==c)c=e;if(f<d||d!==d)d=f;0<=g?(e=(a.min.z-h.z)*g,g*=a.max.z-h.z):(e=(a.max.z-h.z)*g,g*=a.min.z-h.z);if(c>g||e>d)return null;if(e>c||c!==\\nc)c=e;if(g<d||d!==d)d=g;return 0>d?null:this.at(0<=c?c:d,b)},intersectTriangle:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3,d=new THREE.Vector3;return function(e,f,g,h,k){b.subVectors(f,e);c.subVectors(g,e);d.crossVectors(b,c);f=this.direction.dot(d);if(0<f){if(h)return null;h=1}else if(0>f)h=-1,f=-f;else return null;a.subVectors(this.origin,e);e=h*this.direction.dot(c.crossVectors(a,c));if(0>e)return null;g=h*this.direction.dot(b.cross(a));if(0>g||e+g>f)return null;\\ne=-h*a.dot(d);return 0>e?null:this.at(e/f,k)}}(),applyMatrix4:function(a){this.direction.add(this.origin).applyMatrix4(a);this.origin.applyMatrix4(a);this.direction.sub(this.origin);this.direction.normalize();return this},equals:function(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)},clone:function(){return(new THREE.Ray).copy(this)}};THREE.Sphere=function(a,b){this.center=void 0!==a?a:new THREE.Vector3;this.radius=void 0!==b?b:0};\\nTHREE.Sphere.prototype={constructor:THREE.Sphere,set:function(a,b){this.center.copy(a);this.radius=b;return this},setFromPoints:function(){var a=new THREE.Box3;return function(b,c){var d=this.center;void 0!==c?d.copy(c):a.setFromPoints(b).center(d);for(var e=0,f=0,g=b.length;f<g;f++)e=Math.max(e,d.distanceToSquared(b[f]));this.radius=Math.sqrt(e);return this}}(),copy:function(a){this.center.copy(a.center);this.radius=a.radius;return this},empty:function(){return 0>=this.radius},containsPoint:function(a){return a.distanceToSquared(this.center)<=\\nthis.radius*this.radius},distanceToPoint:function(a){return a.distanceTo(this.center)-this.radius},intersectsSphere:function(a){var b=this.radius+a.radius;return a.center.distanceToSquared(this.center)<=b*b},clampPoint:function(a,b){var c=this.center.distanceToSquared(a),d=b||new THREE.Vector3;d.copy(a);c>this.radius*this.radius&&(d.sub(this.center).normalize(),d.multiplyScalar(this.radius).add(this.center));return d},getBoundingBox:function(a){a=a||new THREE.Box3;a.set(this.center,this.center);a.expandByScalar(this.radius);\\nreturn a},applyMatrix4:function(a){this.center.applyMatrix4(a);this.radius*=a.getMaxScaleOnAxis();return this},translate:function(a){this.center.add(a);return this},equals:function(a){return a.center.equals(this.center)&&a.radius===this.radius},clone:function(){return(new THREE.Sphere).copy(this)}};\\nTHREE.Frustum=function(a,b,c,d,e,f){this.planes=[void 0!==a?a:new THREE.Plane,void 0!==b?b:new THREE.Plane,void 0!==c?c:new THREE.Plane,void 0!==d?d:new THREE.Plane,void 0!==e?e:new THREE.Plane,void 0!==f?f:new THREE.Plane]};\\nTHREE.Frustum.prototype={constructor:THREE.Frustum,set:function(a,b,c,d,e,f){var g=this.planes;g[0].copy(a);g[1].copy(b);g[2].copy(c);g[3].copy(d);g[4].copy(e);g[5].copy(f);return this},copy:function(a){for(var b=this.planes,c=0;6>c;c++)b[c].copy(a.planes[c]);return this},setFromMatrix:function(a){var b=this.planes,c=a.elements;a=c[0];var d=c[1],e=c[2],f=c[3],g=c[4],h=c[5],k=c[6],l=c[7],n=c[8],q=c[9],r=c[10],t=c[11],s=c[12],p=c[13],v=c[14],c=c[15];b[0].setComponents(f-a,l-g,t-n,c-s).normalize();b[1].setComponents(f+\\na,l+g,t+n,c+s).normalize();b[2].setComponents(f+d,l+h,t+q,c+p).normalize();b[3].setComponents(f-d,l-h,t-q,c-p).normalize();b[4].setComponents(f-e,l-k,t-r,c-v).normalize();b[5].setComponents(f+e,l+k,t+r,c+v).normalize();return this},intersectsObject:function(){var a=new THREE.Sphere;return function(b){var c=b.geometry;null===c.boundingSphere&&c.computeBoundingSphere();a.copy(c.boundingSphere);a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSphere:function(a){var b=this.planes,\\nc=a.center;a=-a.radius;for(var d=0;6>d;d++)if(b[d].distanceToPoint(c)<a)return!1;return!0},intersectsBox:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){for(var d=this.planes,e=0;6>e;e++){var f=d[e];a.x=0<f.normal.x?c.min.x:c.max.x;b.x=0<f.normal.x?c.max.x:c.min.x;a.y=0<f.normal.y?c.min.y:c.max.y;b.y=0<f.normal.y?c.max.y:c.min.y;a.z=0<f.normal.z?c.min.z:c.max.z;b.z=0<f.normal.z?c.max.z:c.min.z;var g=f.distanceToPoint(a),f=f.distanceToPoint(b);if(0>g&&0>f)return!1}return!0}}(),\\ncontainsPoint:function(a){for(var b=this.planes,c=0;6>c;c++)if(0>b[c].distanceToPoint(a))return!1;return!0},clone:function(){return(new THREE.Frustum).copy(this)}};THREE.Plane=function(a,b){this.normal=void 0!==a?a:new THREE.Vector3(1,0,0);this.constant=void 0!==b?b:0};\\nTHREE.Plane.prototype={constructor:THREE.Plane,set:function(a,b){this.normal.copy(a);this.constant=b;return this},setComponents:function(a,b,c,d){this.normal.set(a,b,c);this.constant=d;return this},setFromNormalAndCoplanarPoint:function(a,b){this.normal.copy(a);this.constant=-b.dot(this.normal);return this},setFromCoplanarPoints:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){d=a.subVectors(e,d).cross(b.subVectors(c,d)).normalize();this.setFromNormalAndCoplanarPoint(d,\\nc);return this}}(),copy:function(a){this.normal.copy(a.normal);this.constant=a.constant;return this},normalize:function(){var a=1/this.normal.length();this.normal.multiplyScalar(a);this.constant*=a;return this},negate:function(){this.constant*=-1;this.normal.negate();return this},distanceToPoint:function(a){return this.normal.dot(a)+this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,b){return this.orthoPoint(a,b).sub(a).negate()},orthoPoint:function(a,\\nb){var c=this.distanceToPoint(a);return(b||new THREE.Vector3).copy(this.normal).multiplyScalar(c)},isIntersectionLine:function(a){var b=this.distanceToPoint(a.start);a=this.distanceToPoint(a.end);return 0>b&&0<a||0>a&&0<b},intersectLine:function(){var a=new THREE.Vector3;return function(b,c){var d=c||new THREE.Vector3,e=b.delta(a),f=this.normal.dot(e);if(0==f){if(0==this.distanceToPoint(b.start))return d.copy(b.start)}else return f=-(b.start.dot(this.normal)+this.constant)/f,0>f||1<f?void 0:d.copy(e).multiplyScalar(f).add(b.start)}}(),\\ncoplanarPoint:function(a){return(a||new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Matrix3;return function(d,e){var f=e||c.getNormalMatrix(d),f=a.copy(this.normal).applyMatrix3(f),g=this.coplanarPoint(b);g.applyMatrix4(d);this.setFromNormalAndCoplanarPoint(f,g);return this}}(),translate:function(a){this.constant-=a.dot(this.normal);return this},equals:function(a){return a.normal.equals(this.normal)&&\\na.constant==this.constant},clone:function(){return(new THREE.Plane).copy(this)}};\\nTHREE.Math={generateUUID:function(){var a=\\\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\".split(\\\"\\\"),b=Array(36),c=0,d;return function(){for(var e=0;36>e;e++)8==e||13==e||18==e||23==e?b[e]=\\\"-\\\":14==e?b[e]=\\\"4\\\":(2>=c&&(c=33554432+16777216*Math.random()|0),d=c&15,c>>=4,b[e]=a[19==e?d&3|8:d]);return b.join(\\\"\\\")}}(),clamp:function(a,b,c){return a<b?b:a>c?c:a},clampBottom:function(a,b){return a<b?b:a},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},smoothstep:function(a,b,c){if(a<=\\nb)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},random16:function(){return(65280*Math.random()+255*Math.random())/65535},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(.5-Math.random())},sign:function(a){return 0>a?-1:0<a?1:0},degToRad:function(){var a=Math.PI/180;return function(b){return b*\\na}}(),radToDeg:function(){var a=180/Math.PI;return function(b){return b*a}}(),isPowerOfTwo:function(a){return 0===(a&a-1)&&0!==a}};\\nTHREE.Spline=function(a){function b(a,b,c,d,e,f,g){a=.5*(c-a);d=.5*(d-b);return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b}this.points=a;var c=[],d={x:0,y:0,z:0},e,f,g,h,k,l,n,q,r;this.initFromArray=function(a){this.points=[];for(var b=0;b<a.length;b++)this.points[b]={x:a[b][0],y:a[b][1],z:a[b][2]}};this.getPoint=function(a){e=(this.points.length-1)*a;f=Math.floor(e);g=e-f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>this.points.length-2?this.points.length-1:f+1;c[3]=f>this.points.length-3?this.points.length-1:f+\\n2;l=this.points[c[0]];n=this.points[c[1]];q=this.points[c[2]];r=this.points[c[3]];h=g*g;k=g*h;d.x=b(l.x,n.x,q.x,r.x,g,h,k);d.y=b(l.y,n.y,q.y,r.y,g,h,k);d.z=b(l.z,n.z,q.z,r.z,g,h,k);return d};this.getControlPointsArray=function(){var a,b,c=this.points.length,d=[];for(a=0;a<c;a++)b=this.points[a],d[a]=[b.x,b.y,b.z];return d};this.getLength=function(a){var b,c,d,e=b=b=0,f=new THREE.Vector3,g=new THREE.Vector3,h=[],k=0;h[0]=0;a||(a=100);c=this.points.length*a;f.copy(this.points[0]);for(a=1;a<c;a++)b=\\na/c,d=this.getPoint(b),g.copy(d),k+=g.distanceTo(f),f.copy(d),b*=this.points.length-1,b=Math.floor(b),b!=e&&(h[b]=k,e=b);h[h.length]=k;return{chunks:h,total:k}};this.reparametrizeByArcLength=function(a){var b,c,d,e,f,g,h=[],k=new THREE.Vector3,l=this.getLength();h.push(k.copy(this.points[0]).clone());for(b=1;b<this.points.length;b++){c=l.chunks[b]-l.chunks[b-1];g=Math.ceil(a*c/l.total);e=(b-1)/(this.points.length-1);f=b/(this.points.length-1);for(c=1;c<g-1;c++)d=e+1/g*c*(f-e),d=this.getPoint(d),h.push(k.copy(d).clone());\\nh.push(k.copy(this.points[b]).clone())}this.points=h}};THREE.Triangle=function(a,b,c){this.a=void 0!==a?a:new THREE.Vector3;this.b=void 0!==b?b:new THREE.Vector3;this.c=void 0!==c?c:new THREE.Vector3};THREE.Triangle.normal=function(){var a=new THREE.Vector3;return function(b,c,d,e){e=e||new THREE.Vector3;e.subVectors(d,c);a.subVectors(b,c);e.cross(a);b=e.lengthSq();return 0<b?e.multiplyScalar(1/Math.sqrt(b)):e.set(0,0,0)}}();\\nTHREE.Triangle.barycoordFromPoint=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f,g,h){a.subVectors(g,e);b.subVectors(f,e);c.subVectors(d,e);d=a.dot(a);e=a.dot(b);f=a.dot(c);var k=b.dot(b);g=b.dot(c);var l=d*k-e*e;h=h||new THREE.Vector3;if(0==l)return h.set(-2,-1,-1);l=1/l;k=(k*f-e*g)*l;d=(d*g-e*f)*l;return h.set(1-k-d,d,k)}}();\\nTHREE.Triangle.containsPoint=function(){var a=new THREE.Vector3;return function(b,c,d,e){b=THREE.Triangle.barycoordFromPoint(b,c,d,e,a);return 0<=b.x&&0<=b.y&&1>=b.x+b.y}}();\\nTHREE.Triangle.prototype={constructor:THREE.Triangle,set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this},setFromPointsAndIndices:function(a,b,c,d){this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this},copy:function(a){this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this},area:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){a.subVectors(this.c,this.b);b.subVectors(this.a,this.b);return.5*a.cross(b).length()}}(),midpoint:function(a){return(a||\\nnew THREE.Vector3).addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},normal:function(a){return THREE.Triangle.normal(this.a,this.b,this.c,a)},plane:function(a){return(a||new THREE.Plane).setFromCoplanarPoints(this.a,this.b,this.c)},barycoordFromPoint:function(a,b){return THREE.Triangle.barycoordFromPoint(a,this.a,this.b,this.c,b)},containsPoint:function(a){return THREE.Triangle.containsPoint(a,this.a,this.b,this.c)},equals:function(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)},\\nclone:function(){return(new THREE.Triangle).copy(this)}};THREE.Clock=function(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1};\\nTHREE.Clock.prototype={constructor:THREE.Clock,start:function(){this.oldTime=this.startTime=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now();this.running=!0},stop:function(){this.getElapsedTime();this.running=!1},getElapsedTime:function(){this.getDelta();return this.elapsedTime},getDelta:function(){var a=0;this.autoStart&&!this.running&&this.start();if(this.running){var b=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now(),\\na=.001*(b-this.oldTime);this.oldTime=b;this.elapsedTime+=a}return a}};THREE.EventDispatcher=function(){};\\nTHREE.EventDispatcher.prototype={constructor:THREE.EventDispatcher,apply:function(a){a.addEventListener=THREE.EventDispatcher.prototype.addEventListener;a.hasEventListener=THREE.EventDispatcher.prototype.hasEventListener;a.removeEventListener=THREE.EventDispatcher.prototype.removeEventListener;a.dispatchEvent=THREE.EventDispatcher.prototype.dispatchEvent},addEventListener:function(a,b){void 0===this._listeners&&(this._listeners={});var c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&\\nc[a].push(b)},hasEventListener:function(a,b){if(void 0===this._listeners)return!1;var c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)?!0:!1},removeEventListener:function(a,b){if(void 0!==this._listeners){var c=this._listeners[a];if(void 0!==c){var d=c.indexOf(b);-1!==d&&c.splice(d,1)}}},dispatchEvent:function(a){if(void 0!==this._listeners){var b=this._listeners[a.type];if(void 0!==b){a.target=this;for(var c=[],d=b.length,e=0;e<d;e++)c[e]=b[e];for(e=0;e<d;e++)c[e].call(this,a)}}}};\\n(function(a){a.Raycaster=function(b,c,f,g){this.ray=new a.Ray(b,c);this.near=f||0;this.far=g||Infinity;this.params={Sprite:{},Mesh:{},PointCloud:{threshold:1},LOD:{},Line:{}}};var b=function(a,b){return a.distance-b.distance},c=function(a,b,f,g){a.raycast(b,f);if(!0===g){a=a.children;g=0;for(var h=a.length;g<h;g++)c(a[g],b,f,!0)}};a.Raycaster.prototype={constructor:a.Raycaster,precision:1E-4,linePrecision:1,set:function(a,b){this.ray.set(a,b)},intersectObject:function(a,e){var f=[];c(a,this,f,e);\\nf.sort(b);return f},intersectObjects:function(a,e){for(var f=[],g=0,h=a.length;g<h;g++)c(a[g],this,f,e);f.sort(b);return f}}})(THREE);\\nTHREE.Object3D=function(){this.id=THREE.Object3DIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\\\"\\\";this.parent=void 0;this.children=[];this.up=THREE.Object3D.DefaultUp.clone();var a=new THREE.Vector3,b=new THREE.Euler,c=new THREE.Quaternion,d=new THREE.Vector3(1,1,1);b.onChange(function(){c.setFromEuler(b,!1)});c.onChange(function(){b.setFromQuaternion(c,void 0,!1)});Object.defineProperties(this,{position:{enumerable:!0,value:a},rotation:{enumerable:!0,value:b},quaternion:{enumerable:!0,value:c},\\nscale:{enumerable:!0,value:d}});this.renderDepth=null;this.rotationAutoUpdate=!0;this.matrix=new THREE.Matrix4;this.matrixWorld=new THREE.Matrix4;this.matrixAutoUpdate=!0;this.matrixWorldNeedsUpdate=!1;this.visible=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0;this.userData={}};THREE.Object3D.DefaultUp=new THREE.Vector3(0,1,0);\\nTHREE.Object3D.prototype={constructor:THREE.Object3D,get eulerOrder(){console.warn(\\\"THREE.Object3D: .eulerOrder has been moved to .rotation.order.\\\");return this.rotation.order},set eulerOrder(a){console.warn(\\\"THREE.Object3D: .eulerOrder has been moved to .rotation.order.\\\");this.rotation.order=a},get useQuaternion(){console.warn(\\\"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.\\\")},set useQuaternion(a){console.warn(\\\"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.\\\")},\\napplyMatrix:function(a){this.matrix.multiplyMatrices(a,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale)},setRotationFromAxisAngle:function(a,b){this.quaternion.setFromAxisAngle(a,b)},setRotationFromEuler:function(a){this.quaternion.setFromEuler(a,!0)},setRotationFromMatrix:function(a){this.quaternion.setFromRotationMatrix(a)},setRotationFromQuaternion:function(a){this.quaternion.copy(a)},rotateOnAxis:function(){var a=new THREE.Quaternion;return function(b,c){a.setFromAxisAngle(b,\\nc);this.quaternion.multiply(a);return this}}(),rotateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.rotateOnAxis(a,b)}}(),translateOnAxis:function(){var a=new THREE.Vector3;return function(b,c){a.copy(b).applyQuaternion(this.quaternion);this.position.add(a.multiplyScalar(c));\\nreturn this}}(),translate:function(a,b){console.warn(\\\"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.\\\");return this.translateOnAxis(b,a)},translateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.translateOnAxis(a,b)}}(),translateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.translateOnAxis(a,b)}}(),translateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.translateOnAxis(a,\\nb)}}(),localToWorld:function(a){return a.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var a=new THREE.Matrix4;return function(b){return b.applyMatrix4(a.getInverse(this.matrixWorld))}}(),lookAt:function(){var a=new THREE.Matrix4;return function(b){a.lookAt(b,this.position,this.up);this.quaternion.setFromRotationMatrix(a)}}(),add:function(a){if(1<arguments.length){for(var b=0;b<arguments.length;b++)this.add(arguments[b]);return this}if(a===this)return console.error(\\\"THREE.Object3D.add:\\\",\\na,\\\"can't be added as a child of itself.\\\"),this;if(a instanceof THREE.Object3D){void 0!==a.parent&&a.parent.remove(a);a.parent=this;a.dispatchEvent({type:\\\"added\\\"});this.children.push(a);for(b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__addObject(a)}else console.error(\\\"THREE.Object3D.add:\\\",a,\\\"is not an instance of THREE.Object3D.\\\");return this},remove:function(a){if(1<arguments.length)for(var b=0;b<arguments.length;b++)this.remove(arguments[b]);b=this.children.indexOf(a);\\nif(-1!==b){a.parent=void 0;a.dispatchEvent({type:\\\"removed\\\"});this.children.splice(b,1);for(b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__removeObject(a)}},raycast:function(){},traverse:function(a){a(this);for(var b=0,c=this.children.length;b<c;b++)this.children[b].traverse(a)},traverseVisible:function(a){if(!1!==this.visible){a(this);for(var b=0,c=this.children.length;b<c;b++)this.children[b].traverseVisible(a)}},getObjectById:function(a,b){for(var c=0,d=this.children.length;c<\\nd;c++){var e=this.children[c];if(e.id===a||!0===b&&(e=e.getObjectById(a,b),void 0!==e))return e}},getObjectByName:function(a,b){for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.name===a||!0===b&&(e=e.getObjectByName(a,b),void 0!==e))return e}},getChildByName:function(a,b){console.warn(\\\"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().\\\");return this.getObjectByName(a,b)},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale);\\nthis.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){!0===this.matrixAutoUpdate&&this.updateMatrix();if(!0===this.matrixWorldNeedsUpdate||!0===a)void 0===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)},clone:function(a,b){void 0===a&&(a=new THREE.Object3D);void 0===b&&(b=!0);a.name=this.name;a.up.copy(this.up);\\na.position.copy(this.position);a.quaternion.copy(this.quaternion);a.scale.copy(this.scale);a.renderDepth=this.renderDepth;a.rotationAutoUpdate=this.rotationAutoUpdate;a.matrix.copy(this.matrix);a.matrixWorld.copy(this.matrixWorld);a.matrixAutoUpdate=this.matrixAutoUpdate;a.matrixWorldNeedsUpdate=this.matrixWorldNeedsUpdate;a.visible=this.visible;a.castShadow=this.castShadow;a.receiveShadow=this.receiveShadow;a.frustumCulled=this.frustumCulled;a.userData=JSON.parse(JSON.stringify(this.userData));if(!0===\\nb)for(var c=0;c<this.children.length;c++)a.add(this.children[c].clone());return a}};THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);THREE.Object3DIdCount=0;\\nTHREE.Projector=function(){function a(){if(q===t){var a=new THREE.RenderableVertex;r.push(a);t++;q++;return a}return r[q++]}function b(){if(p===w){var a=new THREE.RenderableFace;v.push(a);w++;p++;return a}return v[p++]}function c(){if(D===x){var a=new THREE.RenderableLine;A.push(a);x++;D++;return a}return A[D++]}function d(){if(I===y){var a=new THREE.RenderableSprite;z.push(a);y++;I++;return a}return z[I++]}function e(a,b){return a.z!==b.z?b.z-a.z:a.id!==b.id?a.id-b.id:0}function f(a,b){var c=0,d=\\n1,e=a.z+a.w,f=b.z+b.w,g=-a.z+a.w,h=-b.z+b.w;if(0<=e&&0<=f&&0<=g&&0<=h)return!0;if(0>e&&0>f||0>g&&0>h)return!1;0>e?c=Math.max(c,e/(e-f)):0>f&&(d=Math.min(d,e/(e-f)));0>g?c=Math.max(c,g/(g-h)):0>h&&(d=Math.min(d,g/(g-h)));if(d<c)return!1;a.lerp(b,c);b.lerp(a,1-d);return!0}var g,h,k=[],l=0,n,q,r=[],t=0,s,p,v=[],w=0,u,D,A=[],x=0,C,I,z=[],y=0,K={objects:[],lights:[],elements:[]},N=new THREE.Vector3,ba=new THREE.Vector3,P=new THREE.Vector3,O=new THREE.Vector3,J=new THREE.Vector4,E=new THREE.Box3(new THREE.Vector3(-1,\\n-1,-1),new THREE.Vector3(1,1,1)),Q=new THREE.Box3,L=Array(3),R=new THREE.Matrix4,B=new THREE.Matrix4,S,V=new THREE.Matrix4,W=new THREE.Matrix3,H=new THREE.Frustum,oa=new THREE.Vector4,$=new THREE.Vector4;this.projectVector=function(a,b){b.matrixWorldInverse.getInverse(b.matrixWorld);B.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);return a.applyProjection(B)};this.unprojectVector=function(){var a=new THREE.Matrix4;return function(b,c){a.getInverse(c.projectionMatrix);B.multiplyMatrices(c.matrixWorld,\\na);return b.applyProjection(B)}}();this.pickingRay=function(a,b){a.z=-1;var c=new THREE.Vector3(a.x,a.y,1);this.unprojectVector(a,b);this.unprojectVector(c,b);c.sub(a).normalize();return new THREE.Raycaster(a,c)};var X=new function(){var d=[],e=[],f=null,g=null,h=new THREE.Matrix3,k=function(a){var b=a.positionWorld,c=a.positionScreen;b.copy(a.position).applyMatrix4(S);c.copy(b).applyMatrix4(B);b=1/c.w;c.x*=b;c.y*=b;c.z*=b;a.visible=-1<=c.x&&1>=c.x&&-1<=c.y&&1>=c.y&&-1<=c.z&&1>=c.z},l=function(a,\\nb,c){if(!0===a.visible||!0===b.visible||!0===c.visible)return!0;L[0]=a.positionScreen;L[1]=b.positionScreen;L[2]=c.positionScreen;return E.isIntersectionBox(Q.setFromPoints(L))},q=function(a,b,c){return 0>(c.positionScreen.x-a.positionScreen.x)*(b.positionScreen.y-a.positionScreen.y)-(c.positionScreen.y-a.positionScreen.y)*(b.positionScreen.x-a.positionScreen.x)};return{setObject:function(a){f=a;g=f.material;h.getNormalMatrix(f.matrixWorld);d.length=0;e.length=0},projectVertex:k,checkTriangleVisibility:l,\\ncheckBackfaceCulling:q,pushVertex:function(b,c,d){n=a();n.position.set(b,c,d);k(n)},pushNormal:function(a,b,c){d.push(a,b,c)},pushUv:function(a,b){e.push(a,b)},pushLine:function(a,b){var d=r[a],e=r[b];u=c();u.id=f.id;u.v1.copy(d);u.v2.copy(e);u.z=(d.positionScreen.z+e.positionScreen.z)/2;u.material=f.material;K.elements.push(u)},pushTriangle:function(a,c,k){var n=r[a],p=r[c],t=r[k];if(!1!==l(n,p,t)&&(g.side===THREE.DoubleSide||!0===q(n,p,t))){s=b();s.id=f.id;s.v1.copy(n);s.v2.copy(p);s.v3.copy(t);\\ns.z=(n.positionScreen.z+p.positionScreen.z+t.positionScreen.z)/3;for(n=0;3>n;n++)p=3*arguments[n],t=s.vertexNormalsModel[n],t.set(d[p],d[p+1],d[p+2]),t.applyMatrix3(h).normalize(),p=2*arguments[n],s.uvs[n].set(e[p],e[p+1]);s.vertexNormalsLength=3;s.material=f.material;K.elements.push(s)}}}};this.projectScene=function(n,t,w,v){I=D=p=0;K.elements.length=0;!0===n.autoUpdate&&n.updateMatrixWorld();void 0===t.parent&&t.updateMatrixWorld();R.copy(t.matrixWorldInverse.getInverse(t.matrixWorld));B.multiplyMatrices(t.projectionMatrix,\\nR);H.setFromMatrix(B);h=0;K.objects.length=0;K.lights.length=0;n.traverseVisible(function(a){if(a instanceof THREE.Light)K.lights.push(a);else if(a instanceof THREE.Mesh||a instanceof THREE.Line||a instanceof THREE.Sprite)if(!1===a.frustumCulled||!0===H.intersectsObject(a)){if(h===l){var b=new THREE.RenderableObject;k.push(b);l++;h++;g=b}else g=k[h++];g.id=a.id;g.object=a;null!==a.renderDepth?g.z=a.renderDepth:(O.setFromMatrixPosition(a.matrixWorld),O.applyProjection(B),g.z=O.z);K.objects.push(g)}});\\n!0===w&&K.objects.sort(e);n=0;for(w=K.objects.length;n<w;n++){var A=K.objects[n].object,x=A.geometry;X.setObject(A);S=A.matrixWorld;q=0;if(A instanceof THREE.Mesh)if(x instanceof THREE.BufferGeometry){var z=x.attributes,A=x.offsets;if(void 0!==z.position){for(var G=z.position.array,x=0,y=G.length;x<y;x+=3)X.pushVertex(G[x],G[x+1],G[x+2]);if(void 0!==z.normal)for(var L=z.normal.array,x=0,y=L.length;x<y;x+=3)X.pushNormal(L[x],L[x+1],L[x+2]);if(void 0!==z.uv)for(L=z.uv.array,x=0,y=L.length;x<y;x+=2)X.pushUv(L[x],\\nL[x+1]);if(void 0!==z.index)if(z=z.index.array,0<A.length)for(n=0;n<A.length;n++)for(y=A[n],G=y.index,x=y.start,y=y.start+y.count;x<y;x+=3)X.pushTriangle(z[x]+G,z[x+1]+G,z[x+2]+G);else for(x=0,y=z.length;x<y;x+=3)X.pushTriangle(z[x],z[x+1],z[x+2]);else for(x=0,y=G.length/3;x<y;x+=3)X.pushTriangle(x,x+1,x+2)}}else{if(x instanceof THREE.Geometry){var Q=x.vertices,y=x.faces,z=x.faceVertexUvs[0];W.getNormalMatrix(S);for(var G=A.material instanceof THREE.MeshFaceMaterial,L=!0===G?A.material:null,E=0,ca=\\nQ.length;E<ca;E++){var la=Q[E];X.pushVertex(la.x,la.y,la.z)}Q=0;for(E=y.length;Q<E;Q++){var ca=y[Q],qa=!0===G?L.materials[ca.materialIndex]:A.material;if(void 0!==qa){var ua=qa.side,la=r[ca.a],ja=r[ca.b],Fa=r[ca.c];if(!0===qa.morphTargets){var va=x.morphTargets,Ka=A.morphTargetInfluences,aa=la.position,ra=ja.position,Da=Fa.position;N.set(0,0,0);ba.set(0,0,0);P.set(0,0,0);for(var Qa=0,cb=va.length;Qa<cb;Qa++){var Ga=Ka[Qa];if(0!==Ga){var xa=va[Qa].vertices;N.x+=(xa[ca.a].x-aa.x)*Ga;N.y+=(xa[ca.a].y-\\naa.y)*Ga;N.z+=(xa[ca.a].z-aa.z)*Ga;ba.x+=(xa[ca.b].x-ra.x)*Ga;ba.y+=(xa[ca.b].y-ra.y)*Ga;ba.z+=(xa[ca.b].z-ra.z)*Ga;P.x+=(xa[ca.c].x-Da.x)*Ga;P.y+=(xa[ca.c].y-Da.y)*Ga;P.z+=(xa[ca.c].z-Da.z)*Ga}}la.position.add(N);ja.position.add(ba);Fa.position.add(P);X.projectVertex(la);X.projectVertex(ja);X.projectVertex(Fa)}if(!1!==X.checkTriangleVisibility(la,ja,Fa)){va=X.checkBackfaceCulling(la,ja,Fa);if(ua!==THREE.DoubleSide){if(ua===THREE.FrontSide&&!1===va)continue;if(ua===THREE.BackSide&&!0===va)continue}s=\\nb();s.id=A.id;s.v1.copy(la);s.v2.copy(ja);s.v3.copy(Fa);s.normalModel.copy(ca.normal);!1!==va||ua!==THREE.BackSide&&ua!==THREE.DoubleSide||s.normalModel.negate();s.normalModel.applyMatrix3(W).normalize();Ka=ca.vertexNormals;aa=0;for(ra=Math.min(Ka.length,3);aa<ra;aa++)Da=s.vertexNormalsModel[aa],Da.copy(Ka[aa]),!1!==va||ua!==THREE.BackSide&&ua!==THREE.DoubleSide||Da.negate(),Da.applyMatrix3(W).normalize();s.vertexNormalsLength=Ka.length;ua=z[Q];if(void 0!==ua)for(va=0;3>va;va++)s.uvs[va].copy(ua[va]);\\ns.color=ca.color;s.material=qa;s.z=(la.positionScreen.z+ja.positionScreen.z+Fa.positionScreen.z)/3;K.elements.push(s)}}}}}else if(A instanceof THREE.Line)if(x instanceof THREE.BufferGeometry){if(z=x.attributes,void 0!==z.position){G=z.position.array;x=0;for(y=G.length;x<y;x+=3)X.pushVertex(G[x],G[x+1],G[x+2]);if(void 0!==z.index)for(z=z.index.array,x=0,y=z.length;x<y;x+=2)X.pushLine(z[x],z[x+1]);else for(z=A.type===THREE.LinePieces?2:1,x=0,y=G.length/3-1;x<y;x+=z)X.pushLine(x,x+1)}}else{if(x instanceof\\nTHREE.Geometry&&(V.multiplyMatrices(B,S),Q=A.geometry.vertices,0!==Q.length))for(la=a(),la.positionScreen.copy(Q[0]).applyMatrix4(V),z=A.type===THREE.LinePieces?2:1,E=1,ca=Q.length;E<ca;E++)la=a(),la.positionScreen.copy(Q[E]).applyMatrix4(V),0<(E+1)%z||(ja=r[q-2],oa.copy(la.positionScreen),$.copy(ja.positionScreen),!0===f(oa,$)&&(oa.multiplyScalar(1/oa.w),$.multiplyScalar(1/$.w),u=c(),u.id=A.id,u.v1.positionScreen.copy(oa),u.v2.positionScreen.copy($),u.z=Math.max(oa.z,$.z),u.material=A.material,A.material.vertexColors===\\nTHREE.VertexColors&&(u.vertexColors[0].copy(A.geometry.colors[E]),u.vertexColors[1].copy(A.geometry.colors[E-1])),K.elements.push(u)))}else A instanceof THREE.Sprite&&(J.set(S.elements[12],S.elements[13],S.elements[14],1),J.applyMatrix4(B),x=1/J.w,J.z*=x,-1<=J.z&&1>=J.z&&(C=d(),C.id=A.id,C.x=J.x*x,C.y=J.y*x,C.z=J.z,C.object=A,C.rotation=A.rotation,C.scale.x=A.scale.x*Math.abs(C.x-(J.x+t.projectionMatrix.elements[0])/(J.w+t.projectionMatrix.elements[12])),C.scale.y=A.scale.y*Math.abs(C.y-(J.y+t.projectionMatrix.elements[5])/\\n(J.w+t.projectionMatrix.elements[13])),C.material=A.material,K.elements.push(C)))}!0===v&&K.elements.sort(e);return K}};THREE.Face3=function(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d instanceof THREE.Vector3?d:new THREE.Vector3;this.vertexNormals=d instanceof Array?d:[];this.color=e instanceof THREE.Color?e:new THREE.Color;this.vertexColors=e instanceof Array?e:[];this.vertexTangents=[];this.materialIndex=void 0!==f?f:0};\\nTHREE.Face3.prototype={constructor:THREE.Face3,clone:function(){var a=new THREE.Face3(this.a,this.b,this.c);a.normal.copy(this.normal);a.color.copy(this.color);a.materialIndex=this.materialIndex;for(var b=0,c=this.vertexNormals.length;b<c;b++)a.vertexNormals[b]=this.vertexNormals[b].clone();b=0;for(c=this.vertexColors.length;b<c;b++)a.vertexColors[b]=this.vertexColors[b].clone();b=0;for(c=this.vertexTangents.length;b<c;b++)a.vertexTangents[b]=this.vertexTangents[b].clone();return a}};\\nTHREE.Face4=function(a,b,c,d,e,f,g){console.warn(\\\"THREE.Face4 has been removed. A THREE.Face3 will be created instead.\\\");return new THREE.Face3(a,b,c,e,f,g)};THREE.BufferAttribute=function(a,b){this.array=a;this.itemSize=b};\\nTHREE.BufferAttribute.prototype={constructor:THREE.BufferAttribute,get length(){return this.array.length},set:function(a){this.array.set(a);return this},setX:function(a,b){this.array[a*this.itemSize]=b;return this},setY:function(a,b){this.array[a*this.itemSize+1]=b;return this},setZ:function(a,b){this.array[a*this.itemSize+2]=b;return this},setXY:function(a,b,c){a*=this.itemSize;this.array[a]=b;this.array[a+1]=c;return this},setXYZ:function(a,b,c,d){a*=this.itemSize;this.array[a]=b;this.array[a+1]=\\nc;this.array[a+2]=d;return this},setXYZW:function(a,b,c,d,e){a*=this.itemSize;this.array[a]=b;this.array[a+1]=c;this.array[a+2]=d;this.array[a+3]=e;return this}};THREE.Int8Attribute=function(a,b){console.warn(\\\"THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\\\");return new THREE.BufferAttribute(a,b)};\\nTHREE.Uint8Attribute=function(a,b){console.warn(\\\"THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\\\");return new THREE.BufferAttribute(a,b)};THREE.Uint8ClampedAttribute=function(a,b){console.warn(\\\"THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\\\");return new THREE.BufferAttribute(a,b)};\\nTHREE.Int16Attribute=function(a,b){console.warn(\\\"THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\\\");return new THREE.BufferAttribute(a,b)};THREE.Uint16Attribute=function(a,b){console.warn(\\\"THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\\\");return new THREE.BufferAttribute(a,b)};\\nTHREE.Int32Attribute=function(a,b){console.warn(\\\"THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\\\");return new THREE.BufferAttribute(a,b)};THREE.Uint32Attribute=function(a,b){console.warn(\\\"THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\\\");return new THREE.BufferAttribute(a,b)};\\nTHREE.Float32Attribute=function(a,b){console.warn(\\\"THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\\\");return new THREE.BufferAttribute(a,b)};THREE.Float64Attribute=function(a,b){console.warn(\\\"THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\\\");return new THREE.BufferAttribute(a,b)};\\nTHREE.BufferGeometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\\\"\\\";this.attributes={};this.offsets=this.drawcalls=[];this.boundingSphere=this.boundingBox=null};\\nTHREE.BufferGeometry.prototype={constructor:THREE.BufferGeometry,addAttribute:function(a,b,c){!1===b instanceof THREE.BufferAttribute?(console.warn(\\\"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).\\\"),this.attributes[a]={array:b,itemSize:c}):this.attributes[a]=b},getAttribute:function(a){return this.attributes[a]},addDrawCall:function(a,b,c){this.drawcalls.push({start:a,count:b,index:void 0!==c?c:0})},applyMatrix:function(a){var b=this.attributes.position;void 0!==b&&(a.applyToVector3Array(b.array),\\nb.needsUpdate=!0);b=this.attributes.normal;void 0!==b&&((new THREE.Matrix3).getNormalMatrix(a).applyToVector3Array(b.array),b.needsUpdate=!0)},fromGeometry:function(a,b){b=b||{vertexColors:THREE.NoColors};var c=a.vertices,d=a.faces,e=a.faceVertexUvs,f=b.vertexColors,g=0<e[0].length,h=3==d[0].vertexNormals.length,k=new Float32Array(9*d.length);this.addAttribute(\\\"position\\\",new THREE.BufferAttribute(k,3));var l=new Float32Array(9*d.length);this.addAttribute(\\\"normal\\\",new THREE.BufferAttribute(l,3));if(f!==\\nTHREE.NoColors){var n=new Float32Array(9*d.length);this.addAttribute(\\\"color\\\",new THREE.BufferAttribute(n,3))}if(!0===g){var q=new Float32Array(6*d.length);this.addAttribute(\\\"uvs\\\",new THREE.BufferAttribute(q,2))}for(var r=0,t=0,s=0;r<d.length;r++,t+=6,s+=9){var p=d[r],v=c[p.a],w=c[p.b],u=c[p.c];k[s]=v.x;k[s+1]=v.y;k[s+2]=v.z;k[s+3]=w.x;k[s+4]=w.y;k[s+5]=w.z;k[s+6]=u.x;k[s+7]=u.y;k[s+8]=u.z;!0===h?(v=p.vertexNormals[0],w=p.vertexNormals[1],u=p.vertexNormals[2],l[s]=v.x,l[s+1]=v.y,l[s+2]=v.z,l[s+3]=\\nw.x,l[s+4]=w.y,l[s+5]=w.z,l[s+6]=u.x,l[s+7]=u.y,l[s+8]=u.z):(v=p.normal,l[s]=v.x,l[s+1]=v.y,l[s+2]=v.z,l[s+3]=v.x,l[s+4]=v.y,l[s+5]=v.z,l[s+6]=v.x,l[s+7]=v.y,l[s+8]=v.z);f===THREE.FaceColors?(p=p.color,n[s]=p.r,n[s+1]=p.g,n[s+2]=p.b,n[s+3]=p.r,n[s+4]=p.g,n[s+5]=p.b,n[s+6]=p.r,n[s+7]=p.g,n[s+8]=p.b):f===THREE.VertexColors&&(v=p.vertexColors[0],w=p.vertexColors[1],p=p.vertexColors[2],n[s]=v.r,n[s+1]=v.g,n[s+2]=v.b,n[s+3]=w.r,n[s+4]=w.g,n[s+5]=w.b,n[s+6]=p.r,n[s+7]=p.g,n[s+8]=p.b);!0===g&&(p=e[0][r][0],\\nv=e[0][r][1],w=e[0][r][2],q[t]=p.x,q[t+1]=p.y,q[t+2]=v.x,q[t+3]=v.y,q[t+4]=w.x,q[t+5]=w.y)}this.computeBoundingSphere();return this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);var a=this.attributes.position.array;if(a){var b=this.boundingBox;3<=a.length&&(b.min.x=b.max.x=a[0],b.min.y=b.max.y=a[1],b.min.z=b.max.z=a[2]);for(var c=3,d=a.length;c<d;c+=3){var e=a[c],f=a[c+1],g=a[c+2];e<b.min.x?b.min.x=e:e>b.max.x&&(b.max.x=e);f<b.min.y?b.min.y=f:f>b.max.y&&\\n(b.max.y=f);g<b.min.z?b.min.z=g:g>b.max.z&&(b.max.z=g)}}if(void 0===a||0===a.length)this.boundingBox.min.set(0,0,0),this.boundingBox.max.set(0,0,0);(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \\\"position\\\" attribute is likely to have NaN values.')},computeBoundingSphere:function(){var a=new THREE.Box3,b=new THREE.Vector3;return function(){null===this.boundingSphere&&\\n(this.boundingSphere=new THREE.Sphere);var c=this.attributes.position.array;if(c){a.makeEmpty();for(var d=this.boundingSphere.center,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),a.expandByPoint(b);a.center(d);for(var g=0,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),g=Math.max(g,d.distanceToSquared(b));this.boundingSphere.radius=Math.sqrt(g);isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \\\"position\\\" attribute is likely to have NaN values.')}}}(),\\ncomputeFaceNormals:function(){},computeVertexNormals:function(){if(this.attributes.position){var a,b,c,d;a=this.attributes.position.array.length;if(void 0===this.attributes.normal)this.attributes.normal={itemSize:3,array:new Float32Array(a)};else for(a=0,b=this.attributes.normal.array.length;a<b;a++)this.attributes.normal.array[a]=0;var e=this.attributes.position.array,f=this.attributes.normal.array,g,h,k,l,n,q,r=new THREE.Vector3,t=new THREE.Vector3,s=new THREE.Vector3,p=new THREE.Vector3,v=new THREE.Vector3;\\nif(this.attributes.index){var w=this.attributes.index.array,u=0<this.offsets.length?this.offsets:[{start:0,count:w.length,index:0}];c=0;for(d=u.length;c<d;++c){b=u[c].start;g=u[c].count;var D=u[c].index;a=b;for(b+=g;a<b;a+=3)g=D+w[a],h=D+w[a+1],k=D+w[a+2],l=e[3*g],n=e[3*g+1],q=e[3*g+2],r.set(l,n,q),l=e[3*h],n=e[3*h+1],q=e[3*h+2],t.set(l,n,q),l=e[3*k],n=e[3*k+1],q=e[3*k+2],s.set(l,n,q),p.subVectors(s,t),v.subVectors(r,t),p.cross(v),f[3*g]+=p.x,f[3*g+1]+=p.y,f[3*g+2]+=p.z,f[3*h]+=p.x,f[3*h+1]+=p.y,\\nf[3*h+2]+=p.z,f[3*k]+=p.x,f[3*k+1]+=p.y,f[3*k+2]+=p.z}}else for(a=0,b=e.length;a<b;a+=9)l=e[a],n=e[a+1],q=e[a+2],r.set(l,n,q),l=e[a+3],n=e[a+4],q=e[a+5],t.set(l,n,q),l=e[a+6],n=e[a+7],q=e[a+8],s.set(l,n,q),p.subVectors(s,t),v.subVectors(r,t),p.cross(v),f[a]=p.x,f[a+1]=p.y,f[a+2]=p.z,f[a+3]=p.x,f[a+4]=p.y,f[a+5]=p.z,f[a+6]=p.x,f[a+7]=p.y,f[a+8]=p.z;this.normalizeNormals();this.normalsNeedUpdate=!0}},computeTangents:function(){function a(a,b,c){q=d[3*a];r=d[3*a+1];t=d[3*a+2];s=d[3*b];p=d[3*b+1];v=d[3*\\nb+2];w=d[3*c];u=d[3*c+1];D=d[3*c+2];A=f[2*a];x=f[2*a+1];C=f[2*b];I=f[2*b+1];z=f[2*c];y=f[2*c+1];K=s-q;N=w-q;ba=p-r;P=u-r;O=v-t;J=D-t;E=C-A;Q=z-A;L=I-x;R=y-x;B=1/(E*R-Q*L);S.set((R*K-L*N)*B,(R*ba-L*P)*B,(R*O-L*J)*B);V.set((E*N-Q*K)*B,(E*P-Q*ba)*B,(E*J-Q*O)*B);k[a].add(S);k[b].add(S);k[c].add(S);l[a].add(V);l[b].add(V);l[c].add(V)}function b(a){za.x=e[3*a];za.y=e[3*a+1];za.z=e[3*a+2];Oa.copy(za);G=k[a];Ea.copy(G);Ea.sub(za.multiplyScalar(za.dot(G))).normalize();Aa.crossVectors(Oa,G);Ba=Aa.dot(l[a]);\\nPa=0>Ba?-1:1;h[4*a]=Ea.x;h[4*a+1]=Ea.y;h[4*a+2]=Ea.z;h[4*a+3]=Pa}if(void 0===this.attributes.index||void 0===this.attributes.position||void 0===this.attributes.normal||void 0===this.attributes.uv)console.warn(\\\"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\\\");else{var c=this.attributes.index.array,d=this.attributes.position.array,e=this.attributes.normal.array,f=this.attributes.uv.array,g=d.length/3;void 0===this.attributes.tangent&&(this.attributes.tangent=\\n{itemSize:4,array:new Float32Array(4*g)});for(var h=this.attributes.tangent.array,k=[],l=[],n=0;n<g;n++)k[n]=new THREE.Vector3,l[n]=new THREE.Vector3;var q,r,t,s,p,v,w,u,D,A,x,C,I,z,y,K,N,ba,P,O,J,E,Q,L,R,B,S=new THREE.Vector3,V=new THREE.Vector3,W,H,oa,$,X,T=this.offsets,n=0;for(H=T.length;n<H;++n){W=T[n].start;oa=T[n].count;var ya=T[n].index,g=W;for(W+=oa;g<W;g+=3)oa=ya+c[g],$=ya+c[g+1],X=ya+c[g+2],a(oa,$,X)}var Ea=new THREE.Vector3,Aa=new THREE.Vector3,za=new THREE.Vector3,Oa=new THREE.Vector3,\\nPa,G,Ba,n=0;for(H=T.length;n<H;++n)for(W=T[n].start,oa=T[n].count,ya=T[n].index,g=W,W+=oa;g<W;g+=3)oa=ya+c[g],$=ya+c[g+1],X=ya+c[g+2],b(oa),b($),b(X)}},computeOffsets:function(a){var b=a;void 0===a&&(b=65535);Date.now();a=this.attributes.index.array;for(var c=this.attributes.position.array,d=a.length/3,e=new Uint16Array(a.length),f=0,g=0,h=[{start:0,count:0,index:0}],k=h[0],l=0,n=0,q=new Int32Array(6),r=new Int32Array(c.length),t=new Int32Array(c.length),s=0;s<c.length;s++)r[s]=-1,t[s]=-1;for(c=0;c<\\nd;c++){for(var p=n=0;3>p;p++)s=a[3*c+p],-1==r[s]?(q[2*p]=s,q[2*p+1]=-1,n++):r[s]<k.index?(q[2*p]=s,q[2*p+1]=-1,l++):(q[2*p]=s,q[2*p+1]=r[s]);if(g+n>k.index+b)for(k={start:f,count:0,index:g},h.push(k),n=0;6>n;n+=2)p=q[n+1],-1<p&&p<k.index&&(q[n+1]=-1);for(n=0;6>n;n+=2)s=q[n],p=q[n+1],-1===p&&(p=g++),r[s]=p,t[p]=s,e[f++]=p-k.index,k.count++}this.reorderBuffers(e,t,g);return this.offsets=h},merge:function(){console.log(\\\"BufferGeometry.merge(): TODO\\\")},normalizeNormals:function(){for(var a=this.attributes.normal.array,\\nb,c,d,e=0,f=a.length;e<f;e+=3)b=a[e],c=a[e+1],d=a[e+2],b=1/Math.sqrt(b*b+c*c+d*d),a[e]*=b,a[e+1]*=b,a[e+2]*=b},reorderBuffers:function(a,b,c){var d={},e=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],f;for(f in this.attributes)if(\\\"index\\\"!=f)for(var g=this.attributes[f].array,h=0,k=e.length;h<k;h++){var l=e[h];if(g instanceof l){d[f]=new l(this.attributes[f].itemSize*c);break}}for(e=0;e<c;e++)for(f in g=b[e],this.attributes)if(\\\"index\\\"!=\\nf)for(var h=this.attributes[f].array,k=this.attributes[f].itemSize,l=d[f],n=0;n<k;n++)l[e*k+n]=h[g*k+n];this.attributes.index.array=a;for(f in this.attributes)\\\"index\\\"!=f&&(this.attributes[f].array=d[f],this.attributes[f].numItems=this.attributes[f].itemSize*c)},clone:function(){var a=new THREE.BufferGeometry,b=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],c;for(c in this.attributes){for(var d=this.attributes[c],e=d.array,f={itemSize:d.itemSize,\\narray:null},d=0,g=b.length;d<g;d++){var h=b[d];if(e instanceof h){f.array=new h(e);break}}a.attributes[c]=f}d=0;for(g=this.offsets.length;d<g;d++)b=this.offsets[d],a.offsets.push({start:b.start,index:b.index,count:b.count});return a},dispose:function(){this.dispatchEvent({type:\\\"dispose\\\"})}};THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);\\nTHREE.Geometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\\\"\\\";this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphColors=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.dynamic=!0;this.groupsNeedUpdate=this.buffersNeedUpdate=this.lineDistancesNeedUpdate=this.colorsNeedUpdate=this.tangentsNeedUpdate=this.normalsNeedUpdate=\\nthis.uvsNeedUpdate=this.elementsNeedUpdate=this.verticesNeedUpdate=!1};\\nTHREE.Geometry.prototype={constructor:THREE.Geometry,applyMatrix:function(a){for(var b=(new THREE.Matrix3).getNormalMatrix(a),c=0,d=this.vertices.length;c<d;c++)this.vertices[c].applyMatrix4(a);c=0;for(d=this.faces.length;c<d;c++){a=this.faces[c];a.normal.applyMatrix3(b).normalize();for(var e=0,f=a.vertexNormals.length;e<f;e++)a.vertexNormals[e].applyMatrix3(b).normalize()}this.boundingBox instanceof THREE.Box3&&this.computeBoundingBox();this.boundingSphere instanceof THREE.Sphere&&this.computeBoundingSphere()},\\ncenter:function(){this.computeBoundingBox();var a=new THREE.Vector3;a.addVectors(this.boundingBox.min,this.boundingBox.max);a.multiplyScalar(-.5);this.applyMatrix((new THREE.Matrix4).makeTranslation(a.x,a.y,a.z));this.computeBoundingBox();return a},computeFaceNormals:function(){for(var a=new THREE.Vector3,b=new THREE.Vector3,c=0,d=this.faces.length;c<d;c++){var e=this.faces[c],f=this.vertices[e.a],g=this.vertices[e.b];a.subVectors(this.vertices[e.c],g);b.subVectors(f,g);a.cross(b);a.normalize();e.normal.copy(a)}},\\ncomputeVertexNormals:function(a){var b,c,d;d=Array(this.vertices.length);b=0;for(c=this.vertices.length;b<c;b++)d[b]=new THREE.Vector3;if(a){var e,f,g,h=new THREE.Vector3,k=new THREE.Vector3;new THREE.Vector3;new THREE.Vector3;new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],e=this.vertices[c.a],f=this.vertices[c.b],g=this.vertices[c.c],h.subVectors(g,f),k.subVectors(e,f),h.cross(k),d[c.a].add(h),d[c.b].add(h),d[c.c].add(h)}else for(a=0,b=this.faces.length;a<b;a++)c=this.faces[a],\\nd[c.a].add(c.normal),d[c.b].add(c.normal),d[c.c].add(c.normal);b=0;for(c=this.vertices.length;b<c;b++)d[b].normalize();a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c.vertexNormals[0]=d[c.a].clone(),c.vertexNormals[1]=d[c.b].clone(),c.vertexNormals[2]=d[c.c].clone()},computeMorphNormals:function(){var a,b,c,d,e;c=0;for(d=this.faces.length;c<d;c++)for(e=this.faces[c],e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||\\n(e.__originalVertexNormals=[]),a=0,b=e.vertexNormals.length;a<b;a++)e.__originalVertexNormals[a]?e.__originalVertexNormals[a].copy(e.vertexNormals[a]):e.__originalVertexNormals[a]=e.vertexNormals[a].clone();var f=new THREE.Geometry;f.faces=this.faces;a=0;for(b=this.morphTargets.length;a<b;a++){if(!this.morphNormals[a]){this.morphNormals[a]={};this.morphNormals[a].faceNormals=[];this.morphNormals[a].vertexNormals=[];e=this.morphNormals[a].faceNormals;var g=this.morphNormals[a].vertexNormals,h,k;c=\\n0;for(d=this.faces.length;c<d;c++)h=new THREE.Vector3,k={a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3},e.push(h),g.push(k)}g=this.morphNormals[a];f.vertices=this.morphTargets[a].vertices;f.computeFaceNormals();f.computeVertexNormals();c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],h=g.faceNormals[c],k=g.vertexNormals[c],h.copy(e.normal),k.a.copy(e.vertexNormals[0]),k.b.copy(e.vertexNormals[1]),k.c.copy(e.vertexNormals[2])}c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],e.normal=\\ne.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals},computeTangents:function(){var a,b,c,d,e,f,g,h,k,l,n,q,r,t,s,p,v,w=[],u=[];c=new THREE.Vector3;var D=new THREE.Vector3,A=new THREE.Vector3,x=new THREE.Vector3,C=new THREE.Vector3;a=0;for(b=this.vertices.length;a<b;a++)w[a]=new THREE.Vector3,u[a]=new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)e=this.faces[a],f=this.faceVertexUvs[0][a],d=e.a,v=e.b,e=e.c,g=this.vertices[d],h=this.vertices[v],k=this.vertices[e],l=f[0],n=f[1],q=f[2],\\nf=h.x-g.x,r=k.x-g.x,t=h.y-g.y,s=k.y-g.y,h=h.z-g.z,g=k.z-g.z,k=n.x-l.x,p=q.x-l.x,n=n.y-l.y,l=q.y-l.y,q=1/(k*l-p*n),c.set((l*f-n*r)*q,(l*t-n*s)*q,(l*h-n*g)*q),D.set((k*r-p*f)*q,(k*s-p*t)*q,(k*g-p*h)*q),w[d].add(c),w[v].add(c),w[e].add(c),u[d].add(D),u[v].add(D),u[e].add(D);D=[\\\"a\\\",\\\"b\\\",\\\"c\\\",\\\"d\\\"];a=0;for(b=this.faces.length;a<b;a++)for(e=this.faces[a],c=0;c<Math.min(e.vertexNormals.length,3);c++)C.copy(e.vertexNormals[c]),d=e[D[c]],v=w[d],A.copy(v),A.sub(C.multiplyScalar(C.dot(v))).normalize(),x.crossVectors(e.vertexNormals[c],\\nv),d=x.dot(u[d]),d=0>d?-1:1,e.vertexTangents[c]=new THREE.Vector4(A.x,A.y,A.z,d);this.hasTangents=!0},computeLineDistances:function(){for(var a=0,b=this.vertices,c=0,d=b.length;c<d;c++)0<c&&(a+=b[c].distanceTo(b[c-1])),this.lineDistances[c]=a},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);this.boundingSphere.setFromPoints(this.vertices)},\\nmerge:function(a,b,c){if(!1===a instanceof THREE.Geometry)console.error(\\\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\\\",a);else{var d,e=this.vertices.length,f=this.vertices,g=a.vertices,h=this.faces,k=a.faces,l=this.faceVertexUvs[0];a=a.faceVertexUvs[0];void 0===c&&(c=0);void 0!==b&&(d=(new THREE.Matrix3).getNormalMatrix(b));for(var n=0,q=g.length;n<q;n++){var r=g[n].clone();void 0!==b&&r.applyMatrix4(b);f.push(r)}n=0;for(q=k.length;n<q;n++){var g=k[n],t,s=g.vertexNormals,p=\\ng.vertexColors,r=new THREE.Face3(g.a+e,g.b+e,g.c+e);r.normal.copy(g.normal);void 0!==d&&r.normal.applyMatrix3(d).normalize();b=0;for(f=s.length;b<f;b++)t=s[b].clone(),void 0!==d&&t.applyMatrix3(d).normalize(),r.vertexNormals.push(t);r.color.copy(g.color);b=0;for(f=p.length;b<f;b++)t=p[b],r.vertexColors.push(t.clone());r.materialIndex=g.materialIndex+c;h.push(r)}n=0;for(q=a.length;n<q;n++)if(c=a[n],d=[],void 0!==c){b=0;for(f=c.length;b<f;b++)d.push(new THREE.Vector2(c[b].x,c[b].y));l.push(d)}}},mergeVertices:function(){var a=\\n{},b=[],c=[],d,e=Math.pow(10,4),f,g;f=0;for(g=this.vertices.length;f<g;f++)d=this.vertices[f],d=Math.round(d.x*e)+\\\"_\\\"+Math.round(d.y*e)+\\\"_\\\"+Math.round(d.z*e),void 0===a[d]?(a[d]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[d]];a=[];f=0;for(g=this.faces.length;f<g;f++)for(e=this.faces[f],e.a=c[e.a],e.b=c[e.b],e.c=c[e.c],e=[e.a,e.b,e.c],d=0;3>d;d++)if(e[d]==e[(d+1)%3]){a.push(f);break}for(f=a.length-1;0<=f;f--)for(e=a[f],this.faces.splice(e,1),c=0,g=this.faceVertexUvs.length;c<g;c++)this.faceVertexUvs[c].splice(e,\\n1);f=this.vertices.length-b.length;this.vertices=b;return f},makeGroups:function(){var a=0;return function(b,c){var d,e,f,g,h={},k,l=this.morphTargets.length,n=this.morphNormals.length;this.geometryGroups={};this.geometryGroupsList=[];d=0;for(e=this.faces.length;d<e;d++)f=this.faces[d],f=b?f.materialIndex:0,f in h||(h[f]={hash:f,counter:0}),g=h[f].hash+\\\"_\\\"+h[f].counter,g in this.geometryGroups||(k={id:a++,faces3:[],materialIndex:f,vertices:0,numMorphTargets:l,numMorphNormals:n},this.geometryGroups[g]=\\nk,this.geometryGroupsList.push(k)),this.geometryGroups[g].vertices+3>c&&(h[f].counter+=1,g=h[f].hash+\\\"_\\\"+h[f].counter,g in this.geometryGroups||(k={id:a++,faces3:[],materialIndex:f,vertices:0,numMorphTargets:l,numMorphNormals:n},this.geometryGroups[g]=k,this.geometryGroupsList.push(k))),this.geometryGroups[g].faces3.push(d),this.geometryGroups[g].vertices+=3}}(),clone:function(){for(var a=new THREE.Geometry,b=this.vertices,c=0,d=b.length;c<d;c++)a.vertices.push(b[c].clone());b=this.faces;c=0;for(d=\\nb.length;c<d;c++)a.faces.push(b[c].clone());b=this.faceVertexUvs[0];c=0;for(d=b.length;c<d;c++){for(var e=b[c],f=[],g=0,h=e.length;g<h;g++)f.push(new THREE.Vector2(e[g].x,e[g].y));a.faceVertexUvs[0].push(f)}return a},dispose:function(){this.dispatchEvent({type:\\\"dispose\\\"})}};THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);THREE.GeometryIdCount=0;THREE.Camera=function(){THREE.Object3D.call(this);this.matrixWorldInverse=new THREE.Matrix4;this.projectionMatrix=new THREE.Matrix4};\\nTHREE.Camera.prototype=Object.create(THREE.Object3D.prototype);THREE.Camera.prototype.lookAt=function(){var a=new THREE.Matrix4;return function(b){a.lookAt(this.position,b,this.up);this.quaternion.setFromRotationMatrix(a)}}();THREE.Camera.prototype.clone=function(a){void 0===a&&(a=new THREE.Camera);THREE.Object3D.prototype.clone.call(this,a);a.matrixWorldInverse.copy(this.matrixWorldInverse);a.projectionMatrix.copy(this.projectionMatrix);return a};\\nTHREE.CubeCamera=function(a,b,c){THREE.Object3D.call(this);var d=new THREE.PerspectiveCamera(90,1,a,b);d.up.set(0,-1,0);d.lookAt(new THREE.Vector3(1,0,0));this.add(d);var e=new THREE.PerspectiveCamera(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new THREE.Vector3(-1,0,0));this.add(e);var f=new THREE.PerspectiveCamera(90,1,a,b);f.up.set(0,0,1);f.lookAt(new THREE.Vector3(0,1,0));this.add(f);var g=new THREE.PerspectiveCamera(90,1,a,b);g.up.set(0,0,-1);g.lookAt(new THREE.Vector3(0,-1,0));this.add(g);var h=new THREE.PerspectiveCamera(90,\\n1,a,b);h.up.set(0,-1,0);h.lookAt(new THREE.Vector3(0,0,1));this.add(h);var k=new THREE.PerspectiveCamera(90,1,a,b);k.up.set(0,-1,0);k.lookAt(new THREE.Vector3(0,0,-1));this.add(k);this.renderTarget=new THREE.WebGLRenderTargetCube(c,c,{format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter});this.updateCubeMap=function(a,b){var c=this.renderTarget,r=c.generateMipmaps;c.generateMipmaps=!1;c.activeCubeFace=0;a.render(b,d,c);c.activeCubeFace=1;a.render(b,e,c);c.activeCubeFace=\\n2;a.render(b,f,c);c.activeCubeFace=3;a.render(b,g,c);c.activeCubeFace=4;a.render(b,h,c);c.generateMipmaps=r;c.activeCubeFace=5;a.render(b,k,c)}};THREE.CubeCamera.prototype=Object.create(THREE.Object3D.prototype);THREE.OrthographicCamera=function(a,b,c,d,e,f){THREE.Camera.call(this);this.left=a;this.right=b;this.top=c;this.bottom=d;this.near=void 0!==e?e:.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()};THREE.OrthographicCamera.prototype=Object.create(THREE.Camera.prototype);\\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix=function(){this.projectionMatrix.makeOrthographic(this.left,this.right,this.top,this.bottom,this.near,this.far)};THREE.OrthographicCamera.prototype.clone=function(){var a=new THREE.OrthographicCamera;THREE.Camera.prototype.clone.call(this,a);a.left=this.left;a.right=this.right;a.top=this.top;a.bottom=this.bottom;a.near=this.near;a.far=this.far;return a};\\nTHREE.PerspectiveCamera=function(a,b,c,d){THREE.Camera.call(this);this.fov=void 0!==a?a:50;this.aspect=void 0!==b?b:1;this.near=void 0!==c?c:.1;this.far=void 0!==d?d:2E3;this.updateProjectionMatrix()};THREE.PerspectiveCamera.prototype=Object.create(THREE.Camera.prototype);THREE.PerspectiveCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);this.fov=2*THREE.Math.radToDeg(Math.atan(b/(2*a)));this.updateProjectionMatrix()};\\nTHREE.PerspectiveCamera.prototype.setViewOffset=function(a,b,c,d,e,f){this.fullWidth=a;this.fullHeight=b;this.x=c;this.y=d;this.width=e;this.height=f;this.updateProjectionMatrix()};\\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix=function(){if(this.fullWidth){var a=this.fullWidth/this.fullHeight,b=Math.tan(THREE.Math.degToRad(.5*this.fov))*this.near,c=-b,d=a*c,a=Math.abs(a*b-d),c=Math.abs(b-c);this.projectionMatrix.makeFrustum(d+this.x*a/this.fullWidth,d+(this.x+this.width)*a/this.fullWidth,b-(this.y+this.height)*c/this.fullHeight,b-this.y*c/this.fullHeight,this.near,this.far)}else this.projectionMatrix.makePerspective(this.fov,this.aspect,this.near,this.far)};\\nTHREE.PerspectiveCamera.prototype.clone=function(){var a=new THREE.PerspectiveCamera;THREE.Camera.prototype.clone.call(this,a);a.fov=this.fov;a.aspect=this.aspect;a.near=this.near;a.far=this.far;return a};THREE.Light=function(a){THREE.Object3D.call(this);this.color=new THREE.Color(a)};THREE.Light.prototype=Object.create(THREE.Object3D.prototype);THREE.Light.prototype.clone=function(a){void 0===a&&(a=new THREE.Light);THREE.Object3D.prototype.clone.call(this,a);a.color.copy(this.color);return a};\\nTHREE.AmbientLight=function(a){THREE.Light.call(this,a)};THREE.AmbientLight.prototype=Object.create(THREE.Light.prototype);THREE.AmbientLight.prototype.clone=function(){var a=new THREE.AmbientLight;THREE.Light.prototype.clone.call(this,a);return a};\\nTHREE.AreaLight=function(a,b){THREE.Light.call(this,a);this.normal=new THREE.Vector3(0,-1,0);this.right=new THREE.Vector3(1,0,0);this.intensity=void 0!==b?b:1;this.height=this.width=1;this.constantAttenuation=1.5;this.linearAttenuation=.5;this.quadraticAttenuation=.1};THREE.AreaLight.prototype=Object.create(THREE.Light.prototype);\\nTHREE.DirectionalLight=function(a,b){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraLeft=-500;this.shadowCameraTop=this.shadowCameraRight=500;this.shadowCameraBottom=-500;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowCascade=!1;this.shadowCascadeOffset=new THREE.Vector3(0,\\n0,-1E3);this.shadowCascadeCount=2;this.shadowCascadeBias=[0,0,0];this.shadowCascadeWidth=[512,512,512];this.shadowCascadeHeight=[512,512,512];this.shadowCascadeNearZ=[-1,.99,.998];this.shadowCascadeFarZ=[.99,.998,1];this.shadowCascadeArray=[];this.shadowMatrix=this.shadowCamera=this.shadowMapSize=this.shadowMap=null};THREE.DirectionalLight.prototype=Object.create(THREE.Light.prototype);\\nTHREE.DirectionalLight.prototype.clone=function(){var a=new THREE.DirectionalLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;a.shadowCameraNear=this.shadowCameraNear;a.shadowCameraFar=this.shadowCameraFar;a.shadowCameraLeft=this.shadowCameraLeft;a.shadowCameraRight=this.shadowCameraRight;a.shadowCameraTop=this.shadowCameraTop;a.shadowCameraBottom=this.shadowCameraBottom;a.shadowCameraVisible=\\nthis.shadowCameraVisible;a.shadowBias=this.shadowBias;a.shadowDarkness=this.shadowDarkness;a.shadowMapWidth=this.shadowMapWidth;a.shadowMapHeight=this.shadowMapHeight;a.shadowCascade=this.shadowCascade;a.shadowCascadeOffset.copy(this.shadowCascadeOffset);a.shadowCascadeCount=this.shadowCascadeCount;a.shadowCascadeBias=this.shadowCascadeBias.slice(0);a.shadowCascadeWidth=this.shadowCascadeWidth.slice(0);a.shadowCascadeHeight=this.shadowCascadeHeight.slice(0);a.shadowCascadeNearZ=this.shadowCascadeNearZ.slice(0);\\na.shadowCascadeFarZ=this.shadowCascadeFarZ.slice(0);return a};THREE.HemisphereLight=function(a,b,c){THREE.Light.call(this,a);this.position.set(0,100,0);this.groundColor=new THREE.Color(b);this.intensity=void 0!==c?c:1};THREE.HemisphereLight.prototype=Object.create(THREE.Light.prototype);THREE.HemisphereLight.prototype.clone=function(){var a=new THREE.HemisphereLight;THREE.Light.prototype.clone.call(this,a);a.groundColor.copy(this.groundColor);a.intensity=this.intensity;return a};\\nTHREE.PointLight=function(a,b,c){THREE.Light.call(this,a);this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0};THREE.PointLight.prototype=Object.create(THREE.Light.prototype);THREE.PointLight.prototype.clone=function(){var a=new THREE.PointLight;THREE.Light.prototype.clone.call(this,a);a.intensity=this.intensity;a.distance=this.distance;return a};\\nTHREE.SpotLight=function(a,b,c,d,e){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/3;this.exponent=void 0!==e?e:10;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraFov=50;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowMatrix=this.shadowCamera=this.shadowMapSize=\\nthis.shadowMap=null};THREE.SpotLight.prototype=Object.create(THREE.Light.prototype);\\nTHREE.SpotLight.prototype.clone=function(){var a=new THREE.SpotLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.distance=this.distance;a.angle=this.angle;a.exponent=this.exponent;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;a.shadowCameraNear=this.shadowCameraNear;a.shadowCameraFar=this.shadowCameraFar;a.shadowCameraFov=this.shadowCameraFov;a.shadowCameraVisible=this.shadowCameraVisible;a.shadowBias=this.shadowBias;a.shadowDarkness=\\nthis.shadowDarkness;a.shadowMapWidth=this.shadowMapWidth;a.shadowMapHeight=this.shadowMapHeight;return a};THREE.Cache=function(){this.files={}};THREE.Cache.prototype={constructor:THREE.Cache,add:function(a,b){this.files[a]=b},get:function(a){return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}};\\nTHREE.Loader=function(a){this.statusDomElement=(this.showStatus=a)?THREE.Loader.prototype.addStatusElement():null;this.imageLoader=new THREE.ImageLoader;this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){}};\\nTHREE.Loader.prototype={constructor:THREE.Loader,crossOrigin:void 0,addStatusElement:function(){var a=document.createElement(\\\"div\\\");a.style.position=\\\"absolute\\\";a.style.right=\\\"0px\\\";a.style.top=\\\"0px\\\";a.style.fontSize=\\\"0.8em\\\";a.style.textAlign=\\\"left\\\";a.style.background=\\\"rgba(0,0,0,0.25)\\\";a.style.color=\\\"#fff\\\";a.style.width=\\\"120px\\\";a.style.padding=\\\"0.5em 0.5em 0.5em 0.5em\\\";a.style.zIndex=1E3;a.innerHTML=\\\"Loading ...\\\";return a},updateProgress:function(a){var b=\\\"Loaded \\\",b=a.total?b+((100*a.loaded/a.total).toFixed(0)+\\n\\\"%\\\"):b+((a.loaded/1024).toFixed(2)+\\\" KB\\\");this.statusDomElement.innerHTML=b},extractUrlBase:function(a){a=a.split(\\\"/\\\");if(1===a.length)return\\\"./\\\";a.pop();return a.join(\\\"/\\\")+\\\"/\\\"},initMaterials:function(a,b){for(var c=[],d=0;d<a.length;++d)c[d]=this.createMaterial(a[d],b);return c},needsTangents:function(a){for(var b=0,c=a.length;b<c;b++)if(a[b]instanceof THREE.ShaderMaterial)return!0;return!1},createMaterial:function(a,b){function c(a){a=Math.log(a)/Math.LN2;return Math.pow(2,Math.round(a))}function d(a,\\nd,e,g,h,k,p){var v=b+e,w,u=THREE.Loader.Handlers.get(v);null!==u?w=u.load(v):(w=new THREE.Texture,u=f.imageLoader,u.crossOrigin=f.crossOrigin,u.load(v,function(a){if(!1===THREE.Math.isPowerOfTwo(a.width)||!1===THREE.Math.isPowerOfTwo(a.height)){var b=c(a.width),d=c(a.height),e=document.createElement(\\\"canvas\\\");e.width=b;e.height=d;e.getContext(\\\"2d\\\").drawImage(a,0,0,b,d);w.image=e}else w.image=a;w.needsUpdate=!0}));w.sourceFile=e;g&&(w.repeat.set(g[0],g[1]),1!==g[0]&&(w.wrapS=THREE.RepeatWrapping),\\n1!==g[1]&&(w.wrapT=THREE.RepeatWrapping));h&&w.offset.set(h[0],h[1]);k&&(e={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==e[k[0]]&&(w.wrapS=e[k[0]]),void 0!==e[k[1]]&&(w.wrapT=e[k[1]]));p&&(w.anisotropy=p);a[d]=w}function e(a){return(255*a[0]<<16)+(255*a[1]<<8)+255*a[2]}var f=this,g=\\\"MeshLambertMaterial\\\",h={color:15658734,opacity:1,map:null,lightMap:null,normalMap:null,bumpMap:null,wireframe:!1};if(a.shading){var k=a.shading.toLowerCase();\\\"phong\\\"===k?g=\\\"MeshPhongMaterial\\\":\\n\\\"basic\\\"===k&&(g=\\\"MeshBasicMaterial\\\")}void 0!==a.blending&&void 0!==THREE[a.blending]&&(h.blending=THREE[a.blending]);if(void 0!==a.transparent||1>a.opacity)h.transparent=a.transparent;void 0!==a.depthTest&&(h.depthTest=a.depthTest);void 0!==a.depthWrite&&(h.depthWrite=a.depthWrite);void 0!==a.visible&&(h.visible=a.visible);void 0!==a.flipSided&&(h.side=THREE.BackSide);void 0!==a.doubleSided&&(h.side=THREE.DoubleSide);void 0!==a.wireframe&&(h.wireframe=a.wireframe);void 0!==a.vertexColors&&(\\\"face\\\"===\\na.vertexColors?h.vertexColors=THREE.FaceColors:a.vertexColors&&(h.vertexColors=THREE.VertexColors));a.colorDiffuse?h.color=e(a.colorDiffuse):a.DbgColor&&(h.color=a.DbgColor);a.colorSpecular&&(h.specular=e(a.colorSpecular));a.colorAmbient&&(h.ambient=e(a.colorAmbient));a.colorEmissive&&(h.emissive=e(a.colorEmissive));a.transparency&&(h.opacity=a.transparency);a.specularCoef&&(h.shininess=a.specularCoef);a.mapDiffuse&&b&&d(h,\\\"map\\\",a.mapDiffuse,a.mapDiffuseRepeat,a.mapDiffuseOffset,a.mapDiffuseWrap,\\na.mapDiffuseAnisotropy);a.mapLight&&b&&d(h,\\\"lightMap\\\",a.mapLight,a.mapLightRepeat,a.mapLightOffset,a.mapLightWrap,a.mapLightAnisotropy);a.mapBump&&b&&d(h,\\\"bumpMap\\\",a.mapBump,a.mapBumpRepeat,a.mapBumpOffset,a.mapBumpWrap,a.mapBumpAnisotropy);a.mapNormal&&b&&d(h,\\\"normalMap\\\",a.mapNormal,a.mapNormalRepeat,a.mapNormalOffset,a.mapNormalWrap,a.mapNormalAnisotropy);a.mapSpecular&&b&&d(h,\\\"specularMap\\\",a.mapSpecular,a.mapSpecularRepeat,a.mapSpecularOffset,a.mapSpecularWrap,a.mapSpecularAnisotropy);a.mapAlpha&&\\nb&&d(h,\\\"alphaMap\\\",a.mapAlpha,a.mapAlphaRepeat,a.mapAlphaOffset,a.mapAlphaWrap,a.mapAlphaAnisotropy);a.mapBumpScale&&(h.bumpScale=a.mapBumpScale);a.mapNormal?(g=THREE.ShaderLib.normalmap,k=THREE.UniformsUtils.clone(g.uniforms),k.tNormal.value=h.normalMap,a.mapNormalFactor&&k.uNormalScale.value.set(a.mapNormalFactor,a.mapNormalFactor),h.map&&(k.tDiffuse.value=h.map,k.enableDiffuse.value=!0),h.specularMap&&(k.tSpecular.value=h.specularMap,k.enableSpecular.value=!0),h.lightMap&&(k.tAO.value=h.lightMap,\\nk.enableAO.value=!0),k.diffuse.value.setHex(h.color),k.specular.value.setHex(h.specular),k.ambient.value.setHex(h.ambient),k.shininess.value=h.shininess,void 0!==h.opacity&&(k.opacity.value=h.opacity),g=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:k,lights:!0,fog:!0}),h.transparent&&(g.transparent=!0)):g=new THREE[g](h);void 0!==a.DbgName&&(g.name=a.DbgName);return g}};\\nTHREE.Loader.Handlers={handlers:[],add:function(a,b){this.handlers.push(a,b)},get:function(a){for(var b=0,c=this.handlers.length;b<c;b+=2){var d=this.handlers[b+1];if(this.handlers[b].test(a))return d}return null}};THREE.XHRLoader=function(a){this.cache=new THREE.Cache;this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\\nTHREE.XHRLoader.prototype={constructor:THREE.XHRLoader,load:function(a,b,c,d){var e=this,f=e.cache.get(a);void 0!==f?b&&b(f):TiddlyWiki&&a.match(/^tw:/)?(f=TiddlyWiki.load(a),e.manager.itemStart(a),void 0!==b&&(e.cache.add(a,f),b(f),e.manager.itemEnd(f)),hack.log(\\\"url: \\\"+a+\\\": loaded\\\",hack.loader,\\\"THREE.XHRLoader.load\\\")):(f=new XMLHttpRequest,f.open(\\\"GET\\\",a,!0),f.addEventListener(\\\"load\\\",function(c){e.cache.add(a,this.response);b&&b(this.response);e.manager.itemEnd(a)},!1),void 0!==c&&f.addEventListener(\\\"progress\\\",\\nfunction(a){c(a)},!1),void 0!==d&&f.addEventListener(\\\"error\\\",function(a){d(a)},!1),void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin),void 0!==this.responseType&&(f.responseType=this.responseType),f.send(null),e.manager.itemStart(a))},setResponseType:function(a){this.responseType=a},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.ImageLoader=function(a){this.cache=new THREE.Cache;this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\\nTHREE.ImageLoader.prototype={constructor:THREE.ImageLoader,load:function(a,b,c,d){var e=this,f=e.cache.get(a);if(void 0!==f)b(f);else return f=document.createElement(\\\"img\\\"),TiddlyWiki&&a.match(/^tw:/)&&(hack.log(\\\"url: \\\"+a+(f.crossOrigin?' [crossOrigin=\\\"'+f.crossOrigin+'\\\"]':\\\"\\\")+\\\": to be loaded\\\",hack.loader,\\\"THREE.ImageLoader.load\\\"),a=TiddlyWiki.load(a)),void 0!==b&&f.addEventListener(\\\"load\\\",function(c){e.cache.add(a,this);b(this);e.manager.itemEnd(a)},!1),void 0!==c&&f.addEventListener(\\\"progress\\\",\\nfunction(a){c(a)},!1),void 0!==d&&f.addEventListener(\\\"error\\\",function(a){d(a)},!1),void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin),f.src=a,e.manager.itemStart(a),f},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.JSONLoader=function(a){THREE.Loader.call(this,a);this.withCredentials=!1};THREE.JSONLoader.prototype=Object.create(THREE.Loader.prototype);\\nTHREE.JSONLoader.prototype.load=function(a,b,c){c=c&&\\\"string\\\"===typeof c?c:this.extractUrlBase(a);this.onLoadStart();this.loadAjaxJSON(this,a,b,c)};\\nTHREE.JSONLoader.prototype.loadAjaxJSON=function(a,b,c,d,e){if(TiddlyWiki&&b.match(/^tw:/)){var f=JSON.parse(TiddlyWiki.load(b));void 0!==f.metadata&&\\\"scene\\\"===f.metadata.type?console.error('THREE.JSONLoader: \\\"'+b+'\\\" seems to be a Scene. Use THREE.SceneLoader instead.'):(f=a.parse(f,d),c(f.geometry,f.materials),a.onLoadComplete(),hack.log(\\\"url: \\\"+b+\\\": loaded\\\",hack.loader,\\\"THREE.JSONLoader.loadAjaxJSON\\\"))}else{var g=new XMLHttpRequest,h=0;g.onreadystatechange=function(){if(g.readyState===g.DONE)if(200===\\ng.status||0===g.status){if(g.responseText){var f=JSON.parse(g.responseText);if(void 0!==f.metadata&&\\\"scene\\\"===f.metadata.type){console.error('THREE.JSONLoader: \\\"'+b+'\\\" seems to be a Scene. Use THREE.SceneLoader instead.');return}f=a.parse(f,d);c(f.geometry,f.materials)}else console.error('THREE.JSONLoader: \\\"'+b+'\\\" seems to be unreachable or the file is empty.');a.onLoadComplete()}else console.error(\\\"THREE.JSONLoader: Couldn't load \\\\\\\"\\\"+b+'\\\" ('+g.status+\\\")\\\");else g.readyState===g.LOADING?e&&(0===h&&\\n(h=g.getResponseHeader(\\\"Content-Length\\\")),e({total:h,loaded:g.responseText.length})):g.readyState===g.HEADERS_RECEIVED&&void 0!==e&&(h=g.getResponseHeader(\\\"Content-Length\\\"))};g.open(\\\"GET\\\",b,!0);g.withCredentials=this.withCredentials;g.send(null)}};\\nTHREE.JSONLoader.prototype.parse=function(a,b){var c=new THREE.Geometry,d=void 0!==a.scale?1/a.scale:1;(function(b){var d,g,h,k,l,n,q,r,t,s,p,v,w,u=a.faces;n=a.vertices;var D=a.normals,A=a.colors,x=0;if(void 0!==a.uvs){for(d=0;d<a.uvs.length;d++)a.uvs[d].length&&x++;for(d=0;d<x;d++)c.faceVertexUvs[d]=[]}k=0;for(l=n.length;k<l;)d=new THREE.Vector3,d.x=n[k++]*b,d.y=n[k++]*b,d.z=n[k++]*b,c.vertices.push(d);k=0;for(l=u.length;k<l;)if(b=u[k++],t=b&1,h=b&2,d=b&8,q=b&16,s=b&32,n=b&64,b&=128,t){t=new THREE.Face3;\\nt.a=u[k];t.b=u[k+1];t.c=u[k+3];p=new THREE.Face3;p.a=u[k+1];p.b=u[k+2];p.c=u[k+3];k+=4;h&&(h=u[k++],t.materialIndex=h,p.materialIndex=h);h=c.faces.length;if(d)for(d=0;d<x;d++)for(v=a.uvs[d],c.faceVertexUvs[d][h]=[],c.faceVertexUvs[d][h+1]=[],g=0;4>g;g++)r=u[k++],w=v[2*r],r=v[2*r+1],w=new THREE.Vector2(w,r),2!==g&&c.faceVertexUvs[d][h].push(w),0!==g&&c.faceVertexUvs[d][h+1].push(w);q&&(q=3*u[k++],t.normal.set(D[q++],D[q++],D[q]),p.normal.copy(t.normal));if(s)for(d=0;4>d;d++)q=3*u[k++],s=new THREE.Vector3(D[q++],\\nD[q++],D[q]),2!==d&&t.vertexNormals.push(s),0!==d&&p.vertexNormals.push(s);n&&(n=u[k++],n=A[n],t.color.setHex(n),p.color.setHex(n));if(b)for(d=0;4>d;d++)n=u[k++],n=A[n],2!==d&&t.vertexColors.push(new THREE.Color(n)),0!==d&&p.vertexColors.push(new THREE.Color(n));c.faces.push(t);c.faces.push(p)}else{t=new THREE.Face3;t.a=u[k++];t.b=u[k++];t.c=u[k++];h&&(h=u[k++],t.materialIndex=h);h=c.faces.length;if(d)for(d=0;d<x;d++)for(v=a.uvs[d],c.faceVertexUvs[d][h]=[],g=0;3>g;g++)r=u[k++],w=v[2*r],r=v[2*r+1],\\nw=new THREE.Vector2(w,r),c.faceVertexUvs[d][h].push(w);q&&(q=3*u[k++],t.normal.set(D[q++],D[q++],D[q]));if(s)for(d=0;3>d;d++)q=3*u[k++],s=new THREE.Vector3(D[q++],D[q++],D[q]),t.vertexNormals.push(s);n&&(n=u[k++],t.color.setHex(A[n]));if(b)for(d=0;3>d;d++)n=u[k++],t.vertexColors.push(new THREE.Color(A[n]));c.faces.push(t)}})(d);(function(){var b=void 0!==a.influencesPerVertex?a.influencesPerVertex:2;if(a.skinWeights)for(var d=0,g=a.skinWeights.length;d<g;d+=b)c.skinWeights.push(new THREE.Vector4(a.skinWeights[d],\\n1<b?a.skinWeights[d+1]:0,2<b?a.skinWeights[d+2]:0,3<b?a.skinWeights[d+3]:0));if(a.skinIndices)for(d=0,g=a.skinIndices.length;d<g;d+=b)c.skinIndices.push(new THREE.Vector4(a.skinIndices[d],1<b?a.skinIndices[d+1]:0,2<b?a.skinIndices[d+2]:0,3<b?a.skinIndices[d+3]:0));c.bones=a.bones;c.bones&&0<c.bones.length&&(c.skinWeights.length!==c.skinIndices.length||c.skinIndices.length!==c.vertices.length)&&console.warn(\\\"When skinning, number of vertices (\\\"+c.vertices.length+\\\"), skinIndices (\\\"+c.skinIndices.length+\\n\\\"), and skinWeights (\\\"+c.skinWeights.length+\\\") should match.\\\");c.animation=a.animation;c.animations=a.animations})();(function(b){if(void 0!==a.morphTargets){var d,g,h,k,l,n;d=0;for(g=a.morphTargets.length;d<g;d++)for(c.morphTargets[d]={},c.morphTargets[d].name=a.morphTargets[d].name,c.morphTargets[d].vertices=[],l=c.morphTargets[d].vertices,n=a.morphTargets[d].vertices,h=0,k=n.length;h<k;h+=3){var q=new THREE.Vector3;q.x=n[h]*b;q.y=n[h+1]*b;q.z=n[h+2]*b;l.push(q)}}if(void 0!==a.morphColors)for(d=\\n0,g=a.morphColors.length;d<g;d++)for(c.morphColors[d]={},c.morphColors[d].name=a.morphColors[d].name,c.morphColors[d].colors=[],k=c.morphColors[d].colors,l=a.morphColors[d].colors,b=0,h=l.length;b<h;b+=3)n=new THREE.Color(16755200),n.setRGB(l[b],l[b+1],l[b+2]),k.push(n)})(d);c.computeFaceNormals();c.computeBoundingSphere();if(void 0===a.materials||0===a.materials.length)return{geometry:c};d=this.initMaterials(a.materials,b);this.needsTangents(d)&&c.computeTangents();return{geometry:c,materials:d}};\\nTHREE.LoadingManager=function(a,b,c){var d=this,e=0,f=0;this.onLoad=a;this.onProgress=b;this.onError=c;this.itemStart=function(a){f++};this.itemEnd=function(a){e++;if(void 0!==d.onProgress)d.onProgress(a,e,f);if(e===f&&void 0!==d.onLoad)d.onLoad()}};THREE.DefaultLoadingManager=new THREE.LoadingManager;THREE.BufferGeometryLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\\nTHREE.BufferGeometryLoader.prototype={constructor:THREE.BufferGeometryLoader,load:function(a,b,c,d){var e=this,f=new THREE.XHRLoader;f.setCrossOrigin(this.crossOrigin);f.load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=new THREE.BufferGeometry,c=a.attributes,d;for(d in c){var e=c[d];b.attributes[d]={itemSize:e.itemSize,array:new self[e.type](e.array)}}c=a.offsets;void 0!==c&&(b.offsets=JSON.parse(JSON.stringify(c)));a=a.boundingSphere;\\nvoid 0!==a&&(b.boundingSphere=new THREE.Sphere((new THREE.Vector3).fromArray(void 0!==a.center?a.center:[0,0,0]),a.radius));return b}};THREE.MaterialLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\\nTHREE.MaterialLoader.prototype={constructor:THREE.MaterialLoader,load:function(a,b,c,d){var e=this,f=new THREE.XHRLoader;f.setCrossOrigin(this.crossOrigin);f.load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=new THREE[a.type];void 0!==a.color&&b.color.setHex(a.color);void 0!==a.ambient&&b.ambient.setHex(a.ambient);void 0!==a.emissive&&b.emissive.setHex(a.emissive);void 0!==a.specular&&b.specular.setHex(a.specular);void 0!==a.shininess&&\\n(b.shininess=a.shininess);void 0!==a.uniforms&&(b.uniforms=a.uniforms);void 0!==a.vertexShader&&(b.vertexShader=a.vertexShader);void 0!==a.fragmentShader&&(b.fragmentShader=a.fragmentShader);void 0!==a.vertexColors&&(b.vertexColors=a.vertexColors);void 0!==a.blending&&(b.blending=a.blending);void 0!==a.side&&(b.side=a.side);void 0!==a.opacity&&(b.opacity=a.opacity);void 0!==a.transparent&&(b.transparent=a.transparent);void 0!==a.wireframe&&(b.wireframe=a.wireframe);if(void 0!==a.materials)for(var c=\\n0,d=a.materials.length;c<d;c++)b.materials.push(this.parse(a.materials[c]));return b}};THREE.ObjectLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\\nTHREE.ObjectLoader.prototype={constructor:THREE.ObjectLoader,load:function(a,b,c,d){var e=this,f=new THREE.XHRLoader(e.manager);f.setCrossOrigin(this.crossOrigin);f.load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=this.parseGeometries(a.geometries),c=this.parseMaterials(a.materials);return this.parseObject(a.object,b,c)},parseGeometries:function(a){var b={};if(void 0!==a)for(var c=new THREE.JSONLoader,d=new THREE.BufferGeometryLoader,\\ne=0,f=a.length;e<f;e++){var g,h=a[e];switch(h.type){case \\\"PlaneGeometry\\\":g=new THREE.PlaneGeometry(h.width,h.height,h.widthSegments,h.heightSegments);break;case \\\"BoxGeometry\\\":case \\\"CubeGeometry\\\":g=new THREE.BoxGeometry(h.width,h.height,h.depth,h.widthSegments,h.heightSegments,h.depthSegments);break;case \\\"CircleGeometry\\\":g=new THREE.CircleGeometry(h.radius,h.segments);break;case \\\"CylinderGeometry\\\":g=new THREE.CylinderGeometry(h.radiusTop,h.radiusBottom,h.height,h.radialSegments,h.heightSegments,h.openEnded);\\nbreak;case \\\"SphereGeometry\\\":g=new THREE.SphereGeometry(h.radius,h.widthSegments,h.heightSegments,h.phiStart,h.phiLength,h.thetaStart,h.thetaLength);break;case \\\"IcosahedronGeometry\\\":g=new THREE.IcosahedronGeometry(h.radius,h.detail);break;case \\\"TorusGeometry\\\":g=new THREE.TorusGeometry(h.radius,h.tube,h.radialSegments,h.tubularSegments,h.arc);break;case \\\"TorusKnotGeometry\\\":g=new THREE.TorusKnotGeometry(h.radius,h.tube,h.radialSegments,h.tubularSegments,h.p,h.q,h.heightScale);break;case \\\"BufferGeometry\\\":g=\\nd.parse(h.data);break;case \\\"Geometry\\\":g=c.parse(h.data).geometry}g.uuid=h.uuid;void 0!==h.name&&(g.name=h.name);b[h.uuid]=g}return b},parseMaterials:function(a){var b={};if(void 0!==a)for(var c=new THREE.MaterialLoader,d=0,e=a.length;d<e;d++){var f=a[d],g=c.parse(f);g.uuid=f.uuid;void 0!==f.name&&(g.name=f.name);b[f.uuid]=g}return b},parseObject:function(){var a=new THREE.Matrix4;return function(b,c,d){var e;switch(b.type){case \\\"Scene\\\":e=new THREE.Scene;break;case \\\"PerspectiveCamera\\\":e=new THREE.PerspectiveCamera(b.fov,\\nb.aspect,b.near,b.far);break;case \\\"OrthographicCamera\\\":e=new THREE.OrthographicCamera(b.left,b.right,b.top,b.bottom,b.near,b.far);break;case \\\"AmbientLight\\\":e=new THREE.AmbientLight(b.color);break;case \\\"DirectionalLight\\\":e=new THREE.DirectionalLight(b.color,b.intensity);break;case \\\"PointLight\\\":e=new THREE.PointLight(b.color,b.intensity,b.distance);break;case \\\"SpotLight\\\":e=new THREE.SpotLight(b.color,b.intensity,b.distance,b.angle,b.exponent);break;case \\\"HemisphereLight\\\":e=new THREE.HemisphereLight(b.color,\\nb.groundColor,b.intensity);break;case \\\"Mesh\\\":e=c[b.geometry];var f=d[b.material];void 0===e&&console.error(\\\"THREE.ObjectLoader: Undefined geometry \\\"+b.geometry);void 0===f&&console.error(\\\"THREE.ObjectLoader: Undefined material \\\"+b.material);e=new THREE.Mesh(e,f);break;case \\\"Sprite\\\":f=d[b.material];void 0===f&&console.error(\\\"THREE.ObjectLoader: Undefined material \\\"+b.material);e=new THREE.Sprite(f);break;default:e=new THREE.Object3D}e.uuid=b.uuid;void 0!==b.name&&(e.name=b.name);void 0!==b.matrix?\\n(a.fromArray(b.matrix),a.decompose(e.position,e.quaternion,e.scale)):(void 0!==b.position&&e.position.fromArray(b.position),void 0!==b.rotation&&e.rotation.fromArray(b.rotation),void 0!==b.scale&&e.scale.fromArray(b.scale));void 0!==b.visible&&(e.visible=b.visible);void 0!==b.userData&&(e.userData=b.userData);if(void 0!==b.children)for(var g in b.children)e.add(this.parseObject(b.children[g],c,d));return e}}()};THREE.TextureLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\\nTHREE.TextureLoader.prototype={constructor:THREE.TextureLoader,load:function(a,b,c,d){var e=new THREE.ImageLoader(this.manager);e.setCrossOrigin(this.crossOrigin);e.load(a,function(a){a=new THREE.Texture(a);a.needsUpdate=!0;void 0!==b&&b(a)},c,d)},setCrossOrigin:function(a){this.crossOrigin=a}};\\nTHREE.Material=function(){this.id=THREE.MaterialIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\\\"\\\";this.side=THREE.FrontSide;this.opacity=1;this.transparent=!1;this.blending=THREE.NormalBlending;this.blendSrc=THREE.SrcAlphaFactor;this.blendDst=THREE.OneMinusSrcAlphaFactor;this.blendEquation=THREE.AddEquation;this.depthWrite=this.depthTest=!0;this.polygonOffset=!1;this.overdraw=this.alphaTest=this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.needsUpdate=this.visible=!0};\\nTHREE.Material.prototype={constructor:THREE.Material,setValues:function(a){if(void 0!==a)for(var b in a){var c=a[b];if(void 0===c)console.warn(\\\"THREE.Material: '\\\"+b+\\\"' parameter is undefined.\\\");else if(b in this){var d=this[b];d instanceof THREE.Color?d.set(c):d instanceof THREE.Vector3&&c instanceof THREE.Vector3?d.copy(c):this[b]=\\\"overdraw\\\"==b?Number(c):c}}},clone:function(a){void 0===a&&(a=new THREE.Material);a.name=this.name;a.side=this.side;a.opacity=this.opacity;a.transparent=this.transparent;\\na.blending=this.blending;a.blendSrc=this.blendSrc;a.blendDst=this.blendDst;a.blendEquation=this.blendEquation;a.depthTest=this.depthTest;a.depthWrite=this.depthWrite;a.polygonOffset=this.polygonOffset;a.polygonOffsetFactor=this.polygonOffsetFactor;a.polygonOffsetUnits=this.polygonOffsetUnits;a.alphaTest=this.alphaTest;a.overdraw=this.overdraw;a.visible=this.visible;return a},dispose:function(){this.dispatchEvent({type:\\\"dispose\\\"})}};THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);\\nTHREE.MaterialIdCount=0;THREE.LineBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.linewidth=1;this.linejoin=this.linecap=\\\"round\\\";this.vertexColors=THREE.NoColors;this.fog=!0;this.setValues(a)};THREE.LineBasicMaterial.prototype=Object.create(THREE.Material.prototype);\\nTHREE.LineBasicMaterial.prototype.clone=function(){var a=new THREE.LineBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.linecap=this.linecap;a.linejoin=this.linejoin;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.LineDashedMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.scale=this.linewidth=1;this.dashSize=3;this.gapSize=1;this.vertexColors=!1;this.fog=!0;this.setValues(a)};\\nTHREE.LineDashedMaterial.prototype=Object.create(THREE.Material.prototype);THREE.LineDashedMaterial.prototype.clone=function(){var a=new THREE.LineDashedMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.scale=this.scale;a.dashSize=this.dashSize;a.gapSize=this.gapSize;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};\\nTHREE.MeshBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.envMap=this.alphaMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\\\"round\\\";this.vertexColors=THREE.NoColors;this.morphTargets=this.skinning=!1;this.setValues(a)};\\nTHREE.MeshBasicMaterial.prototype=Object.create(THREE.Material.prototype);\\nTHREE.MeshBasicMaterial.prototype.clone=function(){var a=new THREE.MeshBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.alphaMap=this.alphaMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;\\na.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;return a};\\nTHREE.MeshLambertMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.wrapAround=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.envMap=this.alphaMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\\n\\\"round\\\";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshLambertMaterial.prototype=Object.create(THREE.Material.prototype);\\nTHREE.MeshLambertMaterial.prototype.clone=function(){var a=new THREE.MeshLambertMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.alphaMap=this.alphaMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;\\na.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};\\nTHREE.MeshPhongMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.specular=new THREE.Color(1118481);this.shininess=30;this.wrapAround=this.metal=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.bumpMap=this.lightMap=this.map=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new THREE.Vector2(1,1);this.envMap=this.alphaMap=this.specularMap=null;this.combine=THREE.MultiplyOperation;this.reflectivity=\\n1;this.refractionRatio=.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\\\"round\\\";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshPhongMaterial.prototype=Object.create(THREE.Material.prototype);\\nTHREE.MeshPhongMaterial.prototype.clone=function(){var a=new THREE.MeshPhongMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.specular.copy(this.specular);a.shininess=this.shininess;a.metal=this.metal;a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.bumpMap=this.bumpMap;a.bumpScale=this.bumpScale;a.normalMap=this.normalMap;a.normalScale.copy(this.normalScale);\\na.specularMap=this.specularMap;a.alphaMap=this.alphaMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};\\nTHREE.MeshDepthMaterial=function(a){THREE.Material.call(this);this.wireframe=this.morphTargets=!1;this.wireframeLinewidth=1;this.setValues(a)};THREE.MeshDepthMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshDepthMaterial.prototype.clone=function(){var a=new THREE.MeshDepthMaterial;THREE.Material.prototype.clone.call(this,a);a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};\\nTHREE.MeshNormalMaterial=function(a){THREE.Material.call(this,a);this.shading=THREE.FlatShading;this.wireframe=!1;this.wireframeLinewidth=1;this.morphTargets=!1;this.setValues(a)};THREE.MeshNormalMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshNormalMaterial.prototype.clone=function(){var a=new THREE.MeshNormalMaterial;THREE.Material.prototype.clone.call(this,a);a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};\\nTHREE.MeshFaceMaterial=function(a){this.materials=a instanceof Array?a:[]};THREE.MeshFaceMaterial.prototype.clone=function(){for(var a=new THREE.MeshFaceMaterial,b=0;b<this.materials.length;b++)a.materials.push(this.materials[b].clone());return a};THREE.PointCloudMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=null;this.size=1;this.sizeAttenuation=!0;this.vertexColors=THREE.NoColors;this.fog=!0;this.setValues(a)};THREE.PointCloudMaterial.prototype=Object.create(THREE.Material.prototype);\\nTHREE.PointCloudMaterial.prototype.clone=function(){var a=new THREE.PointCloudMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.size=this.size;a.sizeAttenuation=this.sizeAttenuation;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.ParticleBasicMaterial=function(a){console.warn(\\\"THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.\\\");return new THREE.PointCloudMaterial(a)};\\nTHREE.ParticleSystemMaterial=function(a){console.warn(\\\"THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.\\\");return new THREE.PointCloudMaterial(a)};\\nTHREE.ShaderMaterial=function(a){THREE.Material.call(this);this.defines={};this.uniforms={};this.attributes=null;this.vertexShader=\\\"void main() {\\\\n\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n}\\\";this.fragmentShader=\\\"void main() {\\\\n\\\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\\\n}\\\";this.shading=THREE.SmoothShading;this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=\\n!1;this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName=void 0;this.setValues(a)};THREE.ShaderMaterial.prototype=Object.create(THREE.Material.prototype);\\nTHREE.ShaderMaterial.prototype.clone=function(){var a=new THREE.ShaderMaterial;THREE.Material.prototype.clone.call(this,a);a.fragmentShader=this.fragmentShader;a.vertexShader=this.vertexShader;a.uniforms=THREE.UniformsUtils.clone(this.uniforms);a.attributes=this.attributes;a.defines=this.defines;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.fog=this.fog;a.lights=this.lights;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=\\nthis.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.RawShaderMaterial=function(a){THREE.ShaderMaterial.call(this,a)};THREE.RawShaderMaterial.prototype=Object.create(THREE.ShaderMaterial.prototype);THREE.RawShaderMaterial.prototype.clone=function(){var a=new THREE.RawShaderMaterial;THREE.ShaderMaterial.prototype.clone.call(this,a);return a};THREE.SpriteMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=null;this.rotation=0;this.fog=!1;this.setValues(a)};\\nTHREE.SpriteMaterial.prototype=Object.create(THREE.Material.prototype);THREE.SpriteMaterial.prototype.clone=function(){var a=new THREE.SpriteMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.rotation=this.rotation;a.fog=this.fog;return a};THREE.SpriteCanvasMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.program=function(a,c){};this.setValues(a)};THREE.SpriteCanvasMaterial.prototype=Object.create(THREE.Material.prototype);\\nTHREE.SpriteCanvasMaterial.prototype.clone=function(){var a=new THREE.SpriteCanvasMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.program=this.program;return a};THREE.ParticleCanvasMaterial=THREE.SpriteCanvasMaterial;\\nTHREE.Texture=function(a,b,c,d,e,f,g,h,k){this.id=THREE.TextureIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\\\"\\\";this.image=void 0!==a?a:THREE.Texture.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=void 0!==b?b:THREE.Texture.DEFAULT_MAPPING;this.wrapS=void 0!==c?c:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==d?d:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==e?e:THREE.LinearFilter;this.minFilter=void 0!==f?f:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==k?k:1;this.format=void 0!==\\ng?g:THREE.RGBAFormat;this.type=void 0!==h?h:THREE.UnsignedByteType;this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this._needsUpdate=!1;this.onUpdate=null};THREE.Texture.DEFAULT_IMAGE=void 0;THREE.Texture.DEFAULT_MAPPING=new THREE.UVMapping;\\nTHREE.Texture.prototype={constructor:THREE.Texture,get needsUpdate(){return this._needsUpdate},set needsUpdate(a){!0===a&&this.update();this._needsUpdate=a},clone:function(a){void 0===a&&(a=new THREE.Texture);a.image=this.image;a.mipmaps=this.mipmaps.slice(0);a.mapping=this.mapping;a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.format=this.format;a.type=this.type;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.generateMipmaps=\\nthis.generateMipmaps;a.premultiplyAlpha=this.premultiplyAlpha;a.flipY=this.flipY;a.unpackAlignment=this.unpackAlignment;return a},update:function(){this.dispatchEvent({type:\\\"update\\\"})},dispose:function(){this.dispatchEvent({type:\\\"dispose\\\"})}};THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);THREE.TextureIdCount=0;THREE.CubeTexture=function(a,b,c,d,e,f,g,h,k){THREE.Texture.call(this,a,b,c,d,e,f,g,h,k);this.images=a};THREE.CubeTexture.prototype=Object.create(THREE.Texture.prototype);\\nTHREE.CubeTexture.clone=function(a){void 0===a&&(a=new THREE.CubeTexture);THREE.Texture.prototype.clone.call(this,a);a.images=this.images;return a};THREE.CompressedTexture=function(a,b,c,d,e,f,g,h,k,l,n){THREE.Texture.call(this,null,f,g,h,k,l,d,e,n);this.image={width:b,height:c};this.mipmaps=a;this.generateMipmaps=!1};THREE.CompressedTexture.prototype=Object.create(THREE.Texture.prototype);\\nTHREE.CompressedTexture.prototype.clone=function(){var a=new THREE.CompressedTexture;THREE.Texture.prototype.clone.call(this,a);return a};THREE.DataTexture=function(a,b,c,d,e,f,g,h,k,l,n){THREE.Texture.call(this,null,f,g,h,k,l,d,e,n);this.image={data:a,width:b,height:c}};THREE.DataTexture.prototype=Object.create(THREE.Texture.prototype);THREE.DataTexture.prototype.clone=function(){var a=new THREE.DataTexture;THREE.Texture.prototype.clone.call(this,a);return a};\\nTHREE.PointCloud=function(a,b){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.PointCloudMaterial({color:16777215*Math.random()});this.sortParticles=!1};THREE.PointCloud.prototype=Object.create(THREE.Object3D.prototype);\\nTHREE.PointCloud.prototype.raycast=function(){var a=new THREE.Matrix4,b=new THREE.Ray;return function(c,d){var e=this,f=e.geometry,g=c.params.PointCloud.threshold;a.getInverse(this.matrixWorld);b.copy(c.ray).applyMatrix4(a);if(null===f.boundingBox||!1!==b.isIntersectionBox(f.boundingBox)){var h=g/((this.scale.x+this.scale.y+this.scale.z)/3),k=new THREE.Vector3,g=function(a,f){var g=b.distanceToPoint(a);if(g<h){var k=b.closestPointToPoint(a);k.applyMatrix4(e.matrixWorld);var l=c.ray.origin.distanceTo(k);\\nd.push({distance:l,distanceToRay:g,point:k.clone(),index:f,face:null,object:e})}};if(f instanceof THREE.BufferGeometry){var l=f.attributes,n=l.position.array;if(void 0!==l.index){var l=l.index.array,q=f.offsets;0===q.length&&(q=[{start:0,count:l.length,index:0}]);for(var r=0,t=q.length;r<t;++r)for(var s=q[r].start,p=q[r].index,f=s,s=s+q[r].count;f<s;f++){var v=p+l[f];k.set(n[3*v],n[3*v+1],n[3*v+2]);g(k,v)}}else for(l=n.length/3,f=0;f<l;f++)k.set(n[3*f],n[3*f+1],n[3*f+2]),g(k,f)}else for(k=this.geometry.vertices,\\nf=0;f<k.length;f++)g(k[f],f)}}}();THREE.PointCloud.prototype.clone=function(a){void 0===a&&(a=new THREE.PointCloud(this.geometry,this.material));a.sortParticles=this.sortParticles;THREE.Object3D.prototype.clone.call(this,a);return a};THREE.ParticleSystem=function(a,b){console.warn(\\\"THREE.ParticleSystem has been renamed to THREE.PointCloud.\\\");return new THREE.PointCloud(a,b)};\\nTHREE.Line=function(a,b,c){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.LineBasicMaterial({color:16777215*Math.random()});this.type=void 0!==c?c:THREE.LineStrip};THREE.LineStrip=0;THREE.LinePieces=1;THREE.Line.prototype=Object.create(THREE.Object3D.prototype);\\nTHREE.Line.prototype.raycast=function(){var a=new THREE.Matrix4,b=new THREE.Ray,c=new THREE.Sphere;return function(d,e){var f=d.linePrecision,f=f*f,g=this.geometry;null===g.boundingSphere&&g.computeBoundingSphere();c.copy(g.boundingSphere);c.applyMatrix4(this.matrixWorld);if(!1!==d.ray.isIntersectionSphere(c)&&(a.getInverse(this.matrixWorld),b.copy(d.ray).applyMatrix4(a),g instanceof THREE.Geometry))for(var g=g.vertices,h=g.length,k=new THREE.Vector3,l=new THREE.Vector3,n=this.type===THREE.LineStrip?\\n1:2,q=0;q<h-1;q+=n)if(!(b.distanceSqToSegment(g[q],g[q+1],l,k)>f)){var r=b.origin.distanceTo(l);r<d.near||r>d.far||e.push({distance:r,point:k.clone().applyMatrix4(this.matrixWorld),face:null,faceIndex:null,object:this})}}}();THREE.Line.prototype.clone=function(a){void 0===a&&(a=new THREE.Line(this.geometry,this.material,this.type));THREE.Object3D.prototype.clone.call(this,a);return a};\\nTHREE.Mesh=function(a,b){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.MeshBasicMaterial({color:16777215*Math.random()});this.updateMorphTargets()};THREE.Mesh.prototype=Object.create(THREE.Object3D.prototype);\\nTHREE.Mesh.prototype.updateMorphTargets=function(){if(void 0!==this.geometry.morphTargets&&0<this.geometry.morphTargets.length){this.morphTargetBase=-1;this.morphTargetForcedOrder=[];this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var a=0,b=this.geometry.morphTargets.length;a<b;a++)this.morphTargetInfluences.push(0),this.morphTargetDictionary[this.geometry.morphTargets[a].name]=a}};\\nTHREE.Mesh.prototype.getMorphTargetIndexByName=function(a){if(void 0!==this.morphTargetDictionary[a])return this.morphTargetDictionary[a];console.log(\\\"THREE.Mesh.getMorphTargetIndexByName: morph target \\\"+a+\\\" does not exist. Returning 0.\\\");return 0};\\nTHREE.Mesh.prototype.raycast=function(){var a=new THREE.Matrix4,b=new THREE.Ray,c=new THREE.Sphere,d=new THREE.Vector3,e=new THREE.Vector3,f=new THREE.Vector3;return function(g,h){var k=this.geometry;null===k.boundingSphere&&k.computeBoundingSphere();c.copy(k.boundingSphere);c.applyMatrix4(this.matrixWorld);if(!1!==g.ray.isIntersectionSphere(c)&&(a.getInverse(this.matrixWorld),b.copy(g.ray).applyMatrix4(a),null===k.boundingBox||!1!==b.isIntersectionBox(k.boundingBox)))if(k instanceof THREE.BufferGeometry){var l=\\nthis.material;if(void 0!==l){var n=k.attributes,q,r,t=g.precision;if(void 0!==n.index){var s=n.index.array,p=n.position.array,v=k.offsets;0===v.length&&(v=[{start:0,count:s.length,index:0}]);for(var w=0,u=v.length;w<u;++w)for(var n=v[w].start,D=v[w].index,k=n,A=n+v[w].count;k<A;k+=3){n=D+s[k];q=D+s[k+1];r=D+s[k+2];d.set(p[3*n],p[3*n+1],p[3*n+2]);e.set(p[3*q],p[3*q+1],p[3*q+2]);f.set(p[3*r],p[3*r+1],p[3*r+2]);var x=l.side===THREE.BackSide?b.intersectTriangle(f,e,d,!0):b.intersectTriangle(d,e,f,l.side!==\\nTHREE.DoubleSide);if(null!==x){x.applyMatrix4(this.matrixWorld);var C=g.ray.origin.distanceTo(x);C<t||C<g.near||C>g.far||h.push({distance:C,point:x,indices:[n,q,r],face:null,faceIndex:null,object:this})}}}else for(p=n.position.array,s=k=0,A=p.length;k<A;k+=3,s+=9)n=k,q=k+1,r=k+2,d.set(p[s],p[s+1],p[s+2]),e.set(p[s+3],p[s+4],p[s+5]),f.set(p[s+6],p[s+7],p[s+8]),x=l.side===THREE.BackSide?b.intersectTriangle(f,e,d,!0):b.intersectTriangle(d,e,f,l.side!==THREE.DoubleSide),null!==x&&(x.applyMatrix4(this.matrixWorld),\\nC=g.ray.origin.distanceTo(x),C<t||C<g.near||C>g.far||h.push({distance:C,point:x,indices:[n,q,r],face:null,faceIndex:null,object:this}))}}else if(k instanceof THREE.Geometry)for(s=this.material instanceof THREE.MeshFaceMaterial,p=!0===s?this.material.materials:null,t=g.precision,v=k.vertices,w=0,u=k.faces.length;w<u;w++)if(D=k.faces[w],l=!0===s?p[D.materialIndex]:this.material,void 0!==l){n=v[D.a];q=v[D.b];r=v[D.c];if(!0===l.morphTargets){x=k.morphTargets;C=this.morphTargetInfluences;d.set(0,0,0);\\ne.set(0,0,0);f.set(0,0,0);for(var A=0,I=x.length;A<I;A++){var z=C[A];if(0!==z){var y=x[A].vertices;d.x+=(y[D.a].x-n.x)*z;d.y+=(y[D.a].y-n.y)*z;d.z+=(y[D.a].z-n.z)*z;e.x+=(y[D.b].x-q.x)*z;e.y+=(y[D.b].y-q.y)*z;e.z+=(y[D.b].z-q.z)*z;f.x+=(y[D.c].x-r.x)*z;f.y+=(y[D.c].y-r.y)*z;f.z+=(y[D.c].z-r.z)*z}}d.add(n);e.add(q);f.add(r);n=d;q=e;r=f}x=l.side===THREE.BackSide?b.intersectTriangle(r,q,n,!0):b.intersectTriangle(n,q,r,l.side!==THREE.DoubleSide);null!==x&&(x.applyMatrix4(this.matrixWorld),C=g.ray.origin.distanceTo(x),\\nC<t||C<g.near||C>g.far||h.push({distance:C,point:x,face:D,faceIndex:w,object:this}))}}}();THREE.Mesh.prototype.clone=function(a,b){void 0===a&&(a=new THREE.Mesh(this.geometry,this.material));THREE.Object3D.prototype.clone.call(this,a,b);return a};THREE.Bone=function(a){THREE.Object3D.call(this);this.skin=a;this.accumulatedSclWeight=this.accumulatedPosWeight=this.accumulatedRotWeight=0};THREE.Bone.prototype=Object.create(THREE.Object3D.prototype);\\nTHREE.Bone.prototype.updateMatrixWorld=function(a){THREE.Object3D.prototype.updateMatrixWorld.call(this,a);this.accumulatedSclWeight=this.accumulatedPosWeight=this.accumulatedRotWeight=0};\\nTHREE.Skeleton=function(a,b,c){this.useVertexTexture=void 0!==c?c:!0;this.identityMatrix=new THREE.Matrix4;a=a||[];this.bones=a.slice(0);this.useVertexTexture?(this.boneTextureHeight=this.boneTextureWidth=a=256<this.bones.length?64:64<this.bones.length?32:16<this.bones.length?16:8,this.boneMatrices=new Float32Array(this.boneTextureWidth*this.boneTextureHeight*4),this.boneTexture=new THREE.DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,THREE.RGBAFormat,THREE.FloatType),\\nthis.boneTexture.minFilter=THREE.NearestFilter,this.boneTexture.magFilter=THREE.NearestFilter,this.boneTexture.generateMipmaps=!1,this.boneTexture.flipY=!1):this.boneMatrices=new Float32Array(16*this.bones.length);if(void 0===b)this.calculateInverses();else if(this.bones.length===b.length)this.boneInverses=b.slice(0);else for(console.warn(\\\"THREE.Skeleton bonInverses is the wrong length.\\\"),this.boneInverses=[],b=0,a=this.bones.length;b<a;b++)this.boneInverses.push(new THREE.Matrix4)};\\nTHREE.Skeleton.prototype.calculateInverses=function(){this.boneInverses=[];for(var a=0,b=this.bones.length;a<b;a++){var c=new THREE.Matrix4;this.bones[a]&&c.getInverse(this.bones[a].matrixWorld);this.boneInverses.push(c)}};\\nTHREE.Skeleton.prototype.pose=function(){for(var a,b=0,c=this.bones.length;b<c;b++)(a=this.bones[b])&&a.matrixWorld.getInverse(this.boneInverses[b]);b=0;for(c=this.bones.length;b<c;b++)if(a=this.bones[b])a.parent?(a.matrix.getInverse(a.parent.matrixWorld),a.matrix.multiply(a.matrixWorld)):a.matrix.copy(a.matrixWorld),a.matrix.decompose(a.position,a.quaternion,a.scale)};\\nTHREE.Skeleton.prototype.update=function(){for(var a=new THREE.Matrix4,b=0,c=this.bones.length;b<c;b++)a.multiplyMatrices(this.bones[b]?this.bones[b].matrixWorld:this.identityMatrix,this.boneInverses[b]),a.flattenToArrayOffset(this.boneMatrices,16*b);this.useVertexTexture&&(this.boneTexture.needsUpdate=!0)};\\nTHREE.SkinnedMesh=function(a,b,c){THREE.Mesh.call(this,a,b);this.bindMode=\\\"attached\\\";this.bindMatrix=new THREE.Matrix4;this.bindMatrixInverse=new THREE.Matrix4;a=[];if(this.geometry&&void 0!==this.geometry.bones){for(var d,e,f,g,h=0,k=this.geometry.bones.length;h<k;++h)d=this.geometry.bones[h],e=d.pos,f=d.rotq,g=d.scl,b=new THREE.Bone(this),a.push(b),b.name=d.name,b.position.set(e[0],e[1],e[2]),b.quaternion.set(f[0],f[1],f[2],f[3]),void 0!==g?b.scale.set(g[0],g[1],g[2]):b.scale.set(1,1,1);h=0;for(k=\\nthis.geometry.bones.length;h<k;++h)d=this.geometry.bones[h],-1!==d.parent?a[d.parent].add(a[h]):this.add(a[h])}this.normalizeSkinWeights();this.updateMatrixWorld(!0);this.bind(new THREE.Skeleton(a,void 0,c))};THREE.SkinnedMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.SkinnedMesh.prototype.bind=function(a,b){this.skeleton=a;void 0===b&&(this.updateMatrixWorld(!0),b=this.matrixWorld);this.bindMatrix.copy(b);this.bindMatrixInverse.getInverse(b)};THREE.SkinnedMesh.prototype.pose=function(){this.skeleton.pose()};\\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights=function(){if(this.geometry instanceof THREE.Geometry)for(var a=0;a<this.geometry.skinIndices.length;a++){var b=this.geometry.skinWeights[a],c=1/b.lengthManhattan();Infinity!==c?b.multiplyScalar(c):b.set(1)}};\\nTHREE.SkinnedMesh.prototype.updateMatrixWorld=function(a){THREE.Mesh.prototype.updateMatrixWorld.call(this,!0);\\\"attached\\\"===this.bindMode?this.bindMatrixInverse.getInverse(this.matrixWorld):\\\"detached\\\"===this.bindMode?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn(\\\"THREE.SkinnedMesh unreckognized bindMode: \\\"+this.bindMode)};\\nTHREE.SkinnedMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.SkinnedMesh(this.geometry,this.material,this.useVertexTexture));THREE.Mesh.prototype.clone.call(this,a);return a};THREE.MorphAnimMesh=function(a,b){THREE.Mesh.call(this,a,b);this.duration=1E3;this.mirroredLoop=!1;this.currentKeyframe=this.lastKeyframe=this.time=0;this.direction=1;this.directionBackwards=!1;this.setFrameRange(0,this.geometry.morphTargets.length-1)};THREE.MorphAnimMesh.prototype=Object.create(THREE.Mesh.prototype);\\nTHREE.MorphAnimMesh.prototype.setFrameRange=function(a,b){this.startKeyframe=a;this.endKeyframe=b;this.length=this.endKeyframe-this.startKeyframe+1};THREE.MorphAnimMesh.prototype.setDirectionForward=function(){this.direction=1;this.directionBackwards=!1};THREE.MorphAnimMesh.prototype.setDirectionBackward=function(){this.direction=-1;this.directionBackwards=!0};\\nTHREE.MorphAnimMesh.prototype.parseAnimations=function(){var a=this.geometry;a.animations||(a.animations={});for(var b,c=a.animations,d=/([a-z]+)_?(\\\\d+)/,e=0,f=a.morphTargets.length;e<f;e++){var g=a.morphTargets[e].name.match(d);if(g&&1<g.length){g=g[1];c[g]||(c[g]={start:Infinity,end:-Infinity});var h=c[g];e<h.start&&(h.start=e);e>h.end&&(h.end=e);b||(b=g)}}a.firstAnimation=b};\\nTHREE.MorphAnimMesh.prototype.setAnimationLabel=function(a,b,c){this.geometry.animations||(this.geometry.animations={});this.geometry.animations[a]={start:b,end:c}};THREE.MorphAnimMesh.prototype.playAnimation=function(a,b){var c=this.geometry.animations[a];c?(this.setFrameRange(c.start,c.end),this.duration=(c.end-c.start)/b*1E3,this.time=0):console.warn(\\\"animation[\\\"+a+\\\"] undefined\\\")};\\nTHREE.MorphAnimMesh.prototype.updateAnimation=function(a){var b=this.duration/this.length;this.time+=this.direction*a;if(this.mirroredLoop){if(this.time>this.duration||0>this.time)this.direction*=-1,this.time>this.duration&&(this.time=this.duration,this.directionBackwards=!0),0>this.time&&(this.time=0,this.directionBackwards=!1)}else this.time%=this.duration,0>this.time&&(this.time+=this.duration);a=this.startKeyframe+THREE.Math.clamp(Math.floor(this.time/b),0,this.length-1);a!==this.currentKeyframe&&\\n(this.morphTargetInfluences[this.lastKeyframe]=0,this.morphTargetInfluences[this.currentKeyframe]=1,this.morphTargetInfluences[a]=0,this.lastKeyframe=this.currentKeyframe,this.currentKeyframe=a);b=this.time%b/b;this.directionBackwards&&(b=1-b);this.morphTargetInfluences[this.currentKeyframe]=b;this.morphTargetInfluences[this.lastKeyframe]=1-b};\\nTHREE.MorphAnimMesh.prototype.interpolateTargets=function(a,b,c){for(var d=this.morphTargetInfluences,e=0,f=d.length;e<f;e++)d[e]=0;-1<a&&(d[a]=1-c);-1<b&&(d[b]=c)};\\nTHREE.MorphAnimMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.MorphAnimMesh(this.geometry,this.material));a.duration=this.duration;a.mirroredLoop=this.mirroredLoop;a.time=this.time;a.lastKeyframe=this.lastKeyframe;a.currentKeyframe=this.currentKeyframe;a.direction=this.direction;a.directionBackwards=this.directionBackwards;THREE.Mesh.prototype.clone.call(this,a);return a};THREE.LOD=function(){THREE.Object3D.call(this);this.objects=[]};THREE.LOD.prototype=Object.create(THREE.Object3D.prototype);\\nTHREE.LOD.prototype.addLevel=function(a,b){void 0===b&&(b=0);b=Math.abs(b);for(var c=0;c<this.objects.length&&!(b<this.objects[c].distance);c++);this.objects.splice(c,0,{distance:b,object:a});this.add(a)};THREE.LOD.prototype.getObjectForDistance=function(a){for(var b=1,c=this.objects.length;b<c&&!(a<this.objects[b].distance);b++);return this.objects[b-1].object};\\nTHREE.LOD.prototype.raycast=function(){var a=new THREE.Vector3;return function(b,c){a.setFromMatrixPosition(this.matrixWorld);var d=b.ray.origin.distanceTo(a);this.getObjectForDistance(d).raycast(b,c)}}();\\nTHREE.LOD.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){if(1<this.objects.length){a.setFromMatrixPosition(c.matrixWorld);b.setFromMatrixPosition(this.matrixWorld);c=a.distanceTo(b);this.objects[0].object.visible=!0;for(var d=1,e=this.objects.length;d<e;d++)if(c>=this.objects[d].distance)this.objects[d-1].object.visible=!1,this.objects[d].object.visible=!0;else break;for(;d<e;d++)this.objects[d].object.visible=!1}}}();\\nTHREE.LOD.prototype.clone=function(a){void 0===a&&(a=new THREE.LOD);THREE.Object3D.prototype.clone.call(this,a);for(var b=0,c=this.objects.length;b<c;b++){var d=this.objects[b].object.clone();d.visible=0===b;a.addLevel(d,this.objects[b].distance)}return a};\\nTHREE.Sprite=function(){var a=new Float32Array([-.5,-.5,0,.5,-.5,0,.5,.5,0]),b=new THREE.BufferGeometry;b.addAttribute(\\\"position\\\",new THREE.BufferAttribute(a,3));return function(a){THREE.Object3D.call(this);this.geometry=b;this.material=void 0!==a?a:new THREE.SpriteMaterial}}();THREE.Sprite.prototype=Object.create(THREE.Object3D.prototype);\\nTHREE.Sprite.prototype.raycast=function(){var a=new THREE.Vector3;return function(b,c){a.setFromMatrixPosition(this.matrixWorld);var d=b.ray.distanceToPoint(a);d>this.scale.x||c.push({distance:d,point:this.position,face:null,object:this})}}();THREE.Sprite.prototype.updateMatrix=function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0};\\nTHREE.Sprite.prototype.clone=function(a){void 0===a&&(a=new THREE.Sprite(this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Particle=THREE.Sprite;THREE.Scene=function(){THREE.Object3D.call(this);this.overrideMaterial=this.fog=null;this.autoUpdate=!0;this.matrixAutoUpdate=!1;this.__lights=[];this.__objectsAdded=[];this.__objectsRemoved=[]};THREE.Scene.prototype=Object.create(THREE.Object3D.prototype);\\nTHREE.Scene.prototype.__addObject=function(a){if(a instanceof THREE.Light)-1===this.__lights.indexOf(a)&&this.__lights.push(a),a.target&&void 0===a.target.parent&&this.add(a.target);else if(!(a instanceof THREE.Camera||a instanceof THREE.Bone)){this.__objectsAdded.push(a);var b=this.__objectsRemoved.indexOf(a);-1!==b&&this.__objectsRemoved.splice(b,1)}this.dispatchEvent({type:\\\"objectAdded\\\",object:a});a.dispatchEvent({type:\\\"addedToScene\\\",scene:this});for(b=0;b<a.children.length;b++)this.__addObject(a.children[b])};\\nTHREE.Scene.prototype.__removeObject=function(a){if(a instanceof THREE.Light){var b=this.__lights.indexOf(a);-1!==b&&this.__lights.splice(b,1);if(a.shadowCascadeArray)for(b=0;b<a.shadowCascadeArray.length;b++)this.__removeObject(a.shadowCascadeArray[b])}else a instanceof THREE.Camera||(this.__objectsRemoved.push(a),b=this.__objectsAdded.indexOf(a),-1!==b&&this.__objectsAdded.splice(b,1));this.dispatchEvent({type:\\\"objectRemoved\\\",object:a});a.dispatchEvent({type:\\\"removedFromScene\\\",scene:this});for(b=\\n0;b<a.children.length;b++)this.__removeObject(a.children[b])};THREE.Scene.prototype.clone=function(a){void 0===a&&(a=new THREE.Scene);THREE.Object3D.prototype.clone.call(this,a);null!==this.fog&&(a.fog=this.fog.clone());null!==this.overrideMaterial&&(a.overrideMaterial=this.overrideMaterial.clone());a.autoUpdate=this.autoUpdate;a.matrixAutoUpdate=this.matrixAutoUpdate;return a};THREE.Fog=function(a,b,c){this.name=\\\"\\\";this.color=new THREE.Color(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3};\\nTHREE.Fog.prototype.clone=function(){return new THREE.Fog(this.color.getHex(),this.near,this.far)};THREE.FogExp2=function(a,b){this.name=\\\"\\\";this.color=new THREE.Color(a);this.density=void 0!==b?b:2.5E-4};THREE.FogExp2.prototype.clone=function(){return new THREE.FogExp2(this.color.getHex(),this.density)};\\nTHREE.CanvasRenderer=function(a){function b(a,b,c,d){l(b);n(c);q(d);r(a.getStyle());O.stroke();ra.expandByScalar(2*b)}function c(a){t(a.getStyle());O.fill()}function d(a){e(a.target)}function e(a){if(!(a instanceof THREE.CompressedTexture)){var b=a.wrapS===THREE.RepeatWrapping,c=a.wrapT===THREE.RepeatWrapping,d=a.image,e=document.createElement(\\\"canvas\\\");e.width=d.width;e.height=d.height;var f=e.getContext(\\\"2d\\\");f.setTransform(1,0,0,-1,0,d.height);f.drawImage(d,0,0);Ca[a.id]=O.createPattern(e,!0===\\nb&&!0===c?\\\"repeat\\\":!0===b&&!1===c?\\\"repeat-x\\\":!1===b&&!0===c?\\\"repeat-y\\\":\\\"no-repeat\\\")}}function f(a,b,c,f,g,h,k,l,n,r,q,s,p){if(!(p instanceof THREE.DataTexture)){!1===p.hasEventListener(\\\"update\\\",d)&&(void 0!==p.image&&0<p.image.width&&e(p),p.addEventListener(\\\"update\\\",d));var m=Ca[p.id];if(void 0!==m){t(m);var m=p.offset.x/p.repeat.x,w=p.offset.y/p.repeat.y,u=p.image.width*p.repeat.x;p=p.image.height*p.repeat.y;k=(k+m)*u;l=(l+w)*p;c-=a;f-=b;g-=a;h-=b;n=(n+m)*u-k;r=(r+w)*p-l;q=(q+m)*u-k;s=(s+w)*p-l;\\np=n*s-q*r;0!==p&&(m=1/p,p=(s*c-r*g)*m,r=(s*f-r*h)*m,c=(n*g-q*c)*m,f=(n*h-q*f)*m,a=a-p*k-c*l,b=b-r*k-f*l,O.save(),O.transform(p,r,c,f,a,b),O.fill(),O.restore())}else t(\\\"rgba(0,0,0,1)\\\"),O.fill()}}function g(a,b,c){var d=b.x-a.x,e=b.y-a.y,f=d*d+e*e;0!==f&&(c/=Math.sqrt(f),d*=c,e*=c,b.x+=d,b.y+=e,a.x-=d,a.y-=e)}function h(a){Q!==a&&(Q=O.globalAlpha=a)}function k(a){L!==a&&(a===THREE.NormalBlending?O.globalCompositeOperation=\\\"source-over\\\":a===THREE.AdditiveBlending?O.globalCompositeOperation=\\\"lighter\\\":\\na===THREE.SubtractiveBlending&&(O.globalCompositeOperation=\\\"darker\\\"),L=a)}function l(a){S!==a&&(S=O.lineWidth=a)}function n(a){V!==a&&(V=O.lineCap=a)}function q(a){W!==a&&(W=O.lineJoin=a)}function r(a){R!==a&&(R=O.strokeStyle=a)}function t(a){B!==a&&(B=O.fillStyle=a)}function s(a){H.length!==a.length&&(O.setLineDash(a),H=a)}console.log(\\\"THREE.CanvasRenderer\\\",THREE.REVISION);var p=THREE.Math.smoothstep;a=a||{};var v=this,w,u,D,A=new THREE.Projector,x=void 0!==a.canvas?a.canvas:document.createElement(\\\"canvas\\\"),\\nC=x.width,I=x.height,z=Math.floor(C/2),y=Math.floor(I/2),K=0,N=0,ba=C,P=I,O=x.getContext(\\\"2d\\\",{alpha:!0===a.alpha}),J=new THREE.Color(0),E=0,Q=1,L=0,R=null,B=null,S=null,V=null,W=null,H=[],oa,$,X,T;new THREE.RenderableVertex;new THREE.RenderableVertex;var ya,Ea,Aa,za,Oa,Pa,G=new THREE.Color;new THREE.Color;new THREE.Color;new THREE.Color;new THREE.Color;var Ba=new THREE.Color,Ya=new THREE.Color,Za=new THREE.Color,Ca={},ca,la,qa,ua,ja,Fa,va,Ka=new THREE.Box2,aa=new THREE.Box2,ra=new THREE.Box2,Da=\\nnew THREE.Color,Qa=new THREE.Color,cb=new THREE.Color,Ga=new THREE.Vector3,xa=new THREE.Vector3,ma=new THREE.Vector3,Ja=new THREE.Matrix3;void 0===O.setLineDash&&(O.setLineDash=function(){});this.domElement=x;this.devicePixelRatio=void 0!==a.devicePixelRatio?a.devicePixelRatio:void 0!==self.devicePixelRatio?self.devicePixelRatio:1;this.sortElements=this.sortObjects=this.autoClear=!0;this.info={render:{vertices:0,faces:0}};this.supportsVertexTextures=function(){};this.setFaceCulling=function(){};this.setSize=\\nfunction(a,b,c){C=a*this.devicePixelRatio;I=b*this.devicePixelRatio;x.width=C;x.height=I;z=Math.floor(C/2);y=Math.floor(I/2);!1!==c&&(x.style.width=a+\\\"px\\\",x.style.height=b+\\\"px\\\");Ka.min.set(-z,-y);Ka.max.set(z,y);aa.min.set(-z,-y);aa.max.set(z,y);Q=1;L=0;W=V=S=B=R=null;this.setViewport(0,0,a,b)};this.setViewport=function(a,b,c,d){K=a*this.devicePixelRatio;N=b*this.devicePixelRatio;ba=c*this.devicePixelRatio;P=d*this.devicePixelRatio};this.setScissor=function(){};this.enableScissorTest=function(){};\\nthis.setClearColor=function(a,b){J.set(a);E=void 0!==b?b:1;aa.min.set(-z,-y);aa.max.set(z,y)};this.setClearColorHex=function(a,b){console.warn(\\\"THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.\\\");this.setClearColor(a,b)};this.getClearColor=function(){return J};this.getClearAlpha=function(){return E};this.getMaxAnisotropy=function(){return 0};this.clear=function(){!1===aa.empty()&&(aa.intersect(Ka),aa.expandByScalar(2),aa.min.x+=z,aa.min.y=-aa.min.y+y,aa.max.x+=\\nz,aa.max.y=-aa.max.y+y,1>E&&O.clearRect(aa.min.x|0,aa.min.y|0,aa.max.x-aa.min.x|0,aa.max.y-aa.min.y|0),0<E&&(k(THREE.NormalBlending),h(1),t(\\\"rgba(\\\"+Math.floor(255*J.r)+\\\",\\\"+Math.floor(255*J.g)+\\\",\\\"+Math.floor(255*J.b)+\\\",\\\"+E+\\\")\\\"),O.fillRect(aa.min.x|0,aa.min.y|0,aa.max.x-aa.min.x|0,aa.max.y-aa.min.y|0)),aa.makeEmpty())};this.clearColor=function(){};this.clearDepth=function(){};this.clearStencil=function(){};this.render=function(a,x){if(!1===x instanceof THREE.Camera)console.error(\\\"THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.\\\");\\nelse{!0===this.autoClear&&this.clear();v.info.render.vertices=0;v.info.render.faces=0;O.setTransform(ba/C,0,0,-P/I,K,I-N);O.translate(z,y);w=A.projectScene(a,x,this.sortObjects,this.sortElements);u=w.elements;D=w.lights;oa=x;Ja.getNormalMatrix(x.matrixWorldInverse);Da.setRGB(0,0,0);Qa.setRGB(0,0,0);cb.setRGB(0,0,0);for(var L=0,Q=D.length;L<Q;L++){var E=D[L],H=E.color;E instanceof THREE.AmbientLight?Da.add(H):E instanceof THREE.DirectionalLight?Qa.add(H):E instanceof THREE.PointLight&&cb.add(H)}L=\\n0;for(Q=u.length;L<Q;L++){var J=u[L],B=J.material;if(void 0!==B&&0!==B.opacity){ra.makeEmpty();if(J instanceof THREE.RenderableSprite){$=J;$.x*=z;$.y*=y;var E=$,R=J,H=B;h(H.opacity);k(H.blending);var ea=R.scale.x*z,R=R.scale.y*y,J=.5*Math.sqrt(ea*ea+R*R);ra.min.set(E.x-J,E.y-J);ra.max.set(E.x+J,E.y+J);if(H instanceof THREE.SpriteMaterial){var da=H.map;if(null!==da&&void 0!==da.image){!1===da.hasEventListener(\\\"update\\\",d)&&(0<da.image.width&&e(da),da.addEventListener(\\\"update\\\",d));J=Ca[da.id];void 0!==\\nJ?t(J):t(\\\"rgba( 0, 0, 0, 1 )\\\");var S=da.image,J=S.width*da.offset.x,B=S.height*da.offset.y,V=S.width*da.repeat.x,da=S.height*da.repeat.y,S=ea/V,m=R/da;O.save();O.translate(E.x,E.y);0!==H.rotation&&O.rotate(H.rotation);O.translate(-ea/2,-R/2);O.scale(S,m);O.translate(-J,-B);O.fillRect(J,B,V,da)}else t(H.color.getStyle()),O.save(),O.translate(E.x,E.y),0!==H.rotation&&O.rotate(H.rotation),O.scale(ea,-R),O.fillRect(-.5,-.5,1,1);O.restore()}else H instanceof THREE.SpriteCanvasMaterial&&(r(H.color.getStyle()),\\nt(H.color.getStyle()),O.save(),O.translate(E.x,E.y),0!==H.rotation&&O.rotate(H.rotation),O.scale(ea,R),H.program(O),O.restore())}else if(J instanceof THREE.RenderableLine){if($=J.v1,X=J.v2,$.positionScreen.x*=z,$.positionScreen.y*=y,X.positionScreen.x*=z,X.positionScreen.y*=y,ra.setFromPoints([$.positionScreen,X.positionScreen]),!0===Ka.isIntersectionBox(ra))if(E=$,H=X,ea=J,R=B,h(R.opacity),k(R.blending),O.beginPath(),O.moveTo(E.positionScreen.x,E.positionScreen.y),O.lineTo(H.positionScreen.x,H.positionScreen.y),\\nR instanceof THREE.LineBasicMaterial){l(R.linewidth);n(R.linecap);q(R.linejoin);if(R.vertexColors!==THREE.VertexColors)r(R.color.getStyle());else if(J=ea.vertexColors[0].getStyle(),ea=ea.vertexColors[1].getStyle(),J===ea)r(J);else{try{var W=O.createLinearGradient(E.positionScreen.x,E.positionScreen.y,H.positionScreen.x,H.positionScreen.y);W.addColorStop(0,J);W.addColorStop(1,ea)}catch(xb){W=J}r(W)}O.stroke();ra.expandByScalar(2*R.linewidth)}else R instanceof THREE.LineDashedMaterial&&(l(R.linewidth),\\nn(R.linecap),q(R.linejoin),r(R.color.getStyle()),s([R.dashSize,R.gapSize]),O.stroke(),ra.expandByScalar(2*R.linewidth),s([]))}else if(J instanceof THREE.RenderableFace){$=J.v1;X=J.v2;T=J.v3;if(-1>$.positionScreen.z||1<$.positionScreen.z)continue;if(-1>X.positionScreen.z||1<X.positionScreen.z)continue;if(-1>T.positionScreen.z||1<T.positionScreen.z)continue;$.positionScreen.x*=z;$.positionScreen.y*=y;X.positionScreen.x*=z;X.positionScreen.y*=y;T.positionScreen.x*=z;T.positionScreen.y*=y;0<B.overdraw&&\\n(g($.positionScreen,X.positionScreen,B.overdraw),g(X.positionScreen,T.positionScreen,B.overdraw),g(T.positionScreen,$.positionScreen,B.overdraw));ra.setFromPoints([$.positionScreen,X.positionScreen,T.positionScreen]);if(!0===Ka.isIntersectionBox(ra)){H=$;ea=X;R=T;E=B;v.info.render.vertices+=3;v.info.render.faces++;h(E.opacity);k(E.blending);ya=H.positionScreen.x;Ea=H.positionScreen.y;Aa=ea.positionScreen.x;za=ea.positionScreen.y;Oa=R.positionScreen.x;Pa=R.positionScreen.y;var B=ya,V=Ea,da=Aa,S=za,\\nm=Oa,Ta=Pa;O.beginPath();O.moveTo(B,V);O.lineTo(da,S);O.lineTo(m,Ta);O.closePath();if((E instanceof THREE.MeshLambertMaterial||E instanceof THREE.MeshPhongMaterial)&&null===E.map){Ba.copy(E.color);Ya.copy(E.emissive);E.vertexColors===THREE.FaceColors&&Ba.multiply(J.color);G.copy(Da);xa.copy(H.positionWorld).add(ea.positionWorld).add(R.positionWorld).divideScalar(3);H=xa;ea=J.normalModel;R=G;J=0;for(B=D.length;J<B;J++)V=D[J],Za.copy(V.color),V instanceof THREE.DirectionalLight?(da=Ga.setFromMatrixPosition(V.matrixWorld).normalize(),\\nS=ea.dot(da),0>=S||(S*=V.intensity,R.add(Za.multiplyScalar(S)))):V instanceof THREE.PointLight&&(da=Ga.setFromMatrixPosition(V.matrixWorld),S=ea.dot(Ga.subVectors(da,H).normalize()),0>=S||(S*=0==V.distance?1:1-Math.min(H.distanceTo(da)/V.distance,1),0!=S&&(S*=V.intensity,R.add(Za.multiplyScalar(S)))));G.multiply(Ba).add(Ya);!0===E.wireframe?b(G,E.wireframeLinewidth,E.wireframeLinecap,E.wireframeLinejoin):c(G)}else E instanceof THREE.MeshBasicMaterial||E instanceof THREE.MeshLambertMaterial||E instanceof\\nTHREE.MeshPhongMaterial?null!==E.map?E.map.mapping instanceof THREE.UVMapping&&(ca=J.uvs,f(ya,Ea,Aa,za,Oa,Pa,ca[0].x,ca[0].y,ca[1].x,ca[1].y,ca[2].x,ca[2].y,E.map)):null!==E.envMap?E.envMap.mapping instanceof THREE.SphericalReflectionMapping?(ma.copy(J.vertexNormalsModel[0]).applyMatrix3(Ja),la=.5*ma.x+.5,qa=.5*ma.y+.5,ma.copy(J.vertexNormalsModel[1]).applyMatrix3(Ja),ua=.5*ma.x+.5,ja=.5*ma.y+.5,ma.copy(J.vertexNormalsModel[2]).applyMatrix3(Ja),Fa=.5*ma.x+.5,va=.5*ma.y+.5,f(ya,Ea,Aa,za,Oa,Pa,la,qa,\\nua,ja,Fa,va,E.envMap)):E.envMap.mapping instanceof THREE.SphericalRefractionMapping&&(ma.copy(J.vertexNormalsModel[0]).applyMatrix3(Ja),la=-.5*ma.x+.5,qa=-.5*ma.y+.5,ma.copy(J.vertexNormalsModel[1]).applyMatrix3(Ja),ua=-.5*ma.x+.5,ja=-.5*ma.y+.5,ma.copy(J.vertexNormalsModel[2]).applyMatrix3(Ja),Fa=-.5*ma.x+.5,va=-.5*ma.y+.5,f(ya,Ea,Aa,za,Oa,Pa,la,qa,ua,ja,Fa,va,E.envMap)):(G.copy(E.color),E.vertexColors===THREE.FaceColors&&G.multiply(J.color),!0===E.wireframe?b(G,E.wireframeLinewidth,E.wireframeLinecap,\\nE.wireframeLinejoin):c(G)):(E instanceof THREE.MeshDepthMaterial?G.r=G.g=G.b=1-p(H.positionScreen.z*H.positionScreen.w,oa.near,oa.far):E instanceof THREE.MeshNormalMaterial?(ma.copy(J.normalModel).applyMatrix3(Ja),G.setRGB(ma.x,ma.y,ma.z).multiplyScalar(.5).addScalar(.5)):G.setRGB(1,1,1),!0===E.wireframe?b(G,E.wireframeLinewidth,E.wireframeLinecap,E.wireframeLinejoin):c(G))}}aa.union(ra)}}O.setTransform(1,0,0,1,0,0)}}};THREE.ShaderChunk={};THREE.ShaderChunk.alphatest_fragment=\\\"#ifdef ALPHATEST\\\\n\\\\n\\\\tif ( gl_FragColor.a < ALPHATEST ) discard;\\\\n\\\\n#endif\\\\n\\\";\\nTHREE.ShaderChunk.lights_lambert_vertex=\\\"vLightFront = vec3( 0.0 );\\\\n\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\tvLightBack = vec3( 0.0 );\\\\n\\\\n#endif\\\\n\\\\ntransformedNormal = normalize( transformedNormal );\\\\n\\\\n#if MAX_DIR_LIGHTS > 0\\\\n\\\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\\\n\\\\n\\\\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\\\n\\\\tvec3 dirVector = normalize( lDirection.xyz );\\\\n\\\\n\\\\tfloat dotProduct = dot( transformedNormal, dirVector );\\\\n\\\\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\\\n\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\\\n\\\\n\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\n\\\\t\\\\t\\\\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\t#ifdef WRAP_AROUND\\\\n\\\\n\\\\t\\\\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\\\n\\\\t\\\\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\\\\n\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\t\\\\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\\\\n\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\\\\n\\\\n\\\\t#endif\\\\n\\\\n}\\\\n\\\\n#endif\\\\n\\\\n#if MAX_POINT_LIGHTS > 0\\\\n\\\\n\\\\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\\\n\\\\t\\\\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\\\n\\\\n\\\\t\\\\tfloat lDistance = 1.0;\\\\n\\\\t\\\\tif ( pointLightDistance[ i ] > 0.0 )\\\\n\\\\t\\\\t\\\\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\\\n\\\\n\\\\t\\\\tlVector = normalize( lVector );\\\\n\\\\t\\\\tfloat dotProduct = dot( transformedNormal, lVector );\\\\n\\\\n\\\\t\\\\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\\\\n\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\t\\\\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\n\\\\t\\\\t\\\\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\\\n\\\\t\\\\t\\\\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\\\\n\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\t\\\\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\\n\\\\n#if MAX_SPOT_LIGHTS > 0\\\\n\\\\n\\\\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\\\n\\\\t\\\\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\\\n\\\\n\\\\t\\\\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\\\\n\\\\n\\\\t\\\\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\\\n\\\\n\\\\t\\\\t\\\\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\\\n\\\\n\\\\t\\\\t\\\\tfloat lDistance = 1.0;\\\\n\\\\t\\\\t\\\\tif ( spotLightDistance[ i ] > 0.0 )\\\\n\\\\t\\\\t\\\\t\\\\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\\\n\\\\n\\\\t\\\\t\\\\tlVector = normalize( lVector );\\\\n\\\\n\\\\t\\\\t\\\\tfloat dotProduct = dot( transformedNormal, lVector );\\\\n\\\\t\\\\t\\\\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\\\n\\\\t\\\\t\\\\t\\\\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\tvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\\n\\\\n#if MAX_HEMI_LIGHTS > 0\\\\n\\\\n\\\\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\\\n\\\\t\\\\tvec3 lVector = normalize( lDirection.xyz );\\\\n\\\\n\\\\t\\\\tfloat dotProduct = dot( transformedNormal, lVector );\\\\n\\\\n\\\\t\\\\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\\\n\\\\t\\\\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\\\\n\\\\n\\\\t\\\\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\\\n\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\t\\\\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\\n\\\\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\\\\n\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\tvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.map_particle_pars_fragment=\\\"#ifdef USE_MAP\\\\n\\\\n\\\\tuniform sampler2D map;\\\\n\\\\n#endif\\\";THREE.ShaderChunk.default_vertex=\\\"vec4 mvPosition;\\\\n\\\\n#ifdef USE_SKINNING\\\\n\\\\n\\\\tmvPosition = modelViewMatrix * skinned;\\\\n\\\\n#endif\\\\n\\\\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\\\\n\\\\n\\\\tmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\\\\n\\\\n#endif\\\\n\\\\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\\\\n\\\\n\\\\tmvPosition = modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\n#endif\\\\n\\\\ngl_Position = projectionMatrix * mvPosition;\\\";\\nTHREE.ShaderChunk.map_pars_fragment=\\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\\\n\\\\n\\\\tvarying vec2 vUv;\\\\n\\\\n#endif\\\\n\\\\n#ifdef USE_MAP\\\\n\\\\n\\\\tuniform sampler2D map;\\\\n\\\\n#endif\\\";THREE.ShaderChunk.skinnormal_vertex=\\\"#ifdef USE_SKINNING\\\\n\\\\n\\\\tmat4 skinMatrix = mat4( 0.0 );\\\\n\\\\tskinMatrix += skinWeight.x * boneMatX;\\\\n\\\\tskinMatrix += skinWeight.y * boneMatY;\\\\n\\\\tskinMatrix += skinWeight.z * boneMatZ;\\\\n\\\\tskinMatrix += skinWeight.w * boneMatW;\\\\n\\\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\\\n\\\\n\\\\t#ifdef USE_MORPHNORMALS\\\\n\\\\n\\\\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\\\\n\\\\n\\\\t#endif\\\\n\\\\n#endif\\\\n\\\";\\nTHREE.ShaderChunk.logdepthbuf_pars_vertex=\\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\tuniform float logDepthBufFC;\\\\n\\\\n#endif\\\";THREE.ShaderChunk.lightmap_pars_vertex=\\\"#ifdef USE_LIGHTMAP\\\\n\\\\n\\\\tvarying vec2 vUv2;\\\\n\\\\n#endif\\\";THREE.ShaderChunk.lights_phong_fragment=\\\"vec3 normal = normalize( vNormal );\\\\nvec3 viewPosition = normalize( vViewPosition );\\\\n\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\\\n\\\\n#endif\\\\n\\\\n#ifdef USE_NORMALMAP\\\\n\\\\n\\\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\\\n\\\\n#elif defined( USE_BUMPMAP )\\\\n\\\\n\\\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\\\n\\\\n#endif\\\\n\\\\n#if MAX_POINT_LIGHTS > 0\\\\n\\\\n\\\\tvec3 pointDiffuse = vec3( 0.0 );\\\\n\\\\tvec3 pointSpecular = vec3( 0.0 );\\\\n\\\\n\\\\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\\\n\\\\t\\\\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\\\n\\\\n\\\\t\\\\tfloat lDistance = 1.0;\\\\n\\\\t\\\\tif ( pointLightDistance[ i ] > 0.0 )\\\\n\\\\t\\\\t\\\\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\\\n\\\\n\\\\t\\\\tlVector = normalize( lVector );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t// diffuse\\\\n\\\\n\\\\t\\\\tfloat dotProduct = dot( normal, lVector );\\\\n\\\\n\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\n\\\\t\\\\t\\\\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\\\n\\\\t\\\\t\\\\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\\\n\\\\n\\\\t\\\\t\\\\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\\\n\\\\n\\\\t\\\\t#else\\\\n\\\\n\\\\t\\\\t\\\\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tpointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t// specular\\\\n\\\\n\\\\t\\\\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\\\n\\\\t\\\\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\\\n\\\\t\\\\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\\\n\\\\n\\\\t\\\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\\\n\\\\n\\\\t\\\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\\\n\\\\t\\\\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\\n\\\\n#if MAX_SPOT_LIGHTS > 0\\\\n\\\\n\\\\tvec3 spotDiffuse = vec3( 0.0 );\\\\n\\\\tvec3 spotSpecular = vec3( 0.0 );\\\\n\\\\n\\\\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\\\n\\\\t\\\\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\\\n\\\\n\\\\t\\\\tfloat lDistance = 1.0;\\\\n\\\\t\\\\tif ( spotLightDistance[ i ] > 0.0 )\\\\n\\\\t\\\\t\\\\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\\\n\\\\n\\\\t\\\\tlVector = normalize( lVector );\\\\n\\\\n\\\\t\\\\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\\\n\\\\n\\\\t\\\\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\\\n\\\\n\\\\t\\\\t\\\\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t// diffuse\\\\n\\\\n\\\\t\\\\t\\\\tfloat dotProduct = dot( normal, lVector );\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\\\n\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\tspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t// specular\\\\n\\\\n\\\\t\\\\t\\\\tvec3 spotHalfVector = normalize( lVector + viewPosition );\\\\n\\\\t\\\\t\\\\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\\\n\\\\t\\\\t\\\\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\\\n\\\\n\\\\t\\\\t\\\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\\\n\\\\n\\\\t\\\\t\\\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\\\\n\\\\t\\\\t\\\\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\\n\\\\n#if MAX_DIR_LIGHTS > 0\\\\n\\\\n\\\\tvec3 dirDiffuse = vec3( 0.0 );\\\\n\\\\tvec3 dirSpecular = vec3( 0.0 );\\\\n\\\\n\\\\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\\\n\\\\t\\\\tvec3 dirVector = normalize( lDirection.xyz );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t// diffuse\\\\n\\\\n\\\\t\\\\tfloat dotProduct = dot( normal, dirVector );\\\\n\\\\n\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\n\\\\t\\\\t\\\\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\\\n\\\\t\\\\t\\\\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\\\n\\\\n\\\\t\\\\t\\\\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\\\n\\\\n\\\\t\\\\t#else\\\\n\\\\n\\\\t\\\\t\\\\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tdirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\\\n\\\\n\\\\t\\\\t// specular\\\\n\\\\n\\\\t\\\\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\\\n\\\\t\\\\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\\\n\\\\t\\\\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\\\n\\\\n\\\\t\\\\t/*\\\\n\\\\t\\\\t// fresnel term from skin shader\\\\n\\\\t\\\\tconst float F0 = 0.128;\\\\n\\\\n\\\\t\\\\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\\\\n\\\\t\\\\tfloat exponential = pow( base, 5.0 );\\\\n\\\\n\\\\t\\\\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\\\\n\\\\t\\\\t*/\\\\n\\\\n\\\\t\\\\t/*\\\\n\\\\t\\\\t// fresnel term from fresnel shader\\\\n\\\\t\\\\tconst float mFresnelBias = 0.08;\\\\n\\\\t\\\\tconst float mFresnelScale = 0.3;\\\\n\\\\t\\\\tconst float mFresnelPower = 5.0;\\\\n\\\\n\\\\t\\\\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\\\\n\\\\t\\\\t*/\\\\n\\\\n\\\\t\\\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\\\n\\\\n\\\\t\\\\t// \\\\t\\\\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\\\\n\\\\n\\\\t\\\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\\\n\\\\t\\\\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\\\n\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\\n\\\\n#if MAX_HEMI_LIGHTS > 0\\\\n\\\\n\\\\tvec3 hemiDiffuse = vec3( 0.0 );\\\\n\\\\tvec3 hemiSpecular = vec3( 0.0 );\\\\n\\\\n\\\\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\\\n\\\\t\\\\tvec3 lVector = normalize( lDirection.xyz );\\\\n\\\\n\\\\t\\\\t// diffuse\\\\n\\\\n\\\\t\\\\tfloat dotProduct = dot( normal, lVector );\\\\n\\\\t\\\\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\\\n\\\\n\\\\t\\\\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\\\n\\\\n\\\\t\\\\themiDiffuse += diffuse * hemiColor;\\\\n\\\\n\\\\t\\\\t// specular (sky light)\\\\n\\\\n\\\\t\\\\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\\\n\\\\t\\\\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\\\n\\\\t\\\\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\\\\n\\\\n\\\\t\\\\t// specular (ground light)\\\\n\\\\n\\\\t\\\\tvec3 lVectorGround = -lVector;\\\\n\\\\n\\\\t\\\\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\\\n\\\\t\\\\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\\\n\\\\t\\\\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\\\\n\\\\n\\\\t\\\\tfloat dotProductGround = dot( normal, lVectorGround );\\\\n\\\\n\\\\t\\\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\\\n\\\\n\\\\t\\\\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\\\\n\\\\t\\\\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\\\\n\\\\t\\\\themiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\\n\\\\nvec3 totalDiffuse = vec3( 0.0 );\\\\nvec3 totalSpecular = vec3( 0.0 );\\\\n\\\\n#if MAX_DIR_LIGHTS > 0\\\\n\\\\n\\\\ttotalDiffuse += dirDiffuse;\\\\n\\\\ttotalSpecular += dirSpecular;\\\\n\\\\n#endif\\\\n\\\\n#if MAX_HEMI_LIGHTS > 0\\\\n\\\\n\\\\ttotalDiffuse += hemiDiffuse;\\\\n\\\\ttotalSpecular += hemiSpecular;\\\\n\\\\n#endif\\\\n\\\\n#if MAX_POINT_LIGHTS > 0\\\\n\\\\n\\\\ttotalDiffuse += pointDiffuse;\\\\n\\\\ttotalSpecular += pointSpecular;\\\\n\\\\n#endif\\\\n\\\\n#if MAX_SPOT_LIGHTS > 0\\\\n\\\\n\\\\ttotalDiffuse += spotDiffuse;\\\\n\\\\ttotalSpecular += spotSpecular;\\\\n\\\\n#endif\\\\n\\\\n#ifdef METAL\\\\n\\\\n\\\\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\\\\n\\\\n#else\\\\n\\\\n\\\\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.fog_pars_fragment=\\\"#ifdef USE_FOG\\\\n\\\\n\\\\tuniform vec3 fogColor;\\\\n\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\n\\\\t\\\\tuniform float fogDensity;\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\t\\\\tuniform float fogNear;\\\\n\\\\t\\\\tuniform float fogFar;\\\\n\\\\t#endif\\\\n\\\\n#endif\\\";THREE.ShaderChunk.morphnormal_vertex=\\\"#ifdef USE_MORPHNORMALS\\\\n\\\\n\\\\tvec3 morphedNormal = vec3( 0.0 );\\\\n\\\\n\\\\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\\\n\\\\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\\\n\\\\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\\\n\\\\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\\\n\\\\n\\\\tmorphedNormal += normal;\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.envmap_pars_fragment=\\\"#ifdef USE_ENVMAP\\\\n\\\\n\\\\tuniform float reflectivity;\\\\n\\\\tuniform samplerCube envMap;\\\\n\\\\tuniform float flipEnvMap;\\\\n\\\\tuniform int combine;\\\\n\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\n\\\\t\\\\tuniform bool useRefract;\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\n\\\\t#endif\\\\n\\\\n#endif\\\";THREE.ShaderChunk.logdepthbuf_fragment=\\\"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\\\n\\\\n\\\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.normalmap_pars_fragment=\\\"#ifdef USE_NORMALMAP\\\\n\\\\n\\\\tuniform sampler2D normalMap;\\\\n\\\\tuniform vec2 normalScale;\\\\n\\\\n\\\\t\\\\t\\\\t// Per-Pixel Tangent Space Normal Mapping\\\\n\\\\t\\\\t\\\\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\\\n\\\\n\\\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\\\n\\\\n\\\\t\\\\tvec3 q0 = dFdx( eye_pos.xyz );\\\\n\\\\t\\\\tvec3 q1 = dFdy( eye_pos.xyz );\\\\n\\\\t\\\\tvec2 st0 = dFdx( vUv.st );\\\\n\\\\t\\\\tvec2 st1 = dFdy( vUv.st );\\\\n\\\\n\\\\t\\\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\\\n\\\\t\\\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\\\n\\\\t\\\\tvec3 N = normalize( surf_norm );\\\\n\\\\n\\\\t\\\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\\\n\\\\t\\\\tmapN.xy = normalScale * mapN.xy;\\\\n\\\\t\\\\tmat3 tsn = mat3( S, T, N );\\\\n\\\\t\\\\treturn normalize( tsn * mapN );\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\\n\\\";\\nTHREE.ShaderChunk.lights_phong_pars_vertex=\\\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\\\n\\\\n\\\\tvarying vec3 vWorldPosition;\\\\n\\\\n#endif\\\\n\\\";THREE.ShaderChunk.lightmap_pars_fragment=\\\"#ifdef USE_LIGHTMAP\\\\n\\\\n\\\\tvarying vec2 vUv2;\\\\n\\\\tuniform sampler2D lightMap;\\\\n\\\\n#endif\\\";THREE.ShaderChunk.shadowmap_vertex=\\\"#ifdef USE_SHADOWMAP\\\\n\\\\n\\\\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\\\n\\\\n\\\\t\\\\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.lights_phong_vertex=\\\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\\\n\\\\n\\\\tvWorldPosition = worldPosition.xyz;\\\\n\\\\n#endif\\\";THREE.ShaderChunk.map_fragment=\\\"#ifdef USE_MAP\\\\n\\\\n\\\\tvec4 texelColor = texture2D( map, vUv );\\\\n\\\\n\\\\t#ifdef GAMMA_INPUT\\\\n\\\\n\\\\t\\\\ttexelColor.xyz *= texelColor.xyz;\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\tgl_FragColor = gl_FragColor * texelColor;\\\\n\\\\n#endif\\\";THREE.ShaderChunk.lightmap_vertex=\\\"#ifdef USE_LIGHTMAP\\\\n\\\\n\\\\tvUv2 = uv2;\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.map_particle_fragment=\\\"#ifdef USE_MAP\\\\n\\\\n\\\\tgl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\\\\n\\\\n#endif\\\";THREE.ShaderChunk.color_pars_fragment=\\\"#ifdef USE_COLOR\\\\n\\\\n\\\\tvarying vec3 vColor;\\\\n\\\\n#endif\\\\n\\\";THREE.ShaderChunk.color_vertex=\\\"#ifdef USE_COLOR\\\\n\\\\n\\\\t#ifdef GAMMA_INPUT\\\\n\\\\n\\\\t\\\\tvColor = color * color;\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\t\\\\tvColor = color;\\\\n\\\\n\\\\t#endif\\\\n\\\\n#endif\\\";THREE.ShaderChunk.skinning_vertex=\\\"#ifdef USE_SKINNING\\\\n\\\\n\\\\t#ifdef USE_MORPHTARGETS\\\\n\\\\n\\\\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\tvec4 skinned = vec4( 0.0 );\\\\n\\\\tskinned += boneMatX * skinVertex * skinWeight.x;\\\\n\\\\tskinned += boneMatY * skinVertex * skinWeight.y;\\\\n\\\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\\\n\\\\tskinned += boneMatW * skinVertex * skinWeight.w;\\\\n\\\\tskinned  = bindMatrixInverse * skinned;\\\\n\\\\n#endif\\\\n\\\";\\nTHREE.ShaderChunk.envmap_pars_vertex=\\\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\\\\n\\\\n\\\\tvarying vec3 vReflect;\\\\n\\\\n\\\\tuniform float refractionRatio;\\\\n\\\\tuniform bool useRefract;\\\\n\\\\n#endif\\\\n\\\";THREE.ShaderChunk.linear_to_gamma_fragment=\\\"#ifdef GAMMA_OUTPUT\\\\n\\\\n\\\\tgl_FragColor.xyz = sqrt( gl_FragColor.xyz );\\\\n\\\\n#endif\\\";THREE.ShaderChunk.color_pars_vertex=\\\"#ifdef USE_COLOR\\\\n\\\\n\\\\tvarying vec3 vColor;\\\\n\\\\n#endif\\\";THREE.ShaderChunk.lights_lambert_pars_vertex=\\\"uniform vec3 ambient;\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\n\\\\nuniform vec3 ambientLightColor;\\\\n\\\\n#if MAX_DIR_LIGHTS > 0\\\\n\\\\n\\\\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\\\n\\\\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\\\n\\\\n#endif\\\\n\\\\n#if MAX_HEMI_LIGHTS > 0\\\\n\\\\n\\\\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\\\n\\\\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\\\n\\\\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\\\n\\\\n#endif\\\\n\\\\n#if MAX_POINT_LIGHTS > 0\\\\n\\\\n\\\\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\\\n\\\\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\\\n\\\\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\\\n\\\\n#endif\\\\n\\\\n#if MAX_SPOT_LIGHTS > 0\\\\n\\\\n\\\\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\\\n\\\\n#endif\\\\n\\\\n#ifdef WRAP_AROUND\\\\n\\\\n\\\\tuniform vec3 wrapRGB;\\\\n\\\\n#endif\\\\n\\\";\\nTHREE.ShaderChunk.map_pars_vertex=\\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\\\n\\\\n\\\\tvarying vec2 vUv;\\\\n\\\\tuniform vec4 offsetRepeat;\\\\n\\\\n#endif\\\\n\\\";THREE.ShaderChunk.envmap_fragment=\\\"#ifdef USE_ENVMAP\\\\n\\\\n\\\\tvec3 reflectVec;\\\\n\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\n\\\\t\\\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\\\n\\\\n\\\\t\\\\t// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\\\\n\\\\t\\\\t// Transforming Normal Vectors with the Inverse Transformation\\\\n\\\\n\\\\t\\\\tvec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\\\\n\\\\n\\\\t\\\\tif ( useRefract ) {\\\\n\\\\n\\\\t\\\\t\\\\treflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\n\\\\t\\\\t} else { \\\\n\\\\n\\\\t\\\\t\\\\treflectVec = reflect( cameraToVertex, worldNormal );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\t\\\\treflectVec = vReflect;\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\n\\\\t\\\\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\\\n\\\\t\\\\tvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\t\\\\tvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\t#ifdef GAMMA_INPUT\\\\n\\\\n\\\\t\\\\tcubeColor.xyz *= cubeColor.xyz;\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\tif ( combine == 1 ) {\\\\n\\\\n\\\\t\\\\tgl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\\\\n\\\\n\\\\t} else if ( combine == 2 ) {\\\\n\\\\n\\\\t\\\\tgl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\\\\n\\\\n\\\\t} else {\\\\n\\\\n\\\\t\\\\tgl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.specularmap_pars_fragment=\\\"#ifdef USE_SPECULARMAP\\\\n\\\\n\\\\tuniform sampler2D specularMap;\\\\n\\\\n#endif\\\";THREE.ShaderChunk.logdepthbuf_vertex=\\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\n\\\\tgl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\\\\n\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\n\\\\t\\\\tvFragDepth = 1.0 + gl_Position.w;\\\\n\\\\n#else\\\\n\\\\n\\\\t\\\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\\\n\\\\n\\\\t#endif\\\\n\\\\n#endif\\\";THREE.ShaderChunk.morphtarget_pars_vertex=\\\"#ifdef USE_MORPHTARGETS\\\\n\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\n\\\\tuniform float morphTargetInfluences[ 8 ];\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\tuniform float morphTargetInfluences[ 4 ];\\\\n\\\\n\\\\t#endif\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.specularmap_fragment=\\\"float specularStrength;\\\\n\\\\n#ifdef USE_SPECULARMAP\\\\n\\\\n\\\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\\\n\\\\tspecularStrength = texelSpecular.r;\\\\n\\\\n#else\\\\n\\\\n\\\\tspecularStrength = 1.0;\\\\n\\\\n#endif\\\";THREE.ShaderChunk.fog_fragment=\\\"#ifdef USE_FOG\\\\n\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\n\\\\t\\\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\t\\\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\n\\\\t\\\\tconst float LOG2 = 1.442695;\\\\n\\\\t\\\\tfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\\\\n\\\\t\\\\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\t\\\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\\\n\\\\n\\\\t#endif\\\\n\\\\t\\\\n\\\\tgl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.bumpmap_pars_fragment=\\\"#ifdef USE_BUMPMAP\\\\n\\\\n\\\\tuniform sampler2D bumpMap;\\\\n\\\\tuniform float bumpScale;\\\\n\\\\n\\\\t\\\\t\\\\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\\\\n\\\\t\\\\t\\\\t//\\\\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\\\\n\\\\n\\\\t\\\\t\\\\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\\\\n\\\\n\\\\tvec2 dHdxy_fwd() {\\\\n\\\\n\\\\t\\\\tvec2 dSTdx = dFdx( vUv );\\\\n\\\\t\\\\tvec2 dSTdy = dFdy( vUv );\\\\n\\\\n\\\\t\\\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\\\n\\\\t\\\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\\\n\\\\t\\\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\\\n\\\\n\\\\t\\\\treturn vec2( dBx, dBy );\\\\n\\\\n\\\\t}\\\\n\\\\n\\\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\\\n\\\\n\\\\t\\\\tvec3 vSigmaX = dFdx( surf_pos );\\\\n\\\\t\\\\tvec3 vSigmaY = dFdy( surf_pos );\\\\n\\\\t\\\\tvec3 vN = surf_norm;\\\\t\\\\t// normalized\\\\n\\\\n\\\\t\\\\tvec3 R1 = cross( vSigmaY, vN );\\\\n\\\\t\\\\tvec3 R2 = cross( vN, vSigmaX );\\\\n\\\\n\\\\t\\\\tfloat fDet = dot( vSigmaX, R1 );\\\\n\\\\n\\\\t\\\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\\\n\\\\t\\\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.defaultnormal_vertex=\\\"vec3 objectNormal;\\\\n\\\\n#ifdef USE_SKINNING\\\\n\\\\n\\\\tobjectNormal = skinnedNormal.xyz;\\\\n\\\\n#endif\\\\n\\\\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\\\\n\\\\n\\\\tobjectNormal = morphedNormal;\\\\n\\\\n#endif\\\\n\\\\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\\\\n\\\\n\\\\tobjectNormal = normal;\\\\n\\\\n#endif\\\\n\\\\n#ifdef FLIP_SIDED\\\\n\\\\n\\\\tobjectNormal = -objectNormal;\\\\n\\\\n#endif\\\\n\\\\nvec3 transformedNormal = normalMatrix * objectNormal;\\\";\\nTHREE.ShaderChunk.lights_phong_pars_fragment=\\\"uniform vec3 ambientLightColor;\\\\n\\\\n#if MAX_DIR_LIGHTS > 0\\\\n\\\\n\\\\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\\\n\\\\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\\\n\\\\n#endif\\\\n\\\\n#if MAX_HEMI_LIGHTS > 0\\\\n\\\\n\\\\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\\\n\\\\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\\\n\\\\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\\\n\\\\n#endif\\\\n\\\\n#if MAX_POINT_LIGHTS > 0\\\\n\\\\n\\\\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\\\n\\\\n\\\\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\\\n\\\\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\\\n\\\\n#endif\\\\n\\\\n#if MAX_SPOT_LIGHTS > 0\\\\n\\\\n\\\\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\\\n\\\\n\\\\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\\\n\\\\n#endif\\\\n\\\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\\\n\\\\n\\\\tvarying vec3 vWorldPosition;\\\\n\\\\n#endif\\\\n\\\\n#ifdef WRAP_AROUND\\\\n\\\\n\\\\tuniform vec3 wrapRGB;\\\\n\\\\n#endif\\\\n\\\\nvarying vec3 vViewPosition;\\\\nvarying vec3 vNormal;\\\";\\nTHREE.ShaderChunk.skinbase_vertex=\\\"#ifdef USE_SKINNING\\\\n\\\\n\\\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\\\n\\\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\\\n\\\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\\\n\\\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\\\n\\\\n#endif\\\";THREE.ShaderChunk.map_vertex=\\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\\\n\\\\n\\\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.lightmap_fragment=\\\"#ifdef USE_LIGHTMAP\\\\n\\\\n\\\\tgl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\\\\n\\\\n#endif\\\";THREE.ShaderChunk.shadowmap_pars_vertex=\\\"#ifdef USE_SHADOWMAP\\\\n\\\\n\\\\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\\\n\\\\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\\\\n\\\\n#endif\\\";THREE.ShaderChunk.color_fragment=\\\"#ifdef USE_COLOR\\\\n\\\\n\\\\tgl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\\\\n\\\\n#endif\\\";THREE.ShaderChunk.morphtarget_vertex=\\\"#ifdef USE_MORPHTARGETS\\\\n\\\\n\\\\tvec3 morphed = vec3( 0.0 );\\\\n\\\\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\\\n\\\\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\\\n\\\\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\\\n\\\\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\\\n\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\n\\\\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\\\n\\\\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\\\n\\\\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\\\n\\\\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\tmorphed += position;\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.envmap_vertex=\\\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\\\\n\\\\n\\\\tvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\\\\n\\\\tworldNormal = normalize( worldNormal );\\\\n\\\\n\\\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\\\n\\\\n\\\\tif ( useRefract ) {\\\\n\\\\n\\\\t\\\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\n\\\\t} else {\\\\n\\\\n\\\\t\\\\tvReflect = reflect( cameraToVertex, worldNormal );\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.shadowmap_fragment=\\\"#ifdef USE_SHADOWMAP\\\\n\\\\n\\\\t#ifdef SHADOWMAP_DEBUG\\\\n\\\\n\\\\t\\\\tvec3 frustumColors[3];\\\\n\\\\t\\\\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\\\n\\\\t\\\\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\\\n\\\\t\\\\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\t#ifdef SHADOWMAP_CASCADE\\\\n\\\\n\\\\t\\\\tint inFrustumCount = 0;\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\tfloat fDepth;\\\\n\\\\tvec3 shadowColor = vec3( 1.0 );\\\\n\\\\n\\\\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\\\n\\\\n\\\\t\\\\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t// if ( something && something ) breaks ATI OpenGL shader compiler\\\\n\\\\t\\\\t\\\\t\\\\t// if ( all( something, something ) ) using this instead\\\\n\\\\n\\\\t\\\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\\\n\\\\t\\\\tbool inFrustum = all( inFrustumVec );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t// don't shadow pixels outside of light frustum\\\\n\\\\t\\\\t\\\\t\\\\t// use just first frustum (for cascades)\\\\n\\\\t\\\\t\\\\t\\\\t// don't shadow pixels behind far plane of light frustum\\\\n\\\\n\\\\t\\\\t#ifdef SHADOWMAP_CASCADE\\\\n\\\\n\\\\t\\\\t\\\\tinFrustumCount += int( inFrustum );\\\\n\\\\t\\\\t\\\\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\\\\n\\\\n\\\\t\\\\t#else\\\\n\\\\n\\\\t\\\\t\\\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tbool frustumTest = all( frustumTestVec );\\\\n\\\\n\\\\t\\\\tif ( frustumTest ) {\\\\n\\\\n\\\\t\\\\t\\\\tshadowCoord.z += shadowBias[ i ];\\\\n\\\\n\\\\t\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF )\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Percentage-close filtering\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// (9 pixel kernel)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://fabiensanglard.net/shadowmappingPCF/\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat shadow = 0.0;\\\\n\\\\n\\\\t\\\\t/*\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// must enroll loop manually\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfloat fDepth = unpackDepth( rgbaDepth );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z )\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshadow += 1.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tshadow /= 9.0;\\\\n\\\\n\\\\t\\\\t*/\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tconst float shadowDelta = 1.0 / 9.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\\\n\\\\t\\\\t\\\\t\\\\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat dx0 = -1.25 * xPixelOffset;\\\\n\\\\t\\\\t\\\\t\\\\tfloat dy0 = -1.25 * yPixelOffset;\\\\n\\\\t\\\\t\\\\t\\\\tfloat dx1 = 1.25 * xPixelOffset;\\\\n\\\\t\\\\t\\\\t\\\\tfloat dy1 = 1.25 * yPixelOffset;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\\\n\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\\\n\\\\n\\\\t\\\\t\\\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Percentage-close filtering\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// (9 pixel kernel)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://fabiensanglard.net/shadowmappingPCF/\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat shadow = 0.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\\\n\\\\t\\\\t\\\\t\\\\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat dx0 = -1.0 * xPixelOffset;\\\\n\\\\t\\\\t\\\\t\\\\tfloat dy0 = -1.0 * yPixelOffset;\\\\n\\\\t\\\\t\\\\t\\\\tfloat dx1 = 1.0 * xPixelOffset;\\\\n\\\\t\\\\t\\\\t\\\\tfloat dy1 = 1.0 * yPixelOffset;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tmat3 shadowKernel;\\\\n\\\\t\\\\t\\\\t\\\\tmat3 depthKernel;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\\\n\\\\t\\\\t\\\\t\\\\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\\\n\\\\t\\\\t\\\\t\\\\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec3 shadowZ = vec3( shadowCoord.z );\\\\n\\\\t\\\\t\\\\t\\\\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\\\n\\\\t\\\\t\\\\t\\\\tshadowKernel[0] *= vec3(0.25);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\\\n\\\\t\\\\t\\\\t\\\\tshadowKernel[1] *= vec3(0.25);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\\\n\\\\t\\\\t\\\\t\\\\tshadowKernel[2] *= vec3(0.25);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\\\n\\\\t\\\\t\\\\t\\\\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec4 shadowValues;\\\\n\\\\t\\\\t\\\\t\\\\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\\\n\\\\t\\\\t\\\\t\\\\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\\\n\\\\t\\\\t\\\\t\\\\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\\\n\\\\t\\\\t\\\\t\\\\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tshadow = dot( shadowValues, vec4( 1.0 ) );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\\\n\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\\\n\\\\t\\\\t\\\\t\\\\tfloat fDepth = unpackDepth( rgbaDepth );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tif ( fDepth < shadowCoord.z )\\\\n\\\\n\\\\t\\\\t// spot with multiple shadows is darker\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\\\n\\\\n\\\\t\\\\t// spot with multiple shadows has the same color as single shadow spot\\\\n\\\\n\\\\t\\\\t// \\\\t\\\\t\\\\t\\\\t\\\\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\n\\\\t\\\\t#ifdef SHADOWMAP_DEBUG\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef SHADOWMAP_CASCADE\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\\\\n\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t}\\\\n\\\\n\\\\t#ifdef GAMMA_OUTPUT\\\\n\\\\n\\\\t\\\\tshadowColor *= shadowColor;\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\tgl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\\\\n\\\\n#endif\\\\n\\\";\\nTHREE.ShaderChunk.worldpos_vertex=\\\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\\\n\\\\n\\\\t#ifdef USE_SKINNING\\\\n\\\\n\\\\t\\\\tvec4 worldPosition = modelMatrix * skinned;\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\t#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\\\\n\\\\n\\\\t\\\\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\\\\n\\\\n\\\\t#endif\\\\n\\\\n\\\\t#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\\\\n\\\\n\\\\t\\\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\\n\\\\n\\\\t#endif\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.shadowmap_pars_fragment=\\\"#ifdef USE_SHADOWMAP\\\\n\\\\n\\\\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\\\\n\\\\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\\\\n\\\\n\\\\tuniform float shadowDarkness[ MAX_SHADOWS ];\\\\n\\\\tuniform float shadowBias[ MAX_SHADOWS ];\\\\n\\\\n\\\\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\\\n\\\\n\\\\tfloat unpackDepth( const in vec4 rgba_depth ) {\\\\n\\\\n\\\\t\\\\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\\\n\\\\t\\\\tfloat depth = dot( rgba_depth, bit_shift );\\\\n\\\\t\\\\treturn depth;\\\\n\\\\n\\\\t}\\\\n\\\\n#endif\\\";\\nTHREE.ShaderChunk.skinning_pars_vertex=\\\"#ifdef USE_SKINNING\\\\n\\\\n\\\\tuniform mat4 bindMatrix;\\\\n\\\\tuniform mat4 bindMatrixInverse;\\\\n\\\\n\\\\t#ifdef BONE_TEXTURE\\\\n\\\\n\\\\t\\\\tuniform sampler2D boneTexture;\\\\n\\\\t\\\\tuniform int boneTextureWidth;\\\\n\\\\t\\\\tuniform int boneTextureHeight;\\\\n\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\n\\\\t\\\\t\\\\tfloat j = i * 4.0;\\\\n\\\\t\\\\t\\\\tfloat x = mod( j, float( boneTextureWidth ) );\\\\n\\\\t\\\\t\\\\tfloat y = floor( j / float( boneTextureWidth ) );\\\\n\\\\n\\\\t\\\\t\\\\tfloat dx = 1.0 / float( boneTextureWidth );\\\\n\\\\t\\\\t\\\\tfloat dy = 1.0 / float( boneTextureHeight );\\\\n\\\\n\\\\t\\\\t\\\\ty = dy * ( y + 0.5 );\\\\n\\\\n\\\\t\\\\t\\\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\\\n\\\\n\\\\t\\\\t\\\\tmat4 bone = mat4( v1, v2, v3, v4 );\\\\n\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t#else\\\\n\\\\n\\\\t\\\\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\\\n\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\n\\\\t\\\\t\\\\tmat4 bone = boneGlobalMatrices[ int(i) ];\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t#endif\\\\n\\\\n#endif\\\\n\\\";\\nTHREE.ShaderChunk.logdepthbuf_pars_fragment=\\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\n\\\\tuniform float logDepthBufFC;\\\\n\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\n\\\\t\\\\t#extension GL_EXT_frag_depth : enable\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\n\\\\t#endif\\\\n\\\\n#endif\\\";THREE.ShaderChunk.alphamap_fragment=\\\"#ifdef USE_ALPHAMAP\\\\n\\\\n\\\\tgl_FragColor.a *= texture2D( alphaMap, vUv ).g;\\\\n\\\\n#endif\\\\n\\\";THREE.ShaderChunk.alphamap_pars_fragment=\\\"#ifdef USE_ALPHAMAP\\\\n\\\\n\\\\tuniform sampler2D alphaMap;\\\\n\\\\n#endif\\\\n\\\";\\nTHREE.UniformsUtils={merge:function(a){var b,c,d,e={};for(b=0;b<a.length;b++)for(c in d=this.clone(a[b]),d)e[c]=d[c];return e},clone:function(a){var b,c,d,e={};for(b in a)for(c in e[b]={},a[b])d=a[b][c],e[b][c]=d instanceof THREE.Color||d instanceof THREE.Vector2||d instanceof THREE.Vector3||d instanceof THREE.Vector4||d instanceof THREE.Matrix4||d instanceof THREE.Texture?d.clone():d instanceof Array?d.slice():d;return e}};\\nTHREE.UniformsLib={common:{diffuse:{type:\\\"c\\\",value:new THREE.Color(15658734)},opacity:{type:\\\"f\\\",value:1},map:{type:\\\"t\\\",value:null},offsetRepeat:{type:\\\"v4\\\",value:new THREE.Vector4(0,0,1,1)},lightMap:{type:\\\"t\\\",value:null},specularMap:{type:\\\"t\\\",value:null},alphaMap:{type:\\\"t\\\",value:null},envMap:{type:\\\"t\\\",value:null},flipEnvMap:{type:\\\"f\\\",value:-1},useRefract:{type:\\\"i\\\",value:0},reflectivity:{type:\\\"f\\\",value:1},refractionRatio:{type:\\\"f\\\",value:.98},combine:{type:\\\"i\\\",value:0},morphTargetInfluences:{type:\\\"f\\\",\\nvalue:0}},bump:{bumpMap:{type:\\\"t\\\",value:null},bumpScale:{type:\\\"f\\\",value:1}},normalmap:{normalMap:{type:\\\"t\\\",value:null},normalScale:{type:\\\"v2\\\",value:new THREE.Vector2(1,1)}},fog:{fogDensity:{type:\\\"f\\\",value:2.5E-4},fogNear:{type:\\\"f\\\",value:1},fogFar:{type:\\\"f\\\",value:2E3},fogColor:{type:\\\"c\\\",value:new THREE.Color(16777215)}},lights:{ambientLightColor:{type:\\\"fv\\\",value:[]},directionalLightDirection:{type:\\\"fv\\\",value:[]},directionalLightColor:{type:\\\"fv\\\",value:[]},hemisphereLightDirection:{type:\\\"fv\\\",value:[]},\\nhemisphereLightSkyColor:{type:\\\"fv\\\",value:[]},hemisphereLightGroundColor:{type:\\\"fv\\\",value:[]},pointLightColor:{type:\\\"fv\\\",value:[]},pointLightPosition:{type:\\\"fv\\\",value:[]},pointLightDistance:{type:\\\"fv1\\\",value:[]},spotLightColor:{type:\\\"fv\\\",value:[]},spotLightPosition:{type:\\\"fv\\\",value:[]},spotLightDirection:{type:\\\"fv\\\",value:[]},spotLightDistance:{type:\\\"fv1\\\",value:[]},spotLightAngleCos:{type:\\\"fv1\\\",value:[]},spotLightExponent:{type:\\\"fv1\\\",value:[]}},particle:{psColor:{type:\\\"c\\\",value:new THREE.Color(15658734)},\\nopacity:{type:\\\"f\\\",value:1},size:{type:\\\"f\\\",value:1},scale:{type:\\\"f\\\",value:1},map:{type:\\\"t\\\",value:null},fogDensity:{type:\\\"f\\\",value:2.5E-4},fogNear:{type:\\\"f\\\",value:1},fogFar:{type:\\\"f\\\",value:2E3},fogColor:{type:\\\"c\\\",value:new THREE.Color(16777215)}},shadowmap:{shadowMap:{type:\\\"tv\\\",value:[]},shadowMapSize:{type:\\\"v2v\\\",value:[]},shadowBias:{type:\\\"fv1\\\",value:[]},shadowDarkness:{type:\\\"fv1\\\",value:[]},shadowMatrix:{type:\\\"m4v\\\",value:[]}}};\\nTHREE.ShaderLib={basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.shadowmap]),vertexShader:[THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,\\\"void main() {\\\",THREE.ShaderChunk.map_vertex,\\nTHREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.skinbase_vertex,\\\"\\\\t#ifdef USE_ENVMAP\\\",THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,\\\"\\\\t#endif\\\",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.shadowmap_vertex,\\\"}\\\"].join(\\\"\\\\n\\\"),\\nfragmentShader:[\\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.alphamap_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,\\\"void main() {\\\\n\\\\tgl_FragColor = vec4( diffuse, opacity );\\\",THREE.ShaderChunk.logdepthbuf_fragment,\\nTHREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphamap_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,\\\"}\\\"].join(\\\"\\\\n\\\")},lambert:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,\\n{ambient:{type:\\\"c\\\",value:new THREE.Color(16777215)},emissive:{type:\\\"c\\\",value:new THREE.Color(0)},wrapRGB:{type:\\\"v3\\\",value:new THREE.Vector3(1,1,1)}}]),vertexShader:[\\\"#define LAMBERT\\\\nvarying vec3 vLightFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n#endif\\\",THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_lambert_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,\\nTHREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,\\\"void main() {\\\",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,THREE.ShaderChunk.worldpos_vertex,\\nTHREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_lambert_vertex,THREE.ShaderChunk.shadowmap_vertex,\\\"}\\\"].join(\\\"\\\\n\\\"),fragmentShader:[\\\"uniform float opacity;\\\\nvarying vec3 vLightFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n#endif\\\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.alphamap_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,\\nTHREE.ShaderChunk.specularmap_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,\\\"void main() {\\\\n\\\\tgl_FragColor = vec4( vec3( 1.0 ), opacity );\\\",THREE.ShaderChunk.logdepthbuf_fragment,THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphamap_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,\\\"\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\tif ( gl_FrontFacing )\\\\n\\\\t\\\\t\\\\tgl_FragColor.xyz *= vLightFront;\\\\n\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\tgl_FragColor.xyz *= vLightBack;\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_FragColor.xyz *= vLightFront;\\\\n\\\\t#endif\\\",\\nTHREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,\\\"}\\\"].join(\\\"\\\\n\\\")},phong:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.bump,THREE.UniformsLib.normalmap,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:\\\"c\\\",value:new THREE.Color(16777215)},emissive:{type:\\\"c\\\",value:new THREE.Color(0)},\\nspecular:{type:\\\"c\\\",value:new THREE.Color(1118481)},shininess:{type:\\\"f\\\",value:30},wrapRGB:{type:\\\"v3\\\",value:new THREE.Vector3(1,1,1)}}]),vertexShader:[\\\"#define PHONG\\\\nvarying vec3 vViewPosition;\\\\nvarying vec3 vNormal;\\\",THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_phong_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\\nTHREE.ShaderChunk.logdepthbuf_pars_vertex,\\\"void main() {\\\",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,\\\"\\\\tvNormal = normalize( transformedNormal );\\\",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,\\\"\\\\tvViewPosition = -mvPosition.xyz;\\\",\\nTHREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_phong_vertex,THREE.ShaderChunk.shadowmap_vertex,\\\"}\\\"].join(\\\"\\\\n\\\"),fragmentShader:[\\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\nuniform vec3 ambient;\\\\nuniform vec3 emissive;\\\\nuniform vec3 specular;\\\\nuniform float shininess;\\\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.alphamap_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,\\nTHREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.lights_phong_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.bumpmap_pars_fragment,THREE.ShaderChunk.normalmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,\\\"void main() {\\\\n\\\\tgl_FragColor = vec4( vec3( 1.0 ), opacity );\\\",THREE.ShaderChunk.logdepthbuf_fragment,THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphamap_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,\\nTHREE.ShaderChunk.lights_phong_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,\\\"}\\\"].join(\\\"\\\\n\\\")},particle_basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.particle,THREE.UniformsLib.shadowmap]),vertexShader:[\\\"uniform float size;\\\\nuniform float scale;\\\",THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\\nTHREE.ShaderChunk.logdepthbuf_pars_vertex,\\\"void main() {\\\",THREE.ShaderChunk.color_vertex,\\\"\\\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\t#ifdef USE_SIZEATTENUATION\\\\n\\\\t\\\\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_PointSize = size;\\\\n\\\\t#endif\\\\n\\\\tgl_Position = projectionMatrix * mvPosition;\\\",THREE.ShaderChunk.logdepthbuf_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.shadowmap_vertex,\\\"}\\\"].join(\\\"\\\\n\\\"),fragmentShader:[\\\"uniform vec3 psColor;\\\\nuniform float opacity;\\\",\\nTHREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_particle_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,\\\"void main() {\\\\n\\\\tgl_FragColor = vec4( psColor, opacity );\\\",THREE.ShaderChunk.logdepthbuf_fragment,THREE.ShaderChunk.map_particle_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.fog_fragment,\\\"}\\\"].join(\\\"\\\\n\\\")},dashed:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,\\nTHREE.UniformsLib.fog,{scale:{type:\\\"f\\\",value:1},dashSize:{type:\\\"f\\\",value:1},totalSize:{type:\\\"f\\\",value:2}}]),vertexShader:[\\\"uniform float scale;\\\\nattribute float lineDistance;\\\\nvarying float vLineDistance;\\\",THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,\\\"void main() {\\\",THREE.ShaderChunk.color_vertex,\\\"\\\\tvLineDistance = scale * lineDistance;\\\\n\\\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\tgl_Position = projectionMatrix * mvPosition;\\\",THREE.ShaderChunk.logdepthbuf_vertex,\\n\\\"}\\\"].join(\\\"\\\\n\\\"),fragmentShader:[\\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\nuniform float dashSize;\\\\nuniform float totalSize;\\\\nvarying float vLineDistance;\\\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,\\\"void main() {\\\\n\\\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\\\n\\\\t\\\\tdiscard;\\\\n\\\\t}\\\\n\\\\tgl_FragColor = vec4( diffuse, opacity );\\\",THREE.ShaderChunk.logdepthbuf_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.fog_fragment,\\n\\\"}\\\"].join(\\\"\\\\n\\\")},depth:{uniforms:{mNear:{type:\\\"f\\\",value:1},mFar:{type:\\\"f\\\",value:2E3},opacity:{type:\\\"f\\\",value:1}},vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,\\\"void main() {\\\",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,\\\"}\\\"].join(\\\"\\\\n\\\"),fragmentShader:[\\\"uniform float mNear;\\\\nuniform float mFar;\\\\nuniform float opacity;\\\",THREE.ShaderChunk.logdepthbuf_pars_fragment,\\\"void main() {\\\",THREE.ShaderChunk.logdepthbuf_fragment,\\n\\\"\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\\\n\\\\t#endif\\\\n\\\\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\\\\n\\\\tgl_FragColor = vec4( vec3( color ), opacity );\\\\n}\\\"].join(\\\"\\\\n\\\")},normal:{uniforms:{opacity:{type:\\\"f\\\",value:1}},vertexShader:[\\\"varying vec3 vNormal;\\\",THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,\\\"void main() {\\\\n\\\\tvNormal = normalize( normalMatrix * normal );\\\",\\nTHREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,\\\"}\\\"].join(\\\"\\\\n\\\"),fragmentShader:[\\\"uniform float opacity;\\\\nvarying vec3 vNormal;\\\",THREE.ShaderChunk.logdepthbuf_pars_fragment,\\\"void main() {\\\\n\\\\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\\\",THREE.ShaderChunk.logdepthbuf_fragment,\\\"}\\\"].join(\\\"\\\\n\\\")},normalmap:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{enableAO:{type:\\\"i\\\",\\nvalue:0},enableDiffuse:{type:\\\"i\\\",value:0},enableSpecular:{type:\\\"i\\\",value:0},enableReflection:{type:\\\"i\\\",value:0},enableDisplacement:{type:\\\"i\\\",value:0},tDisplacement:{type:\\\"t\\\",value:null},tDiffuse:{type:\\\"t\\\",value:null},tCube:{type:\\\"t\\\",value:null},tNormal:{type:\\\"t\\\",value:null},tSpecular:{type:\\\"t\\\",value:null},tAO:{type:\\\"t\\\",value:null},uNormalScale:{type:\\\"v2\\\",value:new THREE.Vector2(1,1)},uDisplacementBias:{type:\\\"f\\\",value:0},uDisplacementScale:{type:\\\"f\\\",value:1},diffuse:{type:\\\"c\\\",value:new THREE.Color(16777215)},\\nspecular:{type:\\\"c\\\",value:new THREE.Color(1118481)},ambient:{type:\\\"c\\\",value:new THREE.Color(16777215)},shininess:{type:\\\"f\\\",value:30},opacity:{type:\\\"f\\\",value:1},useRefract:{type:\\\"i\\\",value:0},refractionRatio:{type:\\\"f\\\",value:.98},reflectivity:{type:\\\"f\\\",value:.5},uOffset:{type:\\\"v2\\\",value:new THREE.Vector2(0,0)},uRepeat:{type:\\\"v2\\\",value:new THREE.Vector2(1,1)},wrapRGB:{type:\\\"v3\\\",value:new THREE.Vector3(1,1,1)}}]),fragmentShader:[\\\"uniform vec3 ambient;\\\\nuniform vec3 diffuse;\\\\nuniform vec3 specular;\\\\nuniform float shininess;\\\\nuniform float opacity;\\\\nuniform bool enableDiffuse;\\\\nuniform bool enableSpecular;\\\\nuniform bool enableAO;\\\\nuniform bool enableReflection;\\\\nuniform sampler2D tDiffuse;\\\\nuniform sampler2D tNormal;\\\\nuniform sampler2D tSpecular;\\\\nuniform sampler2D tAO;\\\\nuniform samplerCube tCube;\\\\nuniform vec2 uNormalScale;\\\\nuniform bool useRefract;\\\\nuniform float refractionRatio;\\\\nuniform float reflectivity;\\\\nvarying vec3 vTangent;\\\\nvarying vec3 vBinormal;\\\\nvarying vec3 vNormal;\\\\nvarying vec2 vUv;\\\\nuniform vec3 ambientLightColor;\\\\n#if MAX_DIR_LIGHTS > 0\\\\n\\\\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\\\n\\\\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\\\n#endif\\\\n#if MAX_HEMI_LIGHTS > 0\\\\n\\\\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\\\n\\\\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\\\n\\\\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\\\n#endif\\\\n#if MAX_POINT_LIGHTS > 0\\\\n\\\\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\\\n\\\\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\\\n\\\\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\\\n#endif\\\\n#if MAX_SPOT_LIGHTS > 0\\\\n\\\\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\\\n\\\\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\\\n#endif\\\\n#ifdef WRAP_AROUND\\\\n\\\\tuniform vec3 wrapRGB;\\\\n#endif\\\\nvarying vec3 vWorldPosition;\\\\nvarying vec3 vViewPosition;\\\",\\nTHREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,\\\"void main() {\\\",THREE.ShaderChunk.logdepthbuf_fragment,\\\"\\\\tgl_FragColor = vec4( vec3( 1.0 ), opacity );\\\\n\\\\tvec3 specularTex = vec3( 1.0 );\\\\n\\\\tvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\\\\n\\\\tnormalTex.xy *= uNormalScale;\\\\n\\\\tnormalTex = normalize( normalTex );\\\\n\\\\tif( enableDiffuse ) {\\\\n\\\\t\\\\t#ifdef GAMMA_INPUT\\\\n\\\\t\\\\t\\\\tvec4 texelColor = texture2D( tDiffuse, vUv );\\\\n\\\\t\\\\t\\\\ttexelColor.xyz *= texelColor.xyz;\\\\n\\\\t\\\\t\\\\tgl_FragColor = gl_FragColor * texelColor;\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tgl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n\\\\tif( enableAO ) {\\\\n\\\\t\\\\t#ifdef GAMMA_INPUT\\\\n\\\\t\\\\t\\\\tvec4 aoColor = texture2D( tAO, vUv );\\\\n\\\\t\\\\t\\\\taoColor.xyz *= aoColor.xyz;\\\\n\\\\t\\\\t\\\\tgl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tgl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\",\\nTHREE.ShaderChunk.alphatest_fragment,\\\"\\\\tif( enableSpecular )\\\\n\\\\t\\\\tspecularTex = texture2D( tSpecular, vUv ).xyz;\\\\n\\\\tmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\\\\n\\\\tvec3 finalNormal = tsb * normalTex;\\\\n\\\\t#ifdef FLIP_SIDED\\\\n\\\\t\\\\tfinalNormal = -finalNormal;\\\\n\\\\t#endif\\\\n\\\\tvec3 normal = normalize( finalNormal );\\\\n\\\\tvec3 viewPosition = normalize( vViewPosition );\\\\n\\\\t#if MAX_POINT_LIGHTS > 0\\\\n\\\\t\\\\tvec3 pointDiffuse = vec3( 0.0 );\\\\n\\\\t\\\\tvec3 pointSpecular = vec3( 0.0 );\\\\n\\\\t\\\\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\t\\\\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\\\n\\\\t\\\\t\\\\tvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\\\\n\\\\t\\\\t\\\\tfloat pointDistance = 1.0;\\\\n\\\\t\\\\t\\\\tif ( pointLightDistance[ i ] > 0.0 )\\\\n\\\\t\\\\t\\\\t\\\\tpointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\\\\n\\\\t\\\\t\\\\tpointVector = normalize( pointVector );\\\\n\\\\t\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\t\\\\t\\\\t\\\\tfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\tfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tpointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\\\\n\\\\t\\\\t\\\\tvec3 pointHalfVector = normalize( pointVector + viewPosition );\\\\n\\\\t\\\\t\\\\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\\\n\\\\t\\\\t\\\\tfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\\\n\\\\t\\\\t\\\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\\\n\\\\t\\\\t\\\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );\\\\n\\\\t\\\\t\\\\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if MAX_SPOT_LIGHTS > 0\\\\n\\\\t\\\\tvec3 spotDiffuse = vec3( 0.0 );\\\\n\\\\t\\\\tvec3 spotSpecular = vec3( 0.0 );\\\\n\\\\t\\\\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\t\\\\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\\\n\\\\t\\\\t\\\\tvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\\\\n\\\\t\\\\t\\\\tfloat spotDistance = 1.0;\\\\n\\\\t\\\\t\\\\tif ( spotLightDistance[ i ] > 0.0 )\\\\n\\\\t\\\\t\\\\t\\\\tspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\\\\n\\\\t\\\\t\\\\tspotVector = normalize( spotVector );\\\\n\\\\t\\\\t\\\\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\\\n\\\\t\\\\t\\\\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\\\n\\\\t\\\\t\\\\t\\\\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\\\n\\\\t\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\t\\\\tspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\\\\n\\\\t\\\\t\\\\t\\\\tvec3 spotHalfVector = normalize( spotVector + viewPosition );\\\\n\\\\t\\\\t\\\\t\\\\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\tfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\\\n\\\\t\\\\t\\\\t\\\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );\\\\n\\\\t\\\\t\\\\t\\\\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if MAX_DIR_LIGHTS > 0\\\\n\\\\t\\\\tvec3 dirDiffuse = vec3( 0.0 );\\\\n\\\\t\\\\tvec3 dirSpecular = vec3( 0.0 );\\\\n\\\\t\\\\tfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\\\\n\\\\t\\\\t\\\\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\\\n\\\\t\\\\t\\\\tvec3 dirVector = normalize( lDirection.xyz );\\\\n\\\\t\\\\t\\\\t#ifdef WRAP_AROUND\\\\n\\\\t\\\\t\\\\t\\\\tfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\tfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\tvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tdirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\\\\n\\\\t\\\\t\\\\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\\\n\\\\t\\\\t\\\\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\\\n\\\\t\\\\t\\\\tfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\\\n\\\\t\\\\t\\\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\\\n\\\\t\\\\t\\\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\\\n\\\\t\\\\t\\\\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if MAX_HEMI_LIGHTS > 0\\\\n\\\\t\\\\tvec3 hemiDiffuse = vec3( 0.0 );\\\\n\\\\t\\\\tvec3 hemiSpecular = vec3( 0.0 );\\\\n\\\\t\\\\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\t\\\\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\\\n\\\\t\\\\t\\\\tvec3 lVector = normalize( lDirection.xyz );\\\\n\\\\t\\\\t\\\\tfloat dotProduct = dot( normal, lVector );\\\\n\\\\t\\\\t\\\\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\\\n\\\\t\\\\t\\\\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\\\n\\\\t\\\\t\\\\themiDiffuse += diffuse * hemiColor;\\\\n\\\\t\\\\t\\\\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\\\n\\\\t\\\\t\\\\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\\\n\\\\t\\\\t\\\\tfloat hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\\\\n\\\\t\\\\t\\\\tvec3 lVectorGround = -lVector;\\\\n\\\\t\\\\t\\\\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\\\n\\\\t\\\\t\\\\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\\\n\\\\t\\\\t\\\\tfloat hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\\\\n\\\\t\\\\t\\\\tfloat dotProductGround = dot( normal, lVectorGround );\\\\n\\\\t\\\\t\\\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\\\n\\\\t\\\\t\\\\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\\\\n\\\\t\\\\t\\\\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\\\\n\\\\t\\\\t\\\\themiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n\\\\tvec3 totalDiffuse = vec3( 0.0 );\\\\n\\\\tvec3 totalSpecular = vec3( 0.0 );\\\\n\\\\t#if MAX_DIR_LIGHTS > 0\\\\n\\\\t\\\\ttotalDiffuse += dirDiffuse;\\\\n\\\\t\\\\ttotalSpecular += dirSpecular;\\\\n\\\\t#endif\\\\n\\\\t#if MAX_HEMI_LIGHTS > 0\\\\n\\\\t\\\\ttotalDiffuse += hemiDiffuse;\\\\n\\\\t\\\\ttotalSpecular += hemiSpecular;\\\\n\\\\t#endif\\\\n\\\\t#if MAX_POINT_LIGHTS > 0\\\\n\\\\t\\\\ttotalDiffuse += pointDiffuse;\\\\n\\\\t\\\\ttotalSpecular += pointSpecular;\\\\n\\\\t#endif\\\\n\\\\t#if MAX_SPOT_LIGHTS > 0\\\\n\\\\t\\\\ttotalDiffuse += spotDiffuse;\\\\n\\\\t\\\\ttotalSpecular += spotSpecular;\\\\n\\\\t#endif\\\\n\\\\t#ifdef METAL\\\\n\\\\t\\\\tgl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\\\n\\\\t#endif\\\\n\\\\tif ( enableReflection ) {\\\\n\\\\t\\\\tvec3 vReflect;\\\\n\\\\t\\\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\\\n\\\\t\\\\tif ( useRefract ) {\\\\n\\\\t\\\\t\\\\tvReflect = refract( cameraToVertex, normal, refractionRatio );\\\\n\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\tvReflect = reflect( cameraToVertex, normal );\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\\\\n\\\\t\\\\t#ifdef GAMMA_INPUT\\\\n\\\\t\\\\t\\\\tcubeColor.xyz *= cubeColor.xyz;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tgl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\\\\n\\\\t}\\\",\\nTHREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,\\\"}\\\"].join(\\\"\\\\n\\\"),vertexShader:[\\\"attribute vec4 tangent;\\\\nuniform vec2 uOffset;\\\\nuniform vec2 uRepeat;\\\\nuniform bool enableDisplacement;\\\\n#ifdef VERTEX_TEXTURES\\\\n\\\\tuniform sampler2D tDisplacement;\\\\n\\\\tuniform float uDisplacementScale;\\\\n\\\\tuniform float uDisplacementBias;\\\\n#endif\\\\nvarying vec3 vTangent;\\\\nvarying vec3 vBinormal;\\\\nvarying vec3 vNormal;\\\\nvarying vec2 vUv;\\\\nvarying vec3 vWorldPosition;\\\\nvarying vec3 vViewPosition;\\\",\\nTHREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,\\\"void main() {\\\",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,\\\"\\\\t#ifdef USE_SKINNING\\\\n\\\\t\\\\tvNormal = normalize( normalMatrix * skinnedNormal.xyz );\\\\n\\\\t\\\\tvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\\\\n\\\\t\\\\tvTangent = normalize( normalMatrix * skinnedTangent.xyz );\\\\n\\\\t#else\\\\n\\\\t\\\\tvNormal = normalize( normalMatrix * normal );\\\\n\\\\t\\\\tvTangent = normalize( normalMatrix * tangent.xyz );\\\\n\\\\t#endif\\\\n\\\\tvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\\\\n\\\\tvUv = uv * uRepeat + uOffset;\\\\n\\\\tvec3 displacedPosition;\\\\n\\\\t#ifdef VERTEX_TEXTURES\\\\n\\\\t\\\\tif ( enableDisplacement ) {\\\\n\\\\t\\\\t\\\\tvec3 dv = texture2D( tDisplacement, uv ).xyz;\\\\n\\\\t\\\\t\\\\tfloat df = uDisplacementScale * dv.x + uDisplacementBias;\\\\n\\\\t\\\\t\\\\tdisplacedPosition = position + normalize( normal ) * df;\\\\n\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\t#ifdef USE_SKINNING\\\\n\\\\t\\\\t\\\\t\\\\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\\\\n\\\\t\\\\t\\\\t\\\\tvec4 skinned = vec4( 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\tskinned += boneMatX * skinVertex * skinWeight.x;\\\\n\\\\t\\\\t\\\\t\\\\tskinned += boneMatY * skinVertex * skinWeight.y;\\\\n\\\\t\\\\t\\\\t\\\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\\\n\\\\t\\\\t\\\\t\\\\tskinned += boneMatW * skinVertex * skinWeight.w;\\\\n\\\\t\\\\t\\\\t\\\\tskinned  = bindMatrixInverse * skinned;\\\\n\\\\t\\\\t\\\\t\\\\tdisplacedPosition = skinned.xyz;\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tdisplacedPosition = position;\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t}\\\\n\\\\t#else\\\\n\\\\t\\\\t#ifdef USE_SKINNING\\\\n\\\\t\\\\t\\\\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\\\\n\\\\t\\\\t\\\\tvec4 skinned = vec4( 0.0 );\\\\n\\\\t\\\\t\\\\tskinned += boneMatX * skinVertex * skinWeight.x;\\\\n\\\\t\\\\t\\\\tskinned += boneMatY * skinVertex * skinWeight.y;\\\\n\\\\t\\\\t\\\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\\\n\\\\t\\\\t\\\\tskinned += boneMatW * skinVertex * skinWeight.w;\\\\n\\\\t\\\\t\\\\tskinned  = bindMatrixInverse * skinned;\\\\n\\\\t\\\\t\\\\tdisplacedPosition = skinned.xyz;\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tdisplacedPosition = position;\\\\n\\\\t\\\\t#endif\\\\n\\\\t#endif\\\\n\\\\tvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\\\\n\\\\tvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\\\\n\\\\tgl_Position = projectionMatrix * mvPosition;\\\",\\nTHREE.ShaderChunk.logdepthbuf_vertex,\\\"\\\\tvWorldPosition = worldPosition.xyz;\\\\n\\\\tvViewPosition = -mvPosition.xyz;\\\\n\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\\\n\\\\t\\\\t\\\\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n}\\\"].join(\\\"\\\\n\\\")},cube:{uniforms:{tCube:{type:\\\"t\\\",value:null},tFlip:{type:\\\"f\\\",value:-1}},vertexShader:[\\\"varying vec3 vWorldPosition;\\\",THREE.ShaderChunk.logdepthbuf_pars_vertex,\\\"void main() {\\\\n\\\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\\n\\\\tvWorldPosition = worldPosition.xyz;\\\\n\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\",\\nTHREE.ShaderChunk.logdepthbuf_vertex,\\\"}\\\"].join(\\\"\\\\n\\\"),fragmentShader:[\\\"uniform samplerCube tCube;\\\\nuniform float tFlip;\\\\nvarying vec3 vWorldPosition;\\\",THREE.ShaderChunk.logdepthbuf_pars_fragment,\\\"void main() {\\\\n\\\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\\",THREE.ShaderChunk.logdepthbuf_fragment,\\\"}\\\"].join(\\\"\\\\n\\\")},depthRGBA:{uniforms:{},vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,\\n\\\"void main() {\\\",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,\\\"}\\\"].join(\\\"\\\\n\\\"),fragmentShader:[THREE.ShaderChunk.logdepthbuf_pars_fragment,\\\"vec4 pack_depth( const in float depth ) {\\\\n\\\\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\\\n\\\\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\\\n\\\\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\\\\n\\\\tres -= res.xxyz * bit_mask;\\\\n\\\\treturn res;\\\\n}\\\\nvoid main() {\\\",\\nTHREE.ShaderChunk.logdepthbuf_fragment,\\\"\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\\\\n\\\\t#endif\\\\n}\\\"].join(\\\"\\\\n\\\")}};\\nTHREE.WebGLRenderer=function(a){function b(a,b){var c=a.vertices.length,d=b.material;if(d.attributes){void 0===a.__webglCustomAttributesList&&(a.__webglCustomAttributesList=[]);for(var e in d.attributes){var f=d.attributes[e];if(!f.__webglInitialized||f.createUniqueBuffers){f.__webglInitialized=!0;var g=1;\\\"v2\\\"===f.type?g=2:\\\"v3\\\"===f.type?g=3:\\\"v4\\\"===f.type?g=4:\\\"c\\\"===f.type&&(g=3);f.size=g;f.array=new Float32Array(c*g);f.buffer=m.createBuffer();f.buffer.belongsToAttribute=e;f.needsUpdate=!0}a.__webglCustomAttributesList.push(f)}}}\\nfunction c(a,b){var c=b.geometry,g=a.faces3,h=3*g.length,k=1*g.length,l=3*g.length,g=d(b,a),n=f(g),r=e(g),p=g.vertexColors?g.vertexColors:!1;a.__vertexArray=new Float32Array(3*h);r&&(a.__normalArray=new Float32Array(3*h));c.hasTangents&&(a.__tangentArray=new Float32Array(4*h));p&&(a.__colorArray=new Float32Array(3*h));n&&(0<c.faceVertexUvs.length&&(a.__uvArray=new Float32Array(2*h)),1<c.faceVertexUvs.length&&(a.__uv2Array=new Float32Array(2*h)));b.geometry.skinWeights.length&&b.geometry.skinIndices.length&&\\n(a.__skinIndexArray=new Float32Array(4*h),a.__skinWeightArray=new Float32Array(4*h));c=null!==Eb&&21845<k?Uint32Array:Uint16Array;a.__typeArray=c;a.__faceArray=new c(3*k);a.__lineArray=new c(2*l);if(a.numMorphTargets)for(a.__morphTargetsArrays=[],c=0,n=a.numMorphTargets;c<n;c++)a.__morphTargetsArrays.push(new Float32Array(3*h));if(a.numMorphNormals)for(a.__morphNormalsArrays=[],c=0,n=a.numMorphNormals;c<n;c++)a.__morphNormalsArrays.push(new Float32Array(3*h));a.__webglFaceCount=3*k;a.__webglLineCount=\\n2*l;if(g.attributes){void 0===a.__webglCustomAttributesList&&(a.__webglCustomAttributesList=[]);for(var q in g.attributes){var k=g.attributes[q],l={},s;for(s in k)l[s]=k[s];if(!l.__webglInitialized||l.createUniqueBuffers)l.__webglInitialized=!0,c=1,\\\"v2\\\"===l.type?c=2:\\\"v3\\\"===l.type?c=3:\\\"v4\\\"===l.type?c=4:\\\"c\\\"===l.type&&(c=3),l.size=c,l.array=new Float32Array(h*c),l.buffer=m.createBuffer(),l.buffer.belongsToAttribute=q,k.needsUpdate=!0,l.__original=k;a.__webglCustomAttributesList.push(l)}}a.__inittedArrays=\\n!0}function d(a,b){return a.material instanceof THREE.MeshFaceMaterial?a.material.materials[b.materialIndex]:a.material}function e(a){return a instanceof THREE.MeshBasicMaterial&&!a.envMap||a instanceof THREE.MeshDepthMaterial?!1:a&&void 0!==a.shading&&a.shading===THREE.SmoothShading?THREE.SmoothShading:THREE.FlatShading}function f(a){return a.map||a.lightMap||a.bumpMap||a.normalMap||a.specularMap||a.alphaMap||a instanceof THREE.ShaderMaterial?!0:!1}function g(a){for(var b in a.attributes){var c=\\n\\\"index\\\"===b?m.ELEMENT_ARRAY_BUFFER:m.ARRAY_BUFFER,d=a.attributes[b];d.buffer=m.createBuffer();m.bindBuffer(c,d.buffer);m.bufferData(c,d.array,m.STATIC_DRAW)}}function h(a,b,c,d){for(var e in b){var f=b[e],g=c[e];if(0<=f)if(g){var h=g.itemSize;m.bindBuffer(m.ARRAY_BUFFER,g.buffer);l(f);m.vertexAttribPointer(f,h,m.FLOAT,!1,0,d*h*4)}else a.defaultAttributeValues&&(2===a.defaultAttributeValues[e].length?m.vertexAttrib2fv(f,a.defaultAttributeValues[e]):3===a.defaultAttributeValues[e].length&&m.vertexAttrib3fv(f,\\na.defaultAttributeValues[e]))}n()}function k(){for(var a=0,b=pb.length;a<b;a++)pb[a]=0}function l(a){pb[a]=1;0===tb[a]&&(m.enableVertexAttribArray(a),tb[a]=1)}function n(){for(var a=0,b=tb.length;a<b;a++)tb[a]!==pb[a]&&(m.disableVertexAttribArray(a),tb[a]=0)}function q(a,b){return a.z!==b.z?b.z-a.z:a.id-b.id}function r(a,b){return a.z!==b.z?a.z-b.z:a.id-b.id}function t(a,b){return b[0]-a[0]}function s(a,b,h){if(!1!==b.visible){var k=a.__webglObjects[b.id];if(k&&(!1===b.frustumCulled||!0===jc.intersectsObject(b))){var l=\\nb.geometry,n,r,p;if(l instanceof THREE.BufferGeometry){var q=m.DYNAMIC_DRAW,w=l.attributes,u,v;for(u in w)v=w[u],v.needsUpdate&&(\\\"index\\\"===u?(m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,v.buffer),m.bufferData(m.ELEMENT_ARRAY_BUFFER,v.array,q)):(m.bindBuffer(m.ARRAY_BUFFER,v.buffer),m.bufferData(m.ARRAY_BUFFER,v.array,q)),v.needsUpdate=!1)}else if(b instanceof THREE.Mesh){if(l.buffersNeedUpdate||l.groupsNeedUpdate)l instanceof THREE.BufferGeometry?g(l):b instanceof THREE.Mesh&&D(a,b,l);for(var A=0,z=l.geometryGroupsList.length;A<\\nz;A++)if(n=l.geometryGroupsList[A],p=d(b,n),(l.buffersNeedUpdate||l.groupsNeedUpdate)&&c(n,b),r=p.attributes&&x(p),l.verticesNeedUpdate||l.morphTargetsNeedUpdate||l.elementsNeedUpdate||l.uvsNeedUpdate||l.normalsNeedUpdate||l.colorsNeedUpdate||l.tangentsNeedUpdate||r){var y=n,E=b,I=m.DYNAMIC_DRAW,J=!l.dynamic,L=p;if(y.__inittedArrays){var K=e(L),H=L.vertexColors?L.vertexColors:!1,Q=f(L),O=K===THREE.SmoothShading,B=void 0,N=void 0,P=void 0,T=void 0,R=void 0,ba=void 0,S=void 0,$=void 0,X=void 0,V=void 0,\\nza=void 0,ga=void 0,ha=void 0,ia=void 0,Ea=void 0,aa=void 0,da=void 0,ya=void 0,U=void 0,ca=void 0,W=void 0,Ba=void 0,Aa=void 0,la=void 0,ma=void 0,oa=void 0,ra=void 0,ua=void 0,va=void 0,ja=void 0,Fa=void 0,Da=void 0,Ga=void 0,Ya=void 0,qa=void 0,Ka=void 0,xa=void 0,Ca=void 0,Ja=void 0,Qa=void 0,db=0,eb=0,Sa=0,Za=0,Ta=0,gb=0,Ua=0,ub=0,$a=0,wa=0,Ha=0,M=0,Ra=void 0,hb=y.__vertexArray,cb=y.__uvArray,fb=y.__uv2Array,yb=y.__normalArray,Va=y.__tangentArray,ib=y.__colorArray,Wa=y.__skinIndexArray,Xa=y.__skinWeightArray,\\ntb=y.__morphTargetsArrays,wb=y.__morphNormalsArrays,sb=y.__webglCustomAttributesList,F=void 0,pb=y.__faceArray,zb=y.__lineArray,La=E.geometry,Db=La.elementsNeedUpdate,xb=La.uvsNeedUpdate,Eb=La.normalsNeedUpdate,Ob=La.tangentsNeedUpdate,Pb=La.colorsNeedUpdate,Sb=La.morphTargetsNeedUpdate,lc=La.vertices,ka=y.faces3,jb=La.faces,Hb=La.faceVertexUvs[0],Ib=La.faceVertexUvs[1],mc=La.skinIndices,Vb=La.skinWeights,Wb=La.morphTargets,Jb=La.morphNormals;if(La.verticesNeedUpdate){B=0;for(N=ka.length;B<N;B++)T=\\njb[ka[B]],ga=lc[T.a],ha=lc[T.b],ia=lc[T.c],hb[eb]=ga.x,hb[eb+1]=ga.y,hb[eb+2]=ga.z,hb[eb+3]=ha.x,hb[eb+4]=ha.y,hb[eb+5]=ha.z,hb[eb+6]=ia.x,hb[eb+7]=ia.y,hb[eb+8]=ia.z,eb+=9;m.bindBuffer(m.ARRAY_BUFFER,y.__webglVertexBuffer);m.bufferData(m.ARRAY_BUFFER,hb,I)}if(Sb)for(qa=0,Ka=Wb.length;qa<Ka;qa++){B=Ha=0;for(N=ka.length;B<N;B++)Ja=ka[B],T=jb[Ja],ga=Wb[qa].vertices[T.a],ha=Wb[qa].vertices[T.b],ia=Wb[qa].vertices[T.c],xa=tb[qa],xa[Ha]=ga.x,xa[Ha+1]=ga.y,xa[Ha+2]=ga.z,xa[Ha+3]=ha.x,xa[Ha+4]=ha.y,xa[Ha+\\n5]=ha.z,xa[Ha+6]=ia.x,xa[Ha+7]=ia.y,xa[Ha+8]=ia.z,L.morphNormals&&(O?(Qa=Jb[qa].vertexNormals[Ja],ya=Qa.a,U=Qa.b,ca=Qa.c):ca=U=ya=Jb[qa].faceNormals[Ja],Ca=wb[qa],Ca[Ha]=ya.x,Ca[Ha+1]=ya.y,Ca[Ha+2]=ya.z,Ca[Ha+3]=U.x,Ca[Ha+4]=U.y,Ca[Ha+5]=U.z,Ca[Ha+6]=ca.x,Ca[Ha+7]=ca.y,Ca[Ha+8]=ca.z),Ha+=9;m.bindBuffer(m.ARRAY_BUFFER,y.__webglMorphTargetsBuffers[qa]);m.bufferData(m.ARRAY_BUFFER,tb[qa],I);L.morphNormals&&(m.bindBuffer(m.ARRAY_BUFFER,y.__webglMorphNormalsBuffers[qa]),m.bufferData(m.ARRAY_BUFFER,wb[qa],\\nI))}if(Vb.length){B=0;for(N=ka.length;B<N;B++)T=jb[ka[B]],la=Vb[T.a],ma=Vb[T.b],oa=Vb[T.c],Xa[wa]=la.x,Xa[wa+1]=la.y,Xa[wa+2]=la.z,Xa[wa+3]=la.w,Xa[wa+4]=ma.x,Xa[wa+5]=ma.y,Xa[wa+6]=ma.z,Xa[wa+7]=ma.w,Xa[wa+8]=oa.x,Xa[wa+9]=oa.y,Xa[wa+10]=oa.z,Xa[wa+11]=oa.w,ra=mc[T.a],ua=mc[T.b],va=mc[T.c],Wa[wa]=ra.x,Wa[wa+1]=ra.y,Wa[wa+2]=ra.z,Wa[wa+3]=ra.w,Wa[wa+4]=ua.x,Wa[wa+5]=ua.y,Wa[wa+6]=ua.z,Wa[wa+7]=ua.w,Wa[wa+8]=va.x,Wa[wa+9]=va.y,Wa[wa+10]=va.z,Wa[wa+11]=va.w,wa+=12;0<wa&&(m.bindBuffer(m.ARRAY_BUFFER,\\ny.__webglSkinIndicesBuffer),m.bufferData(m.ARRAY_BUFFER,Wa,I),m.bindBuffer(m.ARRAY_BUFFER,y.__webglSkinWeightsBuffer),m.bufferData(m.ARRAY_BUFFER,Xa,I))}if(Pb&&H){B=0;for(N=ka.length;B<N;B++)T=jb[ka[B]],S=T.vertexColors,$=T.color,3===S.length&&H===THREE.VertexColors?(W=S[0],Ba=S[1],Aa=S[2]):Aa=Ba=W=$,ib[$a]=W.r,ib[$a+1]=W.g,ib[$a+2]=W.b,ib[$a+3]=Ba.r,ib[$a+4]=Ba.g,ib[$a+5]=Ba.b,ib[$a+6]=Aa.r,ib[$a+7]=Aa.g,ib[$a+8]=Aa.b,$a+=9;0<$a&&(m.bindBuffer(m.ARRAY_BUFFER,y.__webglColorBuffer),m.bufferData(m.ARRAY_BUFFER,\\nib,I))}if(Ob&&La.hasTangents){B=0;for(N=ka.length;B<N;B++)T=jb[ka[B]],X=T.vertexTangents,Ea=X[0],aa=X[1],da=X[2],Va[Ua]=Ea.x,Va[Ua+1]=Ea.y,Va[Ua+2]=Ea.z,Va[Ua+3]=Ea.w,Va[Ua+4]=aa.x,Va[Ua+5]=aa.y,Va[Ua+6]=aa.z,Va[Ua+7]=aa.w,Va[Ua+8]=da.x,Va[Ua+9]=da.y,Va[Ua+10]=da.z,Va[Ua+11]=da.w,Ua+=12;m.bindBuffer(m.ARRAY_BUFFER,y.__webglTangentBuffer);m.bufferData(m.ARRAY_BUFFER,Va,I)}if(Eb&&K){B=0;for(N=ka.length;B<N;B++)if(T=jb[ka[B]],R=T.vertexNormals,ba=T.normal,3===R.length&&O)for(ja=0;3>ja;ja++)Da=R[ja],\\nyb[gb]=Da.x,yb[gb+1]=Da.y,yb[gb+2]=Da.z,gb+=3;else for(ja=0;3>ja;ja++)yb[gb]=ba.x,yb[gb+1]=ba.y,yb[gb+2]=ba.z,gb+=3;m.bindBuffer(m.ARRAY_BUFFER,y.__webglNormalBuffer);m.bufferData(m.ARRAY_BUFFER,yb,I)}if(xb&&Hb&&Q){B=0;for(N=ka.length;B<N;B++)if(P=ka[B],V=Hb[P],void 0!==V)for(ja=0;3>ja;ja++)Ga=V[ja],cb[Sa]=Ga.x,cb[Sa+1]=Ga.y,Sa+=2;0<Sa&&(m.bindBuffer(m.ARRAY_BUFFER,y.__webglUVBuffer),m.bufferData(m.ARRAY_BUFFER,cb,I))}if(xb&&Ib&&Q){B=0;for(N=ka.length;B<N;B++)if(P=ka[B],za=Ib[P],void 0!==za)for(ja=\\n0;3>ja;ja++)Ya=za[ja],fb[Za]=Ya.x,fb[Za+1]=Ya.y,Za+=2;0<Za&&(m.bindBuffer(m.ARRAY_BUFFER,y.__webglUV2Buffer),m.bufferData(m.ARRAY_BUFFER,fb,I))}if(Db){B=0;for(N=ka.length;B<N;B++)pb[Ta]=db,pb[Ta+1]=db+1,pb[Ta+2]=db+2,Ta+=3,zb[ub]=db,zb[ub+1]=db+1,zb[ub+2]=db,zb[ub+3]=db+2,zb[ub+4]=db+1,zb[ub+5]=db+2,ub+=6,db+=3;m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,y.__webglFaceBuffer);m.bufferData(m.ELEMENT_ARRAY_BUFFER,pb,I);m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,y.__webglLineBuffer);m.bufferData(m.ELEMENT_ARRAY_BUFFER,\\nzb,I)}if(sb)for(ja=0,Fa=sb.length;ja<Fa;ja++)if(F=sb[ja],F.__original.needsUpdate){M=0;if(1===F.size)if(void 0===F.boundTo||\\\"vertices\\\"===F.boundTo)for(B=0,N=ka.length;B<N;B++)T=jb[ka[B]],F.array[M]=F.value[T.a],F.array[M+1]=F.value[T.b],F.array[M+2]=F.value[T.c],M+=3;else{if(\\\"faces\\\"===F.boundTo)for(B=0,N=ka.length;B<N;B++)Ra=F.value[ka[B]],F.array[M]=Ra,F.array[M+1]=Ra,F.array[M+2]=Ra,M+=3}else if(2===F.size)if(void 0===F.boundTo||\\\"vertices\\\"===F.boundTo)for(B=0,N=ka.length;B<N;B++)T=jb[ka[B]],ga=\\nF.value[T.a],ha=F.value[T.b],ia=F.value[T.c],F.array[M]=ga.x,F.array[M+1]=ga.y,F.array[M+2]=ha.x,F.array[M+3]=ha.y,F.array[M+4]=ia.x,F.array[M+5]=ia.y,M+=6;else{if(\\\"faces\\\"===F.boundTo)for(B=0,N=ka.length;B<N;B++)ia=ha=ga=Ra=F.value[ka[B]],F.array[M]=ga.x,F.array[M+1]=ga.y,F.array[M+2]=ha.x,F.array[M+3]=ha.y,F.array[M+4]=ia.x,F.array[M+5]=ia.y,M+=6}else if(3===F.size){var ta;ta=\\\"c\\\"===F.type?[\\\"r\\\",\\\"g\\\",\\\"b\\\"]:[\\\"x\\\",\\\"y\\\",\\\"z\\\"];if(void 0===F.boundTo||\\\"vertices\\\"===F.boundTo)for(B=0,N=ka.length;B<N;B++)T=jb[ka[B]],\\nga=F.value[T.a],ha=F.value[T.b],ia=F.value[T.c],F.array[M]=ga[ta[0]],F.array[M+1]=ga[ta[1]],F.array[M+2]=ga[ta[2]],F.array[M+3]=ha[ta[0]],F.array[M+4]=ha[ta[1]],F.array[M+5]=ha[ta[2]],F.array[M+6]=ia[ta[0]],F.array[M+7]=ia[ta[1]],F.array[M+8]=ia[ta[2]],M+=9;else if(\\\"faces\\\"===F.boundTo)for(B=0,N=ka.length;B<N;B++)ia=ha=ga=Ra=F.value[ka[B]],F.array[M]=ga[ta[0]],F.array[M+1]=ga[ta[1]],F.array[M+2]=ga[ta[2]],F.array[M+3]=ha[ta[0]],F.array[M+4]=ha[ta[1]],F.array[M+5]=ha[ta[2]],F.array[M+6]=ia[ta[0]],F.array[M+\\n7]=ia[ta[1]],F.array[M+8]=ia[ta[2]],M+=9;else if(\\\"faceVertices\\\"===F.boundTo)for(B=0,N=ka.length;B<N;B++)Ra=F.value[ka[B]],ga=Ra[0],ha=Ra[1],ia=Ra[2],F.array[M]=ga[ta[0]],F.array[M+1]=ga[ta[1]],F.array[M+2]=ga[ta[2]],F.array[M+3]=ha[ta[0]],F.array[M+4]=ha[ta[1]],F.array[M+5]=ha[ta[2]],F.array[M+6]=ia[ta[0]],F.array[M+7]=ia[ta[1]],F.array[M+8]=ia[ta[2]],M+=9}else if(4===F.size)if(void 0===F.boundTo||\\\"vertices\\\"===F.boundTo)for(B=0,N=ka.length;B<N;B++)T=jb[ka[B]],ga=F.value[T.a],ha=F.value[T.b],ia=F.value[T.c],\\nF.array[M]=ga.x,F.array[M+1]=ga.y,F.array[M+2]=ga.z,F.array[M+3]=ga.w,F.array[M+4]=ha.x,F.array[M+5]=ha.y,F.array[M+6]=ha.z,F.array[M+7]=ha.w,F.array[M+8]=ia.x,F.array[M+9]=ia.y,F.array[M+10]=ia.z,F.array[M+11]=ia.w,M+=12;else if(\\\"faces\\\"===F.boundTo)for(B=0,N=ka.length;B<N;B++)ia=ha=ga=Ra=F.value[ka[B]],F.array[M]=ga.x,F.array[M+1]=ga.y,F.array[M+2]=ga.z,F.array[M+3]=ga.w,F.array[M+4]=ha.x,F.array[M+5]=ha.y,F.array[M+6]=ha.z,F.array[M+7]=ha.w,F.array[M+8]=ia.x,F.array[M+9]=ia.y,F.array[M+10]=ia.z,\\nF.array[M+11]=ia.w,M+=12;else if(\\\"faceVertices\\\"===F.boundTo)for(B=0,N=ka.length;B<N;B++)Ra=F.value[ka[B]],ga=Ra[0],ha=Ra[1],ia=Ra[2],F.array[M]=ga.x,F.array[M+1]=ga.y,F.array[M+2]=ga.z,F.array[M+3]=ga.w,F.array[M+4]=ha.x,F.array[M+5]=ha.y,F.array[M+6]=ha.z,F.array[M+7]=ha.w,F.array[M+8]=ia.x,F.array[M+9]=ia.y,F.array[M+10]=ia.z,F.array[M+11]=ia.w,M+=12;m.bindBuffer(m.ARRAY_BUFFER,F.buffer);m.bufferData(m.ARRAY_BUFFER,F.array,I)}J&&(delete y.__inittedArrays,delete y.__colorArray,delete y.__normalArray,\\ndelete y.__tangentArray,delete y.__uvArray,delete y.__uv2Array,delete y.__faceArray,delete y.__vertexArray,delete y.__lineArray,delete y.__skinIndexArray,delete y.__skinWeightArray)}}l.verticesNeedUpdate=!1;l.morphTargetsNeedUpdate=!1;l.elementsNeedUpdate=!1;l.uvsNeedUpdate=!1;l.normalsNeedUpdate=!1;l.colorsNeedUpdate=!1;l.tangentsNeedUpdate=!1;l.buffersNeedUpdate=!1;p.attributes&&C(p)}else if(b instanceof THREE.Line){p=d(b,l);r=p.attributes&&x(p);if(l.verticesNeedUpdate||l.colorsNeedUpdate||l.lineDistancesNeedUpdate||\\nr){var Xb=m.DYNAMIC_DRAW,Kb,Lb,Mb,Yb,sa,Zb,Nb=l.vertices,Qb=l.colors,Rb=l.lineDistances,ec=Nb.length,fc=Qb.length,gc=Rb.length,$b=l.__vertexArray,ac=l.__colorArray,Tb=l.__lineDistanceArray,hc=l.colorsNeedUpdate,ic=l.lineDistancesNeedUpdate,nc=l.__webglCustomAttributesList,bc,uc,Ia,Fb,Ma,pa;if(l.verticesNeedUpdate){for(Kb=0;Kb<ec;Kb++)Yb=Nb[Kb],sa=3*Kb,$b[sa]=Yb.x,$b[sa+1]=Yb.y,$b[sa+2]=Yb.z;m.bindBuffer(m.ARRAY_BUFFER,l.__webglVertexBuffer);m.bufferData(m.ARRAY_BUFFER,$b,Xb)}if(hc){for(Lb=0;Lb<fc;Lb++)Zb=\\nQb[Lb],sa=3*Lb,ac[sa]=Zb.r,ac[sa+1]=Zb.g,ac[sa+2]=Zb.b;m.bindBuffer(m.ARRAY_BUFFER,l.__webglColorBuffer);m.bufferData(m.ARRAY_BUFFER,ac,Xb)}if(ic){for(Mb=0;Mb<gc;Mb++)Tb[Mb]=Rb[Mb];m.bindBuffer(m.ARRAY_BUFFER,l.__webglLineDistanceBuffer);m.bufferData(m.ARRAY_BUFFER,Tb,Xb)}if(nc)for(bc=0,uc=nc.length;bc<uc;bc++)if(pa=nc[bc],pa.needsUpdate&&(void 0===pa.boundTo||\\\"vertices\\\"===pa.boundTo)){sa=0;Fb=pa.value.length;if(1===pa.size)for(Ia=0;Ia<Fb;Ia++)pa.array[Ia]=pa.value[Ia];else if(2===pa.size)for(Ia=\\n0;Ia<Fb;Ia++)Ma=pa.value[Ia],pa.array[sa]=Ma.x,pa.array[sa+1]=Ma.y,sa+=2;else if(3===pa.size)if(\\\"c\\\"===pa.type)for(Ia=0;Ia<Fb;Ia++)Ma=pa.value[Ia],pa.array[sa]=Ma.r,pa.array[sa+1]=Ma.g,pa.array[sa+2]=Ma.b,sa+=3;else for(Ia=0;Ia<Fb;Ia++)Ma=pa.value[Ia],pa.array[sa]=Ma.x,pa.array[sa+1]=Ma.y,pa.array[sa+2]=Ma.z,sa+=3;else if(4===pa.size)for(Ia=0;Ia<Fb;Ia++)Ma=pa.value[Ia],pa.array[sa]=Ma.x,pa.array[sa+1]=Ma.y,pa.array[sa+2]=Ma.z,pa.array[sa+3]=Ma.w,sa+=4;m.bindBuffer(m.ARRAY_BUFFER,pa.buffer);m.bufferData(m.ARRAY_BUFFER,\\npa.array,Xb)}}l.verticesNeedUpdate=!1;l.colorsNeedUpdate=!1;l.lineDistancesNeedUpdate=!1;p.attributes&&C(p)}else if(b instanceof THREE.PointCloud){p=d(b,l);r=p.attributes&&x(p);if(l.verticesNeedUpdate||l.colorsNeedUpdate||b.sortParticles||r){var oc=m.DYNAMIC_DRAW,Na,kb,lb,Z,mb,vb,cc=l.vertices,pc=cc.length,qc=l.colors,vc=qc.length,Ab=l.__vertexArray,Bb=l.__colorArray,qb=l.__sortArray,wc=l.verticesNeedUpdate,xc=l.colorsNeedUpdate,rb=l.__webglCustomAttributesList,ab,Gb,fa,bb,na,Y;if(b.sortParticles){kc.copy(Ub);\\nkc.multiply(b.matrixWorld);for(Na=0;Na<pc;Na++)lb=cc[Na],ea.copy(lb),ea.applyProjection(kc),qb[Na]=[ea.z,Na];qb.sort(t);for(Na=0;Na<pc;Na++)lb=cc[qb[Na][1]],Z=3*Na,Ab[Z]=lb.x,Ab[Z+1]=lb.y,Ab[Z+2]=lb.z;for(kb=0;kb<vc;kb++)Z=3*kb,vb=qc[qb[kb][1]],Bb[Z]=vb.r,Bb[Z+1]=vb.g,Bb[Z+2]=vb.b;if(rb)for(ab=0,Gb=rb.length;ab<Gb;ab++)if(Y=rb[ab],void 0===Y.boundTo||\\\"vertices\\\"===Y.boundTo)if(Z=0,bb=Y.value.length,1===Y.size)for(fa=0;fa<bb;fa++)mb=qb[fa][1],Y.array[fa]=Y.value[mb];else if(2===Y.size)for(fa=0;fa<bb;fa++)mb=\\nqb[fa][1],na=Y.value[mb],Y.array[Z]=na.x,Y.array[Z+1]=na.y,Z+=2;else if(3===Y.size)if(\\\"c\\\"===Y.type)for(fa=0;fa<bb;fa++)mb=qb[fa][1],na=Y.value[mb],Y.array[Z]=na.r,Y.array[Z+1]=na.g,Y.array[Z+2]=na.b,Z+=3;else for(fa=0;fa<bb;fa++)mb=qb[fa][1],na=Y.value[mb],Y.array[Z]=na.x,Y.array[Z+1]=na.y,Y.array[Z+2]=na.z,Z+=3;else if(4===Y.size)for(fa=0;fa<bb;fa++)mb=qb[fa][1],na=Y.value[mb],Y.array[Z]=na.x,Y.array[Z+1]=na.y,Y.array[Z+2]=na.z,Y.array[Z+3]=na.w,Z+=4}else{if(wc)for(Na=0;Na<pc;Na++)lb=cc[Na],Z=3*\\nNa,Ab[Z]=lb.x,Ab[Z+1]=lb.y,Ab[Z+2]=lb.z;if(xc)for(kb=0;kb<vc;kb++)vb=qc[kb],Z=3*kb,Bb[Z]=vb.r,Bb[Z+1]=vb.g,Bb[Z+2]=vb.b;if(rb)for(ab=0,Gb=rb.length;ab<Gb;ab++)if(Y=rb[ab],Y.needsUpdate&&(void 0===Y.boundTo||\\\"vertices\\\"===Y.boundTo))if(bb=Y.value.length,Z=0,1===Y.size)for(fa=0;fa<bb;fa++)Y.array[fa]=Y.value[fa];else if(2===Y.size)for(fa=0;fa<bb;fa++)na=Y.value[fa],Y.array[Z]=na.x,Y.array[Z+1]=na.y,Z+=2;else if(3===Y.size)if(\\\"c\\\"===Y.type)for(fa=0;fa<bb;fa++)na=Y.value[fa],Y.array[Z]=na.r,Y.array[Z+1]=\\nna.g,Y.array[Z+2]=na.b,Z+=3;else for(fa=0;fa<bb;fa++)na=Y.value[fa],Y.array[Z]=na.x,Y.array[Z+1]=na.y,Y.array[Z+2]=na.z,Z+=3;else if(4===Y.size)for(fa=0;fa<bb;fa++)na=Y.value[fa],Y.array[Z]=na.x,Y.array[Z+1]=na.y,Y.array[Z+2]=na.z,Y.array[Z+3]=na.w,Z+=4}if(wc||b.sortParticles)m.bindBuffer(m.ARRAY_BUFFER,l.__webglVertexBuffer),m.bufferData(m.ARRAY_BUFFER,Ab,oc);if(xc||b.sortParticles)m.bindBuffer(m.ARRAY_BUFFER,l.__webglColorBuffer),m.bufferData(m.ARRAY_BUFFER,Bb,oc);if(rb)for(ab=0,Gb=rb.length;ab<\\nGb;ab++)if(Y=rb[ab],Y.needsUpdate||b.sortParticles)m.bindBuffer(m.ARRAY_BUFFER,Y.buffer),m.bufferData(m.ARRAY_BUFFER,Y.array,oc)}l.verticesNeedUpdate=!1;l.colorsNeedUpdate=!1;p.attributes&&C(p)}for(var Cb=0,rc=k.length;Cb<rc;Cb++){var dc=k[Cb],nb=dc,yc=nb.object,sc=nb.buffer,tc=yc.geometry,ob=yc.material;ob instanceof THREE.MeshFaceMaterial?(ob=ob.materials[tc instanceof THREE.BufferGeometry?0:sc.materialIndex],ob.transparent?(nb.material=ob,Pa.push(nb)):(nb.material=ob,Oa.push(nb))):ob&&(ob.transparent?\\n(nb.material=ob,Pa.push(nb)):(nb.material=ob,Oa.push(nb)));dc.render=!0;!0===G.sortObjects&&(null!==b.renderDepth?dc.z=b.renderDepth:(ea.setFromMatrixPosition(b.matrixWorld),ea.applyProjection(Ub),dc.z=ea.z))}}Cb=0;for(rc=b.children.length;Cb<rc;Cb++)s(a,b.children[Cb],h)}}function p(a,b,c){if(0!==a.length)for(var d=0,e=a.length;d<e;d++)la=Ya=null,Ca=ca=ja=ua=Da=ra=Fa=-1,fb=!0,a[d].render(b,c,Hb,Ib),la=Ya=null,Ca=ca=ja=ua=Da=ra=Fa=-1,fb=!0}function v(a,b,c,d,e,f){for(var g,h,k,m=a.length-1;-1!==m;m--){g=\\na[m];h=g.object;k=g.buffer;N(h,b);if(f)g=f;else{g=g.material;if(!g)continue;e&&G.setBlending(g.blending,g.blendEquation,g.blendSrc,g.blendDst);G.setDepthTest(g.depthTest);G.setDepthWrite(g.depthWrite);J(g.polygonOffset,g.polygonOffsetFactor,g.polygonOffsetUnits)}G.setMaterialFaces(g);k instanceof THREE.BufferGeometry?G.renderBufferDirect(b,c,d,g,k,h):G.renderBuffer(b,c,d,g,k,h)}}function w(a,b,c,d,e,f,g){for(var h,k,m=0,l=a.length;m<l;m++)if(h=a[m],k=h.object,k.visible){if(g)h=g;else{h=h[b];if(!h)continue;\\nf&&G.setBlending(h.blending,h.blendEquation,h.blendSrc,h.blendDst);G.setDepthTest(h.depthTest);G.setDepthWrite(h.depthWrite);J(h.polygonOffset,h.polygonOffsetFactor,h.polygonOffsetUnits)}G.renderImmediateObject(c,d,e,h,k)}}function u(a){var b=a.object.material;b.transparent?(a.transparent=b,a.opaque=null):(a.opaque=b,a.transparent=null)}function D(a,b,d){var e,f=!1;e=b.material;if(void 0===d.geometryGroups||d.groupsNeedUpdate)delete a.__webglObjects[b.id],d.makeGroups(e instanceof THREE.MeshFaceMaterial,\\nEb?4294967296:65535),d.groupsNeedUpdate=!1;for(var g=0,h=d.geometryGroupsList.length;g<h;g++){e=d.geometryGroupsList[g];if(e.__webglVertexBuffer)f=!1;else{f=e;f.__webglVertexBuffer=m.createBuffer();f.__webglNormalBuffer=m.createBuffer();f.__webglTangentBuffer=m.createBuffer();f.__webglColorBuffer=m.createBuffer();f.__webglUVBuffer=m.createBuffer();f.__webglUV2Buffer=m.createBuffer();f.__webglSkinIndicesBuffer=m.createBuffer();f.__webglSkinWeightsBuffer=m.createBuffer();f.__webglFaceBuffer=m.createBuffer();\\nf.__webglLineBuffer=m.createBuffer();var k=void 0,l=void 0;if(f.numMorphTargets)for(f.__webglMorphTargetsBuffers=[],k=0,l=f.numMorphTargets;k<l;k++)f.__webglMorphTargetsBuffers.push(m.createBuffer());if(f.numMorphNormals)for(f.__webglMorphNormalsBuffers=[],k=0,l=f.numMorphNormals;k<l;k++)f.__webglMorphNormalsBuffers.push(m.createBuffer());G.info.memory.geometries++;c(e,b);d.verticesNeedUpdate=!0;d.morphTargetsNeedUpdate=!0;d.elementsNeedUpdate=!0;d.uvsNeedUpdate=!0;d.normalsNeedUpdate=!0;d.tangentsNeedUpdate=\\n!0;f=d.colorsNeedUpdate=!0}(f||void 0===b.__webglActive)&&A(a.__webglObjects,e,b)}b.__webglActive=!0}function A(a,b,c){var d=c.id;a[d]=a[d]||[];a[d].push({id:d,buffer:b,object:c,material:null,z:0})}function x(a){for(var b in a.attributes)if(a.attributes[b].needsUpdate)return!0;return!1}function C(a){for(var b in a.attributes)a.attributes[b].needsUpdate=!1}function I(a,b){if(a instanceof THREE.Mesh||a instanceof THREE.PointCloud||a instanceof THREE.Line)delete b.__webglObjects[a.id];else if(a instanceof\\nTHREE.ImmediateRenderObject||a.immediateRenderCallback)for(var c=b.__webglObjectsImmediate,d=c.length-1;0<=d;d--)c[d].object===a&&c.splice(d,1);delete a.__webglActive}function z(a,b,c,d,e){qa=0;d.needsUpdate&&(d.program&&Nb(d),G.initMaterial(d,b,c,e),d.needsUpdate=!1);d.morphTargets&&!e.__webglMorphTargetInfluences&&(e.__webglMorphTargetInfluences=new Float32Array(G.maxMorphTargets));var f=!1,g=!1,h=!1,k=d.program,l=k.uniforms,n=d.__webglShader.uniforms;k.id!==Ya&&(m.useProgram(k.program),Ya=k.id,\\nh=g=f=!0);d.id!==Ca&&(-1===Ca&&(h=!0),Ca=d.id,g=!0);if(f||a!==la)m.uniformMatrix4fv(l.projectionMatrix,!1,a.projectionMatrix.elements),Ea&&m.uniform1f(l.logDepthBufFC,2/(Math.log(a.far+1)/Math.LN2)),a!==la&&(la=a),(d instanceof THREE.ShaderMaterial||d instanceof THREE.MeshPhongMaterial||d.envMap)&&null!==l.cameraPosition&&(ea.setFromMatrixPosition(a.matrixWorld),m.uniform3f(l.cameraPosition,ea.x,ea.y,ea.z)),(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof\\nTHREE.ShaderMaterial||d.skinning)&&null!==l.viewMatrix&&m.uniformMatrix4fv(l.viewMatrix,!1,a.matrixWorldInverse.elements);d.skinning&&(e.bindMatrix&&null!==l.bindMatrix&&m.uniformMatrix4fv(l.bindMatrix,!1,e.bindMatrix.elements),e.bindMatrixInverse&&null!==l.bindMatrixInverse&&m.uniformMatrix4fv(l.bindMatrixInverse,!1,e.bindMatrixInverse.elements),Ob&&e.skeleton&&e.skeleton.useVertexTexture?(null!==l.boneTexture&&(f=K(),m.uniform1i(l.boneTexture,f),G.setTexture(e.skeleton.boneTexture,f)),null!==l.boneTextureWidth&&\\nm.uniform1i(l.boneTextureWidth,e.skeleton.boneTextureWidth),null!==l.boneTextureHeight&&m.uniform1i(l.boneTextureHeight,e.skeleton.boneTextureHeight)):e.skeleton&&e.skeleton.boneMatrices&&null!==l.boneGlobalMatrices&&m.uniformMatrix4fv(l.boneGlobalMatrices,!1,e.skeleton.boneMatrices));if(g){c&&d.fog&&(n.fogColor.value=c.color,c instanceof THREE.Fog?(n.fogNear.value=c.near,n.fogFar.value=c.far):c instanceof THREE.FogExp2&&(n.fogDensity.value=c.density));if(d instanceof THREE.MeshPhongMaterial||d instanceof\\nTHREE.MeshLambertMaterial||d.lights){if(fb){var h=!0,p,r=f=0,q=0,s,t,w,u=Jb,v=u.directional.colors,x=u.directional.positions,D=u.point.colors,A=u.point.positions,z=u.point.distances,C=u.spot.colors,I=u.spot.positions,L=u.spot.distances,N=u.spot.directions,J=u.spot.anglesCos,T=u.spot.exponents,H=u.hemi.skyColors,Q=u.hemi.groundColors,O=u.hemi.positions,R=0,X=0,V=0,$=0,za=0,aa=0,ya=0,ca=0,W=p=0;c=w=W=0;for(g=b.length;c<g;c++)p=b[c],p.onlyShadow||(s=p.color,t=p.intensity,w=p.distance,p instanceof THREE.AmbientLight?\\np.visible&&(G.gammaInput?(f+=s.r*s.r,r+=s.g*s.g,q+=s.b*s.b):(f+=s.r,r+=s.g,q+=s.b)):p instanceof THREE.DirectionalLight?(za+=1,p.visible&&(da.setFromMatrixPosition(p.matrixWorld),ea.setFromMatrixPosition(p.target.matrixWorld),da.sub(ea),da.normalize(),p=3*R,x[p]=da.x,x[p+1]=da.y,x[p+2]=da.z,G.gammaInput?ba(v,p,s,t*t):P(v,p,s,t),R+=1)):p instanceof THREE.PointLight?(aa+=1,p.visible&&(W=3*X,G.gammaInput?ba(D,W,s,t*t):P(D,W,s,t),ea.setFromMatrixPosition(p.matrixWorld),A[W]=ea.x,A[W+1]=ea.y,A[W+2]=ea.z,\\nz[X]=w,X+=1)):p instanceof THREE.SpotLight?(ya+=1,p.visible&&(W=3*V,G.gammaInput?ba(C,W,s,t*t):P(C,W,s,t),ea.setFromMatrixPosition(p.matrixWorld),I[W]=ea.x,I[W+1]=ea.y,I[W+2]=ea.z,L[V]=w,da.copy(ea),ea.setFromMatrixPosition(p.target.matrixWorld),da.sub(ea),da.normalize(),N[W]=da.x,N[W+1]=da.y,N[W+2]=da.z,J[V]=Math.cos(p.angle),T[V]=p.exponent,V+=1)):p instanceof THREE.HemisphereLight&&(ca+=1,p.visible&&(da.setFromMatrixPosition(p.matrixWorld),da.normalize(),w=3*$,O[w]=da.x,O[w+1]=da.y,O[w+2]=da.z,\\ns=p.color,p=p.groundColor,G.gammaInput?(t*=t,ba(H,w,s,t),ba(Q,w,p,t)):(P(H,w,s,t),P(Q,w,p,t)),$+=1)));c=3*R;for(g=Math.max(v.length,3*za);c<g;c++)v[c]=0;c=3*X;for(g=Math.max(D.length,3*aa);c<g;c++)D[c]=0;c=3*V;for(g=Math.max(C.length,3*ya);c<g;c++)C[c]=0;c=3*$;for(g=Math.max(H.length,3*ca);c<g;c++)H[c]=0;c=3*$;for(g=Math.max(Q.length,3*ca);c<g;c++)Q[c]=0;u.directional.length=R;u.point.length=X;u.spot.length=V;u.hemi.length=$;u.ambient[0]=f;u.ambient[1]=r;u.ambient[2]=q;fb=!1}h?(h=Jb,n.ambientLightColor.value=\\nh.ambient,n.directionalLightColor.value=h.directional.colors,n.directionalLightDirection.value=h.directional.positions,n.pointLightColor.value=h.point.colors,n.pointLightPosition.value=h.point.positions,n.pointLightDistance.value=h.point.distances,n.spotLightColor.value=h.spot.colors,n.spotLightPosition.value=h.spot.positions,n.spotLightDistance.value=h.spot.distances,n.spotLightDirection.value=h.spot.directions,n.spotLightAngleCos.value=h.spot.anglesCos,n.spotLightExponent.value=h.spot.exponents,\\nn.hemisphereLightSkyColor.value=h.hemi.skyColors,n.hemisphereLightGroundColor.value=h.hemi.groundColors,n.hemisphereLightDirection.value=h.hemi.positions,y(n,!0)):y(n,!1)}if(d instanceof THREE.MeshBasicMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.MeshPhongMaterial){n.opacity.value=d.opacity;G.gammaInput?n.diffuse.value.copyGammaToLinear(d.color):n.diffuse.value=d.color;n.map.value=d.map;n.lightMap.value=d.lightMap;n.specularMap.value=d.specularMap;n.alphaMap.value=d.alphaMap;\\nd.bumpMap&&(n.bumpMap.value=d.bumpMap,n.bumpScale.value=d.bumpScale);d.normalMap&&(n.normalMap.value=d.normalMap,n.normalScale.value.copy(d.normalScale));var U;d.map?U=d.map:d.specularMap?U=d.specularMap:d.normalMap?U=d.normalMap:d.bumpMap?U=d.bumpMap:d.alphaMap&&(U=d.alphaMap);void 0!==U&&(h=U.offset,U=U.repeat,n.offsetRepeat.value.set(h.x,h.y,U.x,U.y));n.envMap.value=d.envMap;n.flipEnvMap.value=d.envMap instanceof THREE.WebGLRenderTargetCube?1:-1;n.reflectivity.value=d.reflectivity;n.refractionRatio.value=\\nd.refractionRatio;n.combine.value=d.combine;n.useRefract.value=d.envMap&&d.envMap.mapping instanceof THREE.CubeRefractionMapping}d instanceof THREE.LineBasicMaterial?(n.diffuse.value=d.color,n.opacity.value=d.opacity):d instanceof THREE.LineDashedMaterial?(n.diffuse.value=d.color,n.opacity.value=d.opacity,n.dashSize.value=d.dashSize,n.totalSize.value=d.dashSize+d.gapSize,n.scale.value=d.scale):d instanceof THREE.PointCloudMaterial?(n.psColor.value=d.color,n.opacity.value=d.opacity,n.size.value=d.size,\\nn.scale.value=S.height/2,n.map.value=d.map):d instanceof THREE.MeshPhongMaterial?(n.shininess.value=d.shininess,G.gammaInput?(n.ambient.value.copyGammaToLinear(d.ambient),n.emissive.value.copyGammaToLinear(d.emissive),n.specular.value.copyGammaToLinear(d.specular)):(n.ambient.value=d.ambient,n.emissive.value=d.emissive,n.specular.value=d.specular),d.wrapAround&&n.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshLambertMaterial?(G.gammaInput?(n.ambient.value.copyGammaToLinear(d.ambient),n.emissive.value.copyGammaToLinear(d.emissive)):\\n(n.ambient.value=d.ambient,n.emissive.value=d.emissive),d.wrapAround&&n.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshDepthMaterial?(n.mNear.value=a.near,n.mFar.value=a.far,n.opacity.value=d.opacity):d instanceof THREE.MeshNormalMaterial&&(n.opacity.value=d.opacity);if(e.receiveShadow&&!d._shadowPass&&n.shadowMatrix)for(U=a=0,h=b.length;U<h;U++)c=b[U],c.castShadow&&(c instanceof THREE.SpotLight||c instanceof THREE.DirectionalLight&&!c.shadowCascade)&&(n.shadowMap.value[a]=c.shadowMap,n.shadowMapSize.value[a]=\\nc.shadowMapSize,n.shadowMatrix.value[a]=c.shadowMatrix,n.shadowDarkness.value[a]=c.shadowDarkness,n.shadowBias.value[a]=c.shadowBias,a++);b=d.uniformsList;d=0;for(n=b.length;d<n;d++)if(a=b[d][0],!1!==a.needsUpdate)switch(c=a.type,h=a.value,U=b[d][1],c){case \\\"1i\\\":m.uniform1i(U,h);break;case \\\"1f\\\":m.uniform1f(U,h);break;case \\\"2f\\\":m.uniform2f(U,h[0],h[1]);break;case \\\"3f\\\":m.uniform3f(U,h[0],h[1],h[2]);break;case \\\"4f\\\":m.uniform4f(U,h[0],h[1],h[2],h[3]);break;case \\\"1iv\\\":m.uniform1iv(U,h);break;case \\\"3iv\\\":m.uniform3iv(U,\\nh);break;case \\\"1fv\\\":m.uniform1fv(U,h);break;case \\\"2fv\\\":m.uniform2fv(U,h);break;case \\\"3fv\\\":m.uniform3fv(U,h);break;case \\\"4fv\\\":m.uniform4fv(U,h);break;case \\\"Matrix3fv\\\":m.uniformMatrix3fv(U,!1,h);break;case \\\"Matrix4fv\\\":m.uniformMatrix4fv(U,!1,h);break;case \\\"i\\\":m.uniform1i(U,h);break;case \\\"f\\\":m.uniform1f(U,h);break;case \\\"v2\\\":m.uniform2f(U,h.x,h.y);break;case \\\"v3\\\":m.uniform3f(U,h.x,h.y,h.z);break;case \\\"v4\\\":m.uniform4f(U,h.x,h.y,h.z,h.w);break;case \\\"c\\\":m.uniform3f(U,h.r,h.g,h.b);break;case \\\"iv1\\\":m.uniform1iv(U,\\nh);break;case \\\"iv\\\":m.uniform3iv(U,h);break;case \\\"fv1\\\":m.uniform1fv(U,h);break;case \\\"fv\\\":m.uniform3fv(U,h);break;case \\\"v2v\\\":void 0===a._array&&(a._array=new Float32Array(2*h.length));c=0;for(g=h.length;c<g;c++)f=2*c,a._array[f]=h[c].x,a._array[f+1]=h[c].y;m.uniform2fv(U,a._array);break;case \\\"v3v\\\":void 0===a._array&&(a._array=new Float32Array(3*h.length));c=0;for(g=h.length;c<g;c++)f=3*c,a._array[f]=h[c].x,a._array[f+1]=h[c].y,a._array[f+2]=h[c].z;m.uniform3fv(U,a._array);break;case \\\"v4v\\\":void 0===\\na._array&&(a._array=new Float32Array(4*h.length));c=0;for(g=h.length;c<g;c++)f=4*c,a._array[f]=h[c].x,a._array[f+1]=h[c].y,a._array[f+2]=h[c].z,a._array[f+3]=h[c].w;m.uniform4fv(U,a._array);break;case \\\"m3\\\":m.uniformMatrix3fv(U,!1,h.elements);break;case \\\"m3v\\\":void 0===a._array&&(a._array=new Float32Array(9*h.length));c=0;for(g=h.length;c<g;c++)h[c].flattenToArrayOffset(a._array,9*c);m.uniformMatrix3fv(U,!1,a._array);break;case \\\"m4\\\":m.uniformMatrix4fv(U,!1,h.elements);break;case \\\"m4v\\\":void 0===a._array&&\\n(a._array=new Float32Array(16*h.length));c=0;for(g=h.length;c<g;c++)h[c].flattenToArrayOffset(a._array,16*c);m.uniformMatrix4fv(U,!1,a._array);break;case \\\"t\\\":f=h;h=K();m.uniform1i(U,h);if(!f)continue;if(f instanceof THREE.CubeTexture||f.image instanceof Array&&6===f.image.length){if(a=f,U=h,6===a.image.length)if(a.needsUpdate){a.image.__webglTextureCube||(a.addEventListener(\\\"dispose\\\",Pb),a.image.__webglTextureCube=m.createTexture(),G.info.memory.textures++);m.activeTexture(m.TEXTURE0+U);m.bindTexture(m.TEXTURE_CUBE_MAP,\\na.image.__webglTextureCube);m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL,a.flipY);U=a instanceof THREE.CompressedTexture;h=[];for(c=0;6>c;c++)G.autoScaleCubemaps&&!U?(g=c,f=a.image[c],q=sc,f.width<=q&&f.height<=q||(u=Math.max(f.width,f.height),r=Math.floor(f.width*q/u),q=Math.floor(f.height*q/u),u=document.createElement(\\\"canvas\\\"),u.width=r,u.height=q,u.getContext(\\\"2d\\\").drawImage(f,0,0,f.width,f.height,0,0,r,q),f=u),h[g]=f):h[c]=a.image[c];c=h[0];g=THREE.Math.isPowerOfTwo(c.width)&&THREE.Math.isPowerOfTwo(c.height);\\nf=B(a.format);r=B(a.type);E(m.TEXTURE_CUBE_MAP,a,g);for(c=0;6>c;c++)if(U)for(u=h[c].mipmaps,v=0,x=u.length;v<x;v++)q=u[v],a.format!==THREE.RGBAFormat?m.compressedTexImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+c,v,f,q.width,q.height,0,q.data):m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+c,v,f,q.width,q.height,0,f,r,q.data);else m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+c,0,f,f,r,h[c]);a.generateMipmaps&&g&&m.generateMipmap(m.TEXTURE_CUBE_MAP);a.needsUpdate=!1;if(a.onUpdate)a.onUpdate()}else m.activeTexture(m.TEXTURE0+\\nU),m.bindTexture(m.TEXTURE_CUBE_MAP,a.image.__webglTextureCube)}else f instanceof THREE.WebGLRenderTargetCube?(a=f,m.activeTexture(m.TEXTURE0+h),m.bindTexture(m.TEXTURE_CUBE_MAP,a.__webglTexture)):G.setTexture(f,h);break;case \\\"tv\\\":void 0===a._array&&(a._array=[]);c=0;for(g=a.value.length;c<g;c++)a._array[c]=K();m.uniform1iv(U,a._array);c=0;for(g=a.value.length;c<g;c++)f=a.value[c],h=a._array[c],f&&G.setTexture(f,h);break;default:console.warn(\\\"THREE.WebGLRenderer: Unknown uniform type: \\\"+c)}}m.uniformMatrix4fv(l.modelViewMatrix,\\n!1,e._modelViewMatrix.elements);l.normalMatrix&&m.uniformMatrix3fv(l.normalMatrix,!1,e._normalMatrix.elements);null!==l.modelMatrix&&m.uniformMatrix4fv(l.modelMatrix,!1,e.matrixWorld.elements);return k}function y(a,b){a.ambientLightColor.needsUpdate=b;a.directionalLightColor.needsUpdate=b;a.directionalLightDirection.needsUpdate=b;a.pointLightColor.needsUpdate=b;a.pointLightPosition.needsUpdate=b;a.pointLightDistance.needsUpdate=b;a.spotLightColor.needsUpdate=b;a.spotLightPosition.needsUpdate=b;a.spotLightDistance.needsUpdate=\\nb;a.spotLightDirection.needsUpdate=b;a.spotLightAngleCos.needsUpdate=b;a.spotLightExponent.needsUpdate=b;a.hemisphereLightSkyColor.needsUpdate=b;a.hemisphereLightGroundColor.needsUpdate=b;a.hemisphereLightDirection.needsUpdate=b}function K(){var a=qa;a>=Qb&&console.warn(\\\"WebGLRenderer: trying to use \\\"+a+\\\" texture units while this GPU supports only \\\"+Qb);qa+=1;return a}function N(a,b){a._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,a.matrixWorld);a._normalMatrix.getNormalMatrix(a._modelViewMatrix)}\\nfunction ba(a,b,c,d){a[b]=c.r*c.r*d;a[b+1]=c.g*c.g*d;a[b+2]=c.b*c.b*d}function P(a,b,c,d){a[b]=c.r*d;a[b+1]=c.g*d;a[b+2]=c.b*d}function O(a){a!==xa&&(m.lineWidth(a),xa=a)}function J(a,b,c){Qa!==a&&(a?m.enable(m.POLYGON_OFFSET_FILL):m.disable(m.POLYGON_OFFSET_FILL),Qa=a);!a||cb===b&&Ga===c||(m.polygonOffset(b,c),cb=b,Ga=c)}function E(a,b,c){c?(m.texParameteri(a,m.TEXTURE_WRAP_S,B(b.wrapS)),m.texParameteri(a,m.TEXTURE_WRAP_T,B(b.wrapT)),m.texParameteri(a,m.TEXTURE_MAG_FILTER,B(b.magFilter)),m.texParameteri(a,\\nm.TEXTURE_MIN_FILTER,B(b.minFilter))):(m.texParameteri(a,m.TEXTURE_WRAP_S,m.CLAMP_TO_EDGE),m.texParameteri(a,m.TEXTURE_WRAP_T,m.CLAMP_TO_EDGE),m.texParameteri(a,m.TEXTURE_MAG_FILTER,R(b.magFilter)),m.texParameteri(a,m.TEXTURE_MIN_FILTER,R(b.minFilter)));Ta&&b.type!==THREE.FloatType&&(1<b.anisotropy||b.__oldAnisotropy)&&(m.texParameterf(a,Ta.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,Rb)),b.__oldAnisotropy=b.anisotropy)}function Q(a,b){m.bindRenderbuffer(m.RENDERBUFFER,a);b.depthBuffer&&!b.stencilBuffer?\\n(m.renderbufferStorage(m.RENDERBUFFER,m.DEPTH_COMPONENT16,b.width,b.height),m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_ATTACHMENT,m.RENDERBUFFER,a)):b.depthBuffer&&b.stencilBuffer?(m.renderbufferStorage(m.RENDERBUFFER,m.DEPTH_STENCIL,b.width,b.height),m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_STENCIL_ATTACHMENT,m.RENDERBUFFER,a)):m.renderbufferStorage(m.RENDERBUFFER,m.RGBA4,b.width,b.height)}function L(a){a instanceof THREE.WebGLRenderTargetCube?(m.bindTexture(m.TEXTURE_CUBE_MAP,a.__webglTexture),\\nm.generateMipmap(m.TEXTURE_CUBE_MAP),m.bindTexture(m.TEXTURE_CUBE_MAP,null)):(m.bindTexture(m.TEXTURE_2D,a.__webglTexture),m.generateMipmap(m.TEXTURE_2D),m.bindTexture(m.TEXTURE_2D,null))}function R(a){return a===THREE.NearestFilter||a===THREE.NearestMipMapNearestFilter||a===THREE.NearestMipMapLinearFilter?m.NEAREST:m.LINEAR}function B(a){if(a===THREE.RepeatWrapping)return m.REPEAT;if(a===THREE.ClampToEdgeWrapping)return m.CLAMP_TO_EDGE;if(a===THREE.MirroredRepeatWrapping)return m.MIRRORED_REPEAT;\\nif(a===THREE.NearestFilter)return m.NEAREST;if(a===THREE.NearestMipMapNearestFilter)return m.NEAREST_MIPMAP_NEAREST;if(a===THREE.NearestMipMapLinearFilter)return m.NEAREST_MIPMAP_LINEAR;if(a===THREE.LinearFilter)return m.LINEAR;if(a===THREE.LinearMipMapNearestFilter)return m.LINEAR_MIPMAP_NEAREST;if(a===THREE.LinearMipMapLinearFilter)return m.LINEAR_MIPMAP_LINEAR;if(a===THREE.UnsignedByteType)return m.UNSIGNED_BYTE;if(a===THREE.UnsignedShort4444Type)return m.UNSIGNED_SHORT_4_4_4_4;if(a===THREE.UnsignedShort5551Type)return m.UNSIGNED_SHORT_5_5_5_1;\\nif(a===THREE.UnsignedShort565Type)return m.UNSIGNED_SHORT_5_6_5;if(a===THREE.ByteType)return m.BYTE;if(a===THREE.ShortType)return m.SHORT;if(a===THREE.UnsignedShortType)return m.UNSIGNED_SHORT;if(a===THREE.IntType)return m.INT;if(a===THREE.UnsignedIntType)return m.UNSIGNED_INT;if(a===THREE.FloatType)return m.FLOAT;if(a===THREE.AlphaFormat)return m.ALPHA;if(a===THREE.RGBFormat)return m.RGB;if(a===THREE.RGBAFormat)return m.RGBA;if(a===THREE.LuminanceFormat)return m.LUMINANCE;if(a===THREE.LuminanceAlphaFormat)return m.LUMINANCE_ALPHA;\\nif(a===THREE.AddEquation)return m.FUNC_ADD;if(a===THREE.SubtractEquation)return m.FUNC_SUBTRACT;if(a===THREE.ReverseSubtractEquation)return m.FUNC_REVERSE_SUBTRACT;if(a===THREE.ZeroFactor)return m.ZERO;if(a===THREE.OneFactor)return m.ONE;if(a===THREE.SrcColorFactor)return m.SRC_COLOR;if(a===THREE.OneMinusSrcColorFactor)return m.ONE_MINUS_SRC_COLOR;if(a===THREE.SrcAlphaFactor)return m.SRC_ALPHA;if(a===THREE.OneMinusSrcAlphaFactor)return m.ONE_MINUS_SRC_ALPHA;if(a===THREE.DstAlphaFactor)return m.DST_ALPHA;\\nif(a===THREE.OneMinusDstAlphaFactor)return m.ONE_MINUS_DST_ALPHA;if(a===THREE.DstColorFactor)return m.DST_COLOR;if(a===THREE.OneMinusDstColorFactor)return m.ONE_MINUS_DST_COLOR;if(a===THREE.SrcAlphaSaturateFactor)return m.SRC_ALPHA_SATURATE;if(void 0!==Sa){if(a===THREE.RGB_S3TC_DXT1_Format)return Sa.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT1_Format)return Sa.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT3_Format)return Sa.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===THREE.RGBA_S3TC_DXT5_Format)return Sa.COMPRESSED_RGBA_S3TC_DXT5_EXT}return 0}\\nconsole.log(\\\"THREE.WebGLRenderer\\\",THREE.REVISION);a=a||{};var S=void 0!==a.canvas?a.canvas:document.createElement(\\\"canvas\\\"),V=void 0!==a.context?a.context:null,W=void 0!==a.precision?a.precision:\\\"highp\\\",H=void 0!==a.alpha?a.alpha:!1,oa=void 0!==a.depth?a.depth:!0,$=void 0!==a.stencil?a.stencil:!0,X=void 0!==a.antialias?a.antialias:!1,T=void 0!==a.premultipliedAlpha?a.premultipliedAlpha:!0,ya=void 0!==a.preserveDrawingBuffer?a.preserveDrawingBuffer:!1,Ea=void 0!==a.logarithmicDepthBuffer?a.logarithmicDepthBuffer:\\n!1,Aa=new THREE.Color(0),za=0,Oa=[],Pa=[];this.domElement=S;this.context=null;this.devicePixelRatio=void 0!==a.devicePixelRatio?a.devicePixelRatio:void 0!==self.devicePixelRatio?self.devicePixelRatio:1;this.sortObjects=this.autoClearStencil=this.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.shadowMapEnabled=this.gammaOutput=this.gammaInput=!1;this.shadowMapAutoUpdate=!0;this.shadowMapType=THREE.PCFShadowMap;this.shadowMapCullFace=THREE.CullFaceFront;this.shadowMapCascade=this.shadowMapDebug=\\n!1;this.maxMorphTargets=8;this.maxMorphNormals=4;this.autoScaleCubemaps=!0;this.renderPluginsPre=[];this.renderPluginsPost=[];this.info={memory:{programs:0,geometries:0,textures:0},render:{calls:0,vertices:0,faces:0,points:0}};var G=this,Ba=[],Ya=null,Za=null,Ca=-1,ca=null,la=null,qa=0,ua=-1,ja=-1,Fa=-1,va=-1,Ka=-1,aa=-1,ra=-1,Da=-1,Qa=null,cb=null,Ga=null,xa=null,ma=0,Ja=0,wb=S.width,sb=S.height,Hb=0,Ib=0,pb=new Uint8Array(16),tb=new Uint8Array(16),jc=new THREE.Frustum,Ub=new THREE.Matrix4,kc=new THREE.Matrix4,\\nea=new THREE.Vector3,da=new THREE.Vector3,fb=!0,Jb={ambient:[0,0,0],directional:{length:0,colors:[],positions:[]},point:{length:0,colors:[],positions:[],distances:[]},spot:{length:0,colors:[],positions:[],distances:[],directions:[],anglesCos:[],exponents:[]},hemi:{length:0,skyColors:[],groundColors:[],positions:[]}},m,Db,xb,Ta,Sa,Eb;(function(){try{var a={alpha:H,depth:oa,stencil:$,antialias:X,premultipliedAlpha:T,preserveDrawingBuffer:ya};m=V||S.getContext(\\\"webgl\\\",a)||S.getContext(\\\"experimental-webgl\\\",\\na);if(null===m)throw\\\"Error creating WebGL context.\\\";}catch(b){console.error(b)}Db=m.getExtension(\\\"OES_texture_float\\\");m.getExtension(\\\"OES_texture_float_linear\\\");xb=m.getExtension(\\\"OES_standard_derivatives\\\");Ta=m.getExtension(\\\"EXT_texture_filter_anisotropic\\\")||m.getExtension(\\\"MOZ_EXT_texture_filter_anisotropic\\\")||m.getExtension(\\\"WEBKIT_EXT_texture_filter_anisotropic\\\");Sa=m.getExtension(\\\"WEBGL_compressed_texture_s3tc\\\")||m.getExtension(\\\"MOZ_WEBGL_compressed_texture_s3tc\\\")||m.getExtension(\\\"WEBKIT_WEBGL_compressed_texture_s3tc\\\");\\nEb=m.getExtension(\\\"OES_element_index_uint\\\");null===Db&&console.log(\\\"THREE.WebGLRenderer: Float textures not supported.\\\");null===xb&&console.log(\\\"THREE.WebGLRenderer: Standard derivatives not supported.\\\");null===Ta&&console.log(\\\"THREE.WebGLRenderer: Anisotropic texture filtering not supported.\\\");null===Sa&&console.log(\\\"THREE.WebGLRenderer: S3TC compressed textures not supported.\\\");null===Eb&&console.log(\\\"THREE.WebGLRenderer: elementindex as unsigned integer not supported.\\\");void 0===m.getShaderPrecisionFormat&&\\n(m.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}});Ea&&m.getExtension(\\\"EXT_frag_depth\\\")})();m.clearColor(0,0,0,1);m.clearDepth(1);m.clearStencil(0);m.enable(m.DEPTH_TEST);m.depthFunc(m.LEQUAL);m.frontFace(m.CCW);m.cullFace(m.BACK);m.enable(m.CULL_FACE);m.enable(m.BLEND);m.blendEquation(m.FUNC_ADD);m.blendFunc(m.SRC_ALPHA,m.ONE_MINUS_SRC_ALPHA);m.viewport(ma,Ja,wb,sb);m.clearColor(Aa.r,Aa.g,Aa.b,za);this.context=m;var Qb=m.getParameter(m.MAX_TEXTURE_IMAGE_UNITS),tc=\\nm.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS);m.getParameter(m.MAX_TEXTURE_SIZE);var sc=m.getParameter(m.MAX_CUBE_MAP_TEXTURE_SIZE),Rb=Ta?m.getParameter(Ta.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,Sb=0<tc,Ob=Sb&&Db;Sa&&m.getParameter(m.COMPRESSED_TEXTURE_FORMATS);var zc=m.getShaderPrecisionFormat(m.VERTEX_SHADER,m.HIGH_FLOAT),Ac=m.getShaderPrecisionFormat(m.VERTEX_SHADER,m.MEDIUM_FLOAT);m.getShaderPrecisionFormat(m.VERTEX_SHADER,m.LOW_FLOAT);var Bc=m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.HIGH_FLOAT),\\nCc=m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.MEDIUM_FLOAT);m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.LOW_FLOAT);var Dc=0<zc.precision&&0<Bc.precision,ec=0<Ac.precision&&0<Cc.precision;\\\"highp\\\"!==W||Dc||(ec?(W=\\\"mediump\\\",console.warn(\\\"THREE.WebGLRenderer: highp not supported, using mediump.\\\")):(W=\\\"lowp\\\",console.warn(\\\"THREE.WebGLRenderer: highp and mediump not supported, using lowp.\\\")));\\\"mediump\\\"!==W||ec||(W=\\\"lowp\\\",console.warn(\\\"THREE.WebGLRenderer: mediump not supported, using lowp.\\\"));this.getContext=\\nfunction(){return m};this.supportsVertexTextures=function(){return Sb};this.supportsFloatTextures=function(){return Db};this.supportsStandardDerivatives=function(){return xb};this.supportsCompressedTextureS3TC=function(){return Sa};this.getMaxAnisotropy=function(){return Rb};this.getPrecision=function(){return W};this.setSize=function(a,b,c){S.width=a*this.devicePixelRatio;S.height=b*this.devicePixelRatio;!1!==c&&(S.style.width=a+\\\"px\\\",S.style.height=b+\\\"px\\\");this.setViewport(0,0,a,b)};this.setViewport=\\nfunction(a,b,c,d){ma=a*this.devicePixelRatio;Ja=b*this.devicePixelRatio;wb=c*this.devicePixelRatio;sb=d*this.devicePixelRatio;m.viewport(ma,Ja,wb,sb)};this.setScissor=function(a,b,c,d){m.scissor(a*this.devicePixelRatio,b*this.devicePixelRatio,c*this.devicePixelRatio,d*this.devicePixelRatio)};this.enableScissorTest=function(a){a?m.enable(m.SCISSOR_TEST):m.disable(m.SCISSOR_TEST)};this.setClearColor=function(a,b){Aa.set(a);za=void 0!==b?b:1;m.clearColor(Aa.r,Aa.g,Aa.b,za)};this.setClearColorHex=function(a,\\nb){console.warn(\\\"THREE.WebGLRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.\\\");this.setClearColor(a,b)};this.getClearColor=function(){return Aa};this.getClearAlpha=function(){return za};this.clear=function(a,b,c){var d=0;if(void 0===a||a)d|=m.COLOR_BUFFER_BIT;if(void 0===b||b)d|=m.DEPTH_BUFFER_BIT;if(void 0===c||c)d|=m.STENCIL_BUFFER_BIT;m.clear(d)};this.clearColor=function(){m.clear(m.COLOR_BUFFER_BIT)};this.clearDepth=function(){m.clear(m.DEPTH_BUFFER_BIT)};this.clearStencil=\\nfunction(){m.clear(m.STENCIL_BUFFER_BIT)};this.clearTarget=function(a,b,c,d){this.setRenderTarget(a);this.clear(b,c,d)};this.addPostPlugin=function(a){a.init(this);this.renderPluginsPost.push(a)};this.addPrePlugin=function(a){a.init(this);this.renderPluginsPre.push(a)};this.updateShadowMap=function(a,b){Ya=null;Ca=ca=Da=ra=Fa=-1;fb=!0;ja=ua=-1;fc(a);this.shadowMapPlugin.update(a,b)};var gc=function(a){a=a.target;a.removeEventListener(\\\"dispose\\\",gc);a.__webglInit=void 0;if(a instanceof THREE.BufferGeometry){a=\\na.attributes;for(var b in a)void 0!==a[b].buffer&&m.deleteBuffer(a[b].buffer);G.info.memory.geometries--}else if(void 0!==a.geometryGroups){b=0;for(var c=a.geometryGroupsList.length;b<c;b++){var d=a.geometryGroupsList[b];if(void 0!==d.numMorphTargets)for(var e=0,f=d.numMorphTargets;e<f;e++)m.deleteBuffer(d.__webglMorphTargetsBuffers[e]);if(void 0!==d.numMorphNormals)for(e=0,f=d.numMorphNormals;e<f;e++)m.deleteBuffer(d.__webglMorphNormalsBuffers[e]);Tb(d)}}else Tb(a)},Pb=function(a){a=a.target;a.removeEventListener(\\\"dispose\\\",\\nPb);a.image&&a.image.__webglTextureCube?m.deleteTexture(a.image.__webglTextureCube):a.__webglInit&&(a.__webglInit=!1,m.deleteTexture(a.__webglTexture));G.info.memory.textures--},hc=function(a){a=a.target;a.removeEventListener(\\\"dispose\\\",hc);if(a&&a.__webglTexture)if(m.deleteTexture(a.__webglTexture),a instanceof THREE.WebGLRenderTargetCube)for(var b=0;6>b;b++)m.deleteFramebuffer(a.__webglFramebuffer[b]),m.deleteRenderbuffer(a.__webglRenderbuffer[b]);else m.deleteFramebuffer(a.__webglFramebuffer),m.deleteRenderbuffer(a.__webglRenderbuffer);\\nG.info.memory.textures--},ic=function(a){a=a.target;a.removeEventListener(\\\"dispose\\\",ic);Nb(a)},Tb=function(a){void 0!==a.__webglVertexBuffer&&m.deleteBuffer(a.__webglVertexBuffer);void 0!==a.__webglNormalBuffer&&m.deleteBuffer(a.__webglNormalBuffer);void 0!==a.__webglTangentBuffer&&m.deleteBuffer(a.__webglTangentBuffer);void 0!==a.__webglColorBuffer&&m.deleteBuffer(a.__webglColorBuffer);void 0!==a.__webglUVBuffer&&m.deleteBuffer(a.__webglUVBuffer);void 0!==a.__webglUV2Buffer&&m.deleteBuffer(a.__webglUV2Buffer);\\nvoid 0!==a.__webglSkinIndicesBuffer&&m.deleteBuffer(a.__webglSkinIndicesBuffer);void 0!==a.__webglSkinWeightsBuffer&&m.deleteBuffer(a.__webglSkinWeightsBuffer);void 0!==a.__webglFaceBuffer&&m.deleteBuffer(a.__webglFaceBuffer);void 0!==a.__webglLineBuffer&&m.deleteBuffer(a.__webglLineBuffer);void 0!==a.__webglLineDistanceBuffer&&m.deleteBuffer(a.__webglLineDistanceBuffer);if(void 0!==a.__webglCustomAttributesList)for(var b in a.__webglCustomAttributesList)m.deleteBuffer(a.__webglCustomAttributesList[b].buffer);\\nG.info.memory.geometries--},Nb=function(a){var b=a.program.program;if(void 0!==b){a.program=void 0;var c,d,e=!1;a=0;for(c=Ba.length;a<c;a++)if(d=Ba[a],d.program===b){d.usedTimes--;0===d.usedTimes&&(e=!0);break}if(!0===e){e=[];a=0;for(c=Ba.length;a<c;a++)d=Ba[a],d.program!==b&&e.push(d);Ba=e;m.deleteProgram(b);G.info.memory.programs--}}};this.renderBufferImmediate=function(a,b,c){k();a.hasPositions&&!a.__webglVertexBuffer&&(a.__webglVertexBuffer=m.createBuffer());a.hasNormals&&!a.__webglNormalBuffer&&\\n(a.__webglNormalBuffer=m.createBuffer());a.hasUvs&&!a.__webglUvBuffer&&(a.__webglUvBuffer=m.createBuffer());a.hasColors&&!a.__webglColorBuffer&&(a.__webglColorBuffer=m.createBuffer());a.hasPositions&&(m.bindBuffer(m.ARRAY_BUFFER,a.__webglVertexBuffer),m.bufferData(m.ARRAY_BUFFER,a.positionArray,m.DYNAMIC_DRAW),l(b.attributes.position),m.vertexAttribPointer(b.attributes.position,3,m.FLOAT,!1,0,0));if(a.hasNormals){m.bindBuffer(m.ARRAY_BUFFER,a.__webglNormalBuffer);if(c.shading===THREE.FlatShading){var d,\\ne,f,g,h,p,r,q,s,t,u,w=3*a.count;for(u=0;u<w;u+=9)t=a.normalArray,d=t[u],e=t[u+1],f=t[u+2],g=t[u+3],p=t[u+4],q=t[u+5],h=t[u+6],r=t[u+7],s=t[u+8],d=(d+g+h)/3,e=(e+p+r)/3,f=(f+q+s)/3,t[u]=d,t[u+1]=e,t[u+2]=f,t[u+3]=d,t[u+4]=e,t[u+5]=f,t[u+6]=d,t[u+7]=e,t[u+8]=f}m.bufferData(m.ARRAY_BUFFER,a.normalArray,m.DYNAMIC_DRAW);l(b.attributes.normal);m.vertexAttribPointer(b.attributes.normal,3,m.FLOAT,!1,0,0)}a.hasUvs&&c.map&&(m.bindBuffer(m.ARRAY_BUFFER,a.__webglUvBuffer),m.bufferData(m.ARRAY_BUFFER,a.uvArray,\\nm.DYNAMIC_DRAW),l(b.attributes.uv),m.vertexAttribPointer(b.attributes.uv,2,m.FLOAT,!1,0,0));a.hasColors&&c.vertexColors!==THREE.NoColors&&(m.bindBuffer(m.ARRAY_BUFFER,a.__webglColorBuffer),m.bufferData(m.ARRAY_BUFFER,a.colorArray,m.DYNAMIC_DRAW),l(b.attributes.color),m.vertexAttribPointer(b.attributes.color,3,m.FLOAT,!1,0,0));n();m.drawArrays(m.TRIANGLES,0,a.count);a.count=0};this.renderBufferDirect=function(a,b,c,d,e,f){if(!1!==d.visible){var g=z(a,b,c,d,f);a=g.attributes;b=e.attributes;c=!1;g=16777215*\\ne.id+2*g.id+(d.wireframe?1:0);g!==ca&&(ca=g,c=!0);c&&k();if(f instanceof THREE.Mesh)if(g=b.index){var l,n;g.array instanceof Uint32Array?(l=m.UNSIGNED_INT,n=4):(l=m.UNSIGNED_SHORT,n=2);e=e.offsets;if(0===e.length)c&&(h(d,a,b,0),m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,g.buffer)),m.drawElements(m.TRIANGLES,g.array.length,l,0),G.info.render.calls++,G.info.render.vertices+=g.array.length,G.info.render.faces+=g.array.length/3;else{c=!0;for(var p=0,r=e.length;p<r;p++){var q=e[p].index;c&&(h(d,a,b,q),m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,\\ng.buffer));m.drawElements(m.TRIANGLES,e[p].count,l,e[p].start*n);G.info.render.calls++;G.info.render.vertices+=e[p].count;G.info.render.faces+=e[p].count/3}}}else c&&h(d,a,b,0),d=e.attributes.position,m.drawArrays(m.TRIANGLES,0,d.array.length/3),G.info.render.calls++,G.info.render.vertices+=d.array.length/3,G.info.render.faces+=d.array.length/9;else if(f instanceof THREE.PointCloud)c&&h(d,a,b,0),d=b.position,m.drawArrays(m.POINTS,0,d.array.length/3),G.info.render.calls++,G.info.render.points+=d.array.length/\\n3;else if(f instanceof THREE.Line)if(f=f.type===THREE.LineStrip?m.LINE_STRIP:m.LINES,O(d.linewidth),g=b.index)if(g.array instanceof Uint32Array?(l=m.UNSIGNED_INT,n=4):(l=m.UNSIGNED_SHORT,n=2),e=e.offsets,0===e.length)c&&(h(d,a,b,0),m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,g.buffer)),m.drawElements(f,g.array.length,l,0),G.info.render.calls++,G.info.render.vertices+=g.array.length;else for(1<e.length&&(c=!0),p=0,r=e.length;p<r;p++)q=e[p].index,c&&(h(d,a,b,q),m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,g.buffer)),\\nm.drawElements(f,e[p].count,l,e[p].start*n),G.info.render.calls++,G.info.render.vertices+=e[p].count;else c&&h(d,a,b,0),d=b.position,m.drawArrays(f,0,d.array.length/3),G.info.render.calls++,G.info.render.points+=d.array.length/3}};this.renderBuffer=function(a,b,c,d,e,f){if(!1!==d.visible){var g,h;c=z(a,b,c,d,f);b=c.attributes;a=!1;c=16777215*e.id+2*c.id+(d.wireframe?1:0);c!==ca&&(ca=c,a=!0);a&&k();if(!d.morphTargets&&0<=b.position)a&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglVertexBuffer),l(b.position),\\nm.vertexAttribPointer(b.position,3,m.FLOAT,!1,0,0));else if(f.morphTargetBase){c=d.program.attributes;-1!==f.morphTargetBase&&0<=c.position?(m.bindBuffer(m.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[f.morphTargetBase]),l(c.position),m.vertexAttribPointer(c.position,3,m.FLOAT,!1,0,0)):0<=c.position&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglVertexBuffer),l(c.position),m.vertexAttribPointer(c.position,3,m.FLOAT,!1,0,0));if(f.morphTargetForcedOrder.length){var p=0;h=f.morphTargetForcedOrder;for(g=f.morphTargetInfluences;p<\\nd.numSupportedMorphTargets&&p<h.length;)0<=c[\\\"morphTarget\\\"+p]&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[h[p]]),l(c[\\\"morphTarget\\\"+p]),m.vertexAttribPointer(c[\\\"morphTarget\\\"+p],3,m.FLOAT,!1,0,0)),0<=c[\\\"morphNormal\\\"+p]&&d.morphNormals&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[h[p]]),l(c[\\\"morphNormal\\\"+p]),m.vertexAttribPointer(c[\\\"morphNormal\\\"+p],3,m.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[p]=g[h[p]],p++}else{h=[];g=f.morphTargetInfluences;var r,q=g.length;for(r=\\n0;r<q;r++)p=g[r],0<p&&h.push([p,r]);h.length>d.numSupportedMorphTargets?(h.sort(t),h.length=d.numSupportedMorphTargets):h.length>d.numSupportedMorphNormals?h.sort(t):0===h.length&&h.push([0,0]);for(p=0;p<d.numSupportedMorphTargets;)h[p]?(r=h[p][1],0<=c[\\\"morphTarget\\\"+p]&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[r]),l(c[\\\"morphTarget\\\"+p]),m.vertexAttribPointer(c[\\\"morphTarget\\\"+p],3,m.FLOAT,!1,0,0)),0<=c[\\\"morphNormal\\\"+p]&&d.morphNormals&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[r]),\\nl(c[\\\"morphNormal\\\"+p]),m.vertexAttribPointer(c[\\\"morphNormal\\\"+p],3,m.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[p]=g[r]):f.__webglMorphTargetInfluences[p]=0,p++}null!==d.program.uniforms.morphTargetInfluences&&m.uniform1fv(d.program.uniforms.morphTargetInfluences,f.__webglMorphTargetInfluences)}if(a){if(e.__webglCustomAttributesList)for(g=0,h=e.__webglCustomAttributesList.length;g<h;g++)c=e.__webglCustomAttributesList[g],0<=b[c.buffer.belongsToAttribute]&&(m.bindBuffer(m.ARRAY_BUFFER,c.buffer),l(b[c.buffer.belongsToAttribute]),\\nm.vertexAttribPointer(b[c.buffer.belongsToAttribute],c.size,m.FLOAT,!1,0,0));0<=b.color&&(0<f.geometry.colors.length||0<f.geometry.faces.length?(m.bindBuffer(m.ARRAY_BUFFER,e.__webglColorBuffer),l(b.color),m.vertexAttribPointer(b.color,3,m.FLOAT,!1,0,0)):d.defaultAttributeValues&&m.vertexAttrib3fv(b.color,d.defaultAttributeValues.color));0<=b.normal&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglNormalBuffer),l(b.normal),m.vertexAttribPointer(b.normal,3,m.FLOAT,!1,0,0));0<=b.tangent&&(m.bindBuffer(m.ARRAY_BUFFER,\\ne.__webglTangentBuffer),l(b.tangent),m.vertexAttribPointer(b.tangent,4,m.FLOAT,!1,0,0));0<=b.uv&&(f.geometry.faceVertexUvs[0]?(m.bindBuffer(m.ARRAY_BUFFER,e.__webglUVBuffer),l(b.uv),m.vertexAttribPointer(b.uv,2,m.FLOAT,!1,0,0)):d.defaultAttributeValues&&m.vertexAttrib2fv(b.uv,d.defaultAttributeValues.uv));0<=b.uv2&&(f.geometry.faceVertexUvs[1]?(m.bindBuffer(m.ARRAY_BUFFER,e.__webglUV2Buffer),l(b.uv2),m.vertexAttribPointer(b.uv2,2,m.FLOAT,!1,0,0)):d.defaultAttributeValues&&m.vertexAttrib2fv(b.uv2,\\nd.defaultAttributeValues.uv2));d.skinning&&0<=b.skinIndex&&0<=b.skinWeight&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglSkinIndicesBuffer),l(b.skinIndex),m.vertexAttribPointer(b.skinIndex,4,m.FLOAT,!1,0,0),m.bindBuffer(m.ARRAY_BUFFER,e.__webglSkinWeightsBuffer),l(b.skinWeight),m.vertexAttribPointer(b.skinWeight,4,m.FLOAT,!1,0,0));0<=b.lineDistance&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglLineDistanceBuffer),l(b.lineDistance),m.vertexAttribPointer(b.lineDistance,1,m.FLOAT,!1,0,0))}n();f instanceof THREE.Mesh?\\n(f=e.__typeArray===Uint32Array?m.UNSIGNED_INT:m.UNSIGNED_SHORT,d.wireframe?(O(d.wireframeLinewidth),a&&m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,e.__webglLineBuffer),m.drawElements(m.LINES,e.__webglLineCount,f,0)):(a&&m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,e.__webglFaceBuffer),m.drawElements(m.TRIANGLES,e.__webglFaceCount,f,0)),G.info.render.calls++,G.info.render.vertices+=e.__webglFaceCount,G.info.render.faces+=e.__webglFaceCount/3):f instanceof THREE.Line?(f=f.type===THREE.LineStrip?m.LINE_STRIP:m.LINES,\\nO(d.linewidth),m.drawArrays(f,0,e.__webglLineCount),G.info.render.calls++):f instanceof THREE.PointCloud&&(m.drawArrays(m.POINTS,0,e.__webglParticleCount),G.info.render.calls++,G.info.render.points+=e.__webglParticleCount)}};this.render=function(a,b,c,d){function e(a){a instanceof THREE.SkinnedMesh&&a.skeleton.update();for(var b=0,c=a.children.length;b<c;b++)e(a.children[b])}if(!1===b instanceof THREE.Camera)console.error(\\\"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\\\");else{var f,\\ng,h,k,m=a.__lights,l=a.fog;Ca=-1;la=null;fb=!0;!0===a.autoUpdate&&a.updateMatrixWorld();void 0===b.parent&&b.updateMatrixWorld();e(a);b.matrixWorldInverse.getInverse(b.matrixWorld);Ub.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);jc.setFromMatrix(Ub);fc(a);Oa.length=0;Pa.length=0;s(a,a,b);!0===G.sortObjects&&(Oa.sort(q),Pa.sort(r));p(this.renderPluginsPre,a,b);G.info.render.calls=0;G.info.render.vertices=0;G.info.render.faces=0;G.info.render.points=0;this.setRenderTarget(c);(this.autoClear||\\nd)&&this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil);k=a.__webglObjectsImmediate;d=0;for(f=k.length;d<f;d++)g=k[d],h=g.object,h.visible&&(N(h,b),u(g));a.overrideMaterial?(d=a.overrideMaterial,this.setBlending(d.blending,d.blendEquation,d.blendSrc,d.blendDst),this.setDepthTest(d.depthTest),this.setDepthWrite(d.depthWrite),J(d.polygonOffset,d.polygonOffsetFactor,d.polygonOffsetUnits),v(Oa,b,m,l,!0,d),v(Pa,b,m,l,!0,d),w(a.__webglObjectsImmediate,\\\"\\\",b,m,l,!1,d)):(d=null,this.setBlending(THREE.NoBlending),\\nv(Oa,b,m,l,!1,d),w(a.__webglObjectsImmediate,\\\"opaque\\\",b,m,l,!1,d),v(Pa,b,m,l,!0,d),w(a.__webglObjectsImmediate,\\\"transparent\\\",b,m,l,!0,d));p(this.renderPluginsPost,a,b);c&&c.generateMipmaps&&c.minFilter!==THREE.NearestFilter&&c.minFilter!==THREE.LinearFilter&&L(c);this.setDepthTest(!0);this.setDepthWrite(!0)}};this.renderImmediateObject=function(a,b,c,d,e){var f=z(a,b,c,d,e);ca=-1;G.setMaterialFaces(d);e.immediateRenderCallback?e.immediateRenderCallback(f,m,jc):e.render(function(a){G.renderBufferImmediate(a,\\nf,d)})};var fc=function(a){a.__webglObjects||(a.__webglObjects={},a.__webglObjectsImmediate=[]);for(;a.__objectsAdded.length;){var c=a.__objectsAdded[0],d=a,e=void 0,f=void 0;void 0===c.__webglInit&&(c.__webglInit=!0,c._modelViewMatrix=new THREE.Matrix4,c._normalMatrix=new THREE.Matrix3);e=c.geometry;if(void 0!==e&&void 0===e.__webglInit)if(e.__webglInit=!0,e.addEventListener(\\\"dispose\\\",gc),e instanceof THREE.BufferGeometry)g(e);else if(c instanceof THREE.Mesh)void 0!==c.__webglActive&&I(c,d),D(d,\\nc,e);else if(c instanceof THREE.Line){if(!e.__webglVertexBuffer){f=e;f.__webglVertexBuffer=m.createBuffer();f.__webglColorBuffer=m.createBuffer();f.__webglLineDistanceBuffer=m.createBuffer();G.info.memory.geometries++;var f=e,h=c,k=f.vertices.length;f.__vertexArray=new Float32Array(3*k);f.__colorArray=new Float32Array(3*k);f.__lineDistanceArray=new Float32Array(1*k);f.__webglLineCount=k;b(f,h);e.verticesNeedUpdate=!0;e.colorsNeedUpdate=!0;e.lineDistancesNeedUpdate=!0}}else c instanceof THREE.PointCloud&&\\n!e.__webglVertexBuffer&&(f=e,f.__webglVertexBuffer=m.createBuffer(),f.__webglColorBuffer=m.createBuffer(),G.info.memory.geometries++,f=e,h=c,k=f.vertices.length,f.__vertexArray=new Float32Array(3*k),f.__colorArray=new Float32Array(3*k),f.__sortArray=[],f.__webglParticleCount=k,b(f,h),e.verticesNeedUpdate=!0,e.colorsNeedUpdate=!0);if(void 0===c.__webglActive){if(c instanceof THREE.Mesh)if(e=c.geometry,e instanceof THREE.BufferGeometry)A(d.__webglObjects,e,c);else{if(e instanceof THREE.Geometry)for(h=\\n0,k=e.geometryGroupsList.length;h<k;h++)f=e.geometryGroupsList[h],A(d.__webglObjects,f,c)}else c instanceof THREE.Line||c instanceof THREE.PointCloud?(e=c.geometry,A(d.__webglObjects,e,c)):(c instanceof THREE.ImmediateRenderObject||c.immediateRenderCallback)&&d.__webglObjectsImmediate.push({id:null,object:c,opaque:null,transparent:null,z:0});c.__webglActive=!0}a.__objectsAdded.splice(0,1)}for(;a.__objectsRemoved.length;)I(a.__objectsRemoved[0],a),a.__objectsRemoved.splice(0,1)};this.initMaterial=\\nfunction(a,b,c,d){var e,f,g,h;a.addEventListener(\\\"dispose\\\",ic);var k,l,n,p;a instanceof THREE.MeshDepthMaterial?p=\\\"depth\\\":a instanceof THREE.MeshNormalMaterial?p=\\\"normal\\\":a instanceof THREE.MeshBasicMaterial?p=\\\"basic\\\":a instanceof THREE.MeshLambertMaterial?p=\\\"lambert\\\":a instanceof THREE.MeshPhongMaterial?p=\\\"phong\\\":a instanceof THREE.LineBasicMaterial?p=\\\"basic\\\":a instanceof THREE.LineDashedMaterial?p=\\\"dashed\\\":a instanceof THREE.PointCloudMaterial&&(p=\\\"particle_basic\\\");p?(e=THREE.ShaderLib[p],a.__webglShader=\\n{uniforms:THREE.UniformsUtils.clone(e.uniforms),vertexShader:e.vertexShader,fragmentShader:e.fragmentShader}):a.__webglShader={uniforms:a.uniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader};n=h=g=f=e=0;for(var r=b.length;n<r;n++){var q=b[n];q.onlyShadow||!1===q.visible||(q instanceof THREE.DirectionalLight&&e++,q instanceof THREE.PointLight&&f++,q instanceof THREE.SpotLight&&g++,q instanceof THREE.HemisphereLight&&h++)}r=n=0;for(q=b.length;r<q;r++){var s=b[r];s.castShadow&&(s instanceof\\nTHREE.SpotLight&&n++,s instanceof THREE.DirectionalLight&&!s.shadowCascade&&n++)}b=n;Ob&&d&&d.skeleton&&d.skeleton.useVertexTexture?n=1024:(n=m.getParameter(m.MAX_VERTEX_UNIFORM_VECTORS),n=Math.floor((n-20)/4),void 0!==d&&d instanceof THREE.SkinnedMesh&&(n=Math.min(d.skeleton.bones.length,n),n<d.skeleton.bones.length&&console.warn(\\\"WebGLRenderer: too many bones - \\\"+d.skeleton.bones.length+\\\", this GPU supports just \\\"+n+\\\" (try OpenGL instead of ANGLE)\\\")));c={precision:W,supportsVertexTextures:Sb,map:!!a.map,\\nenvMap:!!a.envMap,lightMap:!!a.lightMap,bumpMap:!!a.bumpMap,normalMap:!!a.normalMap,specularMap:!!a.specularMap,alphaMap:!!a.alphaMap,vertexColors:a.vertexColors,fog:c,useFog:a.fog,fogExp:c instanceof THREE.FogExp2,sizeAttenuation:a.sizeAttenuation,logarithmicDepthBuffer:Ea,skinning:a.skinning,maxBones:n,useVertexTexture:Ob&&d&&d.skeleton&&d.skeleton.useVertexTexture,morphTargets:a.morphTargets,morphNormals:a.morphNormals,maxMorphTargets:this.maxMorphTargets,maxMorphNormals:this.maxMorphNormals,maxDirLights:e,\\nmaxPointLights:f,maxSpotLights:g,maxHemiLights:h,maxShadows:b,shadowMapEnabled:this.shadowMapEnabled&&d.receiveShadow&&0<b,shadowMapType:this.shadowMapType,shadowMapDebug:this.shadowMapDebug,shadowMapCascade:this.shadowMapCascade,alphaTest:a.alphaTest,metal:a.metal,wrapAround:a.wrapAround,doubleSided:a.side===THREE.DoubleSide,flipSided:a.side===THREE.BackSide};d=[];p?d.push(p):(d.push(a.fragmentShader),d.push(a.vertexShader));for(var t in a.defines)d.push(t),d.push(a.defines[t]);for(l in c)d.push(l),\\nd.push(c[l]);p=d.join();var u;l=0;for(t=Ba.length;l<t;l++)if(d=Ba[l],d.code===p){u=d;u.usedTimes++;break}void 0===u&&(u=new THREE.WebGLProgram(this,p,a,c),Ba.push(u),G.info.memory.programs=Ba.length);a.program=u;u=a.program.attributes;if(a.morphTargets)for(a.numSupportedMorphTargets=0,t=\\\"morphTarget\\\",l=0;l<this.maxMorphTargets;l++)p=t+l,0<=u[p]&&a.numSupportedMorphTargets++;if(a.morphNormals)for(a.numSupportedMorphNormals=0,t=\\\"morphNormal\\\",l=0;l<this.maxMorphNormals;l++)p=t+l,0<=u[p]&&a.numSupportedMorphNormals++;\\na.uniformsList=[];for(k in a.__webglShader.uniforms)(l=a.program.uniforms[k])&&a.uniformsList.push([a.__webglShader.uniforms[k],l])};this.setFaceCulling=function(a,b){a===THREE.CullFaceNone?m.disable(m.CULL_FACE):(b===THREE.FrontFaceDirectionCW?m.frontFace(m.CW):m.frontFace(m.CCW),a===THREE.CullFaceBack?m.cullFace(m.BACK):a===THREE.CullFaceFront?m.cullFace(m.FRONT):m.cullFace(m.FRONT_AND_BACK),m.enable(m.CULL_FACE))};this.setMaterialFaces=function(a){var b=a.side===THREE.DoubleSide;a=a.side===THREE.BackSide;\\nua!==b&&(b?m.disable(m.CULL_FACE):m.enable(m.CULL_FACE),ua=b);ja!==a&&(a?m.frontFace(m.CW):m.frontFace(m.CCW),ja=a)};this.setDepthTest=function(a){ra!==a&&(a?m.enable(m.DEPTH_TEST):m.disable(m.DEPTH_TEST),ra=a)};this.setDepthWrite=function(a){Da!==a&&(m.depthMask(a),Da=a)};this.setBlending=function(a,b,c,d){a!==Fa&&(a===THREE.NoBlending?m.disable(m.BLEND):a===THREE.AdditiveBlending?(m.enable(m.BLEND),m.blendEquation(m.FUNC_ADD),m.blendFunc(m.SRC_ALPHA,m.ONE)):a===THREE.SubtractiveBlending?(m.enable(m.BLEND),\\nm.blendEquation(m.FUNC_ADD),m.blendFunc(m.ZERO,m.ONE_MINUS_SRC_COLOR)):a===THREE.MultiplyBlending?(m.enable(m.BLEND),m.blendEquation(m.FUNC_ADD),m.blendFunc(m.ZERO,m.SRC_COLOR)):a===THREE.CustomBlending?m.enable(m.BLEND):(m.enable(m.BLEND),m.blendEquationSeparate(m.FUNC_ADD,m.FUNC_ADD),m.blendFuncSeparate(m.SRC_ALPHA,m.ONE_MINUS_SRC_ALPHA,m.ONE,m.ONE_MINUS_SRC_ALPHA)),Fa=a);if(a===THREE.CustomBlending){if(b!==va&&(m.blendEquation(B(b)),va=b),c!==Ka||d!==aa)m.blendFunc(B(c),B(d)),Ka=c,aa=d}else aa=\\nKa=va=null};this.setTexture=function(a,b){hack.log(\\\"\\\",hack.render,\\\"THREE.WebGLRenderer.setTexture\\\");if(a.needsUpdate){a.__webglInit||(a.__webglInit=!0,a.addEventListener(\\\"dispose\\\",Pb),a.__webglTexture=m.createTexture(),G.info.memory.textures++);m.activeTexture(m.TEXTURE0+b);m.bindTexture(m.TEXTURE_2D,a.__webglTexture);m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL,a.flipY);m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultiplyAlpha);m.pixelStorei(m.UNPACK_ALIGNMENT,a.unpackAlignment);var c=a.image,d=THREE.Math.isPowerOfTwo(c.width)&&\\nTHREE.Math.isPowerOfTwo(c.height),e=B(a.format),f=B(a.type);E(m.TEXTURE_2D,a,d);var g=a.mipmaps;if(a instanceof THREE.DataTexture)if(0<g.length&&d){for(var h=0,k=g.length;h<k;h++)c=g[h],m.texImage2D(m.TEXTURE_2D,h,e,c.width,c.height,0,e,f,c.data);a.generateMipmaps=!1}else m.texImage2D(m.TEXTURE_2D,0,e,c.width,c.height,0,e,f,c.data);else if(a instanceof THREE.CompressedTexture)for(h=0,k=g.length;h<k;h++)c=g[h],a.format!==THREE.RGBAFormat?m.compressedTexImage2D(m.TEXTURE_2D,h,e,c.width,c.height,0,c.data):\\nm.texImage2D(m.TEXTURE_2D,h,e,c.width,c.height,0,e,f,c.data);else if(0<g.length&&d){h=0;for(k=g.length;h<k;h++)c=g[h],m.texImage2D(m.TEXTURE_2D,h,e,e,f,c);a.generateMipmaps=!1}else m.texImage2D(m.TEXTURE_2D,0,e,e,f,a.image);a.generateMipmaps&&d&&m.generateMipmap(m.TEXTURE_2D);a.needsUpdate=!1;if(a.onUpdate)a.onUpdate()}else m.activeTexture(m.TEXTURE0+b),m.bindTexture(m.TEXTURE_2D,a.__webglTexture)};this.setRenderTarget=function(a){var b=a instanceof THREE.WebGLRenderTargetCube;if(a&&!a.__webglFramebuffer){void 0===\\na.depthBuffer&&(a.depthBuffer=!0);void 0===a.stencilBuffer&&(a.stencilBuffer=!0);a.addEventListener(\\\"dispose\\\",hc);a.__webglTexture=m.createTexture();G.info.memory.textures++;var c=THREE.Math.isPowerOfTwo(a.width)&&THREE.Math.isPowerOfTwo(a.height),d=B(a.format),e=B(a.type);if(b){a.__webglFramebuffer=[];a.__webglRenderbuffer=[];m.bindTexture(m.TEXTURE_CUBE_MAP,a.__webglTexture);E(m.TEXTURE_CUBE_MAP,a,c);for(var f=0;6>f;f++){a.__webglFramebuffer[f]=m.createFramebuffer();a.__webglRenderbuffer[f]=m.createRenderbuffer();\\nm.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+f,0,d,a.width,a.height,0,d,e,null);var g=a,h=m.TEXTURE_CUBE_MAP_POSITIVE_X+f;m.bindFramebuffer(m.FRAMEBUFFER,a.__webglFramebuffer[f]);m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,h,g.__webglTexture,0);Q(a.__webglRenderbuffer[f],a)}c&&m.generateMipmap(m.TEXTURE_CUBE_MAP)}else a.__webglFramebuffer=m.createFramebuffer(),a.__webglRenderbuffer=a.shareDepthFrom?a.shareDepthFrom.__webglRenderbuffer:m.createRenderbuffer(),m.bindTexture(m.TEXTURE_2D,a.__webglTexture),\\nE(m.TEXTURE_2D,a,c),m.texImage2D(m.TEXTURE_2D,0,d,a.width,a.height,0,d,e,null),d=m.TEXTURE_2D,m.bindFramebuffer(m.FRAMEBUFFER,a.__webglFramebuffer),m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,d,a.__webglTexture,0),a.shareDepthFrom?a.depthBuffer&&!a.stencilBuffer?m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_ATTACHMENT,m.RENDERBUFFER,a.__webglRenderbuffer):a.depthBuffer&&a.stencilBuffer&&m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_STENCIL_ATTACHMENT,m.RENDERBUFFER,a.__webglRenderbuffer):\\nQ(a.__webglRenderbuffer,a),c&&m.generateMipmap(m.TEXTURE_2D);b?m.bindTexture(m.TEXTURE_CUBE_MAP,null):m.bindTexture(m.TEXTURE_2D,null);m.bindRenderbuffer(m.RENDERBUFFER,null);m.bindFramebuffer(m.FRAMEBUFFER,null)}a?(b=b?a.__webglFramebuffer[a.activeCubeFace]:a.__webglFramebuffer,c=a.width,a=a.height,e=d=0):(b=null,c=wb,a=sb,d=ma,e=Ja);b!==Za&&(m.bindFramebuffer(m.FRAMEBUFFER,b),m.viewport(d,e,c,a),Za=b);Hb=c;Ib=a};this.shadowMapPlugin=new THREE.ShadowMapPlugin;this.addPrePlugin(this.shadowMapPlugin);\\nthis.addPostPlugin(new THREE.SpritePlugin);this.addPostPlugin(new THREE.LensFlarePlugin)};\\nTHREE.WebGLRenderTarget=function(a,b,c){this.width=a;this.height=b;c=c||{};this.wrapS=void 0!==c.wrapS?c.wrapS:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==c.wrapT?c.wrapT:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==c.magFilter?c.magFilter:THREE.LinearFilter;this.minFilter=void 0!==c.minFilter?c.minFilter:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==c.anisotropy?c.anisotropy:1;this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.format=void 0!==c.format?c.format:\\nTHREE.RGBAFormat;this.type=void 0!==c.type?c.type:THREE.UnsignedByteType;this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.generateMipmaps=!0;this.shareDepthFrom=null};\\nTHREE.WebGLRenderTarget.prototype={constructor:THREE.WebGLRenderTarget,setSize:function(a,b){this.width=a;this.height=b},clone:function(){var a=new THREE.WebGLRenderTarget(this.width,this.height);a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.format=this.format;a.type=this.type;a.depthBuffer=this.depthBuffer;a.stencilBuffer=this.stencilBuffer;a.generateMipmaps=this.generateMipmaps;\\na.shareDepthFrom=this.shareDepthFrom;return a},dispose:function(){this.dispatchEvent({type:\\\"dispose\\\"})}};THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);THREE.WebGLRenderTargetCube=function(a,b,c){THREE.WebGLRenderTarget.call(this,a,b,c);this.activeCubeFace=0};THREE.WebGLRenderTargetCube.prototype=Object.create(THREE.WebGLRenderTarget.prototype);\\nTHREE.WebGLProgram=function(){var a=0;return function(b,c,d,e){var f=b.context,g=d.defines,h=d.__webglShader.uniforms,k=d.attributes,l=d.__webglShader.vertexShader,n=d.__webglShader.fragmentShader,q=d.index0AttributeName;void 0===q&&!0===e.morphTargets&&(q=\\\"position\\\");var r=\\\"SHADOWMAP_TYPE_BASIC\\\";e.shadowMapType===THREE.PCFShadowMap?r=\\\"SHADOWMAP_TYPE_PCF\\\":e.shadowMapType===THREE.PCFSoftShadowMap&&(r=\\\"SHADOWMAP_TYPE_PCF_SOFT\\\");var t,s;t=[];for(var p in g)s=g[p],!1!==s&&(s=\\\"#define \\\"+p+\\\" \\\"+s,t.push(s));\\nt=t.join(\\\"\\\\n\\\");g=f.createProgram();d instanceof THREE.RawShaderMaterial?b=d=\\\"\\\":(d=[\\\"precision \\\"+e.precision+\\\" float;\\\",\\\"precision \\\"+e.precision+\\\" int;\\\",t,e.supportsVertexTextures?\\\"#define VERTEX_TEXTURES\\\":\\\"\\\",b.gammaInput?\\\"#define GAMMA_INPUT\\\":\\\"\\\",b.gammaOutput?\\\"#define GAMMA_OUTPUT\\\":\\\"\\\",\\\"#define MAX_DIR_LIGHTS \\\"+e.maxDirLights,\\\"#define MAX_POINT_LIGHTS \\\"+e.maxPointLights,\\\"#define MAX_SPOT_LIGHTS \\\"+e.maxSpotLights,\\\"#define MAX_HEMI_LIGHTS \\\"+e.maxHemiLights,\\\"#define MAX_SHADOWS \\\"+e.maxShadows,\\\"#define MAX_BONES \\\"+\\ne.maxBones,e.map?\\\"#define USE_MAP\\\":\\\"\\\",e.envMap?\\\"#define USE_ENVMAP\\\":\\\"\\\",e.lightMap?\\\"#define USE_LIGHTMAP\\\":\\\"\\\",e.bumpMap?\\\"#define USE_BUMPMAP\\\":\\\"\\\",e.normalMap?\\\"#define USE_NORMALMAP\\\":\\\"\\\",e.specularMap?\\\"#define USE_SPECULARMAP\\\":\\\"\\\",e.alphaMap?\\\"#define USE_ALPHAMAP\\\":\\\"\\\",e.vertexColors?\\\"#define USE_COLOR\\\":\\\"\\\",e.skinning?\\\"#define USE_SKINNING\\\":\\\"\\\",e.useVertexTexture?\\\"#define BONE_TEXTURE\\\":\\\"\\\",e.morphTargets?\\\"#define USE_MORPHTARGETS\\\":\\\"\\\",e.morphNormals?\\\"#define USE_MORPHNORMALS\\\":\\\"\\\",e.wrapAround?\\\"#define WRAP_AROUND\\\":\\n\\\"\\\",e.doubleSided?\\\"#define DOUBLE_SIDED\\\":\\\"\\\",e.flipSided?\\\"#define FLIP_SIDED\\\":\\\"\\\",e.shadowMapEnabled?\\\"#define USE_SHADOWMAP\\\":\\\"\\\",e.shadowMapEnabled?\\\"#define \\\"+r:\\\"\\\",e.shadowMapDebug?\\\"#define SHADOWMAP_DEBUG\\\":\\\"\\\",e.shadowMapCascade?\\\"#define SHADOWMAP_CASCADE\\\":\\\"\\\",e.sizeAttenuation?\\\"#define USE_SIZEATTENUATION\\\":\\\"\\\",e.logarithmicDepthBuffer?\\\"#define USE_LOGDEPTHBUF\\\":\\\"\\\",\\\"uniform mat4 modelMatrix;\\\\nuniform mat4 modelViewMatrix;\\\\nuniform mat4 projectionMatrix;\\\\nuniform mat4 viewMatrix;\\\\nuniform mat3 normalMatrix;\\\\nuniform vec3 cameraPosition;\\\\nattribute vec3 position;\\\\nattribute vec3 normal;\\\\nattribute vec2 uv;\\\\nattribute vec2 uv2;\\\\n#ifdef USE_COLOR\\\\n\\\\tattribute vec3 color;\\\\n#endif\\\\n#ifdef USE_MORPHTARGETS\\\\n\\\\tattribute vec3 morphTarget0;\\\\n\\\\tattribute vec3 morphTarget1;\\\\n\\\\tattribute vec3 morphTarget2;\\\\n\\\\tattribute vec3 morphTarget3;\\\\n\\\\t#ifdef USE_MORPHNORMALS\\\\n\\\\t\\\\tattribute vec3 morphNormal0;\\\\n\\\\t\\\\tattribute vec3 morphNormal1;\\\\n\\\\t\\\\tattribute vec3 morphNormal2;\\\\n\\\\t\\\\tattribute vec3 morphNormal3;\\\\n\\\\t#else\\\\n\\\\t\\\\tattribute vec3 morphTarget4;\\\\n\\\\t\\\\tattribute vec3 morphTarget5;\\\\n\\\\t\\\\tattribute vec3 morphTarget6;\\\\n\\\\t\\\\tattribute vec3 morphTarget7;\\\\n\\\\t#endif\\\\n#endif\\\\n#ifdef USE_SKINNING\\\\n\\\\tattribute vec4 skinIndex;\\\\n\\\\tattribute vec4 skinWeight;\\\\n#endif\\\\n\\\"].join(\\\"\\\\n\\\"),\\nb=[\\\"precision \\\"+e.precision+\\\" float;\\\",\\\"precision \\\"+e.precision+\\\" int;\\\",e.bumpMap||e.normalMap?\\\"#extension GL_OES_standard_derivatives : enable\\\":\\\"\\\",t,\\\"#define MAX_DIR_LIGHTS \\\"+e.maxDirLights,\\\"#define MAX_POINT_LIGHTS \\\"+e.maxPointLights,\\\"#define MAX_SPOT_LIGHTS \\\"+e.maxSpotLights,\\\"#define MAX_HEMI_LIGHTS \\\"+e.maxHemiLights,\\\"#define MAX_SHADOWS \\\"+e.maxShadows,e.alphaTest?\\\"#define ALPHATEST \\\"+e.alphaTest:\\\"\\\",b.gammaInput?\\\"#define GAMMA_INPUT\\\":\\\"\\\",b.gammaOutput?\\\"#define GAMMA_OUTPUT\\\":\\\"\\\",e.useFog&&e.fog?\\\"#define USE_FOG\\\":\\n\\\"\\\",e.useFog&&e.fogExp?\\\"#define FOG_EXP2\\\":\\\"\\\",e.map?\\\"#define USE_MAP\\\":\\\"\\\",e.envMap?\\\"#define USE_ENVMAP\\\":\\\"\\\",e.lightMap?\\\"#define USE_LIGHTMAP\\\":\\\"\\\",e.bumpMap?\\\"#define USE_BUMPMAP\\\":\\\"\\\",e.normalMap?\\\"#define USE_NORMALMAP\\\":\\\"\\\",e.specularMap?\\\"#define USE_SPECULARMAP\\\":\\\"\\\",e.alphaMap?\\\"#define USE_ALPHAMAP\\\":\\\"\\\",e.vertexColors?\\\"#define USE_COLOR\\\":\\\"\\\",e.metal?\\\"#define METAL\\\":\\\"\\\",e.wrapAround?\\\"#define WRAP_AROUND\\\":\\\"\\\",e.doubleSided?\\\"#define DOUBLE_SIDED\\\":\\\"\\\",e.flipSided?\\\"#define FLIP_SIDED\\\":\\\"\\\",e.shadowMapEnabled?\\\"#define USE_SHADOWMAP\\\":\\n\\\"\\\",e.shadowMapEnabled?\\\"#define \\\"+r:\\\"\\\",e.shadowMapDebug?\\\"#define SHADOWMAP_DEBUG\\\":\\\"\\\",e.shadowMapCascade?\\\"#define SHADOWMAP_CASCADE\\\":\\\"\\\",e.logarithmicDepthBuffer?\\\"#define USE_LOGDEPTHBUF\\\":\\\"\\\",\\\"uniform mat4 viewMatrix;\\\\nuniform vec3 cameraPosition;\\\\n\\\"].join(\\\"\\\\n\\\"));l=new THREE.WebGLShader(f,f.VERTEX_SHADER,d+l);n=new THREE.WebGLShader(f,f.FRAGMENT_SHADER,b+n);f.attachShader(g,l);f.attachShader(g,n);void 0!==q&&f.bindAttribLocation(g,0,q);f.linkProgram(g);!1===f.getProgramParameter(g,f.LINK_STATUS)&&(console.error(\\\"THREE.WebGLProgram: Could not initialise shader.\\\"),\\nconsole.error(\\\"gl.VALIDATE_STATUS\\\",f.getProgramParameter(g,f.VALIDATE_STATUS)),console.error(\\\"gl.getError()\\\",f.getError()));\\\"\\\"!==f.getProgramInfoLog(g)&&console.warn(\\\"THREE.WebGLProgram: gl.getProgramInfoLog()\\\",f.getProgramInfoLog(g));f.deleteShader(l);f.deleteShader(n);q=\\\"viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse\\\".split(\\\" \\\");e.useVertexTexture?(q.push(\\\"boneTexture\\\"),q.push(\\\"boneTextureWidth\\\"),q.push(\\\"boneTextureHeight\\\")):\\nq.push(\\\"boneGlobalMatrices\\\");e.logarithmicDepthBuffer&&q.push(\\\"logDepthBufFC\\\");for(var v in h)q.push(v);h=q;v={};q=0;for(b=h.length;q<b;q++)r=h[q],v[r]=f.getUniformLocation(g,r);this.uniforms=v;q=\\\"position normal uv uv2 tangent color skinIndex skinWeight lineDistance\\\".split(\\\" \\\");for(h=0;h<e.maxMorphTargets;h++)q.push(\\\"morphTarget\\\"+h);for(h=0;h<e.maxMorphNormals;h++)q.push(\\\"morphNormal\\\"+h);for(var w in k)q.push(w);e=q;k={};w=0;for(h=e.length;w<h;w++)v=e[w],k[v]=f.getAttribLocation(g,v);this.attributes=\\nk;this.id=a++;this.code=c;this.usedTimes=1;this.program=g;this.vertexShader=l;this.fragmentShader=n;return this}}();\\nTHREE.WebGLShader=function(){var a=function(a){a=a.split(\\\"\\\\n\\\");for(var c=0;c<a.length;c++)a[c]=c+1+\\\": \\\"+a[c];return a.join(\\\"\\\\n\\\")};return function(b,c,d){c=b.createShader(c);b.shaderSource(c,d);b.compileShader(c);!1===b.getShaderParameter(c,b.COMPILE_STATUS)&&console.error(\\\"THREE.WebGLShader: Shader couldn't compile.\\\");\\\"\\\"!==b.getShaderInfoLog(c)&&(console.warn(\\\"THREE.WebGLShader: gl.getShaderInfoLog()\\\",b.getShaderInfoLog(c)),console.warn(a(d)));return c}}();\\nTHREE.RenderableVertex=function(){this.position=new THREE.Vector3;this.positionWorld=new THREE.Vector3;this.positionScreen=new THREE.Vector4;this.visible=!0};THREE.RenderableVertex.prototype.copy=function(a){this.positionWorld.copy(a.positionWorld);this.positionScreen.copy(a.positionScreen)};\\nTHREE.RenderableFace=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.v3=new THREE.RenderableVertex;this.normalModel=new THREE.Vector3;this.vertexNormalsModel=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.vertexNormalsLength=0;this.color=new THREE.Color;this.material=null;this.uvs=[new THREE.Vector2,new THREE.Vector2,new THREE.Vector2];this.z=0};THREE.RenderableObject=function(){this.id=0;this.object=null;this.z=0};\\nTHREE.RenderableSprite=function(){this.id=0;this.object=null;this.rotation=this.z=this.y=this.x=0;this.scale=new THREE.Vector2;this.material=null};THREE.RenderableLine=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.vertexColors=[new THREE.Color,new THREE.Color];this.material=null;this.z=0};\\nTHREE.GeometryUtils={merge:function(a,b,c){console.warn(\\\"THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.\\\");var d;b instanceof THREE.Mesh&&(b.matrixAutoUpdate&&b.updateMatrix(),d=b.matrix,b=b.geometry);a.merge(b,d,c)},center:function(a){console.warn(\\\"THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.\\\");return a.center()}};\\nTHREE.ImageUtils={crossOrigin:void 0,loadTexture:function(a,b,c,d){var e=new THREE.ImageLoader;e.crossOrigin=this.crossOrigin;var f=new THREE.Texture(void 0,b);e.load(a,function(a){f.image=a;f.needsUpdate=!0;c&&c(f)},void 0,function(a){d&&d(a)});f.sourceFile=a;return f},loadTextureCube:function(a,b,c,d){var e=new THREE.ImageLoader;e.crossOrigin=this.crossOrigin;var f=new THREE.CubeTexture([],b);f.flipY=!1;var g=0;b=function(b){e.load(a[b],function(a){f.images[b]=a;g+=1;6===g&&(f.needsUpdate=!0,c&&\\nc(f))})};d=0;for(var h=a.length;d<h;++d)b(d);return f},loadCompressedTexture:function(){console.error(\\\"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.\\\")},loadCompressedTextureCube:function(){console.error(\\\"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.\\\")},getNormalMap:function(a,b){var c=function(a){var b=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);return[a[0]/b,a[1]/b,a[2]/b]};b|=1;var d=a.width,e=a.height,f=document.createElement(\\\"canvas\\\");\\nf.width=d;f.height=e;var g=f.getContext(\\\"2d\\\");g.drawImage(a,0,0);for(var h=g.getImageData(0,0,d,e).data,k=g.createImageData(d,e),l=k.data,n=0;n<d;n++)for(var q=0;q<e;q++){var r=0>q-1?0:q-1,t=q+1>e-1?e-1:q+1,s=0>n-1?0:n-1,p=n+1>d-1?d-1:n+1,v=[],w=[0,0,h[4*(q*d+n)]/255*b];v.push([-1,0,h[4*(q*d+s)]/255*b]);v.push([-1,-1,h[4*(r*d+s)]/255*b]);v.push([0,-1,h[4*(r*d+n)]/255*b]);v.push([1,-1,h[4*(r*d+p)]/255*b]);v.push([1,0,h[4*(q*d+p)]/255*b]);v.push([1,1,h[4*(t*d+p)]/255*b]);v.push([0,1,h[4*(t*d+n)]/255*\\nb]);v.push([-1,1,h[4*(t*d+s)]/255*b]);r=[];s=v.length;for(t=0;t<s;t++){var p=v[t],u=v[(t+1)%s],p=[p[0]-w[0],p[1]-w[1],p[2]-w[2]],u=[u[0]-w[0],u[1]-w[1],u[2]-w[2]];r.push(c([p[1]*u[2]-p[2]*u[1],p[2]*u[0]-p[0]*u[2],p[0]*u[1]-p[1]*u[0]]))}v=[0,0,0];for(t=0;t<r.length;t++)v[0]+=r[t][0],v[1]+=r[t][1],v[2]+=r[t][2];v[0]/=r.length;v[1]/=r.length;v[2]/=r.length;w=4*(q*d+n);l[w]=(v[0]+1)/2*255|0;l[w+1]=(v[1]+1)/2*255|0;l[w+2]=255*v[2]|0;l[w+3]=255}g.putImageData(k,0,0);return f},generateDataTexture:function(a,\\nb,c){var d=a*b,e=new Uint8Array(3*d),f=Math.floor(255*c.r),g=Math.floor(255*c.g);c=Math.floor(255*c.b);for(var h=0;h<d;h++)e[3*h]=f,e[3*h+1]=g,e[3*h+2]=c;a=new THREE.DataTexture(e,a,b,THREE.RGBFormat);a.needsUpdate=!0;return a}};\\nTHREE.SceneUtils={createMultiMaterialObject:function(a,b){for(var c=new THREE.Object3D,d=0,e=b.length;d<e;d++)c.add(new THREE.Mesh(a,b[d]));return c},detach:function(a,b,c){a.applyMatrix(b.matrixWorld);b.remove(a);c.add(a)},attach:function(a,b,c){var d=new THREE.Matrix4;d.getInverse(c.matrixWorld);a.applyMatrix(d);b.remove(a);c.add(a)}};\\nTHREE.FontUtils={faces:{},face:\\\"helvetiker\\\",weight:\\\"normal\\\",style:\\\"normal\\\",size:150,divisions:10,getFace:function(){try{return this.faces[this.face][this.weight][this.style]}catch(a){throw\\\"The font \\\"+this.face+\\\" with \\\"+this.weight+\\\" weight and \\\"+this.style+\\\" style is missing.\\\";}},loadFace:function(a){var b=a.familyName.toLowerCase();this.faces[b]=this.faces[b]||{};this.faces[b][a.cssFontWeight]=this.faces[b][a.cssFontWeight]||{};this.faces[b][a.cssFontWeight][a.cssFontStyle]=a;return this.faces[b][a.cssFontWeight][a.cssFontStyle]=\\na},drawText:function(a){var b=this.getFace(),c=this.size/b.resolution,d=0,e=String(a).split(\\\"\\\"),f=e.length,g=[];for(a=0;a<f;a++){var h=new THREE.Path,h=this.extractGlyphPoints(e[a],b,c,d,h),d=d+h.offset;g.push(h.path)}return{paths:g,offset:d/2}},extractGlyphPoints:function(a,b,c,d,e){var f=[],g,h,k,l,n,q,r,t,s,p,v,w=b.glyphs[a]||b.glyphs[\\\"?\\\"];if(w){if(w.o)for(b=w._cachedOutline||(w._cachedOutline=w.o.split(\\\" \\\")),l=b.length,a=0;a<l;)switch(k=b[a++],k){case \\\"m\\\":k=b[a++]*c+d;n=b[a++]*c;e.moveTo(k,n);\\nbreak;case \\\"l\\\":k=b[a++]*c+d;n=b[a++]*c;e.lineTo(k,n);break;case \\\"q\\\":k=b[a++]*c+d;n=b[a++]*c;t=b[a++]*c+d;s=b[a++]*c;e.quadraticCurveTo(t,s,k,n);if(g=f[f.length-1])for(q=g.x,r=g.y,g=1,h=this.divisions;g<=h;g++){var u=g/h;THREE.Shape.Utils.b2(u,q,t,k);THREE.Shape.Utils.b2(u,r,s,n)}break;case \\\"b\\\":if(k=b[a++]*c+d,n=b[a++]*c,t=b[a++]*c+d,s=b[a++]*c,p=b[a++]*c+d,v=b[a++]*c,e.bezierCurveTo(t,s,p,v,k,n),g=f[f.length-1])for(q=g.x,r=g.y,g=1,h=this.divisions;g<=h;g++)u=g/h,THREE.Shape.Utils.b3(u,q,t,p,k),THREE.Shape.Utils.b3(u,\\nr,s,v,n)}return{offset:w.ha*c,path:e}}}};\\nTHREE.FontUtils.generateShapes=function(a,b){b=b||{};var c=void 0!==b.curveSegments?b.curveSegments:4,d=void 0!==b.font?b.font:\\\"helvetiker\\\",e=void 0!==b.weight?b.weight:\\\"normal\\\",f=void 0!==b.style?b.style:\\\"normal\\\";THREE.FontUtils.size=void 0!==b.size?b.size:100;THREE.FontUtils.divisions=c;THREE.FontUtils.face=d;THREE.FontUtils.weight=e;THREE.FontUtils.style=f;c=THREE.FontUtils.drawText(a).paths;d=[];e=0;for(f=c.length;e<f;e++)Array.prototype.push.apply(d,c[e].toShapes());return d};\\n(function(a){var b=function(a){for(var b=a.length,e=0,f=b-1,g=0;g<b;f=g++)e+=a[f].x*a[g].y-a[g].x*a[f].y;return.5*e};a.Triangulate=function(a,d){var e=a.length;if(3>e)return null;var f=[],g=[],h=[],k,l,n;if(0<b(a))for(l=0;l<e;l++)g[l]=l;else for(l=0;l<e;l++)g[l]=e-1-l;var q=2*e;for(l=e-1;2<e;){if(0>=q--){console.log(\\\"Warning, unable to triangulate polygon!\\\");break}k=l;e<=k&&(k=0);l=k+1;e<=l&&(l=0);n=l+1;e<=n&&(n=0);var r;a:{var t=r=void 0,s=void 0,p=void 0,v=void 0,w=void 0,u=void 0,D=void 0,A=void 0,\\nt=a[g[k]].x,s=a[g[k]].y,p=a[g[l]].x,v=a[g[l]].y,w=a[g[n]].x,u=a[g[n]].y;if(1E-10>(p-t)*(u-s)-(v-s)*(w-t))r=!1;else{var x=void 0,C=void 0,I=void 0,z=void 0,y=void 0,K=void 0,N=void 0,ba=void 0,P=void 0,O=void 0,P=ba=N=A=D=void 0,x=w-p,C=u-v,I=t-w,z=s-u,y=p-t,K=v-s;for(r=0;r<e;r++)if(D=a[g[r]].x,A=a[g[r]].y,!(D===t&&A===s||D===p&&A===v||D===w&&A===u)&&(N=D-t,ba=A-s,P=D-p,O=A-v,D-=w,A-=u,P=x*O-C*P,N=y*ba-K*N,ba=I*A-z*D,-1E-10<=P&&-1E-10<=ba&&-1E-10<=N)){r=!1;break a}r=!0}}if(r){f.push([a[g[k]],a[g[l]],\\na[g[n]]]);h.push([g[k],g[l],g[n]]);k=l;for(n=l+1;n<e;k++,n++)g[k]=g[n];e--;q=2*e}}return d?h:f};a.Triangulate.area=b;return a})(THREE.FontUtils);self._typeface_js={faces:THREE.FontUtils.faces,loadFace:THREE.FontUtils.loadFace};THREE.typeface_js=self._typeface_js;THREE.Curve=function(){};THREE.Curve.prototype.getPoint=function(a){console.log(\\\"Warning, getPoint() not implemented!\\\");return null};THREE.Curve.prototype.getPointAt=function(a){a=this.getUtoTmapping(a);return this.getPoint(a)};\\nTHREE.Curve.prototype.getPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPoint(b/a));return c};THREE.Curve.prototype.getSpacedPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPointAt(b/a));return c};THREE.Curve.prototype.getLength=function(){var a=this.getLengths();return a[a.length-1]};\\nTHREE.Curve.prototype.getLengths=function(a){a||(a=this.__arcLengthDivisions?this.__arcLengthDivisions:200);if(this.cacheArcLengths&&this.cacheArcLengths.length==a+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var b=[],c,d=this.getPoint(0),e,f=0;b.push(0);for(e=1;e<=a;e++)c=this.getPoint(e/a),f+=c.distanceTo(d),b.push(f),d=c;return this.cacheArcLengths=b};THREE.Curve.prototype.updateArcLengths=function(){this.needsUpdate=!0;this.getLengths()};\\nTHREE.Curve.prototype.getUtoTmapping=function(a,b){var c=this.getLengths(),d=0,e=c.length,f;f=b?b:a*c[e-1];for(var g=0,h=e-1,k;g<=h;)if(d=Math.floor(g+(h-g)/2),k=c[d]-f,0>k)g=d+1;else if(0<k)h=d-1;else{h=d;break}d=h;if(c[d]==f)return d/(e-1);g=c[d];return c=(d+(f-g)/(c[d+1]-g))/(e-1)};THREE.Curve.prototype.getTangent=function(a){var b=a-1E-4;a+=1E-4;0>b&&(b=0);1<a&&(a=1);b=this.getPoint(b);return this.getPoint(a).clone().sub(b).normalize()};\\nTHREE.Curve.prototype.getTangentAt=function(a){a=this.getUtoTmapping(a);return this.getTangent(a)};\\nTHREE.Curve.Utils={tangentQuadraticBezier:function(a,b,c,d){return 2*(1-a)*(c-b)+2*a*(d-c)},tangentCubicBezier:function(a,b,c,d,e){return-3*b*(1-a)*(1-a)+3*c*(1-a)*(1-a)-6*a*c*(1-a)+6*a*d*(1-a)-3*a*a*d+3*a*a*e},tangentSpline:function(a,b,c,d,e){return 6*a*a-6*a+(3*a*a-4*a+1)+(-6*a*a+6*a)+(3*a*a-2*a)},interpolate:function(a,b,c,d,e){a=.5*(c-a);d=.5*(d-b);var f=e*e;return(2*b-2*c+a+d)*e*f+(-3*b+3*c-2*a-d)*f+a*e+b}};\\nTHREE.Curve.create=function(a,b){a.prototype=Object.create(THREE.Curve.prototype);a.prototype.getPoint=b;return a};THREE.CurvePath=function(){this.curves=[];this.bends=[];this.autoClose=!1};THREE.CurvePath.prototype=Object.create(THREE.Curve.prototype);THREE.CurvePath.prototype.add=function(a){this.curves.push(a)};THREE.CurvePath.prototype.checkConnection=function(){};\\nTHREE.CurvePath.prototype.closePath=function(){var a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new THREE.LineCurve(b,a))};THREE.CurvePath.prototype.getPoint=function(a){var b=a*this.getLength(),c=this.getCurveLengths();for(a=0;a<c.length;){if(c[a]>=b)return b=c[a]-b,a=this.curves[a],b=1-b/a.getLength(),a.getPointAt(b);a++}return null};THREE.CurvePath.prototype.getLength=function(){var a=this.getCurveLengths();return a[a.length-1]};\\nTHREE.CurvePath.prototype.getCurveLengths=function(){if(this.cacheLengths&&this.cacheLengths.length==this.curves.length)return this.cacheLengths;var a=[],b=0,c,d=this.curves.length;for(c=0;c<d;c++)b+=this.curves[c].getLength(),a.push(b);return this.cacheLengths=a};\\nTHREE.CurvePath.prototype.getBoundingBox=function(){var a=this.getPoints(),b,c,d,e,f,g;b=c=Number.NEGATIVE_INFINITY;e=f=Number.POSITIVE_INFINITY;var h,k,l,n,q=a[0]instanceof THREE.Vector3;n=q?new THREE.Vector3:new THREE.Vector2;k=0;for(l=a.length;k<l;k++)h=a[k],h.x>b?b=h.x:h.x<e&&(e=h.x),h.y>c?c=h.y:h.y<f&&(f=h.y),q&&(h.z>d?d=h.z:h.z<g&&(g=h.z)),n.add(h);a={minX:e,minY:f,maxX:b,maxY:c};q&&(a.maxZ=d,a.minZ=g);return a};\\nTHREE.CurvePath.prototype.createPointsGeometry=function(a){a=this.getPoints(a,!0);return this.createGeometry(a)};THREE.CurvePath.prototype.createSpacedPointsGeometry=function(a){a=this.getSpacedPoints(a,!0);return this.createGeometry(a)};THREE.CurvePath.prototype.createGeometry=function(a){for(var b=new THREE.Geometry,c=0;c<a.length;c++)b.vertices.push(new THREE.Vector3(a[c].x,a[c].y,a[c].z||0));return b};THREE.CurvePath.prototype.addWrapPath=function(a){this.bends.push(a)};\\nTHREE.CurvePath.prototype.getTransformedPoints=function(a,b){var c=this.getPoints(a),d,e;b||(b=this.bends);d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};THREE.CurvePath.prototype.getTransformedSpacedPoints=function(a,b){var c=this.getSpacedPoints(a),d,e;b||(b=this.bends);d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};\\nTHREE.CurvePath.prototype.getWrapPoints=function(a,b){var c=this.getBoundingBox(),d,e,f,g,h,k;d=0;for(e=a.length;d<e;d++)f=a[d],g=f.x,h=f.y,k=g/c.maxX,k=b.getUtoTmapping(k,g),g=b.getPoint(k),k=b.getTangent(k),k.set(-k.y,k.x).multiplyScalar(h),f.x=g.x+k.x,f.y=g.y+k.y;return a};THREE.Gyroscope=function(){THREE.Object3D.call(this)};THREE.Gyroscope.prototype=Object.create(THREE.Object3D.prototype);\\nTHREE.Gyroscope.prototype.updateMatrixWorld=function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a)this.parent?(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorld.decompose(this.translationWorld,this.quaternionWorld,this.scaleWorld),this.matrix.decompose(this.translationObject,this.quaternionObject,this.scaleObject),this.matrixWorld.compose(this.translationWorld,this.quaternionObject,this.scaleWorld)):this.matrixWorld.copy(this.matrix),\\nthis.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)};THREE.Gyroscope.prototype.translationWorld=new THREE.Vector3;THREE.Gyroscope.prototype.translationObject=new THREE.Vector3;THREE.Gyroscope.prototype.quaternionWorld=new THREE.Quaternion;THREE.Gyroscope.prototype.quaternionObject=new THREE.Quaternion;THREE.Gyroscope.prototype.scaleWorld=new THREE.Vector3;THREE.Gyroscope.prototype.scaleObject=new THREE.Vector3;\\nTHREE.Path=function(a){THREE.CurvePath.call(this);this.actions=[];a&&this.fromPoints(a)};THREE.Path.prototype=Object.create(THREE.CurvePath.prototype);THREE.PathActions={MOVE_TO:\\\"moveTo\\\",LINE_TO:\\\"lineTo\\\",QUADRATIC_CURVE_TO:\\\"quadraticCurveTo\\\",BEZIER_CURVE_TO:\\\"bezierCurveTo\\\",CSPLINE_THRU:\\\"splineThru\\\",ARC:\\\"arc\\\",ELLIPSE:\\\"ellipse\\\"};THREE.Path.prototype.fromPoints=function(a){this.moveTo(a[0].x,a[0].y);for(var b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y)};\\nTHREE.Path.prototype.moveTo=function(a,b){var c=Array.prototype.slice.call(arguments);this.actions.push({action:THREE.PathActions.MOVE_TO,args:c})};THREE.Path.prototype.lineTo=function(a,b){var c=Array.prototype.slice.call(arguments),d=this.actions[this.actions.length-1].args,d=new THREE.LineCurve(new THREE.Vector2(d[d.length-2],d[d.length-1]),new THREE.Vector2(a,b));this.curves.push(d);this.actions.push({action:THREE.PathActions.LINE_TO,args:c})};\\nTHREE.Path.prototype.quadraticCurveTo=function(a,b,c,d){var e=Array.prototype.slice.call(arguments),f=this.actions[this.actions.length-1].args,f=new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length-2],f[f.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d));this.curves.push(f);this.actions.push({action:THREE.PathActions.QUADRATIC_CURVE_TO,args:e})};\\nTHREE.Path.prototype.bezierCurveTo=function(a,b,c,d,e,f){var g=Array.prototype.slice.call(arguments),h=this.actions[this.actions.length-1].args,h=new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length-2],h[h.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d),new THREE.Vector2(e,f));this.curves.push(h);this.actions.push({action:THREE.PathActions.BEZIER_CURVE_TO,args:g})};\\nTHREE.Path.prototype.splineThru=function(a){var b=Array.prototype.slice.call(arguments),c=this.actions[this.actions.length-1].args,c=[new THREE.Vector2(c[c.length-2],c[c.length-1])];Array.prototype.push.apply(c,a);c=new THREE.SplineCurve(c);this.curves.push(c);this.actions.push({action:THREE.PathActions.CSPLINE_THRU,args:b})};THREE.Path.prototype.arc=function(a,b,c,d,e,f){var g=this.actions[this.actions.length-1].args;this.absarc(a+g[g.length-2],b+g[g.length-1],c,d,e,f)};\\nTHREE.Path.prototype.absarc=function(a,b,c,d,e,f){this.absellipse(a,b,c,c,d,e,f)};THREE.Path.prototype.ellipse=function(a,b,c,d,e,f,g){var h=this.actions[this.actions.length-1].args;this.absellipse(a+h[h.length-2],b+h[h.length-1],c,d,e,f,g)};THREE.Path.prototype.absellipse=function(a,b,c,d,e,f,g){var h=Array.prototype.slice.call(arguments),k=new THREE.EllipseCurve(a,b,c,d,e,f,g);this.curves.push(k);k=k.getPoint(1);h.push(k.x);h.push(k.y);this.actions.push({action:THREE.PathActions.ELLIPSE,args:h})};\\nTHREE.Path.prototype.getSpacedPoints=function(a,b){a||(a=40);for(var c=[],d=0;d<a;d++)c.push(this.getPoint(d/a));return c};\\nTHREE.Path.prototype.getPoints=function(a,b){if(this.useSpacedPoints)return console.log(\\\"tata\\\"),this.getSpacedPoints(a,b);a=a||12;var c=[],d,e,f,g,h,k,l,n,q,r,t,s,p;d=0;for(e=this.actions.length;d<e;d++)switch(f=this.actions[d],g=f.action,f=f.args,g){case THREE.PathActions.MOVE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.LINE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.QUADRATIC_CURVE_TO:h=f[2];k=f[3];q=f[0];r=f[1];0<c.length?(g=c[c.length-1],t=g.x,\\ns=g.y):(g=this.actions[d-1].args,t=g[g.length-2],s=g[g.length-1]);for(f=1;f<=a;f++)p=f/a,g=THREE.Shape.Utils.b2(p,t,q,h),p=THREE.Shape.Utils.b2(p,s,r,k),c.push(new THREE.Vector2(g,p));break;case THREE.PathActions.BEZIER_CURVE_TO:h=f[4];k=f[5];q=f[0];r=f[1];l=f[2];n=f[3];0<c.length?(g=c[c.length-1],t=g.x,s=g.y):(g=this.actions[d-1].args,t=g[g.length-2],s=g[g.length-1]);for(f=1;f<=a;f++)p=f/a,g=THREE.Shape.Utils.b3(p,t,q,l,h),p=THREE.Shape.Utils.b3(p,s,r,n,k),c.push(new THREE.Vector2(g,p));break;case THREE.PathActions.CSPLINE_THRU:g=\\nthis.actions[d-1].args;p=[new THREE.Vector2(g[g.length-2],g[g.length-1])];g=a*f[0].length;p=p.concat(f[0]);p=new THREE.SplineCurve(p);for(f=1;f<=g;f++)c.push(p.getPointAt(f/g));break;case THREE.PathActions.ARC:h=f[0];k=f[1];r=f[2];l=f[3];g=f[4];q=!!f[5];t=g-l;s=2*a;for(f=1;f<=s;f++)p=f/s,q||(p=1-p),p=l+p*t,g=h+r*Math.cos(p),p=k+r*Math.sin(p),c.push(new THREE.Vector2(g,p));break;case THREE.PathActions.ELLIPSE:for(h=f[0],k=f[1],r=f[2],n=f[3],l=f[4],g=f[5],q=!!f[6],t=g-l,s=2*a,f=1;f<=s;f++)p=f/s,q||\\n(p=1-p),p=l+p*t,g=h+r*Math.cos(p),p=k+n*Math.sin(p),c.push(new THREE.Vector2(g,p))}d=c[c.length-1];1E-10>Math.abs(d.x-c[0].x)&&1E-10>Math.abs(d.y-c[0].y)&&c.splice(c.length-1,1);b&&c.push(c[0]);return c};\\nTHREE.Path.prototype.toShapes=function(a,b){function c(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c],f=new THREE.Shape;f.actions=e.actions;f.curves=e.curves;b.push(f)}return b}function d(a,b){for(var c=b.length,d=!1,e=c-1,f=0;f<c;e=f++){var g=b[e],h=b[f],k=h.x-g.x,l=h.y-g.y;if(1E-10<Math.abs(l)){if(0>l&&(g=b[f],k=-k,h=b[e],l=-l),!(a.y<g.y||a.y>h.y))if(a.y==g.y){if(a.x==g.x)return!0}else{e=l*(a.x-g.x)-k*(a.y-g.y);if(0==e)return!0;0>e||(d=!d)}}else if(a.y==g.y&&(h.x<=a.x&&a.x<=g.x||g.x<=a.x&&a.x<=\\nh.x))return!0}return d}var e=function(a){var b,c,d,e,f=[],g=new THREE.Path;b=0;for(c=a.length;b<c;b++)d=a[b],e=d.args,d=d.action,d==THREE.PathActions.MOVE_TO&&0!=g.actions.length&&(f.push(g),g=new THREE.Path),g[d].apply(g,e);0!=g.actions.length&&f.push(g);return f}(this.actions);if(0==e.length)return[];if(!0===b)return c(e);var f,g,h,k=[];if(1==e.length)return g=e[0],h=new THREE.Shape,h.actions=g.actions,h.curves=g.curves,k.push(h),k;var l=!THREE.Shape.Utils.isClockWise(e[0].getPoints()),l=a?!l:l;\\nh=[];var n=[],q=[],r=0,t;n[r]=void 0;q[r]=[];var s,p;s=0;for(p=e.length;s<p;s++)g=e[s],t=g.getPoints(),f=THREE.Shape.Utils.isClockWise(t),(f=a?!f:f)?(!l&&n[r]&&r++,n[r]={s:new THREE.Shape,p:t},n[r].s.actions=g.actions,n[r].s.curves=g.curves,l&&r++,q[r]=[]):q[r].push({h:g,p:t[0]});if(!n[0])return c(e);if(1<n.length){s=!1;p=[];g=0;for(e=n.length;g<e;g++)h[g]=[];g=0;for(e=n.length;g<e;g++)for(f=q[g],l=0;l<f.length;l++){r=f[l];t=!0;for(var v=0;v<n.length;v++)d(r.p,n[v].p)&&(g!=v&&p.push({froms:g,tos:v,\\nhole:l}),t?(t=!1,h[v].push(r)):s=!0);t&&h[g].push(r)}0<p.length&&(s||(q=h))}s=0;for(p=n.length;s<p;s++)for(h=n[s].s,k.push(h),g=q[s],e=0,f=g.length;e<f;e++)h.holes.push(g[e].h);return k};THREE.Shape=function(){THREE.Path.apply(this,arguments);this.holes=[]};THREE.Shape.prototype=Object.create(THREE.Path.prototype);THREE.Shape.prototype.extrude=function(a){return new THREE.ExtrudeGeometry(this,a)};THREE.Shape.prototype.makeGeometry=function(a){return new THREE.ShapeGeometry(this,a)};\\nTHREE.Shape.prototype.getPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedPoints(a,this.bends);return d};THREE.Shape.prototype.getSpacedPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedSpacedPoints(a,this.bends);return d};THREE.Shape.prototype.extractAllPoints=function(a){return{shape:this.getTransformedPoints(a),holes:this.getPointsHoles(a)}};\\nTHREE.Shape.prototype.extractPoints=function(a){return this.useSpacedPoints?this.extractAllSpacedPoints(a):this.extractAllPoints(a)};THREE.Shape.prototype.extractAllSpacedPoints=function(a){return{shape:this.getTransformedSpacedPoints(a),holes:this.getSpacedPointsHoles(a)}};\\nTHREE.Shape.Utils={triangulateShape:function(a,b){function c(a,b,c){return a.x!=b.x?a.x<b.x?a.x<=c.x&&c.x<=b.x:b.x<=c.x&&c.x<=a.x:a.y<b.y?a.y<=c.y&&c.y<=b.y:b.y<=c.y&&c.y<=a.y}function d(a,b,d,e,f){var g=b.x-a.x,h=b.y-a.y,k=e.x-d.x,l=e.y-d.y,n=a.x-d.x,q=a.y-d.y,I=h*k-g*l,z=h*n-g*q;if(1E-10<Math.abs(I)){if(0<I){if(0>z||z>I)return[];k=l*n-k*q;if(0>k||k>I)return[]}else{if(0<z||z<I)return[];k=l*n-k*q;if(0<k||k<I)return[]}if(0==k)return!f||0!=z&&z!=I?[a]:[];if(k==I)return!f||0!=z&&z!=I?[b]:[];if(0==z)return[d];\\nif(z==I)return[e];f=k/I;return[{x:a.x+f*g,y:a.y+f*h}]}if(0!=z||l*n!=k*q)return[];h=0==g&&0==h;k=0==k&&0==l;if(h&&k)return a.x!=d.x||a.y!=d.y?[]:[a];if(h)return c(d,e,a)?[a]:[];if(k)return c(a,b,d)?[d]:[];0!=g?(a.x<b.x?(g=a,k=a.x,h=b,a=b.x):(g=b,k=b.x,h=a,a=a.x),d.x<e.x?(b=d,I=d.x,l=e,d=e.x):(b=e,I=e.x,l=d,d=d.x)):(a.y<b.y?(g=a,k=a.y,h=b,a=b.y):(g=b,k=b.y,h=a,a=a.y),d.y<e.y?(b=d,I=d.y,l=e,d=e.y):(b=e,I=e.y,l=d,d=d.y));return k<=I?a<I?[]:a==I?f?[]:[b]:a<=d?[b,h]:[b,l]:k>d?[]:k==d?f?[]:[g]:a<=d?[g,h]:\\n[g,l]}function e(a,b,c,d){var e=b.x-a.x,f=b.y-a.y;b=c.x-a.x;c=c.y-a.y;var g=d.x-a.x;d=d.y-a.y;a=e*c-f*b;e=e*d-f*g;return 1E-10<Math.abs(a)?(b=g*c-d*b,0<a?0<=e&&0<=b:0<=e||0<=b):0<e}var f,g,h,k,l,n={};h=a.concat();f=0;for(g=b.length;f<g;f++)Array.prototype.push.apply(h,b[f]);f=0;for(g=h.length;f<g;f++)l=h[f].x+\\\":\\\"+h[f].y,void 0!==n[l]&&console.log(\\\"Duplicate point\\\",l),n[l]=f;f=function(a,b){function c(a,b){var d=h.length-1,f=a-1;0>f&&(f=d);var g=a+1;g>d&&(g=0);d=e(h[a],h[f],h[g],k[b]);if(!d)return!1;\\nd=k.length-1;f=b-1;0>f&&(f=d);g=b+1;g>d&&(g=0);return(d=e(k[b],k[f],k[g],h[a]))?!0:!1}function f(a,b){var c,e;for(c=0;c<h.length;c++)if(e=c+1,e%=h.length,e=d(a,b,h[c],h[e],!0),0<e.length)return!0;return!1}function g(a,c){var e,f,h,k;for(e=0;e<l.length;e++)for(f=b[l[e]],h=0;h<f.length;h++)if(k=h+1,k%=f.length,k=d(a,c,f[h],f[k],!0),0<k.length)return!0;return!1}var h=a.concat(),k,l=[],n,q,C,I,z,y=[],K,N,ba,P=0;for(n=b.length;P<n;P++)l.push(P);K=0;for(var O=2*l.length;0<l.length;){O--;if(0>O){console.log(\\\"Infinite Loop! Holes left:\\\"+\\nl.length+\\\", Probably Hole outside Shape!\\\");break}for(q=K;q<h.length;q++){C=h[q];n=-1;for(P=0;P<l.length;P++)if(I=l[P],z=C.x+\\\":\\\"+C.y+\\\":\\\"+I,void 0===y[z]){k=b[I];for(N=0;N<k.length;N++)if(I=k[N],c(q,N)&&!f(C,I)&&!g(C,I)){n=N;l.splice(P,1);K=h.slice(0,q+1);I=h.slice(q);N=k.slice(n);ba=k.slice(0,n+1);h=K.concat(N).concat(ba).concat(I);K=q;break}if(0<=n)break;y[z]=!0}if(0<=n)break}}return h}(a,b);var q=THREE.FontUtils.Triangulate(f,!1);f=0;for(g=q.length;f<g;f++)for(k=q[f],h=0;3>h;h++)l=k[h].x+\\\":\\\"+k[h].y,\\nl=n[l],void 0!==l&&(k[h]=l);return q.concat()},isClockWise:function(a){return 0>THREE.FontUtils.Triangulate.area(a)},b2p0:function(a,b){var c=1-a;return c*c*b},b2p1:function(a,b){return 2*(1-a)*a*b},b2p2:function(a,b){return a*a*b},b2:function(a,b,c,d){return this.b2p0(a,b)+this.b2p1(a,c)+this.b2p2(a,d)},b3p0:function(a,b){var c=1-a;return c*c*c*b},b3p1:function(a,b){var c=1-a;return 3*c*c*a*b},b3p2:function(a,b){return 3*(1-a)*a*a*b},b3p3:function(a,b){return a*a*a*b},b3:function(a,b,c,d,e){return this.b3p0(a,\\nb)+this.b3p1(a,c)+this.b3p2(a,d)+this.b3p3(a,e)}};THREE.LineCurve=function(a,b){this.v1=a;this.v2=b};THREE.LineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.LineCurve.prototype.getPoint=function(a){var b=this.v2.clone().sub(this.v1);b.multiplyScalar(a).add(this.v1);return b};THREE.LineCurve.prototype.getPointAt=function(a){return this.getPoint(a)};THREE.LineCurve.prototype.getTangent=function(a){return this.v2.clone().sub(this.v1).normalize()};\\nTHREE.QuadraticBezierCurve=function(a,b,c){this.v0=a;this.v1=b;this.v2=c};THREE.QuadraticBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.QuadraticBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);return new THREE.Vector2(b,a)};\\nTHREE.QuadraticBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.y,this.v1.y,this.v2.y);b=new THREE.Vector2(b,a);b.normalize();return b};THREE.CubicBezierCurve=function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d};THREE.CubicBezierCurve.prototype=Object.create(THREE.Curve.prototype);\\nTHREE.CubicBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);return new THREE.Vector2(b,a)};THREE.CubicBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);b=new THREE.Vector2(b,a);b.normalize();return b};\\nTHREE.SplineCurve=function(a){this.points=void 0==a?[]:a};THREE.SplineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.SplineCurve.prototype.getPoint=function(a){var b=new THREE.Vector2,c=[],d=this.points,e;e=(d.length-1)*a;a=Math.floor(e);e-=a;c[0]=0==a?a:a-1;c[1]=a;c[2]=a>d.length-2?d.length-1:a+1;c[3]=a>d.length-3?d.length-1:a+2;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);return b};\\nTHREE.EllipseCurve=function(a,b,c,d,e,f,g){this.aX=a;this.aY=b;this.xRadius=c;this.yRadius=d;this.aStartAngle=e;this.aEndAngle=f;this.aClockwise=g};THREE.EllipseCurve.prototype=Object.create(THREE.Curve.prototype);\\nTHREE.EllipseCurve.prototype.getPoint=function(a){var b;b=this.aEndAngle-this.aStartAngle;0>b&&(b+=2*Math.PI);b>2*Math.PI&&(b-=2*Math.PI);b=!0===this.aClockwise?this.aEndAngle+(1-a)*(2*Math.PI-b):this.aStartAngle+a*b;a=this.aX+this.xRadius*Math.cos(b);b=this.aY+this.yRadius*Math.sin(b);return new THREE.Vector2(a,b)};THREE.ArcCurve=function(a,b,c,d,e,f){THREE.EllipseCurve.call(this,a,b,c,c,d,e,f)};THREE.ArcCurve.prototype=Object.create(THREE.EllipseCurve.prototype);\\nTHREE.LineCurve3=THREE.Curve.create(function(a,b){this.v1=a;this.v2=b},function(a){var b=new THREE.Vector3;b.subVectors(this.v2,this.v1);b.multiplyScalar(a);b.add(this.v1);return b});THREE.QuadraticBezierCurve3=THREE.Curve.create(function(a,b,c){this.v0=a;this.v1=b;this.v2=c},function(a){var b,c;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);c=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);a=THREE.Shape.Utils.b2(a,this.v0.z,this.v1.z,this.v2.z);return new THREE.Vector3(b,c,a)});\\nTHREE.CubicBezierCurve3=THREE.Curve.create(function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d},function(a){var b,c;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);c=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);a=THREE.Shape.Utils.b3(a,this.v0.z,this.v1.z,this.v2.z,this.v3.z);return new THREE.Vector3(b,c,a)});\\nTHREE.SplineCurve3=THREE.Curve.create(function(a){this.points=void 0==a?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e;a*=d.length-1;e=Math.floor(a);a-=e;c[0]=0==e?e:e-1;c[1]=e;c[2]=e>d.length-2?d.length-1:e+1;c[3]=e>d.length-3?d.length-1:e+2;e=d[c[0]];var f=d[c[1]],g=d[c[2]],c=d[c[3]];b.x=THREE.Curve.Utils.interpolate(e.x,f.x,g.x,c.x,a);b.y=THREE.Curve.Utils.interpolate(e.y,f.y,g.y,c.y,a);b.z=THREE.Curve.Utils.interpolate(e.z,f.z,g.z,c.z,a);return b});\\nTHREE.ClosedSplineCurve3=THREE.Curve.create(function(a){this.points=void 0==a?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e;e=(d.length-0)*a;a=Math.floor(e);e-=a;a+=0<a?0:(Math.floor(Math.abs(a)/d.length)+1)*d.length;c[0]=(a-1)%d.length;c[1]=a%d.length;c[2]=(a+1)%d.length;c[3]=(a+2)%d.length;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);b.z=THREE.Curve.Utils.interpolate(d[c[0]].z,\\nd[c[1]].z,d[c[2]].z,d[c[3]].z,e);return b});\\nTHREE.AnimationHandler={LINEAR:0,CATMULLROM:1,CATMULLROM_FORWARD:2,add:function(){console.warn(\\\"THREE.AnimationHandler.add() has been deprecated.\\\")},get:function(){console.warn(\\\"THREE.AnimationHandler.get() has been deprecated.\\\")},remove:function(){console.warn(\\\"THREE.AnimationHandler.remove() has been deprecated.\\\")},animations:[],init:function(a){if(!0!==a.initialized){for(var b=0;b<a.hierarchy.length;b++){for(var c=0;c<a.hierarchy[b].keys.length;c++)if(0>a.hierarchy[b].keys[c].time&&(a.hierarchy[b].keys[c].time=\\n0),void 0!==a.hierarchy[b].keys[c].rot&&!(a.hierarchy[b].keys[c].rot instanceof THREE.Quaternion)){var d=a.hierarchy[b].keys[c].rot;a.hierarchy[b].keys[c].rot=(new THREE.Quaternion).fromArray(d)}if(a.hierarchy[b].keys.length&&void 0!==a.hierarchy[b].keys[0].morphTargets){d={};for(c=0;c<a.hierarchy[b].keys.length;c++)for(var e=0;e<a.hierarchy[b].keys[c].morphTargets.length;e++){var f=a.hierarchy[b].keys[c].morphTargets[e];d[f]=-1}a.hierarchy[b].usedMorphTargets=d;for(c=0;c<a.hierarchy[b].keys.length;c++){var g=\\n{};for(f in d){for(e=0;e<a.hierarchy[b].keys[c].morphTargets.length;e++)if(a.hierarchy[b].keys[c].morphTargets[e]===f){g[f]=a.hierarchy[b].keys[c].morphTargetsInfluences[e];break}e===a.hierarchy[b].keys[c].morphTargets.length&&(g[f]=0)}a.hierarchy[b].keys[c].morphTargetsInfluences=g}}for(c=1;c<a.hierarchy[b].keys.length;c++)a.hierarchy[b].keys[c].time===a.hierarchy[b].keys[c-1].time&&(a.hierarchy[b].keys.splice(c,1),c--);for(c=0;c<a.hierarchy[b].keys.length;c++)a.hierarchy[b].keys[c].index=c}a.initialized=\\n!0;return a}},parse:function(a){var b=function(a,c){c.push(a);for(var d=0;d<a.children.length;d++)b(a.children[d],c)},c=[];if(a instanceof THREE.SkinnedMesh)for(var d=0;d<a.skeleton.bones.length;d++)c.push(a.skeleton.bones[d]);else b(a,c);return c},play:function(a){-1===this.animations.indexOf(a)&&this.animations.push(a)},stop:function(a){a=this.animations.indexOf(a);-1!==a&&this.animations.splice(a,1)},update:function(a){for(var b=0;b<this.animations.length;b++)this.animations[b].update(a)}};\\nTHREE.Animation=function(a,b){this.root=a;this.data=THREE.AnimationHandler.init(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=1;this.isPlaying=!1;this.loop=!0;this.weight=0;this.interpolationType=THREE.AnimationHandler.LINEAR};THREE.Animation.prototype.keyTypes=[\\\"pos\\\",\\\"rot\\\",\\\"scl\\\"];THREE.Animation.prototype.play=function(a,b){this.currentTime=void 0!==a?a:0;this.weight=void 0!==b?b:1;this.isPlaying=!0;this.reset();THREE.AnimationHandler.play(this)};\\nTHREE.Animation.prototype.stop=function(){this.isPlaying=!1;THREE.AnimationHandler.stop(this)};\\nTHREE.Animation.prototype.reset=function(){for(var a=0,b=this.hierarchy.length;a<b;a++){var c=this.hierarchy[a];c.matrixAutoUpdate=!0;void 0===c.animationCache&&(c.animationCache={});void 0===c.animationCache[this.data.name]&&(c.animationCache[this.data.name]={},c.animationCache[this.data.name].prevKey={pos:0,rot:0,scl:0},c.animationCache[this.data.name].nextKey={pos:0,rot:0,scl:0},c.animationCache[this.data.name].originalMatrix=c.matrix);for(var c=c.animationCache[this.data.name],d=0;3>d;d++){for(var e=\\nthis.keyTypes[d],f=this.data.hierarchy[a].keys[0],g=this.getNextKeyWith(e,a,1);g.time<this.currentTime&&g.index>f.index;)f=g,g=this.getNextKeyWith(e,a,g.index+1);c.prevKey[e]=f;c.nextKey[e]=g}}};\\nTHREE.Animation.prototype.update=function(){var a=[],b=new THREE.Vector3,c=new THREE.Vector3,d=new THREE.Quaternion,e=function(a,b){var c=[],d=[],e,q,r,t,s,p;e=(a.length-1)*b;q=Math.floor(e);e-=q;c[0]=0===q?q:q-1;c[1]=q;c[2]=q>a.length-2?q:q+1;c[3]=q>a.length-3?q:q+2;q=a[c[0]];t=a[c[1]];s=a[c[2]];p=a[c[3]];c=e*e;r=e*c;d[0]=f(q[0],t[0],s[0],p[0],e,c,r);d[1]=f(q[1],t[1],s[1],p[1],e,c,r);d[2]=f(q[2],t[2],s[2],p[2],e,c,r);return d},f=function(a,b,c,d,e,f,r){a=.5*(c-a);d=.5*(d-b);return(2*(b-c)+a+d)*r+\\n(-3*(b-c)-2*a-d)*f+a*e+b};return function(f){if(!1!==this.isPlaying&&(this.currentTime+=f*this.timeScale,0!==this.weight)){f=this.data.length;if(!0===this.loop&&this.currentTime>f)this.currentTime%=f,this.reset();else if(!1===this.loop&&this.currentTime>f){this.stop();return}f=0;for(var h=this.hierarchy.length;f<h;f++)for(var k=this.hierarchy[f],l=k.animationCache[this.data.name],n=0;3>n;n++){var q=this.keyTypes[n],r=l.prevKey[q],t=l.nextKey[q];if(t.time<=this.currentTime){r=this.data.hierarchy[f].keys[0];\\nfor(t=this.getNextKeyWith(q,f,1);t.time<this.currentTime&&t.index>r.index;)r=t,t=this.getNextKeyWith(q,f,t.index+1);l.prevKey[q]=r;l.nextKey[q]=t}k.matrixAutoUpdate=!0;k.matrixWorldNeedsUpdate=!0;var s=(this.currentTime-r.time)/(t.time-r.time),p=r[q],v=t[q];0>s&&(s=0);1<s&&(s=1);if(\\\"pos\\\"===q)if(this.interpolationType===THREE.AnimationHandler.LINEAR)c.x=p[0]+(v[0]-p[0])*s,c.y=p[1]+(v[1]-p[1])*s,c.z=p[2]+(v[2]-p[2])*s,k instanceof THREE.Bone?(r=this.weight/(this.weight+k.accumulatedPosWeight),k.position.lerp(c,\\nr),k.accumulatedPosWeight+=this.weight):k.position.copy(c);else{if(this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD)a[0]=this.getPrevKeyWith(\\\"pos\\\",f,r.index-1).pos,a[1]=p,a[2]=v,a[3]=this.getNextKeyWith(\\\"pos\\\",f,t.index+1).pos,s=.33*s+.33,t=e(a,s),r=1,k instanceof THREE.Bone&&(r=this.weight/(this.weight+k.accumulatedPosWeight),k.accumulatedPosWeight+=this.weight),q=k.position,q.x+=(t[0]-q.x)*r,q.y+=(t[1]-q.y)*r,q.z+=(t[2]-\\nq.z)*r,this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD&&(s=e(a,1.01*s),b.set(s[0],s[1],s[2]),b.sub(q),b.y=0,b.normalize(),s=Math.atan2(b.x,b.z),k.rotation.set(0,s,0))}else\\\"rot\\\"===q?(THREE.Quaternion.slerp(p,v,d,s),k instanceof THREE.Bone?0===k.accumulatedRotWeight?(k.quaternion.copy(d),k.accumulatedRotWeight=this.weight):(r=this.weight/(this.weight+k.accumulatedRotWeight),THREE.Quaternion.slerp(k.quaternion,d,k.quaternion,r),k.accumulatedRotWeight+=this.weight):k.quaternion.copy(d)):\\n\\\"scl\\\"===q&&(c.x=p[0]+(v[0]-p[0])*s,c.y=p[1]+(v[1]-p[1])*s,c.z=p[2]+(v[2]-p[2])*s,k instanceof THREE.Bone?(r=this.weight/(this.weight+k.accumulatedSclWeight),k.scale.lerp(c,r),k.accumulatedSclWeight+=this.weight):k.scale.copy(c))}return!0}}}();\\nTHREE.Animation.prototype.getNextKeyWith=function(a,b,c){var d=this.data.hierarchy[b].keys;for(c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?c<d.length-1?c:d.length-1:c%d.length;c<d.length;c++)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[0]};\\nTHREE.Animation.prototype.getPrevKeyWith=function(a,b,c){var d=this.data.hierarchy[b].keys;for(c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?0<c?c:0:0<=c?c:c+d.length;0<=c;c--)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[d.length-1]};\\nTHREE.KeyFrameAnimation=function(a){this.root=a.node;this.data=THREE.AnimationHandler.init(a);this.hierarchy=THREE.AnimationHandler.parse(this.root);this.currentTime=0;this.timeScale=.001;this.isPlaying=!1;this.loop=this.isPaused=!0;a=0;for(var b=this.hierarchy.length;a<b;a++){var c=this.data.hierarchy[a].sids,d=this.hierarchy[a];if(this.data.hierarchy[a].keys.length&&c){for(var e=0;e<c.length;e++){var f=c[e],g=this.getNextKeyWith(f,a,0);g&&g.apply(f)}d.matrixAutoUpdate=!1;this.data.hierarchy[a].node.updateMatrix();\\nd.matrixWorldNeedsUpdate=!0}}};\\nTHREE.KeyFrameAnimation.prototype.play=function(a){this.currentTime=void 0!==a?a:0;if(!1===this.isPlaying){this.isPlaying=!0;var b=this.hierarchy.length,c,d;for(a=0;a<b;a++)c=this.hierarchy[a],d=this.data.hierarchy[a],void 0===d.animationCache&&(d.animationCache={},d.animationCache.prevKey=null,d.animationCache.nextKey=null,d.animationCache.originalMatrix=c.matrix),c=this.data.hierarchy[a].keys,c.length&&(d.animationCache.prevKey=c[0],d.animationCache.nextKey=c[1],this.startTime=Math.min(c[0].time,\\nthis.startTime),this.endTime=Math.max(c[c.length-1].time,this.endTime));this.update(0)}this.isPaused=!1;THREE.AnimationHandler.play(this)};THREE.KeyFrameAnimation.prototype.stop=function(){this.isPaused=this.isPlaying=!1;THREE.AnimationHandler.stop(this);for(var a=0;a<this.data.hierarchy.length;a++){var b=this.hierarchy[a],c=this.data.hierarchy[a];if(void 0!==c.animationCache){var d=c.animationCache.originalMatrix;d.copy(b.matrix);b.matrix=d;delete c.animationCache}}};\\nTHREE.KeyFrameAnimation.prototype.update=function(a){if(!1!==this.isPlaying){this.currentTime+=a*this.timeScale;a=this.data.length;!0===this.loop&&this.currentTime>a&&(this.currentTime%=a);this.currentTime=Math.min(this.currentTime,a);a=0;for(var b=this.hierarchy.length;a<b;a++){var c=this.hierarchy[a],d=this.data.hierarchy[a],e=d.keys,d=d.animationCache;if(e.length){var f=d.prevKey,g=d.nextKey;if(g.time<=this.currentTime){for(;g.time<this.currentTime&&g.index>f.index;)f=g,g=e[f.index+1];d.prevKey=\\nf;d.nextKey=g}g.time>=this.currentTime?f.interpolate(g,this.currentTime):f.interpolate(g,g.time);this.data.hierarchy[a].node.updateMatrix();c.matrixWorldNeedsUpdate=!0}}}};THREE.KeyFrameAnimation.prototype.getNextKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c%=b.length;c<b.length;c++)if(b[c].hasTarget(a))return b[c];return b[0]};\\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c=0<=c?c:c+b.length;0<=c;c--)if(b[c].hasTarget(a))return b[c];return b[b.length-1]};THREE.MorphAnimation=function(a){this.mesh=a;this.frames=a.morphTargetInfluences.length;this.currentTime=0;this.duration=1E3;this.loop=!0;this.isPlaying=!1};\\nTHREE.MorphAnimation.prototype={play:function(){this.isPlaying=!0},pause:function(){this.isPlaying=!1},update:function(){var a=0,b=0;return function(c){if(!1!==this.isPlaying){this.currentTime+=c;!0===this.loop&&this.currentTime>this.duration&&(this.currentTime%=this.duration);this.currentTime=Math.min(this.currentTime,this.duration);c=this.duration/this.frames;var d=Math.floor(this.currentTime/c);d!=b&&(this.mesh.morphTargetInfluences[a]=0,this.mesh.morphTargetInfluences[b]=1,this.mesh.morphTargetInfluences[d]=\\n0,a=b,b=d);this.mesh.morphTargetInfluences[d]=this.currentTime%c/c;this.mesh.morphTargetInfluences[a]=1-this.mesh.morphTargetInfluences[d]}}}()};\\nTHREE.BoxGeometry=function(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,p){var v,w=h.widthSegments,u=h.heightSegments,D=e/2,A=f/2,x=h.vertices.length;if(\\\"x\\\"===a&&\\\"y\\\"===b||\\\"y\\\"===a&&\\\"x\\\"===b)v=\\\"z\\\";else if(\\\"x\\\"===a&&\\\"z\\\"===b||\\\"z\\\"===a&&\\\"x\\\"===b)v=\\\"y\\\",u=h.depthSegments;else if(\\\"z\\\"===a&&\\\"y\\\"===b||\\\"y\\\"===a&&\\\"z\\\"===b)v=\\\"x\\\",w=h.depthSegments;var C=w+1,I=u+1,z=e/w,y=f/u,K=new THREE.Vector3;K[v]=0<g?1:-1;for(e=0;e<I;e++)for(f=0;f<C;f++){var N=new THREE.Vector3;N[a]=(f*z-D)*c;N[b]=(e*y-A)*d;N[v]=g;h.vertices.push(N)}for(e=\\n0;e<u;e++)for(f=0;f<w;f++)A=f+C*e,a=f+C*(e+1),b=f+1+C*(e+1),c=f+1+C*e,d=new THREE.Vector2(f/w,1-e/u),g=new THREE.Vector2(f/w,1-(e+1)/u),v=new THREE.Vector2((f+1)/w,1-(e+1)/u),D=new THREE.Vector2((f+1)/w,1-e/u),A=new THREE.Face3(A+x,a+x,c+x),A.normal.copy(K),A.vertexNormals.push(K.clone(),K.clone(),K.clone()),A.materialIndex=p,h.faces.push(A),h.faceVertexUvs[0].push([d,g,D]),A=new THREE.Face3(a+x,b+x,c+x),A.normal.copy(K),A.vertexNormals.push(K.clone(),K.clone(),K.clone()),A.materialIndex=p,h.faces.push(A),\\nh.faceVertexUvs[0].push([g.clone(),v,D.clone()])}THREE.Geometry.call(this);this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};this.widthSegments=d||1;this.heightSegments=e||1;this.depthSegments=f||1;var h=this;d=a/2;e=b/2;f=c/2;g(\\\"z\\\",\\\"y\\\",-1,-1,c,b,d,0);g(\\\"z\\\",\\\"y\\\",1,-1,c,b,-d,1);g(\\\"x\\\",\\\"z\\\",1,1,a,c,e,2);g(\\\"x\\\",\\\"z\\\",1,-1,a,c,-e,3);g(\\\"x\\\",\\\"y\\\",1,-1,a,b,f,4);g(\\\"x\\\",\\\"y\\\",-1,-1,a,b,-f,5);this.mergeVertices()};THREE.BoxGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.CircleGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.parameters={radius:a,segments:b,thetaStart:c,thetaLength:d};a=a||50;b=void 0!==b?Math.max(3,b):8;c=void 0!==c?c:0;d=void 0!==d?d:2*Math.PI;var e,f=[];e=new THREE.Vector3;var g=new THREE.Vector2(.5,.5);this.vertices.push(e);f.push(g);for(e=0;e<=b;e++){var h=new THREE.Vector3,k=c+e/b*d;h.x=a*Math.cos(k);h.y=a*Math.sin(k);this.vertices.push(h);f.push(new THREE.Vector2((h.x/a+1)/2,(h.y/a+1)/2))}c=new THREE.Vector3(0,0,1);for(e=1;e<=\\nb;e++)this.faces.push(new THREE.Face3(e,e+1,0,[c.clone(),c.clone(),c.clone()])),this.faceVertexUvs[0].push([f[e].clone(),f[e+1].clone(),g.clone()]);this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.CircleGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CubeGeometry=function(a,b,c,d,e,f){console.warn(\\\"THEE.CubeGeometry has been renamed to THREE.BoxGeometry.\\\");return new THREE.BoxGeometry(a,b,c,d,e,f)};\\nTHREE.CylinderGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);this.parameters={radiusTop:a,radiusBottom:b,height:c,radialSegments:d,heightSegments:e,openEnded:f};a=void 0!==a?a:20;b=void 0!==b?b:20;c=void 0!==c?c:100;d=d||8;e=e||1;f=void 0!==f?f:!1;var g=c/2,h,k,l=[],n=[];for(k=0;k<=e;k++){var q=[],r=[],t=k/e,s=t*(b-a)+a;for(h=0;h<=d;h++){var p=h/d,v=new THREE.Vector3;v.x=s*Math.sin(p*Math.PI*2);v.y=-t*c+g;v.z=s*Math.cos(p*Math.PI*2);this.vertices.push(v);q.push(this.vertices.length-1);r.push(new THREE.Vector2(p,\\n1-t))}l.push(q);n.push(r)}c=(b-a)/c;for(h=0;h<d;h++)for(0!==a?(q=this.vertices[l[0][h]].clone(),r=this.vertices[l[0][h+1]].clone()):(q=this.vertices[l[1][h]].clone(),r=this.vertices[l[1][h+1]].clone()),q.setY(Math.sqrt(q.x*q.x+q.z*q.z)*c).normalize(),r.setY(Math.sqrt(r.x*r.x+r.z*r.z)*c).normalize(),k=0;k<e;k++){var t=l[k][h],s=l[k+1][h],p=l[k+1][h+1],v=l[k][h+1],w=q.clone(),u=q.clone(),D=r.clone(),A=r.clone(),x=n[k][h].clone(),C=n[k+1][h].clone(),I=n[k+1][h+1].clone(),z=n[k][h+1].clone();this.faces.push(new THREE.Face3(t,\\ns,v,[w,u,A]));this.faceVertexUvs[0].push([x,C,z]);this.faces.push(new THREE.Face3(s,p,v,[u.clone(),D,A.clone()]));this.faceVertexUvs[0].push([C.clone(),I,z.clone()])}if(!1===f&&0<a)for(this.vertices.push(new THREE.Vector3(0,g,0)),h=0;h<d;h++)t=l[0][h],s=l[0][h+1],p=this.vertices.length-1,w=new THREE.Vector3(0,1,0),u=new THREE.Vector3(0,1,0),D=new THREE.Vector3(0,1,0),x=n[0][h].clone(),C=n[0][h+1].clone(),I=new THREE.Vector2(C.x,0),this.faces.push(new THREE.Face3(t,s,p,[w,u,D])),this.faceVertexUvs[0].push([x,\\nC,I]);if(!1===f&&0<b)for(this.vertices.push(new THREE.Vector3(0,-g,0)),h=0;h<d;h++)t=l[k][h+1],s=l[k][h],p=this.vertices.length-1,w=new THREE.Vector3(0,-1,0),u=new THREE.Vector3(0,-1,0),D=new THREE.Vector3(0,-1,0),x=n[k][h+1].clone(),C=n[k][h].clone(),I=new THREE.Vector2(C.x,1),this.faces.push(new THREE.Face3(t,s,p,[w,u,D])),this.faceVertexUvs[0].push([x,C,I]);this.computeFaceNormals()};THREE.CylinderGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.ExtrudeGeometry=function(a,b){\\\"undefined\\\"!==typeof a&&(THREE.Geometry.call(this),a=a instanceof Array?a:[a],this.addShapeList(a,b),this.computeFaceNormals())};THREE.ExtrudeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry.prototype.addShapeList=function(a,b){for(var c=a.length,d=0;d<c;d++)this.addShape(a[d],b)};\\nTHREE.ExtrudeGeometry.prototype.addShape=function(a,b){function c(a,b,c){b||console.log(\\\"die\\\");return b.clone().multiplyScalar(c).add(a)}function d(a,b,c){var d=THREE.Math.sign,e=1,e=a.x-b.x,f=a.y-b.y,g=c.x-a.x,h=c.y-a.y,k=e*e+f*f;if(1E-10<Math.abs(e*h-f*g)){var l=Math.sqrt(k),d=Math.sqrt(g*g+h*h),k=b.x-f/l;b=b.y+e/l;g=((c.x-h/d-k)*h-(c.y+g/d-b)*g)/(e*h-f*g);c=k+e*g-a.x;a=b+f*g-a.y;e=c*c+a*a;if(2>=e)return new THREE.Vector2(c,a);e=Math.sqrt(e/2)}else a=!1,1E-10<e?1E-10<g&&(a=!0):-1E-10>e?-1E-10>g&&\\n(a=!0):d(f)==d(h)&&(a=!0),a?(c=-f,a=e,e=Math.sqrt(k)):(c=e,a=f,e=Math.sqrt(k/2));return new THREE.Vector2(c/e,a/e)}function e(c,d){var e,f;for(H=c.length;0<=--H;){e=H;f=H-1;0>f&&(f=c.length-1);for(var g=0,h=t+2*n,g=0;g<h;g++){var k=S*g,l=S*(g+1),p=d+e+k,k=d+f+k,q=d+f+l,l=d+e+l,r=c,s=g,v=h,w=e,x=f,p=p+ba,k=k+ba,q=q+ba,l=l+ba;N.faces.push(new THREE.Face3(p,k,l,null,null,u));N.faces.push(new THREE.Face3(k,q,l,null,null,u));p=D.generateSideWallUV(N,a,r,b,p,k,q,l,s,v,w,x);N.faceVertexUvs[0].push([p[0],\\np[1],p[3]]);N.faceVertexUvs[0].push([p[1],p[2],p[3]])}}}function f(a,b,c){N.vertices.push(new THREE.Vector3(a,b,c))}function g(c,d,e,f){c+=ba;d+=ba;e+=ba;N.faces.push(new THREE.Face3(c,d,e,null,null,w));c=f?D.generateBottomUV(N,a,b,c,d,e):D.generateTopUV(N,a,b,c,d,e);N.faceVertexUvs[0].push(c)}var h=void 0!==b.amount?b.amount:100,k=void 0!==b.bevelThickness?b.bevelThickness:6,l=void 0!==b.bevelSize?b.bevelSize:k-2,n=void 0!==b.bevelSegments?b.bevelSegments:3,q=void 0!==b.bevelEnabled?b.bevelEnabled:\\n!0,r=void 0!==b.curveSegments?b.curveSegments:12,t=void 0!==b.steps?b.steps:1,s=b.extrudePath,p,v=!1,w=b.material,u=b.extrudeMaterial,D=void 0!==b.UVGenerator?b.UVGenerator:THREE.ExtrudeGeometry.WorldUVGenerator,A,x,C,I;s&&(p=s.getSpacedPoints(t),v=!0,q=!1,A=void 0!==b.frames?b.frames:new THREE.TubeGeometry.FrenetFrames(s,t,!1),x=new THREE.Vector3,C=new THREE.Vector3,I=new THREE.Vector3);q||(l=k=n=0);var z,y,K,N=this,ba=this.vertices.length,s=a.extractPoints(r),r=s.shape,P=s.holes;if(s=!THREE.Shape.Utils.isClockWise(r)){r=\\nr.reverse();y=0;for(K=P.length;y<K;y++)z=P[y],THREE.Shape.Utils.isClockWise(z)&&(P[y]=z.reverse());s=!1}var O=THREE.Shape.Utils.triangulateShape(r,P),J=r;y=0;for(K=P.length;y<K;y++)z=P[y],r=r.concat(z);var E,Q,L,R,B,S=r.length,V,W=O.length,s=[],H=0;L=J.length;E=L-1;for(Q=H+1;H<L;H++,E++,Q++)E===L&&(E=0),Q===L&&(Q=0),s[H]=d(J[H],J[E],J[Q]);var oa=[],$,X=s.concat();y=0;for(K=P.length;y<K;y++){z=P[y];$=[];H=0;L=z.length;E=L-1;for(Q=H+1;H<L;H++,E++,Q++)E===L&&(E=0),Q===L&&(Q=0),$[H]=d(z[H],z[E],z[Q]);\\noa.push($);X=X.concat($)}for(E=0;E<n;E++){L=E/n;R=k*(1-L);Q=l*Math.sin(L*Math.PI/2);H=0;for(L=J.length;H<L;H++)B=c(J[H],s[H],Q),f(B.x,B.y,-R);y=0;for(K=P.length;y<K;y++)for(z=P[y],$=oa[y],H=0,L=z.length;H<L;H++)B=c(z[H],$[H],Q),f(B.x,B.y,-R)}Q=l;for(H=0;H<S;H++)B=q?c(r[H],X[H],Q):r[H],v?(C.copy(A.normals[0]).multiplyScalar(B.x),x.copy(A.binormals[0]).multiplyScalar(B.y),I.copy(p[0]).add(C).add(x),f(I.x,I.y,I.z)):f(B.x,B.y,0);for(L=1;L<=t;L++)for(H=0;H<S;H++)B=q?c(r[H],X[H],Q):r[H],v?(C.copy(A.normals[L]).multiplyScalar(B.x),\\nx.copy(A.binormals[L]).multiplyScalar(B.y),I.copy(p[L]).add(C).add(x),f(I.x,I.y,I.z)):f(B.x,B.y,h/t*L);for(E=n-1;0<=E;E--){L=E/n;R=k*(1-L);Q=l*Math.sin(L*Math.PI/2);H=0;for(L=J.length;H<L;H++)B=c(J[H],s[H],Q),f(B.x,B.y,h+R);y=0;for(K=P.length;y<K;y++)for(z=P[y],$=oa[y],H=0,L=z.length;H<L;H++)B=c(z[H],$[H],Q),v?f(B.x,B.y+p[t-1].y,p[t-1].x+R):f(B.x,B.y,h+R)}(function(){if(q){var a;a=0*S;for(H=0;H<W;H++)V=O[H],g(V[2]+a,V[1]+a,V[0]+a,!0);a=t+2*n;a*=S;for(H=0;H<W;H++)V=O[H],g(V[0]+a,V[1]+a,V[2]+a,!1)}else{for(H=\\n0;H<W;H++)V=O[H],g(V[2],V[1],V[0],!0);for(H=0;H<W;H++)V=O[H],g(V[0]+S*t,V[1]+S*t,V[2]+S*t,!1)}})();(function(){var a=0;e(J,a);a+=J.length;y=0;for(K=P.length;y<K;y++)z=P[y],e(z,a),a+=z.length})()};\\nTHREE.ExtrudeGeometry.WorldUVGenerator={generateTopUV:function(a,b,c,d,e,f){b=a.vertices[e].x;e=a.vertices[e].y;c=a.vertices[f].x;f=a.vertices[f].y;return[new THREE.Vector2(a.vertices[d].x,a.vertices[d].y),new THREE.Vector2(b,e),new THREE.Vector2(c,f)]},generateBottomUV:function(a,b,c,d,e,f){return this.generateTopUV(a,b,c,d,e,f)},generateSideWallUV:function(a,b,c,d,e,f,g,h,k,l,n,q){b=a.vertices[e].x;c=a.vertices[e].y;e=a.vertices[e].z;d=a.vertices[f].x;k=a.vertices[f].y;f=a.vertices[f].z;l=a.vertices[g].x;\\nn=a.vertices[g].y;g=a.vertices[g].z;q=a.vertices[h].x;var r=a.vertices[h].y;a=a.vertices[h].z;return.01>Math.abs(c-k)?[new THREE.Vector2(b,1-e),new THREE.Vector2(d,1-f),new THREE.Vector2(l,1-g),new THREE.Vector2(q,1-a)]:[new THREE.Vector2(c,1-e),new THREE.Vector2(k,1-f),new THREE.Vector2(n,1-g),new THREE.Vector2(r,1-a)]}};THREE.ExtrudeGeometry.__v1=new THREE.Vector2;THREE.ExtrudeGeometry.__v2=new THREE.Vector2;THREE.ExtrudeGeometry.__v3=new THREE.Vector2;THREE.ExtrudeGeometry.__v4=new THREE.Vector2;\\nTHREE.ExtrudeGeometry.__v5=new THREE.Vector2;THREE.ExtrudeGeometry.__v6=new THREE.Vector2;THREE.ShapeGeometry=function(a,b){THREE.Geometry.call(this);!1===a instanceof Array&&(a=[a]);this.addShapeList(a,b);this.computeFaceNormals()};THREE.ShapeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ShapeGeometry.prototype.addShapeList=function(a,b){for(var c=0,d=a.length;c<d;c++)this.addShape(a[c],b);return this};\\nTHREE.ShapeGeometry.prototype.addShape=function(a,b){void 0===b&&(b={});var c=b.material,d=void 0===b.UVGenerator?THREE.ExtrudeGeometry.WorldUVGenerator:b.UVGenerator,e,f,g,h=this.vertices.length;e=a.extractPoints(void 0!==b.curveSegments?b.curveSegments:12);var k=e.shape,l=e.holes;if(!THREE.Shape.Utils.isClockWise(k))for(k=k.reverse(),e=0,f=l.length;e<f;e++)g=l[e],THREE.Shape.Utils.isClockWise(g)&&(l[e]=g.reverse());var n=THREE.Shape.Utils.triangulateShape(k,l);e=0;for(f=l.length;e<f;e++)g=l[e],\\nk=k.concat(g);l=k.length;f=n.length;for(e=0;e<l;e++)g=k[e],this.vertices.push(new THREE.Vector3(g.x,g.y,0));for(e=0;e<f;e++)l=n[e],k=l[0]+h,g=l[1]+h,l=l[2]+h,this.faces.push(new THREE.Face3(k,g,l,null,null,c)),this.faceVertexUvs[0].push(d.generateBottomUV(this,a,b,k,g,l))};\\nTHREE.LatheGeometry=function(a,b,c,d){THREE.Geometry.call(this);b=b||12;c=c||0;d=d||2*Math.PI;for(var e=1/(a.length-1),f=1/b,g=0,h=b;g<=h;g++)for(var k=c+g*f*d,l=Math.cos(k),n=Math.sin(k),k=0,q=a.length;k<q;k++){var r=a[k],t=new THREE.Vector3;t.x=l*r.x-n*r.y;t.y=n*r.x+l*r.y;t.z=r.z;this.vertices.push(t)}c=a.length;g=0;for(h=b;g<h;g++)for(k=0,q=a.length-1;k<q;k++){b=n=k+c*g;d=n+c;var l=n+1+c,n=n+1,r=g*f,t=k*e,s=r+f,p=t+e;this.faces.push(new THREE.Face3(b,d,n));this.faceVertexUvs[0].push([new THREE.Vector2(r,\\nt),new THREE.Vector2(s,t),new THREE.Vector2(r,p)]);this.faces.push(new THREE.Face3(d,l,n));this.faceVertexUvs[0].push([new THREE.Vector2(s,t),new THREE.Vector2(s,p),new THREE.Vector2(r,p)])}this.mergeVertices();this.computeFaceNormals();this.computeVertexNormals()};THREE.LatheGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.PlaneGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.parameters={width:a,height:b,widthSegments:c,heightSegments:d};var e=a/2,f=b/2;c=c||1;d=d||1;var g=c+1,h=d+1,k=a/c,l=b/d,n=new THREE.Vector3(0,0,1);for(a=0;a<h;a++){var q=a*l-f;for(b=0;b<g;b++)this.vertices.push(new THREE.Vector3(b*k-e,-q,0))}for(a=0;a<d;a++)for(b=0;b<c;b++){var r=b+g*a,e=b+g*(a+1),f=b+1+g*(a+1),h=b+1+g*a,k=new THREE.Vector2(b/c,1-a/d),l=new THREE.Vector2(b/c,1-(a+1)/d),q=new THREE.Vector2((b+1)/c,1-(a+1)/d),t=new THREE.Vector2((b+\\n1)/c,1-a/d),r=new THREE.Face3(r,e,h);r.normal.copy(n);r.vertexNormals.push(n.clone(),n.clone(),n.clone());this.faces.push(r);this.faceVertexUvs[0].push([k,l,t]);r=new THREE.Face3(e,f,h);r.normal.copy(n);r.vertexNormals.push(n.clone(),n.clone(),n.clone());this.faces.push(r);this.faceVertexUvs[0].push([l.clone(),q,t.clone()])}};THREE.PlaneGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.RingGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);a=a||0;b=b||50;e=void 0!==e?e:0;f=void 0!==f?f:2*Math.PI;c=void 0!==c?Math.max(3,c):8;d=void 0!==d?Math.max(1,d):8;var g,h=[],k=a,l=(b-a)/d;for(a=0;a<d+1;a++){for(g=0;g<c+1;g++){var n=new THREE.Vector3,q=e+g/c*f;n.x=k*Math.cos(q);n.y=k*Math.sin(q);this.vertices.push(n);h.push(new THREE.Vector2((n.x/b+1)/2,(n.y/b+1)/2))}k+=l}b=new THREE.Vector3(0,0,1);for(a=0;a<d;a++)for(e=a*(c+1),g=0;g<c;g++)f=q=g+e,l=q+c+1,n=q+c+2,this.faces.push(new THREE.Face3(f,\\nl,n,[b.clone(),b.clone(),b.clone()])),this.faceVertexUvs[0].push([h[f].clone(),h[l].clone(),h[n].clone()]),f=q,l=q+c+2,n=q+1,this.faces.push(new THREE.Face3(f,l,n,[b.clone(),b.clone(),b.clone()])),this.faceVertexUvs[0].push([h[f].clone(),h[l].clone(),h[n].clone()]);this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,k)};THREE.RingGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.SphereGeometry=function(a,b,c,d,e,f,g){THREE.Geometry.call(this);this.parameters={radius:a,widthSegments:b,heightSegments:c,phiStart:d,phiLength:e,thetaStart:f,thetaLength:g};a=a||50;b=Math.max(3,Math.floor(b)||8);c=Math.max(2,Math.floor(c)||6);d=void 0!==d?d:0;e=void 0!==e?e:2*Math.PI;f=void 0!==f?f:0;g=void 0!==g?g:Math.PI;var h,k,l=[],n=[];for(k=0;k<=c;k++){var q=[],r=[];for(h=0;h<=b;h++){var t=h/b,s=k/c,p=new THREE.Vector3;p.x=-a*Math.cos(d+t*e)*Math.sin(f+s*g);p.y=a*Math.cos(f+s*g);p.z=\\na*Math.sin(d+t*e)*Math.sin(f+s*g);this.vertices.push(p);q.push(this.vertices.length-1);r.push(new THREE.Vector2(t,1-s))}l.push(q);n.push(r)}for(k=0;k<c;k++)for(h=0;h<b;h++){d=l[k][h+1];e=l[k][h];f=l[k+1][h];g=l[k+1][h+1];var q=this.vertices[d].clone().normalize(),r=this.vertices[e].clone().normalize(),t=this.vertices[f].clone().normalize(),s=this.vertices[g].clone().normalize(),p=n[k][h+1].clone(),v=n[k][h].clone(),w=n[k+1][h].clone(),u=n[k+1][h+1].clone();Math.abs(this.vertices[d].y)===a?(p.x=(p.x+\\nv.x)/2,this.faces.push(new THREE.Face3(d,f,g,[q,t,s])),this.faceVertexUvs[0].push([p,w,u])):Math.abs(this.vertices[f].y)===a?(w.x=(w.x+u.x)/2,this.faces.push(new THREE.Face3(d,e,f,[q,r,t])),this.faceVertexUvs[0].push([p,v,w])):(this.faces.push(new THREE.Face3(d,e,g,[q,r,s])),this.faceVertexUvs[0].push([p,v,u]),this.faces.push(new THREE.Face3(e,f,g,[r.clone(),t,s.clone()])),this.faceVertexUvs[0].push([v.clone(),w,u.clone()]))}this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,\\na)};THREE.SphereGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TextGeometry=function(a,b){b=b||{};var c=THREE.FontUtils.generateShapes(a,b);b.amount=void 0!==b.height?b.height:50;void 0===b.bevelThickness&&(b.bevelThickness=10);void 0===b.bevelSize&&(b.bevelSize=8);void 0===b.bevelEnabled&&(b.bevelEnabled=!1);THREE.ExtrudeGeometry.call(this,c,b)};THREE.TextGeometry.prototype=Object.create(THREE.ExtrudeGeometry.prototype);\\nTHREE.TorusGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.parameters={radius:a,tube:b,radialSegments:c,tubularSegments:d,arc:e};a=a||100;b=b||40;c=c||8;d=d||6;e=e||2*Math.PI;for(var f=new THREE.Vector3,g=[],h=[],k=0;k<=c;k++)for(var l=0;l<=d;l++){var n=l/d*e,q=k/c*Math.PI*2;f.x=a*Math.cos(n);f.y=a*Math.sin(n);var r=new THREE.Vector3;r.x=(a+b*Math.cos(q))*Math.cos(n);r.y=(a+b*Math.cos(q))*Math.sin(n);r.z=b*Math.sin(q);this.vertices.push(r);g.push(new THREE.Vector2(l/d,k/c));h.push(r.clone().sub(f).normalize())}for(k=\\n1;k<=c;k++)for(l=1;l<=d;l++)a=(d+1)*k+l-1,b=(d+1)*(k-1)+l-1,e=(d+1)*(k-1)+l,f=(d+1)*k+l,n=new THREE.Face3(a,b,f,[h[a].clone(),h[b].clone(),h[f].clone()]),this.faces.push(n),this.faceVertexUvs[0].push([g[a].clone(),g[b].clone(),g[f].clone()]),n=new THREE.Face3(b,e,f,[h[b].clone(),h[e].clone(),h[f].clone()]),this.faces.push(n),this.faceVertexUvs[0].push([g[b].clone(),g[e].clone(),g[f].clone()]);this.computeFaceNormals()};THREE.TorusGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.TorusKnotGeometry=function(a,b,c,d,e,f,g){function h(a,b,c,d,e){var f=Math.cos(a),g=Math.sin(a);a*=b/c;b=Math.cos(a);f*=d*(2+b)*.5;g=d*(2+b)*g*.5;d=e*d*Math.sin(a)*.5;return new THREE.Vector3(f,g,d)}THREE.Geometry.call(this);this.parameters={radius:a,tube:b,radialSegments:c,tubularSegments:d,p:e,q:f,heightScale:g};a=a||100;b=b||40;c=c||64;d=d||8;e=e||2;f=f||3;g=g||1;for(var k=Array(c),l=new THREE.Vector3,n=new THREE.Vector3,q=new THREE.Vector3,r=0;r<c;++r){k[r]=Array(d);var t=r/c*2*e*Math.PI,\\ns=h(t,f,e,a,g),t=h(t+.01,f,e,a,g);l.subVectors(t,s);n.addVectors(t,s);q.crossVectors(l,n);n.crossVectors(q,l);q.normalize();n.normalize();for(t=0;t<d;++t){var p=t/d*2*Math.PI,v=-b*Math.cos(p),p=b*Math.sin(p),w=new THREE.Vector3;w.x=s.x+v*n.x+p*q.x;w.y=s.y+v*n.y+p*q.y;w.z=s.z+v*n.z+p*q.z;k[r][t]=this.vertices.push(w)-1}}for(r=0;r<c;++r)for(t=0;t<d;++t)e=(r+1)%c,f=(t+1)%d,a=k[r][t],b=k[e][t],e=k[e][f],f=k[r][f],g=new THREE.Vector2(r/c,t/d),l=new THREE.Vector2((r+1)/c,t/d),n=new THREE.Vector2((r+1)/\\nc,(t+1)/d),q=new THREE.Vector2(r/c,(t+1)/d),this.faces.push(new THREE.Face3(a,b,f)),this.faceVertexUvs[0].push([g,l,q]),this.faces.push(new THREE.Face3(b,e,f)),this.faceVertexUvs[0].push([l.clone(),n,q.clone()]);this.computeFaceNormals();this.computeVertexNormals()};THREE.TorusKnotGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.TubeGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.parameters={path:a,segments:b,radius:c,radialSegments:d,closed:e};b=b||64;c=c||1;d=d||8;e=e||!1;var f=[],g,h,k=b+1,l,n,q,r,t=new THREE.Vector3,s,p,v;s=new THREE.TubeGeometry.FrenetFrames(a,b,e);p=s.normals;v=s.binormals;this.tangents=s.tangents;this.normals=p;this.binormals=v;for(s=0;s<k;s++)for(f[s]=[],l=s/(k-1),r=a.getPointAt(l),g=p[s],h=v[s],l=0;l<d;l++)n=l/d*2*Math.PI,q=-c*Math.cos(n),n=c*Math.sin(n),t.copy(r),t.x+=q*g.x+n*\\nh.x,t.y+=q*g.y+n*h.y,t.z+=q*g.z+n*h.z,f[s][l]=this.vertices.push(new THREE.Vector3(t.x,t.y,t.z))-1;for(s=0;s<b;s++)for(l=0;l<d;l++)k=e?(s+1)%b:s+1,t=(l+1)%d,a=f[s][l],c=f[k][l],k=f[k][t],t=f[s][t],p=new THREE.Vector2(s/b,l/d),v=new THREE.Vector2((s+1)/b,l/d),g=new THREE.Vector2((s+1)/b,(l+1)/d),h=new THREE.Vector2(s/b,(l+1)/d),this.faces.push(new THREE.Face3(a,c,t)),this.faceVertexUvs[0].push([p,v,h]),this.faces.push(new THREE.Face3(c,k,t)),this.faceVertexUvs[0].push([v.clone(),g,h.clone()]);this.computeFaceNormals();\\nthis.computeVertexNormals()};THREE.TubeGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.TubeGeometry.FrenetFrames=function(a,b,c){new THREE.Vector3;var d=new THREE.Vector3;new THREE.Vector3;var e=[],f=[],g=[],h=new THREE.Vector3,k=new THREE.Matrix4;b+=1;var l,n,q;this.tangents=e;this.normals=f;this.binormals=g;for(l=0;l<b;l++)n=l/(b-1),e[l]=a.getTangentAt(n),e[l].normalize();f[0]=new THREE.Vector3;g[0]=new THREE.Vector3;a=Number.MAX_VALUE;l=Math.abs(e[0].x);n=Math.abs(e[0].y);q=Math.abs(e[0].z);l<=a&&(a=l,d.set(1,0,0));n<=a&&(a=n,d.set(0,1,0));q<=a&&d.set(0,0,1);h.crossVectors(e[0],\\nd).normalize();f[0].crossVectors(e[0],h);g[0].crossVectors(e[0],f[0]);for(l=1;l<b;l++)f[l]=f[l-1].clone(),g[l]=g[l-1].clone(),h.crossVectors(e[l-1],e[l]),1E-4<h.length()&&(h.normalize(),d=Math.acos(THREE.Math.clamp(e[l-1].dot(e[l]),-1,1)),f[l].applyMatrix4(k.makeRotationAxis(h,d))),g[l].crossVectors(e[l],f[l]);if(c)for(d=Math.acos(THREE.Math.clamp(f[0].dot(f[b-1]),-1,1)),d/=b-1,0<e[0].dot(h.crossVectors(f[0],f[b-1]))&&(d=-d),l=1;l<b;l++)f[l].applyMatrix4(k.makeRotationAxis(e[l],d*l)),g[l].crossVectors(e[l],\\nf[l])};\\nTHREE.PolyhedronGeometry=function(a,b,c,d){function e(a){var b=a.normalize().clone();b.index=k.vertices.push(b)-1;var c=Math.atan2(a.z,-a.x)/2/Math.PI+.5;a=Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))/Math.PI+.5;b.uv=new THREE.Vector2(c,1-a);return b}function f(a,b,c){var d=new THREE.Face3(a.index,b.index,c.index,[a.clone(),b.clone(),c.clone()]);k.faces.push(d);v.copy(a).add(b).add(c).divideScalar(3);d=Math.atan2(v.z,-v.x);k.faceVertexUvs[0].push([h(a.uv,a,d),h(b.uv,b,d),h(c.uv,c,d)])}function g(a,b){var c=\\nMath.pow(2,b);Math.pow(4,b);for(var d=e(k.vertices[a.a]),g=e(k.vertices[a.b]),h=e(k.vertices[a.c]),l=[],n=0;n<=c;n++){l[n]=[];for(var p=e(d.clone().lerp(h,n/c)),q=e(g.clone().lerp(h,n/c)),r=c-n,s=0;s<=r;s++)l[n][s]=0==s&&n==c?p:e(p.clone().lerp(q,s/r))}for(n=0;n<c;n++)for(s=0;s<2*(c-n)-1;s++)d=Math.floor(s/2),0==s%2?f(l[n][d+1],l[n+1][d],l[n][d]):f(l[n][d+1],l[n+1][d+1],l[n+1][d])}function h(a,b,c){0>c&&1===a.x&&(a=new THREE.Vector2(a.x-1,a.y));0===b.x&&0===b.z&&(a=new THREE.Vector2(c/2/Math.PI+.5,\\na.y));return a.clone()}THREE.Geometry.call(this);c=c||1;d=d||0;for(var k=this,l=0,n=a.length;l<n;l+=3)e(new THREE.Vector3(a[l],a[l+1],a[l+2]));a=this.vertices;for(var q=[],r=l=0,n=b.length;l<n;l+=3,r++){var t=a[b[l]],s=a[b[l+1]],p=a[b[l+2]];q[r]=new THREE.Face3(t.index,s.index,p.index,[t.clone(),s.clone(),p.clone()])}for(var v=new THREE.Vector3,l=0,n=q.length;l<n;l++)g(q[l],d);l=0;for(n=this.faceVertexUvs[0].length;l<n;l++)b=this.faceVertexUvs[0][l],d=b[0].x,a=b[1].x,q=b[2].x,r=Math.max(d,Math.max(a,\\nq)),t=Math.min(d,Math.min(a,q)),.9<r&&.1>t&&(.2>d&&(b[0].x+=1),.2>a&&(b[1].x+=1),.2>q&&(b[2].x+=1));l=0;for(n=this.vertices.length;l<n;l++)this.vertices[l].multiplyScalar(c);this.mergeVertices();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,c)};THREE.PolyhedronGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.IcosahedronGeometry=function(a,b){this.parameters={radius:a,detail:b};var c=(1+Math.sqrt(5))/2;THREE.PolyhedronGeometry.call(this,[-1,c,0,1,c,0,-1,-c,0,1,-c,0,0,-1,c,0,1,c,0,-1,-c,0,1,-c,c,0,-1,c,0,1,-c,0,-1,-c,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],a,b)};THREE.IcosahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.OctahedronGeometry=function(a,b){this.parameters={radius:a,detail:b};THREE.PolyhedronGeometry.call(this,[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],a,b)};THREE.OctahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TetrahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],a,b)};THREE.TetrahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.ParametricGeometry=function(a,b,c){THREE.Geometry.call(this);var d=this.vertices,e=this.faces,f=this.faceVertexUvs[0],g,h,k,l,n=b+1;for(g=0;g<=c;g++)for(l=g/c,h=0;h<=b;h++)k=h/b,k=a(k,l),d.push(k);var q,r,t,s;for(g=0;g<c;g++)for(h=0;h<b;h++)a=g*n+h,d=g*n+h+1,l=(g+1)*n+h+1,k=(g+1)*n+h,q=new THREE.Vector2(h/b,g/c),r=new THREE.Vector2((h+1)/b,g/c),t=new THREE.Vector2((h+1)/b,(g+1)/c),s=new THREE.Vector2(h/b,(g+1)/c),e.push(new THREE.Face3(a,d,k)),f.push([q,r,s]),e.push(new THREE.Face3(d,l,k)),\\nf.push([r.clone(),t,s.clone()]);this.computeFaceNormals();this.computeVertexNormals()};THREE.ParametricGeometry.prototype=Object.create(THREE.Geometry.prototype);\\nTHREE.AxisHelper=function(a){a=a||1;var b=new Float32Array([0,0,0,a,0,0,0,0,0,0,a,0,0,0,0,0,0,a]),c=new Float32Array([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1]);a=new THREE.BufferGeometry;a.addAttribute(\\\"position\\\",new THREE.BufferAttribute(b,3));a.addAttribute(\\\"color\\\",new THREE.BufferAttribute(c,3));b=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});THREE.Line.call(this,a,b,THREE.LinePieces)};THREE.AxisHelper.prototype=Object.create(THREE.Line.prototype);\\nTHREE.ArrowHelper=function(){var a=new THREE.Geometry;a.vertices.push(new THREE.Vector3(0,0,0),new THREE.Vector3(0,1,0));var b=new THREE.CylinderGeometry(0,.5,1,5,1);b.applyMatrix((new THREE.Matrix4).makeTranslation(0,-.5,0));return function(c,d,e,f,g,h){THREE.Object3D.call(this);void 0===f&&(f=16776960);void 0===e&&(e=1);void 0===g&&(g=.2*e);void 0===h&&(h=.2*g);this.position.copy(d);this.line=new THREE.Line(a,new THREE.LineBasicMaterial({color:f}));this.line.matrixAutoUpdate=!1;this.add(this.line);\\nthis.cone=new THREE.Mesh(b,new THREE.MeshBasicMaterial({color:f}));this.cone.matrixAutoUpdate=!1;this.add(this.cone);this.setDirection(c);this.setLength(e,g,h)}}();THREE.ArrowHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.ArrowHelper.prototype.setDirection=function(){var a=new THREE.Vector3,b;return function(c){.99999<c.y?this.quaternion.set(0,0,0,1):-.99999>c.y?this.quaternion.set(1,0,0,0):(a.set(c.z,0,-c.x).normalize(),b=Math.acos(c.y),this.quaternion.setFromAxisAngle(a,b))}}();\\nTHREE.ArrowHelper.prototype.setLength=function(a,b,c){void 0===b&&(b=.2*a);void 0===c&&(c=.2*b);this.line.scale.set(1,a,1);this.line.updateMatrix();this.cone.scale.set(c,b,c);this.cone.position.y=a;this.cone.updateMatrix()};THREE.ArrowHelper.prototype.setColor=function(a){this.line.material.color.set(a);this.cone.material.color.set(a)};\\nTHREE.BoxHelper=function(a){var b=new THREE.BufferGeometry;b.addAttribute(\\\"position\\\",new THREE.BufferAttribute(new Float32Array(72),3));THREE.Line.call(this,b,new THREE.LineBasicMaterial({color:16776960}),THREE.LinePieces);void 0!==a&&this.update(a)};THREE.BoxHelper.prototype=Object.create(THREE.Line.prototype);\\nTHREE.BoxHelper.prototype.update=function(a){var b=a.geometry;null===b.boundingBox&&b.computeBoundingBox();var c=b.boundingBox.min,b=b.boundingBox.max,d=this.geometry.attributes.position.array;d[0]=b.x;d[1]=b.y;d[2]=b.z;d[3]=c.x;d[4]=b.y;d[5]=b.z;d[6]=c.x;d[7]=b.y;d[8]=b.z;d[9]=c.x;d[10]=c.y;d[11]=b.z;d[12]=c.x;d[13]=c.y;d[14]=b.z;d[15]=b.x;d[16]=c.y;d[17]=b.z;d[18]=b.x;d[19]=c.y;d[20]=b.z;d[21]=b.x;d[22]=b.y;d[23]=b.z;d[24]=b.x;d[25]=b.y;d[26]=c.z;d[27]=c.x;d[28]=b.y;d[29]=c.z;d[30]=c.x;d[31]=b.y;\\nd[32]=c.z;d[33]=c.x;d[34]=c.y;d[35]=c.z;d[36]=c.x;d[37]=c.y;d[38]=c.z;d[39]=b.x;d[40]=c.y;d[41]=c.z;d[42]=b.x;d[43]=c.y;d[44]=c.z;d[45]=b.x;d[46]=b.y;d[47]=c.z;d[48]=b.x;d[49]=b.y;d[50]=b.z;d[51]=b.x;d[52]=b.y;d[53]=c.z;d[54]=c.x;d[55]=b.y;d[56]=b.z;d[57]=c.x;d[58]=b.y;d[59]=c.z;d[60]=c.x;d[61]=c.y;d[62]=b.z;d[63]=c.x;d[64]=c.y;d[65]=c.z;d[66]=b.x;d[67]=c.y;d[68]=b.z;d[69]=b.x;d[70]=c.y;d[71]=c.z;this.geometry.attributes.position.needsUpdate=!0;this.geometry.computeBoundingSphere();this.matrixAutoUpdate=\\n!1;this.matrixWorld=a.matrixWorld};THREE.BoundingBoxHelper=function(a,b){var c=void 0!==b?b:8947848;this.object=a;this.box=new THREE.Box3;THREE.Mesh.call(this,new THREE.BoxGeometry(1,1,1),new THREE.MeshBasicMaterial({color:c,wireframe:!0}))};THREE.BoundingBoxHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.BoundingBoxHelper.prototype.update=function(){this.box.setFromObject(this.object);this.box.size(this.scale);this.box.center(this.position)};\\nTHREE.CameraHelper=function(a){function b(a,b,d){c(a,d);c(b,d)}function c(a,b){d.vertices.push(new THREE.Vector3);d.colors.push(new THREE.Color(b));void 0===f[a]&&(f[a]=[]);f[a].push(d.vertices.length-1)}var d=new THREE.Geometry,e=new THREE.LineBasicMaterial({color:16777215,vertexColors:THREE.FaceColors}),f={};b(\\\"n1\\\",\\\"n2\\\",16755200);b(\\\"n2\\\",\\\"n4\\\",16755200);b(\\\"n4\\\",\\\"n3\\\",16755200);b(\\\"n3\\\",\\\"n1\\\",16755200);b(\\\"f1\\\",\\\"f2\\\",16755200);b(\\\"f2\\\",\\\"f4\\\",16755200);b(\\\"f4\\\",\\\"f3\\\",16755200);b(\\\"f3\\\",\\\"f1\\\",16755200);b(\\\"n1\\\",\\\"f1\\\",16755200);\\nb(\\\"n2\\\",\\\"f2\\\",16755200);b(\\\"n3\\\",\\\"f3\\\",16755200);b(\\\"n4\\\",\\\"f4\\\",16755200);b(\\\"p\\\",\\\"n1\\\",16711680);b(\\\"p\\\",\\\"n2\\\",16711680);b(\\\"p\\\",\\\"n3\\\",16711680);b(\\\"p\\\",\\\"n4\\\",16711680);b(\\\"u1\\\",\\\"u2\\\",43775);b(\\\"u2\\\",\\\"u3\\\",43775);b(\\\"u3\\\",\\\"u1\\\",43775);b(\\\"c\\\",\\\"t\\\",16777215);b(\\\"p\\\",\\\"c\\\",3355443);b(\\\"cn1\\\",\\\"cn2\\\",3355443);b(\\\"cn3\\\",\\\"cn4\\\",3355443);b(\\\"cf1\\\",\\\"cf2\\\",3355443);b(\\\"cf3\\\",\\\"cf4\\\",3355443);THREE.Line.call(this,d,e,THREE.LinePieces);this.camera=a;this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.pointMap=f;this.update()};\\nTHREE.CameraHelper.prototype=Object.create(THREE.Line.prototype);\\nTHREE.CameraHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Camera,c=new THREE.Projector;return function(){function d(d,g,h,k){a.set(g,h,k);c.unprojectVector(a,b);d=e.pointMap[d];if(void 0!==d)for(g=0,h=d.length;g<h;g++)e.geometry.vertices[d[g]].copy(a)}var e=this;b.projectionMatrix.copy(this.camera.projectionMatrix);d(\\\"c\\\",0,0,-1);d(\\\"t\\\",0,0,1);d(\\\"n1\\\",-1,-1,-1);d(\\\"n2\\\",1,-1,-1);d(\\\"n3\\\",-1,1,-1);d(\\\"n4\\\",1,1,-1);d(\\\"f1\\\",-1,-1,1);d(\\\"f2\\\",1,-1,1);d(\\\"f3\\\",-1,1,1);d(\\\"f4\\\",1,1,1);d(\\\"u1\\\",.7,\\n1.1,-1);d(\\\"u2\\\",-.7,1.1,-1);d(\\\"u3\\\",0,2,-1);d(\\\"cf1\\\",-1,0,1);d(\\\"cf2\\\",1,0,1);d(\\\"cf3\\\",0,-1,1);d(\\\"cf4\\\",0,1,1);d(\\\"cn1\\\",-1,0,-1);d(\\\"cn2\\\",1,0,-1);d(\\\"cn3\\\",0,-1,-1);d(\\\"cn4\\\",0,1,-1);this.geometry.verticesNeedUpdate=!0}}();\\nTHREE.DirectionalLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;b=b||1;var c=new THREE.Geometry;c.vertices.push(new THREE.Vector3(-b,b,0),new THREE.Vector3(b,b,0),new THREE.Vector3(b,-b,0),new THREE.Vector3(-b,-b,0),new THREE.Vector3(-b,b,0));var d=new THREE.LineBasicMaterial({fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.lightPlane=new THREE.Line(c,d);this.add(this.lightPlane);\\nc=new THREE.Geometry;c.vertices.push(new THREE.Vector3,new THREE.Vector3);d=new THREE.LineBasicMaterial({fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine=new THREE.Line(c,d);this.add(this.targetLine);this.update()};THREE.DirectionalLightHelper.prototype=Object.create(THREE.Object3D.prototype);\\nTHREE.DirectionalLightHelper.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()};\\nTHREE.DirectionalLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(){a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);c.subVectors(b,a);this.lightPlane.lookAt(c);this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine.geometry.vertices[1].copy(c);this.targetLine.geometry.verticesNeedUpdate=!0;this.targetLine.material.color.copy(this.lightPlane.material.color)}}();\\nTHREE.EdgesHelper=function(a,b){var c=void 0!==b?b:16777215,d=[0,0],e={},f=function(a,b){return a-b},g=[\\\"a\\\",\\\"b\\\",\\\"c\\\"],h=new THREE.BufferGeometry,k=a.geometry.clone();k.mergeVertices();k.computeFaceNormals();for(var l=k.vertices,k=k.faces,n=0,q=0,r=k.length;q<r;q++)for(var t=k[q],s=0;3>s;s++){d[0]=t[g[s]];d[1]=t[g[(s+1)%3]];d.sort(f);var p=d.toString();void 0===e[p]?(e[p]={vert1:d[0],vert2:d[1],face1:q,face2:void 0},n++):e[p].face2=q}h.addAttribute(\\\"position\\\",new THREE.Float32Attribute(6*n,3));d=h.attributes.position.array;\\nf=0;for(p in e)if(g=e[p],void 0===g.face2||.9999>k[g.face1].normal.dot(k[g.face2].normal))n=l[g.vert1],d[f++]=n.x,d[f++]=n.y,d[f++]=n.z,n=l[g.vert2],d[f++]=n.x,d[f++]=n.y,d[f++]=n.z;THREE.Line.call(this,h,new THREE.LineBasicMaterial({color:c}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.EdgesHelper.prototype=Object.create(THREE.Line.prototype);\\nTHREE.FaceNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:16776960;d=void 0!==d?d:1;b=new THREE.Geometry;c=0;for(var e=this.object.geometry.faces.length;c<e;c++)b.vertices.push(new THREE.Vector3,new THREE.Vector3);THREE.Line.call(this,b,new THREE.LineBasicMaterial({color:a,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};THREE.FaceNormalsHelper.prototype=Object.create(THREE.Line.prototype);\\nTHREE.FaceNormalsHelper.prototype.update=function(){var a=this.geometry.vertices,b=this.object,c=b.geometry.vertices,d=b.geometry.faces,e=b.matrixWorld;b.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(e);for(var f=b=0,g=d.length;b<g;b++,f+=2){var h=d[b];a[f].copy(c[h.a]).add(c[h.b]).add(c[h.c]).divideScalar(3).applyMatrix4(e);a[f+1].copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(a[f])}this.geometry.verticesNeedUpdate=!0;return this};\\nTHREE.GridHelper=function(a,b){var c=new THREE.Geometry,d=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});this.color1=new THREE.Color(4473924);this.color2=new THREE.Color(8947848);for(var e=-a;e<=a;e+=b){c.vertices.push(new THREE.Vector3(-a,0,e),new THREE.Vector3(a,0,e),new THREE.Vector3(e,0,-a),new THREE.Vector3(e,0,a));var f=0===e?this.color1:this.color2;c.colors.push(f,f,f,f)}THREE.Line.call(this,c,d,THREE.LinePieces)};THREE.GridHelper.prototype=Object.create(THREE.Line.prototype);\\nTHREE.GridHelper.prototype.setColors=function(a,b){this.color1.set(a);this.color2.set(b);this.geometry.colorsNeedUpdate=!0};\\nTHREE.HemisphereLightHelper=function(a,b,c,d){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.colors=[new THREE.Color,new THREE.Color];a=new THREE.SphereGeometry(b,4,2);a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));for(b=0;8>b;b++)a.faces[b].color=this.colors[4>b?0:1];b=new THREE.MeshBasicMaterial({vertexColors:THREE.FaceColors,wireframe:!0});this.lightSphere=new THREE.Mesh(a,b);this.add(this.lightSphere);\\nthis.update()};THREE.HemisphereLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.HemisphereLightHelper.prototype.dispose=function(){this.lightSphere.geometry.dispose();this.lightSphere.material.dispose()};\\nTHREE.HemisphereLightHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());this.lightSphere.geometry.colorsNeedUpdate=!0}}();\\nTHREE.PointLightHelper=function(a,b){this.light=a;this.light.updateMatrixWorld();var c=new THREE.SphereGeometry(b,4,2),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);THREE.Mesh.call(this,c,d);this.matrixWorld=this.light.matrixWorld;this.matrixAutoUpdate=!1};THREE.PointLightHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose()};\\nTHREE.PointLightHelper.prototype.update=function(){this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)};\\nTHREE.SkeletonHelper=function(a){this.bones=this.getBoneList(a);for(var b=new THREE.Geometry,c=0;c<this.bones.length;c++)this.bones[c].parent instanceof THREE.Bone&&(b.vertices.push(new THREE.Vector3),b.vertices.push(new THREE.Vector3),b.colors.push(new THREE.Color(0,0,1)),b.colors.push(new THREE.Color(0,1,0)));c=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors,depthTest:!1,depthWrite:!1,transparent:!0});THREE.Line.call(this,b,c,THREE.LinePieces);this.root=a;this.matrixWorld=a.matrixWorld;\\nthis.matrixAutoUpdate=!1;this.update()};THREE.SkeletonHelper.prototype=Object.create(THREE.Line.prototype);THREE.SkeletonHelper.prototype.getBoneList=function(a){var b=[];a instanceof THREE.Bone&&b.push(a);for(var c=0;c<a.children.length;c++)b.push.apply(b,this.getBoneList(a.children[c]));return b};\\nTHREE.SkeletonHelper.prototype.update=function(){for(var a=this.geometry,b=(new THREE.Matrix4).getInverse(this.root.matrixWorld),c=new THREE.Matrix4,d=0,e=0;e<this.bones.length;e++){var f=this.bones[e];f.parent instanceof THREE.Bone&&(c.multiplyMatrices(b,f.matrixWorld),a.vertices[d].setFromMatrixPosition(c),c.multiplyMatrices(b,f.parent.matrixWorld),a.vertices[d+1].setFromMatrixPosition(c),d+=2)}a.verticesNeedUpdate=!0;a.computeBoundingSphere()};\\nTHREE.SpotLightHelper=function(a){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;a=new THREE.CylinderGeometry(0,1,1,8,1,!0);a.applyMatrix((new THREE.Matrix4).makeTranslation(0,-.5,0));a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));var b=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});this.cone=new THREE.Mesh(a,b);this.add(this.cone);this.update()};THREE.SpotLightHelper.prototype=Object.create(THREE.Object3D.prototype);\\nTHREE.SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose()};THREE.SpotLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){var c=this.light.distance?this.light.distance:1E4,d=c*Math.tan(this.light.angle);this.cone.scale.set(d,d,c);a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(b.sub(a));this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)}}();\\nTHREE.VertexNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;b=void 0!==c?c:16711680;d=void 0!==d?d:1;c=new THREE.Geometry;a=a.geometry.faces;for(var e=0,f=a.length;e<f;e++)for(var g=0,h=a[e].vertexNormals.length;g<h;g++)c.vertices.push(new THREE.Vector3,new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};THREE.VertexNormalsHelper.prototype=Object.create(THREE.Line.prototype);\\nTHREE.VertexNormalsHelper.prototype.update=function(a){var b=new THREE.Vector3;return function(a){a=[\\\"a\\\",\\\"b\\\",\\\"c\\\",\\\"d\\\"];this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);for(var d=this.geometry.vertices,e=this.object.geometry.vertices,f=this.object.geometry.faces,g=this.object.matrixWorld,h=0,k=0,l=f.length;k<l;k++)for(var n=f[k],q=0,r=n.vertexNormals.length;q<r;q++){var t=n.vertexNormals[q];d[h].copy(e[n[a[q]]]).applyMatrix4(g);b.copy(t).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);\\nb.add(d[h]);h+=1;d[h].copy(b);h+=1}this.geometry.verticesNeedUpdate=!0;return this}}();\\nTHREE.VertexTangentsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;b=void 0!==c?c:255;d=void 0!==d?d:1;c=new THREE.Geometry;a=a.geometry.faces;for(var e=0,f=a.length;e<f;e++)for(var g=0,h=a[e].vertexTangents.length;g<h;g++)c.vertices.push(new THREE.Vector3),c.vertices.push(new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.update()};THREE.VertexTangentsHelper.prototype=Object.create(THREE.Line.prototype);\\nTHREE.VertexTangentsHelper.prototype.update=function(a){var b=new THREE.Vector3;return function(a){a=[\\\"a\\\",\\\"b\\\",\\\"c\\\",\\\"d\\\"];this.object.updateMatrixWorld(!0);for(var d=this.geometry.vertices,e=this.object.geometry.vertices,f=this.object.geometry.faces,g=this.object.matrixWorld,h=0,k=0,l=f.length;k<l;k++)for(var n=f[k],q=0,r=n.vertexTangents.length;q<r;q++){var t=n.vertexTangents[q];d[h].copy(e[n[a[q]]]).applyMatrix4(g);b.copy(t).transformDirection(g).multiplyScalar(this.size);b.add(d[h]);h+=1;d[h].copy(b);\\nh+=1}this.geometry.verticesNeedUpdate=!0;return this}}();\\nTHREE.WireframeHelper=function(a,b){var c=void 0!==b?b:16777215,d=[0,0],e={},f=function(a,b){return a-b},g=[\\\"a\\\",\\\"b\\\",\\\"c\\\"],h=new THREE.BufferGeometry;if(a.geometry instanceof THREE.Geometry){for(var k=a.geometry.vertices,l=a.geometry.faces,n=0,q=new Uint32Array(6*l.length),r=0,t=l.length;r<t;r++)for(var s=l[r],p=0;3>p;p++){d[0]=s[g[p]];d[1]=s[g[(p+1)%3]];d.sort(f);var v=d.toString();void 0===e[v]&&(q[2*n]=d[0],q[2*n+1]=d[1],e[v]=!0,n++)}d=new Float32Array(6*n);r=0;for(t=n;r<t;r++)for(p=0;2>p;p++)n=\\nk[q[2*r+p]],g=6*r+3*p,d[g+0]=n.x,d[g+1]=n.y,d[g+2]=n.z;h.addAttribute(\\\"position\\\",new THREE.BufferAttribute(d,3))}else if(a.geometry instanceof THREE.BufferGeometry){if(void 0!==a.geometry.attributes.index){for(var k=a.geometry.attributes.position.array,t=a.geometry.attributes.index.array,l=a.geometry.offsets,n=0,q=new Uint32Array(2*t.length),s=0,w=l.length;s<w;++s)for(var p=l[s].start,v=l[s].count,g=l[s].index,r=p,u=p+v;r<u;r+=3)for(p=0;3>p;p++)d[0]=g+t[r+p],d[1]=g+t[r+(p+1)%3],d.sort(f),v=d.toString(),\\nvoid 0===e[v]&&(q[2*n]=d[0],q[2*n+1]=d[1],e[v]=!0,n++);d=new Float32Array(6*n);r=0;for(t=n;r<t;r++)for(p=0;2>p;p++)g=6*r+3*p,n=3*q[2*r+p],d[g+0]=k[n],d[g+1]=k[n+1],d[g+2]=k[n+2]}else for(k=a.geometry.attributes.position.array,n=k.length/3,q=n/3,d=new Float32Array(6*n),r=0,t=q;r<t;r++)for(p=0;3>p;p++)g=18*r+6*p,q=9*r+3*p,d[g+0]=k[q],d[g+1]=k[q+1],d[g+2]=k[q+2],n=9*r+(p+1)%3*3,d[g+3]=k[n],d[g+4]=k[n+1],d[g+5]=k[n+2];h.addAttribute(\\\"position\\\",new THREE.BufferAttribute(d,3))}THREE.Line.call(this,h,new THREE.LineBasicMaterial({color:c}),\\nTHREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.WireframeHelper.prototype=Object.create(THREE.Line.prototype);THREE.ImmediateRenderObject=function(){THREE.Object3D.call(this);this.render=function(a){}};THREE.ImmediateRenderObject.prototype=Object.create(THREE.Object3D.prototype);THREE.LensFlare=function(a,b,c,d,e){THREE.Object3D.call(this);this.lensFlares=[];this.positionScreen=new THREE.Vector3;this.customUpdateCallback=void 0;void 0!==a&&this.add(a,b,c,d,e)};\\nTHREE.LensFlare.prototype=Object.create(THREE.Object3D.prototype);THREE.LensFlare.prototype.add=function(a,b,c,d,e,f){void 0===b&&(b=-1);void 0===c&&(c=0);void 0===f&&(f=1);void 0===e&&(e=new THREE.Color(16777215));void 0===d&&(d=THREE.NormalBlending);c=Math.min(c,Math.max(0,c));this.lensFlares.push({texture:a,size:b,distance:c,x:0,y:0,z:0,scale:1,rotation:1,opacity:f,color:e,blending:d})};\\nTHREE.LensFlare.prototype.updateLensFlares=function(){var a,b=this.lensFlares.length,c,d=2*-this.positionScreen.x,e=2*-this.positionScreen.y;for(a=0;a<b;a++)c=this.lensFlares[a],c.x=this.positionScreen.x+d*c.distance,c.y=this.positionScreen.y+e*c.distance,c.wantedRotation=c.x*Math.PI*.25,c.rotation+=.25*(c.wantedRotation-c.rotation)};\\nTHREE.MorphBlendMesh=function(a,b){THREE.Mesh.call(this,a,b);this.animationsMap={};this.animationsList=[];var c=this.geometry.morphTargets.length;this.createAnimation(\\\"__default\\\",0,c-1,c/1);this.setAnimationWeight(\\\"__default\\\",1)};THREE.MorphBlendMesh.prototype=Object.create(THREE.Mesh.prototype);\\nTHREE.MorphBlendMesh.prototype.createAnimation=function(a,b,c,d){b={startFrame:b,endFrame:c,length:c-b+1,fps:d,duration:(c-b)/d,lastFrame:0,currentFrame:0,active:!1,time:0,direction:1,weight:1,directionBackwards:!1,mirroredLoop:!1};this.animationsMap[a]=b;this.animationsList.push(b)};\\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations=function(a){for(var b=/([a-z]+)_?(\\\\d+)/,c,d={},e=this.geometry,f=0,g=e.morphTargets.length;f<g;f++){var h=e.morphTargets[f].name.match(b);if(h&&1<h.length){var k=h[1];d[k]||(d[k]={start:Infinity,end:-Infinity});h=d[k];f<h.start&&(h.start=f);f>h.end&&(h.end=f);c||(c=k)}}for(k in d)h=d[k],this.createAnimation(k,h.start,h.end,a);this.firstAnimation=c};\\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward=function(a){if(a=this.animationsMap[a])a.direction=1,a.directionBackwards=!1};THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward=function(a){if(a=this.animationsMap[a])a.direction=-1,a.directionBackwards=!0};THREE.MorphBlendMesh.prototype.setAnimationFPS=function(a,b){var c=this.animationsMap[a];c&&(c.fps=b,c.duration=(c.end-c.start)/c.fps)};\\nTHREE.MorphBlendMesh.prototype.setAnimationDuration=function(a,b){var c=this.animationsMap[a];c&&(c.duration=b,c.fps=(c.end-c.start)/c.duration)};THREE.MorphBlendMesh.prototype.setAnimationWeight=function(a,b){var c=this.animationsMap[a];c&&(c.weight=b)};THREE.MorphBlendMesh.prototype.setAnimationTime=function(a,b){var c=this.animationsMap[a];c&&(c.time=b)};THREE.MorphBlendMesh.prototype.getAnimationTime=function(a){var b=0;if(a=this.animationsMap[a])b=a.time;return b};\\nTHREE.MorphBlendMesh.prototype.getAnimationDuration=function(a){var b=-1;if(a=this.animationsMap[a])b=a.duration;return b};THREE.MorphBlendMesh.prototype.playAnimation=function(a){var b=this.animationsMap[a];b?(b.time=0,b.active=!0):console.warn(\\\"animation[\\\"+a+\\\"] undefined\\\")};THREE.MorphBlendMesh.prototype.stopAnimation=function(a){if(a=this.animationsMap[a])a.active=!1};\\nTHREE.MorphBlendMesh.prototype.update=function(a){for(var b=0,c=this.animationsList.length;b<c;b++){var d=this.animationsList[b];if(d.active){var e=d.duration/d.length;d.time+=d.direction*a;if(d.mirroredLoop){if(d.time>d.duration||0>d.time)d.direction*=-1,d.time>d.duration&&(d.time=d.duration,d.directionBackwards=!0),0>d.time&&(d.time=0,d.directionBackwards=!1)}else d.time%=d.duration,0>d.time&&(d.time+=d.duration);var f=d.startFrame+THREE.Math.clamp(Math.floor(d.time/e),0,d.length-1),g=d.weight;\\nf!==d.currentFrame&&(this.morphTargetInfluences[d.lastFrame]=0,this.morphTargetInfluences[d.currentFrame]=1*g,this.morphTargetInfluences[f]=0,d.lastFrame=d.currentFrame,d.currentFrame=f);e=d.time%e/e;d.directionBackwards&&(e=1-e);this.morphTargetInfluences[d.currentFrame]=e*g;this.morphTargetInfluences[d.lastFrame]=(1-e)*g}}};\\nTHREE.LensFlarePlugin=function(){function a(a,b){var d=c.createProgram(),e=c.createShader(c.FRAGMENT_SHADER),f=c.createShader(c.VERTEX_SHADER),g=\\\"precision \\\"+b+\\\" float;\\\\n\\\";c.shaderSource(e,g+a.fragmentShader);c.shaderSource(f,g+a.vertexShader);c.compileShader(e);c.compileShader(f);c.attachShader(d,e);c.attachShader(d,f);c.linkProgram(d);return d}var b=[],c,d,e,f,g,h,k,l,n,q,r,t,s;this.init=function(b){c=b.context;d=b;e=b.getPrecision();f=new Float32Array(16);g=new Uint16Array(6);b=0;f[b++]=-1;f[b++]=\\n-1;f[b++]=0;f[b++]=0;f[b++]=1;f[b++]=-1;f[b++]=1;f[b++]=0;f[b++]=1;f[b++]=1;f[b++]=1;f[b++]=1;f[b++]=-1;f[b++]=1;f[b++]=0;f[b++]=1;b=0;g[b++]=0;g[b++]=1;g[b++]=2;g[b++]=0;g[b++]=2;g[b++]=3;h=c.createBuffer();k=c.createBuffer();c.bindBuffer(c.ARRAY_BUFFER,h);c.bufferData(c.ARRAY_BUFFER,f,c.STATIC_DRAW);c.bindBuffer(c.ELEMENT_ARRAY_BUFFER,k);c.bufferData(c.ELEMENT_ARRAY_BUFFER,g,c.STATIC_DRAW);l=c.createTexture();n=c.createTexture();c.bindTexture(c.TEXTURE_2D,l);c.texImage2D(c.TEXTURE_2D,0,c.RGB,16,\\n16,0,c.RGB,c.UNSIGNED_BYTE,null);c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_S,c.CLAMP_TO_EDGE);c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_T,c.CLAMP_TO_EDGE);c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MAG_FILTER,c.NEAREST);c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MIN_FILTER,c.NEAREST);c.bindTexture(c.TEXTURE_2D,n);c.texImage2D(c.TEXTURE_2D,0,c.RGBA,16,16,0,c.RGBA,c.UNSIGNED_BYTE,null);c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_S,c.CLAMP_TO_EDGE);c.texParameteri(c.TEXTURE_2D,c.TEXTURE_WRAP_T,c.CLAMP_TO_EDGE);\\nc.texParameteri(c.TEXTURE_2D,c.TEXTURE_MAG_FILTER,c.NEAREST);c.texParameteri(c.TEXTURE_2D,c.TEXTURE_MIN_FILTER,c.NEAREST);0>=c.getParameter(c.MAX_VERTEX_TEXTURE_IMAGE_UNITS)?(q=!1,r=a(THREE.ShaderFlares.lensFlare,e)):(q=!0,r=a(THREE.ShaderFlares.lensFlareVertexTexture,e));t={};s={};t.vertex=c.getAttribLocation(r,\\\"position\\\");t.uv=c.getAttribLocation(r,\\\"uv\\\");s.renderType=c.getUniformLocation(r,\\\"renderType\\\");s.map=c.getUniformLocation(r,\\\"map\\\");s.occlusionMap=c.getUniformLocation(r,\\\"occlusionMap\\\");s.opacity=\\nc.getUniformLocation(r,\\\"opacity\\\");s.color=c.getUniformLocation(r,\\\"color\\\");s.scale=c.getUniformLocation(r,\\\"scale\\\");s.rotation=c.getUniformLocation(r,\\\"rotation\\\");s.screenPosition=c.getUniformLocation(r,\\\"screenPosition\\\")};this.render=function(a,e,f,g){b.length=0;a.traverseVisible(function(a){a instanceof THREE.LensFlare&&b.push(a)});if(0!==b.length){a=new THREE.Vector3;var D=g/f,A=.5*f,x=.5*g,C=16/g,I=new THREE.Vector2(C*D,C),z=new THREE.Vector3(1,1,0),y=new THREE.Vector2(1,1),K=s,C=t;c.useProgram(r);\\nc.enableVertexAttribArray(t.vertex);c.enableVertexAttribArray(t.uv);c.uniform1i(K.occlusionMap,0);c.uniform1i(K.map,1);c.bindBuffer(c.ARRAY_BUFFER,h);c.vertexAttribPointer(C.vertex,2,c.FLOAT,!1,16,0);c.vertexAttribPointer(C.uv,2,c.FLOAT,!1,16,8);c.bindBuffer(c.ELEMENT_ARRAY_BUFFER,k);c.disable(c.CULL_FACE);c.depthMask(!1);for(var N=0,ba=b.length;N<ba;N++){C=16/g;I.set(C*D,C);var P=b[N];a.set(P.matrixWorld.elements[12],P.matrixWorld.elements[13],P.matrixWorld.elements[14]);a.applyMatrix4(e.matrixWorldInverse);\\na.applyProjection(e.projectionMatrix);z.copy(a);y.x=z.x*A+A;y.y=z.y*x+x;if(q||0<y.x&&y.x<f&&0<y.y&&y.y<g){c.activeTexture(c.TEXTURE1);c.bindTexture(c.TEXTURE_2D,l);c.copyTexImage2D(c.TEXTURE_2D,0,c.RGB,y.x-8,y.y-8,16,16,0);c.uniform1i(K.renderType,0);c.uniform2f(K.scale,I.x,I.y);c.uniform3f(K.screenPosition,z.x,z.y,z.z);c.disable(c.BLEND);c.enable(c.DEPTH_TEST);c.drawElements(c.TRIANGLES,6,c.UNSIGNED_SHORT,0);c.activeTexture(c.TEXTURE0);c.bindTexture(c.TEXTURE_2D,n);c.copyTexImage2D(c.TEXTURE_2D,\\n0,c.RGBA,y.x-8,y.y-8,16,16,0);c.uniform1i(K.renderType,1);c.disable(c.DEPTH_TEST);c.activeTexture(c.TEXTURE1);c.bindTexture(c.TEXTURE_2D,l);c.drawElements(c.TRIANGLES,6,c.UNSIGNED_SHORT,0);P.positionScreen.copy(z);P.customUpdateCallback?P.customUpdateCallback(P):P.updateLensFlares();c.uniform1i(K.renderType,2);c.enable(c.BLEND);for(var O=0,J=P.lensFlares.length;O<J;O++){var E=P.lensFlares[O];.001<E.opacity&&.001<E.scale&&(z.x=E.x,z.y=E.y,z.z=E.z,C=E.size*E.scale/g,I.x=C*D,I.y=C,c.uniform3f(K.screenPosition,\\nz.x,z.y,z.z),c.uniform2f(K.scale,I.x,I.y),c.uniform1f(K.rotation,E.rotation),c.uniform1f(K.opacity,E.opacity),c.uniform3f(K.color,E.color.r,E.color.g,E.color.b),d.setBlending(E.blending,E.blendEquation,E.blendSrc,E.blendDst),d.setTexture(E.texture,1),c.drawElements(c.TRIANGLES,6,c.UNSIGNED_SHORT,0))}}}c.enable(c.CULL_FACE);c.enable(c.DEPTH_TEST);c.depthMask(!0)}}};\\nTHREE.ShadowMapPlugin=function(){function a(b,c,d){if(c.visible){var e=b.__webglObjects[c.id];if(e&&c.castShadow&&(!1===c.frustumCulled||!0===h.intersectsObject(c)))for(var f=0,g=e.length;f<g;f++){var k=e[f];c._modelViewMatrix.multiplyMatrices(d.matrixWorldInverse,c.matrixWorld);r.push(k)}f=0;for(g=c.children.length;f<g;f++)a(b,c.children[f],d)}}var b,c,d,e,f,g,h=new THREE.Frustum,k=new THREE.Matrix4,l=new THREE.Vector3,n=new THREE.Vector3,q=new THREE.Vector3,r=[];this.init=function(a){b=a.context;\\nc=a;a=THREE.ShaderLib.depthRGBA;var h=THREE.UniformsUtils.clone(a.uniforms);d=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h});e=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h,morphTargets:!0});f=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h,skinning:!0});g=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h,\\nmorphTargets:!0,skinning:!0});d._shadowPass=!0;e._shadowPass=!0;f._shadowPass=!0;g._shadowPass=!0};this.render=function(a,b){c.shadowMapEnabled&&c.shadowMapAutoUpdate&&this.update(a,b)};this.update=function(t,s){var p,v,w,u,D,A,x,C,I=[];u=0;b.clearColor(1,1,1,1);b.disable(b.BLEND);b.enable(b.CULL_FACE);b.frontFace(b.CCW);c.shadowMapCullFace===THREE.CullFaceFront?b.cullFace(b.FRONT):b.cullFace(b.BACK);c.setDepthTest(!0);p=0;for(v=t.__lights.length;p<v;p++)if(w=t.__lights[p],w.castShadow)if(w instanceof\\nTHREE.DirectionalLight&&w.shadowCascade)for(D=0;D<w.shadowCascadeCount;D++){var z;if(w.shadowCascadeArray[D])z=w.shadowCascadeArray[D];else{x=w;var y=D;z=new THREE.DirectionalLight;z.isVirtual=!0;z.onlyShadow=!0;z.castShadow=!0;z.shadowCameraNear=x.shadowCameraNear;z.shadowCameraFar=x.shadowCameraFar;z.shadowCameraLeft=x.shadowCameraLeft;z.shadowCameraRight=x.shadowCameraRight;z.shadowCameraBottom=x.shadowCameraBottom;z.shadowCameraTop=x.shadowCameraTop;z.shadowCameraVisible=x.shadowCameraVisible;\\nz.shadowDarkness=x.shadowDarkness;z.shadowBias=x.shadowCascadeBias[y];z.shadowMapWidth=x.shadowCascadeWidth[y];z.shadowMapHeight=x.shadowCascadeHeight[y];z.pointsWorld=[];z.pointsFrustum=[];C=z.pointsWorld;A=z.pointsFrustum;for(var K=0;8>K;K++)C[K]=new THREE.Vector3,A[K]=new THREE.Vector3;C=x.shadowCascadeNearZ[y];x=x.shadowCascadeFarZ[y];A[0].set(-1,-1,C);A[1].set(1,-1,C);A[2].set(-1,1,C);A[3].set(1,1,C);A[4].set(-1,-1,x);A[5].set(1,-1,x);A[6].set(-1,1,x);A[7].set(1,1,x);z.originalCamera=s;A=new THREE.Gyroscope;\\nA.position.copy(w.shadowCascadeOffset);A.add(z);A.add(z.target);s.add(A);w.shadowCascadeArray[D]=z;console.log(\\\"Created virtualLight\\\",z)}y=w;C=D;x=y.shadowCascadeArray[C];x.position.copy(y.position);x.target.position.copy(y.target.position);x.lookAt(x.target);x.shadowCameraVisible=y.shadowCameraVisible;x.shadowDarkness=y.shadowDarkness;x.shadowBias=y.shadowCascadeBias[C];A=y.shadowCascadeNearZ[C];y=y.shadowCascadeFarZ[C];x=x.pointsFrustum;x[0].z=A;x[1].z=A;x[2].z=A;x[3].z=A;x[4].z=y;x[5].z=y;x[6].z=\\ny;x[7].z=y;I[u]=z;u++}else I[u]=w,u++;p=0;for(v=I.length;p<v;p++){w=I[p];w.shadowMap||(D=THREE.LinearFilter,c.shadowMapType===THREE.PCFSoftShadowMap&&(D=THREE.NearestFilter),w.shadowMap=new THREE.WebGLRenderTarget(w.shadowMapWidth,w.shadowMapHeight,{minFilter:D,magFilter:D,format:THREE.RGBAFormat}),w.shadowMapSize=new THREE.Vector2(w.shadowMapWidth,w.shadowMapHeight),w.shadowMatrix=new THREE.Matrix4);if(!w.shadowCamera){if(w instanceof THREE.SpotLight)w.shadowCamera=new THREE.PerspectiveCamera(w.shadowCameraFov,\\nw.shadowMapWidth/w.shadowMapHeight,w.shadowCameraNear,w.shadowCameraFar);else if(w instanceof THREE.DirectionalLight)w.shadowCamera=new THREE.OrthographicCamera(w.shadowCameraLeft,w.shadowCameraRight,w.shadowCameraTop,w.shadowCameraBottom,w.shadowCameraNear,w.shadowCameraFar);else{console.error(\\\"Unsupported light type for shadow\\\");continue}t.add(w.shadowCamera);!0===t.autoUpdate&&t.updateMatrixWorld()}w.shadowCameraVisible&&!w.cameraHelper&&(w.cameraHelper=new THREE.CameraHelper(w.shadowCamera),w.shadowCamera.add(w.cameraHelper));\\nif(w.isVirtual&&z.originalCamera==s){D=s;u=w.shadowCamera;A=w.pointsFrustum;x=w.pointsWorld;l.set(Infinity,Infinity,Infinity);n.set(-Infinity,-Infinity,-Infinity);for(y=0;8>y;y++)C=x[y],C.copy(A[y]),THREE.ShadowMapPlugin.__projector.unprojectVector(C,D),C.applyMatrix4(u.matrixWorldInverse),C.x<l.x&&(l.x=C.x),C.x>n.x&&(n.x=C.x),C.y<l.y&&(l.y=C.y),C.y>n.y&&(n.y=C.y),C.z<l.z&&(l.z=C.z),C.z>n.z&&(n.z=C.z);u.left=l.x;u.right=n.x;u.top=n.y;u.bottom=l.y;u.updateProjectionMatrix()}u=w.shadowMap;A=w.shadowMatrix;\\nD=w.shadowCamera;D.position.setFromMatrixPosition(w.matrixWorld);q.setFromMatrixPosition(w.target.matrixWorld);D.lookAt(q);D.updateMatrixWorld();D.matrixWorldInverse.getInverse(D.matrixWorld);w.cameraHelper&&(w.cameraHelper.visible=w.shadowCameraVisible);w.shadowCameraVisible&&w.cameraHelper.update();A.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);A.multiply(D.projectionMatrix);A.multiply(D.matrixWorldInverse);k.multiplyMatrices(D.projectionMatrix,D.matrixWorldInverse);h.setFromMatrix(k);c.setRenderTarget(u);\\nc.clear();r.length=0;a(t,t,D);w=0;for(u=r.length;w<u;w++)x=r[w],A=x.object,x=x.buffer,y=A.material instanceof THREE.MeshFaceMaterial?A.material.materials[0]:A.material,C=void 0!==A.geometry.morphTargets&&0<A.geometry.morphTargets.length&&y.morphTargets,K=A instanceof THREE.SkinnedMesh&&y.skinning,C=A.customDepthMaterial?A.customDepthMaterial:K?C?g:f:C?e:d,c.setMaterialFaces(y),x instanceof THREE.BufferGeometry?c.renderBufferDirect(D,t.__lights,null,C,x,A):c.renderBuffer(D,t.__lights,null,C,x,A);y=\\nt.__webglObjectsImmediate;w=0;for(u=y.length;w<u;w++)x=y[w],A=x.object,A.visible&&A.castShadow&&(A._modelViewMatrix.multiplyMatrices(D.matrixWorldInverse,A.matrixWorld),c.renderImmediateObject(D,t.__lights,null,d,A))}p=c.getClearColor();v=c.getClearAlpha();b.clearColor(p.r,p.g,p.b,v);b.enable(b.BLEND);c.shadowMapCullFace===THREE.CullFaceFront&&b.cullFace(b.BACK)}};THREE.ShadowMapPlugin.__projector=new THREE.Projector;\\nTHREE.SpritePlugin=function(){var a,b,c,d,e,f,g,h,k,l,n,q,r,t,s,p,v;function w(a,b){return a.z!==b.z?b.z-a.z:b.id-a.id}var u,D,A,x=[],C,I,z,y,K;this.init=function(w){u=w.context;D=w;C=new Float32Array([-.5,-.5,0,0,.5,-.5,1,0,.5,.5,1,1,-.5,.5,0,1]);I=new Uint16Array([0,1,2,0,2,3]);z=u.createBuffer();y=u.createBuffer();u.bindBuffer(u.ARRAY_BUFFER,z);u.bufferData(u.ARRAY_BUFFER,C,u.STATIC_DRAW);u.bindBuffer(u.ELEMENT_ARRAY_BUFFER,y);u.bufferData(u.ELEMENT_ARRAY_BUFFER,I,u.STATIC_DRAW);w=u.createProgram();\\nvar x=u.createShader(u.VERTEX_SHADER),P=u.createShader(u.FRAGMENT_SHADER);u.shaderSource(x,[\\\"precision \\\"+D.getPrecision()+\\\" float;\\\",\\\"uniform mat4 modelViewMatrix;\\\\nuniform mat4 projectionMatrix;\\\\nuniform float rotation;\\\\nuniform vec2 scale;\\\\nuniform vec2 uvOffset;\\\\nuniform vec2 uvScale;\\\\nattribute vec2 position;\\\\nattribute vec2 uv;\\\\nvarying vec2 vUV;\\\\nvoid main() {\\\\nvUV = uvOffset + uv * uvScale;\\\\nvec2 alignedPosition = position * scale;\\\\nvec2 rotatedPosition;\\\\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\\\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\\\nvec4 finalPosition;\\\\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\\\nfinalPosition.xy += rotatedPosition;\\\\nfinalPosition = projectionMatrix * finalPosition;\\\\ngl_Position = finalPosition;\\\\n}\\\"].join(\\\"\\\\n\\\"));\\nu.shaderSource(P,[\\\"precision \\\"+D.getPrecision()+\\\" float;\\\",\\\"uniform vec3 color;\\\\nuniform sampler2D map;\\\\nuniform float opacity;\\\\nuniform int fogType;\\\\nuniform vec3 fogColor;\\\\nuniform float fogDensity;\\\\nuniform float fogNear;\\\\nuniform float fogFar;\\\\nuniform float alphaTest;\\\\nvarying vec2 vUV;\\\\nvoid main() {\\\\nvec4 texture = texture2D( map, vUV );\\\\nif ( texture.a < alphaTest ) discard;\\\\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\\\\nif ( fogType > 0 ) {\\\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\\\nfloat fogFactor = 0.0;\\\\nif ( fogType == 1 ) {\\\\nfogFactor = smoothstep( fogNear, fogFar, depth );\\\\n} else {\\\\nconst float LOG2 = 1.442695;\\\\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\\\\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\\\\n}\\\\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\\\n}\\\\n}\\\"].join(\\\"\\\\n\\\"));\\nu.compileShader(x);u.compileShader(P);u.attachShader(w,x);u.attachShader(w,P);u.linkProgram(w);K=w;p=u.getAttribLocation(K,\\\"position\\\");v=u.getAttribLocation(K,\\\"uv\\\");a=u.getUniformLocation(K,\\\"uvOffset\\\");b=u.getUniformLocation(K,\\\"uvScale\\\");c=u.getUniformLocation(K,\\\"rotation\\\");d=u.getUniformLocation(K,\\\"scale\\\");e=u.getUniformLocation(K,\\\"color\\\");f=u.getUniformLocation(K,\\\"map\\\");g=u.getUniformLocation(K,\\\"opacity\\\");h=u.getUniformLocation(K,\\\"modelViewMatrix\\\");k=u.getUniformLocation(K,\\\"projectionMatrix\\\");l=\\nu.getUniformLocation(K,\\\"fogType\\\");n=u.getUniformLocation(K,\\\"fogDensity\\\");q=u.getUniformLocation(K,\\\"fogNear\\\");r=u.getUniformLocation(K,\\\"fogFar\\\");t=u.getUniformLocation(K,\\\"fogColor\\\");s=u.getUniformLocation(K,\\\"alphaTest\\\");w=document.createElement(\\\"canvas\\\");w.width=8;w.height=8;x=w.getContext(\\\"2d\\\");x.fillStyle=\\\"white\\\";x.fillRect(0,0,8,8);A=new THREE.Texture(w);A.needsUpdate=!0};this.render=function(C,I,P,O){x.length=0;C.traverseVisible(function(a){a instanceof THREE.Sprite&&x.push(a)});if(0!==x.length){u.useProgram(K);\\nu.enableVertexAttribArray(p);u.enableVertexAttribArray(v);u.disable(u.CULL_FACE);u.enable(u.BLEND);u.bindBuffer(u.ARRAY_BUFFER,z);u.vertexAttribPointer(p,2,u.FLOAT,!1,16,0);u.vertexAttribPointer(v,2,u.FLOAT,!1,16,8);u.bindBuffer(u.ELEMENT_ARRAY_BUFFER,y);u.uniformMatrix4fv(k,!1,I.projectionMatrix.elements);u.activeTexture(u.TEXTURE0);u.uniform1i(f,0);O=P=0;var J=C.fog;J?(u.uniform3f(t,J.color.r,J.color.g,J.color.b),J instanceof THREE.Fog?(u.uniform1f(q,J.near),u.uniform1f(r,J.far),u.uniform1i(l,1),\\nO=P=1):J instanceof THREE.FogExp2&&(u.uniform1f(n,J.density),u.uniform1i(l,2),O=P=2)):(u.uniform1i(l,0),O=P=0);for(var J=0,E=x.length;J<E;J++){var Q=x[J],L=Q.material;Q._modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,Q.matrixWorld);Q.z=-Q._modelViewMatrix.elements[14]}x.sort(w);I=[];J=0;for(E=x.length;J<E;J++)Q=x[J],L=Q.material,u.uniform1f(s,L.alphaTest),u.uniformMatrix4fv(h,!1,Q._modelViewMatrix.elements),I[0]=Q.scale.x,I[1]=Q.scale.y,Q=0,C.fog&&L.fog&&(Q=O),P!==Q&&(u.uniform1i(l,Q),P=Q),\\nnull!==L.map?(u.uniform2f(a,L.map.offset.x,L.map.offset.y),u.uniform2f(b,L.map.repeat.x,L.map.repeat.y)):(u.uniform2f(a,0,0),u.uniform2f(b,1,1)),u.uniform1f(g,L.opacity),u.uniform3f(e,L.color.r,L.color.g,L.color.b),u.uniform1f(c,L.rotation),u.uniform2fv(d,I),D.setBlending(L.blending,L.blendEquation,L.blendSrc,L.blendDst),D.setDepthTest(L.depthTest),D.setDepthWrite(L.depthWrite),L.map&&L.map.image&&L.map.image.width?D.setTexture(L.map,0):D.setTexture(A,0),u.drawElements(u.TRIANGLES,6,u.UNSIGNED_SHORT,\\n0);u.enable(u.CULL_FACE)}}};\\nTHREE.DepthPassPlugin=function(){function a(b,c,d){if(c.visible){var e=b.__webglObjects[c.id];if(e&&(!1===c.frustumCulled||!0===h.intersectsObject(c)))for(var f=0,g=e.length;f<g;f++){var k=e[f];c._modelViewMatrix.multiplyMatrices(d.matrixWorldInverse,c.matrixWorld);l.push(k)}f=0;for(g=c.children.length;f<g;f++)a(b,c.children[f],d)}}this.enabled=!1;this.renderTarget=null;var b,c,d,e,f,g,h=new THREE.Frustum,k=new THREE.Matrix4,l=[];this.init=function(a){b=a.context;c=a;a=THREE.ShaderLib.depthRGBA;var h=\\nTHREE.UniformsUtils.clone(a.uniforms);d=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h});e=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h,morphTargets:!0});f=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h,skinning:!0});g=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h,morphTargets:!0,skinning:!0});d._shadowPass=\\n!0;e._shadowPass=!0;f._shadowPass=!0;g._shadowPass=!0};this.render=function(a,b){this.enabled&&this.update(a,b)};this.update=function(n,q){var r,t,s,p,v;b.clearColor(1,1,1,1);b.disable(b.BLEND);c.setDepthTest(!0);!0===n.autoUpdate&&n.updateMatrixWorld();q.matrixWorldInverse.getInverse(q.matrixWorld);k.multiplyMatrices(q.projectionMatrix,q.matrixWorldInverse);h.setFromMatrix(k);c.setRenderTarget(this.renderTarget);c.clear();l.length=0;a(n,n,q);var w;r=0;for(t=l.length;r<t;r++)s=l[r],v=s.object,s=s.buffer,\\nv instanceof THREE.PointCloud&&!v.customDepthMaterial||((w=v.material instanceof THREE.MeshFaceMaterial?v.material.materials[0]:v.material)&&c.setMaterialFaces(v.material),p=void 0!==v.geometry.morphTargets&&0<v.geometry.morphTargets.length&&w.morphTargets,w=v instanceof THREE.SkinnedMesh&&w.skinning,p=v.customDepthMaterial?v.customDepthMaterial:w?p?g:f:p?e:d,s instanceof THREE.BufferGeometry?c.renderBufferDirect(q,n.__lights,null,p,s,v):c.renderBuffer(q,n.__lights,null,p,s,v));p=n.__webglObjectsImmediate;\\nr=0;for(t=p.length;r<t;r++)s=p[r],v=s.object,v.visible&&(v._modelViewMatrix.multiplyMatrices(q.matrixWorldInverse,v.matrixWorld),c.renderImmediateObject(q,n.__lights,null,d,v));r=c.getClearColor();t=c.getClearAlpha();b.clearColor(r.r,r.g,r.b,t);b.enable(b.BLEND)}};\\nTHREE.ShaderFlares={lensFlareVertexTexture:{vertexShader:\\\"uniform lowp int renderType;\\\\nuniform vec3 screenPosition;\\\\nuniform vec2 scale;\\\\nuniform float rotation;\\\\nuniform sampler2D occlusionMap;\\\\nattribute vec2 position;\\\\nattribute vec2 uv;\\\\nvarying vec2 vUV;\\\\nvarying float vVisibility;\\\\nvoid main() {\\\\nvUV = uv;\\\\nvec2 pos = position;\\\\nif( renderType == 2 ) {\\\\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\\\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\\\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\\\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\\\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\\\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\\\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\\\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\\\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\\\\nvVisibility =        visibility.r / 9.0;\\\\nvVisibility *= 1.0 - visibility.g / 9.0;\\\\nvVisibility *=       visibility.b / 9.0;\\\\nvVisibility *= 1.0 - visibility.a / 9.0;\\\\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\\\\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\\\\n}\\\\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\\\\n}\\\",fragmentShader:\\\"uniform lowp int renderType;\\\\nuniform sampler2D map;\\\\nuniform float opacity;\\\\nuniform vec3 color;\\\\nvarying vec2 vUV;\\\\nvarying float vVisibility;\\\\nvoid main() {\\\\nif( renderType == 0 ) {\\\\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\\\\n} else if( renderType == 1 ) {\\\\ngl_FragColor = texture2D( map, vUV );\\\\n} else {\\\\nvec4 texture = texture2D( map, vUV );\\\\ntexture.a *= opacity * vVisibility;\\\\ngl_FragColor = texture;\\\\ngl_FragColor.rgb *= color;\\\\n}\\\\n}\\\"},\\nlensFlare:{vertexShader:\\\"uniform lowp int renderType;\\\\nuniform vec3 screenPosition;\\\\nuniform vec2 scale;\\\\nuniform float rotation;\\\\nattribute vec2 position;\\\\nattribute vec2 uv;\\\\nvarying vec2 vUV;\\\\nvoid main() {\\\\nvUV = uv;\\\\nvec2 pos = position;\\\\nif( renderType == 2 ) {\\\\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\\\\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\\\\n}\\\\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\\\\n}\\\",\\nfragmentShader:\\\"precision mediump float;\\\\nuniform lowp int renderType;\\\\nuniform sampler2D map;\\\\nuniform sampler2D occlusionMap;\\\\nuniform float opacity;\\\\nuniform vec3 color;\\\\nvarying vec2 vUV;\\\\nvoid main() {\\\\nif( renderType == 0 ) {\\\\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\\\\n} else if( renderType == 1 ) {\\\\ngl_FragColor = texture2D( map, vUV );\\\\n} else {\\\\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\\\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\\\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\\\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\\\\nvisibility = ( 1.0 - visibility / 4.0 );\\\\nvec4 texture = texture2D( map, vUV );\\\\ntexture.a *= opacity * visibility;\\\\ngl_FragColor = texture;\\\\ngl_FragColor.rgb *= color;\\\\n}\\\\n}\\\"}};\\n\\nexports.THREE = THREE;})();\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/config.css\": {\n            \"type\": \"text/css\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/config.css\",\n            \"tags\": \"[[$:/tags/Stylesheet]]\",\n            \"text\": \"/* Stats module */\\n#stats {}\\n#stats #fps {background: transparent !important}\\n#stats #fps #fpsText {color: #aaa !important}\\n#stats #fps #fpsGraph {}\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/stringview.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/stringview.js\",\n            \"module-type\": \"library\",\n            \"text\": \"(function(){\\n\\\"use strict\\\";\\n/*\\nThe aims of this library are:\\n\\n    to create a C-like interface for strings (i.e., an array of character codes  an\\n      ArrayBufferView in JavaScript) based upon the JavaScript ArrayBuffer interface\\n    to create a highly extensible library that anyone can extend by adding methods to\\n      the object StringView.prototype\\n    to create a collection of methods for such string-like objects (since now: stringViews)\\n      which work strictly on arrays of numbers rather than on creating new immutable\\n      JavaScript strings\\n    to work with Unicode encodings other than JavaScript's default UTF-16 DOMStrings\\n*/\\n\\n/*\\\\\\n|*|\\n|*|  :: Number.isInteger() polyfill ::\\n|*|\\n|*|  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\\n|*|\\n\\\\*/\\n\\nif (!Number.isInteger) {\\n  Number.isInteger = function isInteger (nVal) {\\n    return typeof nVal === \\\"number\\\" && isFinite(nVal) && nVal > -9007199254740992 && nVal < 9007199254740992 && Math.floor(nVal) === nVal;\\n  };\\n}\\n\\n/*\\\\\\n|*|\\n|*|  StringView - Mozilla Developer Network\\n|*|\\n|*|  Revision #8, October 6, 2014\\n|*|\\n|*|  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/StringView\\n|*|  https://developer.mozilla.org/en-US/docs/User:fusionchess\\n|*|\\n|*|  This framework is released under the GNU Lesser General Public License, version 3 or later.\\n|*|  http://www.gnu.org/licenses/lgpl-3.0.html\\n|*|\\n\\\\*/\\n\\nfunction StringView (vInput, sEncoding /* optional (default: UTF-8) */, nOffset /* optional */, nLength /* optional */) {\\n\\n  var fTAView, aWhole, aRaw, fPutOutptCode, fGetOutptChrSize, nInptLen, nStartIdx = isFinite(nOffset) ? nOffset : 0, nTranscrType = 15;\\n\\n  if (sEncoding) { this.encoding = sEncoding.toString(); }\\n\\n  encSwitch: switch (this.encoding) {\\n    case \\\"UTF-8\\\":\\n      fPutOutptCode = StringView.putUTF8CharCode;\\n      fGetOutptChrSize = StringView.getUTF8CharLength;\\n      fTAView = Uint8Array;\\n      break encSwitch;\\n    case \\\"UTF-16\\\":\\n      fPutOutptCode = StringView.putUTF16CharCode;\\n      fGetOutptChrSize = StringView.getUTF16CharLength;\\n      fTAView = Uint16Array;\\n      break encSwitch;\\n    case \\\"UTF-32\\\":\\n      fTAView = Uint32Array;\\n      nTranscrType &= 14;\\n      break encSwitch;\\n    default:\\n      /* case \\\"ASCII\\\", or case \\\"BinaryString\\\" or unknown cases */\\n      fTAView = Uint8Array;\\n      nTranscrType &= 14;\\n  }\\n\\n  typeSwitch: switch (typeof vInput) {\\n    case \\\"string\\\":\\n      /* the input argument is a primitive string: a new buffer will be created. */\\n      nTranscrType &= 7;\\n      break typeSwitch;\\n    case \\\"object\\\":\\n      classSwitch: switch (vInput.constructor) {\\n        case StringView:\\n          /* the input argument is a stringView: a new buffer will be created. */\\n          nTranscrType &= 3;\\n          break typeSwitch;\\n        case String:\\n          /* the input argument is an objectified string: a new buffer will be created. */\\n          nTranscrType &= 7;\\n          break typeSwitch;\\n        case ArrayBuffer:\\n          /* the input argument is an arrayBuffer: the buffer will be shared. */\\n          aWhole = new fTAView(vInput);\\n          nInptLen = this.encoding === \\\"UTF-32\\\" ?\\n              vInput.byteLength >>> 2\\n            : this.encoding === \\\"UTF-16\\\" ?\\n              vInput.byteLength >>> 1\\n            :\\n              vInput.byteLength;\\n          aRaw = nStartIdx === 0 && (!isFinite(nLength) || nLength === nInptLen) ?\\n            aWhole\\n            : new fTAView(vInput, nStartIdx, !isFinite(nLength) ? nInptLen - nStartIdx : nLength);\\n\\n          break typeSwitch;\\n        case Uint32Array:\\n        case Uint16Array:\\n        case Uint8Array:\\n          /* the input argument is a typedArray: the buffer, and possibly the array itself, will be shared. */\\n          fTAView = vInput.constructor;\\n          nInptLen = vInput.length;\\n          aWhole = vInput.byteOffset === 0 && vInput.length === (\\n            fTAView === Uint32Array ?\\n              vInput.buffer.byteLength >>> 2\\n            : fTAView === Uint16Array ?\\n              vInput.buffer.byteLength >>> 1\\n            :\\n              vInput.buffer.byteLength\\n          ) ? vInput : new fTAView(vInput.buffer);\\n          aRaw = nStartIdx === 0 && (!isFinite(nLength) || nLength === nInptLen) ?\\n            vInput\\n            : vInput.subarray(nStartIdx, isFinite(nLength) ? nStartIdx + nLength : nInptLen);\\n\\n          break typeSwitch;\\n        default:\\n          /* the input argument is an array or another serializable object: a new typedArray will be created. */\\n          aWhole = new fTAView(vInput);\\n          nInptLen = aWhole.length;\\n          aRaw = nStartIdx === 0 && (!isFinite(nLength) || nLength === nInptLen) ?\\n            aWhole\\n            : aWhole.subarray(nStartIdx, isFinite(nLength) ? nStartIdx + nLength : nInptLen);\\n      }\\n      break typeSwitch;\\n    default:\\n      /* the input argument is a number, a boolean or a function: a new typedArray will be created. */\\n      aWhole = aRaw = new fTAView(Number(vInput) || 0);\\n\\n  }\\n\\n  if (nTranscrType < 8) {\\n\\n    var vSource, nOutptLen, nCharStart, nCharEnd, nEndIdx, fGetInptChrSize, fGetInptChrCode;\\n\\n    if (nTranscrType & 4) { /* input is string */\\n\\n      vSource = vInput;\\n      nOutptLen = nInptLen = vSource.length;\\n      nTranscrType ^= this.encoding === \\\"UTF-32\\\" ? 0 : 2;\\n      /* ...or...: nTranscrType ^= Number(this.encoding !== \\\"UTF-32\\\") << 1; */\\n      nStartIdx = nCharStart = nOffset ? Math.max((nOutptLen + nOffset) % nOutptLen, 0) : 0;\\n      nEndIdx = nCharEnd = (Number.isInteger(nLength) ? Math.min(Math.max(nLength, 0) + nStartIdx, nOutptLen) : nOutptLen) - 1;\\n\\n    } else { /* input is stringView */\\n\\n      vSource = vInput.rawData;\\n      nInptLen = vInput.makeIndex();\\n      nStartIdx = nCharStart = nOffset ? Math.max((nInptLen + nOffset) % nInptLen, 0) : 0;\\n      nOutptLen = Number.isInteger(nLength) ? Math.min(Math.max(nLength, 0), nInptLen - nCharStart) : nInptLen;\\n      nEndIdx = nCharEnd = nOutptLen + nCharStart;\\n\\n      if (vInput.encoding === \\\"UTF-8\\\") {\\n        fGetInptChrSize = StringView.getUTF8CharLength;\\n        fGetInptChrCode = StringView.loadUTF8CharCode;\\n      } else if (vInput.encoding === \\\"UTF-16\\\") {\\n        fGetInptChrSize = StringView.getUTF16CharLength;\\n        fGetInptChrCode = StringView.loadUTF16CharCode;\\n      } else {\\n        nTranscrType &= 1;\\n      }\\n\\n    }\\n\\n    if (nOutptLen === 0 || nTranscrType < 4 && vSource.encoding === this.encoding && nCharStart === 0 && nOutptLen === nInptLen) {\\n\\n      /* the encoding is the same, the length too and the offset is 0... or the input is empty! */\\n\\n      nTranscrType = 7;\\n\\n    }\\n\\n    conversionSwitch: switch (nTranscrType) {\\n\\n      case 0:\\n\\n      /* both the source and the new StringView have a fixed-length encoding... */\\n\\n        aWhole = new fTAView(nOutptLen);\\n        for (var nOutptIdx = 0; nOutptIdx < nOutptLen; aWhole[nOutptIdx] = vSource[nStartIdx + nOutptIdx++]);\\n        break conversionSwitch;\\n\\n      case 1:\\n\\n      /* the source has a fixed-length encoding but the new StringView has a variable-length encoding... */\\n\\n        /* mapping... */\\n\\n        nOutptLen = 0;\\n\\n        for (var nInptIdx = nStartIdx; nInptIdx < nEndIdx; nInptIdx++) {\\n          nOutptLen += fGetOutptChrSize(vSource[nInptIdx]);\\n        }\\n\\n        aWhole = new fTAView(nOutptLen);\\n\\n        /* transcription of the source... */\\n\\n        for (var nInptIdx = nStartIdx, nOutptIdx = 0; nOutptIdx < nOutptLen; nInptIdx++) {\\n          nOutptIdx = fPutOutptCode(aWhole, vSource[nInptIdx], nOutptIdx);\\n        }\\n\\n        break conversionSwitch;\\n\\n      case 2:\\n\\n      /* the source has a variable-length encoding but the new StringView has a fixed-length encoding... */\\n\\n        /* mapping... */\\n\\n        nStartIdx = 0;\\n\\n        var nChrCode;\\n\\n        for (nChrIdx = 0; nChrIdx < nCharStart; nChrIdx++) {\\n          nChrCode = fGetInptChrCode(vSource, nStartIdx);\\n          nStartIdx += fGetInptChrSize(nChrCode);\\n        }\\n\\n        aWhole = new fTAView(nOutptLen);\\n\\n        /* transcription of the source... */\\n\\n        for (var nInptIdx = nStartIdx, nOutptIdx = 0; nOutptIdx < nOutptLen; nInptIdx += fGetInptChrSize(nChrCode), nOutptIdx++) {\\n          nChrCode = fGetInptChrCode(vSource, nInptIdx);\\n          aWhole[nOutptIdx] = nChrCode;\\n        }\\n\\n        break conversionSwitch;\\n\\n      case 3:\\n\\n      /* both the source and the new StringView have a variable-length encoding... */\\n\\n        /* mapping... */\\n\\n        nOutptLen = 0;\\n\\n        var nChrCode;\\n\\n        for (var nChrIdx = 0, nInptIdx = 0; nChrIdx < nCharEnd; nInptIdx += fGetInptChrSize(nChrCode)) {\\n          nChrCode = fGetInptChrCode(vSource, nInptIdx);\\n          if (nChrIdx === nCharStart) { nStartIdx = nInptIdx; }\\n          if (++nChrIdx > nCharStart) { nOutptLen += fGetOutptChrSize(nChrCode); }\\n        }\\n\\n        aWhole = new fTAView(nOutptLen);\\n\\n        /* transcription... */\\n\\n        for (var nInptIdx = nStartIdx, nOutptIdx = 0; nOutptIdx < nOutptLen; nInptIdx += fGetInptChrSize(nChrCode)) {\\n          nChrCode = fGetInptChrCode(vSource, nInptIdx);\\n          nOutptIdx = fPutOutptCode(aWhole, nChrCode, nOutptIdx);\\n        }\\n\\n        break conversionSwitch;\\n\\n      case 4:\\n\\n      /* DOMString to ASCII or BinaryString or other unknown encodings */\\n\\n        aWhole = new fTAView(nOutptLen);\\n\\n        /* transcription... */\\n\\n        for (var nIdx = 0; nIdx < nOutptLen; nIdx++) {\\n          aWhole[nIdx] = vSource.charCodeAt(nIdx) & 0xff;\\n        }\\n\\n        break conversionSwitch;\\n\\n      case 5:\\n\\n      /* DOMString to UTF-8 or to UTF-16 */\\n\\n        /* mapping... */\\n\\n        nOutptLen = 0;\\n\\n        for (var nMapIdx = 0; nMapIdx < nInptLen; nMapIdx++) {\\n          if (nMapIdx === nCharStart) { nStartIdx = nOutptLen; }\\n          nOutptLen += fGetOutptChrSize(vSource.charCodeAt(nMapIdx));\\n          if (nMapIdx === nCharEnd) { nEndIdx = nOutptLen; }\\n        }\\n\\n        aWhole = new fTAView(nOutptLen);\\n\\n        /* transcription... */\\n\\n        for (var nOutptIdx = 0, nChrIdx = 0; nOutptIdx < nOutptLen; nChrIdx++) {\\n          nOutptIdx = fPutOutptCode(aWhole, vSource.charCodeAt(nChrIdx), nOutptIdx);\\n        }\\n\\n        break conversionSwitch;\\n\\n      case 6:\\n\\n      /* DOMString to UTF-32 */\\n\\n        aWhole = new fTAView(nOutptLen);\\n\\n        /* transcription... */\\n\\n        for (var nIdx = 0; nIdx < nOutptLen; nIdx++) {\\n          aWhole[nIdx] = vSource.charCodeAt(nIdx);\\n        }\\n\\n        break conversionSwitch;\\n\\n      case 7:\\n\\n        aWhole = new fTAView(nOutptLen ? vSource : 0);\\n        break conversionSwitch;\\n\\n    }\\n\\n    aRaw = nTranscrType > 3 && (nStartIdx > 0 || nEndIdx < aWhole.length - 1) ? aWhole.subarray(nStartIdx, nEndIdx) : aWhole;\\n\\n  }\\n\\n  this.buffer = aWhole.buffer;\\n  this.bufferView = aWhole;\\n  this.rawData = aRaw;\\n\\n  Object.freeze(this);\\n\\n}\\n\\n/* CONSTRUCTOR'S METHODS */\\n\\nStringView.loadUTF8CharCode = function (aChars, nIdx) {\\n\\n  var nLen = aChars.length, nPart = aChars[nIdx];\\n\\n  return nPart > 251 && nPart < 254 && nIdx + 5 < nLen ?\\n      /* (nPart - 252 << 30) may be not safe in ECMAScript! So...: */\\n      /* six bytes */ (nPart - 252) * 1073741824 + (aChars[nIdx + 1] - 128 << 24) + (aChars[nIdx + 2] - 128 << 18) + (aChars[nIdx + 3] - 128 << 12) + (aChars[nIdx + 4] - 128 << 6) + aChars[nIdx + 5] - 128\\n    : nPart > 247 && nPart < 252 && nIdx + 4 < nLen ?\\n      /* five bytes */ (nPart - 248 << 24) + (aChars[nIdx + 1] - 128 << 18) + (aChars[nIdx + 2] - 128 << 12) + (aChars[nIdx + 3] - 128 << 6) + aChars[nIdx + 4] - 128\\n    : nPart > 239 && nPart < 248 && nIdx + 3 < nLen ?\\n      /* four bytes */(nPart - 240 << 18) + (aChars[nIdx + 1] - 128 << 12) + (aChars[nIdx + 2] - 128 << 6) + aChars[nIdx + 3] - 128\\n    : nPart > 223 && nPart < 240 && nIdx + 2 < nLen ?\\n      /* three bytes */ (nPart - 224 << 12) + (aChars[nIdx + 1] - 128 << 6) + aChars[nIdx + 2] - 128\\n    : nPart > 191 && nPart < 224 && nIdx + 1 < nLen ?\\n      /* two bytes */ (nPart - 192 << 6) + aChars[nIdx + 1] - 128\\n    :\\n      /* one byte */ nPart;\\n\\n};\\n\\nStringView.putUTF8CharCode = function (aTarget, nChar, nPutAt) {\\n\\n  var nIdx = nPutAt;\\n\\n  if (nChar < 0x80 /* 128 */) {\\n    /* one byte */\\n    aTarget[nIdx++] = nChar;\\n  } else if (nChar < 0x800 /* 2048 */) {\\n    /* two bytes */\\n    aTarget[nIdx++] = 0xc0 /* 192 */ + (nChar >>> 6);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + (nChar & 0x3f /* 63 */);\\n  } else if (nChar < 0x10000 /* 65536 */) {\\n    /* three bytes */\\n    aTarget[nIdx++] = 0xe0 /* 224 */ + (nChar >>> 12);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar >>> 6) & 0x3f /* 63 */);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + (nChar & 0x3f /* 63 */);\\n  } else if (nChar < 0x200000 /* 2097152 */) {\\n    /* four bytes */\\n    aTarget[nIdx++] = 0xf0 /* 240 */ + (nChar >>> 18);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar >>> 12) & 0x3f /* 63 */);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar >>> 6) & 0x3f /* 63 */);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + (nChar & 0x3f /* 63 */);\\n  } else if (nChar < 0x4000000 /* 67108864 */) {\\n    /* five bytes */\\n    aTarget[nIdx++] = 0xf8 /* 248 */ + (nChar >>> 24);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar >>> 18) & 0x3f /* 63 */);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar >>> 12) & 0x3f /* 63 */);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar >>> 6) & 0x3f /* 63 */);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + (nChar & 0x3f /* 63 */);\\n  } else /* if (nChar <= 0x7fffffff) */ { /* 2147483647 */\\n    /* six bytes */\\n    aTarget[nIdx++] = 0xfc /* 252 */ + /* (nChar >>> 30) may be not safe in ECMAScript! So...: */ (nChar / 1073741824);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar >>> 24) & 0x3f /* 63 */);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar >>> 18) & 0x3f /* 63 */);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar >>> 12) & 0x3f /* 63 */);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar >>> 6) & 0x3f /* 63 */);\\n    aTarget[nIdx++] = 0x80 /* 128 */ + (nChar & 0x3f /* 63 */);\\n  }\\n\\n  return nIdx;\\n\\n};\\n\\nStringView.getUTF8CharLength = function (nChar) {\\n  return nChar < 0x80 ? 1 : nChar < 0x800 ? 2 : nChar < 0x10000 ? 3 : nChar < 0x200000 ? 4 : nChar < 0x4000000 ? 5 : 6;\\n};\\n\\nStringView.loadUTF16CharCode = function (aChars, nIdx) {\\n\\n  /* UTF-16 to DOMString decoding algorithm */\\n  var nFrstChr = aChars[nIdx];\\n\\n  return nFrstChr > 0xD7BF /* 55231 */ && nIdx + 1 < aChars.length ?\\n    (nFrstChr - 0xD800 /* 55296 */ << 10) + aChars[nIdx + 1] + 0x2400 /* 9216 */\\n    : nFrstChr;\\n\\n};\\n\\nStringView.putUTF16CharCode = function (aTarget, nChar, nPutAt) {\\n\\n  var nIdx = nPutAt;\\n\\n  if (nChar < 0x10000 /* 65536 */) {\\n    /* one element */\\n    aTarget[nIdx++] = nChar;\\n  } else {\\n    /* two elements */\\n    aTarget[nIdx++] = 0xD7C0 /* 55232 */ + (nChar >>> 10);\\n    aTarget[nIdx++] = 0xDC00 /* 56320 */ + (nChar & 0x3FF /* 1023 */);\\n  }\\n\\n  return nIdx;\\n\\n};\\n\\nStringView.getUTF16CharLength = function (nChar) {\\n  return nChar < 0x10000 ? 1 : 2;\\n};\\n\\n/* Array of bytes to base64 string decoding */\\n\\nStringView.b64ToUint6 = function (nChr) {\\n\\n  return nChr > 64 && nChr < 91 ?\\n      nChr - 65\\n    : nChr > 96 && nChr < 123 ?\\n      nChr - 71\\n    : nChr > 47 && nChr < 58 ?\\n      nChr + 4\\n    : nChr === 43 ?\\n      62\\n    : nChr === 47 ?\\n      63\\n    :\\n      0;\\n\\n};\\n\\nStringView.uint6ToB64 = function (nUint6) {\\n\\n  return nUint6 < 26 ?\\n      nUint6 + 65\\n    : nUint6 < 52 ?\\n      nUint6 + 71\\n    : nUint6 < 62 ?\\n      nUint6 - 4\\n    : nUint6 === 62 ?\\n      43\\n    : nUint6 === 63 ?\\n      47\\n    :\\n      65;\\n\\n};\\n\\n/* Base64 string to array encoding */\\n\\nStringView.bytesToBase64 = function (aBytes) {\\n\\n  var sB64Enc = \\\"\\\";\\n\\n  for (var nMod3, nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\\n    nMod3 = nIdx % 3;\\n    if (nIdx > 0 && (nIdx * 4 / 3) % 76 === 0) { sB64Enc += \\\"\\\\r\\\\n\\\"; }\\n    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);\\n    if (nMod3 === 2 || aBytes.length - nIdx === 1) {\\n      sB64Enc += String.fromCharCode(StringView.uint6ToB64(nUint24 >>> 18 & 63), StringView.uint6ToB64(nUint24 >>> 12 & 63), StringView.uint6ToB64(nUint24 >>> 6 & 63), StringView.uint6ToB64(nUint24 & 63));\\n      nUint24 = 0;\\n    }\\n  }\\n\\n  return sB64Enc.replace(/A(?=A$|$)/g, \\\"=\\\");\\n\\n};\\n\\n\\nStringView.base64ToBytes = function (sBase64, nBlockBytes) {\\n\\n  var\\n    sB64Enc = sBase64.replace(/[^A-Za-z0-9\\\\+\\\\/]/g, \\\"\\\"), nInLen = sB64Enc.length,\\n    nOutLen = nBlockBytes ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockBytes) * nBlockBytes : nInLen * 3 + 1 >>> 2, aBytes = new Uint8Array(nOutLen);\\n\\n  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\\n    nMod4 = nInIdx & 3;\\n    nUint24 |= StringView.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;\\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\\n        aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\\n      }\\n      nUint24 = 0;\\n    }\\n  }\\n\\n  return aBytes;\\n\\n};\\n\\nStringView.makeFromBase64 = function (sB64Inpt, sEncoding, nByteOffset, nLength) {\\n\\n  return new StringView(sEncoding === \\\"UTF-16\\\" || sEncoding === \\\"UTF-32\\\" ? StringView.base64ToBytes(sB64Inpt, sEncoding === \\\"UTF-16\\\" ? 2 : 4).buffer : StringView.base64ToBytes(sB64Inpt), sEncoding, nByteOffset, nLength);\\n\\n};\\n\\n/* DEFAULT VALUES */\\n\\nStringView.prototype.encoding = \\\"UTF-8\\\"; /* Default encoding... */\\n\\n/* INSTANCES' METHODS */\\n\\nStringView.prototype.makeIndex = function (nChrLength, nStartFrom) {\\n\\n  var\\n\\n    aTarget = this.rawData, nChrEnd, nRawLength = aTarget.length,\\n    nStartIdx = nStartFrom || 0, nIdxEnd = nStartIdx, nStopAtChr = isNaN(nChrLength) ? Infinity : nChrLength;\\n\\n  if (nChrLength + 1 > aTarget.length) { throw new RangeError(\\\"StringView.prototype.makeIndex - The offset can\\\\'t be major than the length of the array - 1.\\\"); }\\n\\n  switch (this.encoding) {\\n\\n    case \\\"UTF-8\\\":\\n\\n      var nPart;\\n\\n      for (nChrEnd = 0; nIdxEnd < nRawLength && nChrEnd < nStopAtChr; nChrEnd++) {\\n        nPart = aTarget[nIdxEnd];\\n        nIdxEnd += nPart > 251 && nPart < 254 && nIdxEnd + 5 < nRawLength ? 6\\n          : nPart > 247 && nPart < 252 && nIdxEnd + 4 < nRawLength ? 5\\n          : nPart > 239 && nPart < 248 && nIdxEnd + 3 < nRawLength ? 4\\n          : nPart > 223 && nPart < 240 && nIdxEnd + 2 < nRawLength ? 3\\n          : nPart > 191 && nPart < 224 && nIdxEnd + 1 < nRawLength ? 2\\n          : 1;\\n      }\\n\\n      break;\\n\\n    case \\\"UTF-16\\\":\\n\\n      for (nChrEnd = nStartIdx; nIdxEnd < nRawLength && nChrEnd < nStopAtChr; nChrEnd++) {\\n        nIdxEnd += aTarget[nIdxEnd] > 0xD7BF /* 55231 */ && nIdxEnd + 1 < aTarget.length ? 2 : 1;\\n      }\\n\\n      break;\\n\\n    default:\\n\\n      nIdxEnd = nChrEnd = isFinite(nChrLength) ? nChrLength : nRawLength - 1;\\n\\n  }\\n\\n  if (nChrLength) { return nIdxEnd; }\\n\\n  return nChrEnd;\\n\\n};\\n\\nStringView.prototype.toBase64 = function (bWholeBuffer) {\\n\\n  return StringView.bytesToBase64(\\n    bWholeBuffer ?\\n      (\\n        this.bufferView.constructor === Uint8Array ?\\n          this.bufferView\\n        :\\n          new Uint8Array(this.buffer)\\n      )\\n    : this.rawData.constructor === Uint8Array ?\\n      this.rawData\\n    :\\n      new Uint8Array(this.buffer, this.rawData.byteOffset, this.rawData.length << (this.rawData.constructor === Uint16Array ? 1 : 2))\\n    );\\n\\n};\\n\\nStringView.prototype.subview = function (nCharOffset /* optional */, nCharLength /* optional */) {\\n\\n  var\\n\\n    nChrLen, nCharStart, nStrLen, bVariableLen = this.encoding === \\\"UTF-8\\\" || this.encoding === \\\"UTF-16\\\",\\n    nStartOffset = nCharOffset, nStringLength, nRawLen = this.rawData.length;\\n\\n  if (nRawLen === 0) {\\n    return new StringView(this.buffer, this.encoding);\\n  }\\n\\n  nStringLength = bVariableLen ? this.makeIndex() : nRawLen;\\n  nCharStart = nCharOffset ? Math.max((nStringLength + nCharOffset) % nStringLength, 0) : 0;\\n  nStrLen = Number.isInteger(nCharLength) ? Math.max(nCharLength, 0) + nCharStart > nStringLength ? nStringLength - nCharStart : nCharLength : nStringLength;\\n\\n  if (nCharStart === 0 && nStrLen === nStringLength) { return this; }\\n\\n  if (bVariableLen) {\\n    nStartOffset = this.makeIndex(nCharStart);\\n    nChrLen = this.makeIndex(nStrLen, nStartOffset) - nStartOffset;\\n  } else {\\n    nStartOffset = nCharStart;\\n    nChrLen = nStrLen - nCharStart;\\n  }\\n\\n  if (this.encoding === \\\"UTF-16\\\") {\\n    nStartOffset <<= 1;\\n  } else if (this.encoding === \\\"UTF-32\\\") {\\n    nStartOffset <<= 2;\\n  }\\n\\n  return new StringView(this.buffer, this.encoding, nStartOffset, nChrLen);\\n\\n};\\n\\nStringView.prototype.forEachChar = function (fCallback, oThat, nChrOffset, nChrLen) {\\n\\n  var aSource = this.rawData, nRawEnd, nRawIdx;\\n\\n  if (this.encoding === \\\"UTF-8\\\" || this.encoding === \\\"UTF-16\\\") {\\n\\n    var fGetInptChrSize, fGetInptChrCode;\\n\\n    if (this.encoding === \\\"UTF-8\\\") {\\n      fGetInptChrSize = StringView.getUTF8CharLength;\\n      fGetInptChrCode = StringView.loadUTF8CharCode;\\n    } else if (this.encoding === \\\"UTF-16\\\") {\\n      fGetInptChrSize = StringView.getUTF16CharLength;\\n      fGetInptChrCode = StringView.loadUTF16CharCode;\\n    }\\n\\n    nRawIdx = isFinite(nChrOffset) ? this.makeIndex(nChrOffset) : 0;\\n    nRawEnd = isFinite(nChrLen) ? this.makeIndex(nChrLen, nRawIdx) : aSource.length;\\n\\n    for (var nChrCode, nChrIdx = 0; nRawIdx < nRawEnd; nChrIdx++) {\\n      nChrCode = fGetInptChrCode(aSource, nRawIdx);\\n      fCallback.call(oThat || null, nChrCode, nChrIdx, nRawIdx, aSource);\\n      nRawIdx += fGetInptChrSize(nChrCode);\\n    }\\n\\n  } else {\\n\\n    nRawIdx = isFinite(nChrOffset) ? nChrOffset : 0;\\n    nRawEnd = isFinite(nChrLen) ? nChrLen + nRawIdx : aSource.length;\\n\\n    for (nRawIdx; nRawIdx < nRawEnd; nRawIdx++) {\\n      fCallback.call(oThat || null, aSource[nRawIdx], nRawIdx, nRawIdx, aSource);\\n    }\\n\\n  }\\n\\n};\\n\\nStringView.prototype.valueOf = StringView.prototype.toString = function () {\\n\\n  if (this.encoding !== \\\"UTF-8\\\" && this.encoding !== \\\"UTF-16\\\") {\\n    /* ASCII, UTF-32 or BinaryString to DOMString */\\n    return String.fromCharCode.apply(null, this.rawData);\\n  }\\n\\n  var fGetCode, fGetIncr, sView = \\\"\\\";\\n\\n  if (this.encoding === \\\"UTF-8\\\") {\\n    fGetIncr = StringView.getUTF8CharLength;\\n    fGetCode = StringView.loadUTF8CharCode;\\n  } else if (this.encoding === \\\"UTF-16\\\") {\\n    fGetIncr = StringView.getUTF16CharLength;\\n    fGetCode = StringView.loadUTF16CharCode;\\n  }\\n\\n  for (var nChr, nLen = this.rawData.length, nIdx = 0; nIdx < nLen; nIdx += fGetIncr(nChr)) {\\n    nChr = fGetCode(this.rawData, nIdx);\\n    sView += String.fromCharCode(nChr);\\n  }\\n\\n  return sView;\\n\\n};\\nexports.StringView = StringView;})();\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/tools.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/tools.js\",\n            \"module-type\": \"library\",\n            \"text\": \"// Tools for playing more easily with Three.js library.\\n//\\n\\n(function() {\\n\\n  var Tools = {};\\n\\n  Tools.Stats = require(\\\"$:/plugins/rboue/Three.js/Lib/stats-min.js\\\").Stats;\\n  Tools.dat = require(\\\"$:/plugins/rboue/Three.js/Lib/dat-gui-min.js\\\").dat;\\n\\n  // Resolve PATH\\n  Tools.resolvePath = function(path) {\\n    if (!tiddlyWiki) return null;\\n    return(tiddlyWiki.resolvePath(path));\\n  };\\n\\n  // Debug tools\\n  //\\n  Tools.log = function() {\\n    this.flagActive = true;\\n  };\\n  Tools.log.prototype = {\\n    start: function() {this.flagActive = true;},\\n    stop: function() {this.flagActive = false;},\\n    log: function(mess, flagNoLog, fonc) {\\n      if (!this.flagActive || flagNoLog) return;\\n      console.log((fonc ? fonc+\\\": \\\" : \\\"\\\")+mess);\\n    },\\n    logPoint: function(x,y) {return \\\"(\\\"+x+\\\",\\\"+y+\\\")\\\";}\\n  };\\n\\n  // Animation object\\n  //\\n  Tools.Animation = function(node, renderFunc, flagStartStopOnClick, flagLog) {\\n    var func = \\\"Tools.Animation\\\";\\n    this.flagNoLog = !flagLog;\\n    this.node = node; // Container DOM node\\n    this.renderFunc = renderFunc; // rendering\\n    this.idAnimation = null; // Internal id used by cancelAnimationFrame() to stop animation\\n    this.flagAnimation = true;\\n\\n    this.nodeId = this.node.getAttribute(\\\"id\\\");\\n    if (!this.nodeId)\\n      alert(\\\"Tools.Animation error: DOM node has no \\\\\\\"id\\\\\\\" attribute. Can't stop animation !\\\");\\n\\n    // Start/Stop on click\\n    if (flagStartStopOnClick) {\\n      var self = this;\\n      this.node.addEventListener(\\\"mousedown\\\", function(event) {\\n        func = \\\"Tools.Animation.onMouseDown\\\";\\n        self.startStop();\\n      }, false);\\n    }\\n  };\\n  Tools.Animation.prototype = {\\n    start: function() {\\n      var func = \\\"Tools.Animation.start\\\";\\n      hack.log(\\\"\\\", this.flagNoLog, func);\\n      this.flagAnimation = true;\\n      var self = this;\\n      var animate = function() {\\n        var func = \\\"Tools.Animation.start.animate\\\";\\n        // Cancel animation when tiddler has been closed (i.e. widget's DOM node disappears, cf.\\n        // Jeremy Ruston 14/12/07 in TiddlyWikiDev group).\\n        if (!document.getElementById(self.nodeId)) {\\n          hack.log(\\\"animation canceled: tiddler closes\\\", self.flagNoLog, func);\\n          self.stop();\\n          return;\\n        }\\n        self.idAnimation = window.requestAnimationFrame(animate);\\n        self.renderFunc();\\n      };\\n      animate();\\n    },\\n    isClosed: function() {\\n      var func = \\\"Tools.Animation.isClosed\\\";\\n      // Cancel animation when tiddler has been closed (i.e. widget's DOM node disappears, cf.\\n      // Jeremy Ruston 14/12/07 in TiddlyWikiDev group).\\n      if (this.nodeId && ! document.getElementById(this.nodeId)) {\\n        hack.log(\\\"animation canceled: tiddler closes\\\", this.flagNoLog, func);\\n        this.stop();\\n        return true;\\n      }\\n      return false;\\n    },\\n    stop: function() {\\n      var func = \\\"Tools.Animation.stop\\\";\\n      hack.log(\\\"\\\", this.flagNoLog, func);\\n      window.cancelAnimationFrame(this.idAnimation);\\n      this.flagAnimation = false;\\n    },\\n    startStop: function() {\\n      if (this.flagAnimation)\\n        this.stop();\\n      else\\n        this.start();\\n    }\\n  };\\n\\n  // Toolbar container for stats and menu\\n  //\\n  Tools.toolbarId = \\\"toolbar\\\"; // id of toolbar  \\n  Tools.toolbarGet = function(node) {\\n    var nodeId = node.getAttribute(\\\"id\\\");\\n    if (!nodeId) return null;\\n    var toolbarId = nodeId + \\\"-\\\" + Tools.toolbarId;\\n    var toolbar = document.getElementById(toolbarId);\\n    if (!toolbar) {\\n      var toolbar = document.createElement(\\\"div\\\");\\n      toolbar.setAttribute(\\\"id\\\", toolbarId);\\n      toolbar.style.position = \\\"relative\\\";\\n      toolbar.style.top = \\\"\\\" + (-node.offsetHeight - 5) + \\\"px\\\";\\n      toolbar.style.zIndex = 10;\\n      node.appendChild(toolbar);\\n    }\\n    return toolbar;\\n  };\\n\\n  // Statistic viewer at upper left corner of widget DOM <node>\\n  //\\n  Tools.addStats = function(node) {\\n    var stats = new Tools.Stats();\\n    stats.domElement.style.position = \\\"relative\\\";\\n    stats.domElement.style.display = \\\"inline-block\\\";\\n    stats.domElement.style.verticalAlign = \\\"top\\\";\\n\\n    // Install stats in toolbar\\n    var toolbar = Tools.toolbarGet(node);\\n    if (toolbar.firstChild)\\n      toolbar.insertBefore(stats.domElement, toolbar.firstChild);\\n    else\\n      toolbar.appendChild(stats.domElement);\\n    return stats;\\n  };\\n\\n  // GUI menu at upper right corner of widget DOM <node> \\n  //\\n  Tools.Gui = function(node, flagOpen) {\\n    this.node = node;\\n    this.gui = new Tools.dat.GUI({autoPlace: false});\\n    this.gui.domElement.style.position = \\\"relative\\\";\\n    this.gui.domElement.style.display = \\\"inline-block\\\";\\n    this.gui.domElement.style.verticalAlign = \\\"top\\\";\\n    this.gui.domElement.style.zIndex = 20;\\n    //this.onTiddlerRefresh();\\n    if (flagOpen)\\n      this.gui.open();\\n    else\\n      this.gui.close();\\n\\n    // Install menu in toolbar\\n    this.toolbar = Tools.toolbarGet(this.node);\\n    this.toolbar.appendChild(this.gui.domElement);\\n  };\\n  Tools.Gui.prototype = {\\n    get: function() {\\n      return this.gui;\\n    },\\n    onTiddlerRefresh: function() {\\n      var offset = this.toolbar.childNodes.length >= 2 ? this.toolbar.firstChild.offsetWidth : 0;\\n      var left = this.toolbar.offsetWidth - offset < 245 ? 0 : this.toolbar.offsetWidth - offset - 245;\\n      this.gui.domElement.style.left = \\\"\\\" + left + \\\"px\\\";\\n    }\\n  };\\n\\n  // Export renderer's view to tiddler\\n  // Parameters :\\n  //   <renderer> : renderer.\\n  //   <tiddlerTitle> : title of the target tiddler with respect to the filesystem mode configuration.\\n  //   <type> : type of tiddler : \\\"image/png\\\" (default), \\\"image/jpeg\\\" or \\\"image/svg+xml\\\".\\n  //   <flagOverwrite> : if true, overwrite existing tiddler without asking.\\n  // Saves renderer's wiew as a tiddler with required type.\\n  //\\n  Tools.exportView = function(renderer, tiddlerTitle, type, flagOverwrite) {\\n    var func = \\\"Tools.exportView\\\";\\n    if (!renderer.domElement) return;\\n    var tag = renderer.domElement.tagName.toUpperCase();\\n    if ((((type == \\\"image/png\\\") || (type == \\\"image/jpeg\\\")) && (tag != \\\"CANVAS\\\")) ||\\n        ((type == \\\"image/svg+xml\\\") && (tag != \\\"SVG\\\"))) {\\n      console.error(func+\\\": bad tiddler type : \\\"+type)\\n      return;\\n    }\\n    TiddlyWiki.exportToTiddler(renderer.domElement, \\\"tw:\\\"+tiddlerTitle, type, flagOverwrite);\\n  };\\n\\n  // Execute code when a condition is fulfilled\\n  // Parameters :\\n  //   <funcTest> : returns true when the condition is fulfilled, false otherwise.\\n  //   <funcExec> : code to execute.\\n  //   <periodicity> : periodicity of the active waiting mechanism (250 ms by default).\\n  //\\n  Tools.wait = function(funcTest, funcExec, periodicity) {\\n    var func = \\\"Tools.wait\\\", flagNoLog = true;\\n    var period = 250; // periodicity in ms\\n    if (periodicity) period = periodicity;\\n    var timerId = null;\\n    var doWait = function() {\\n      var func = \\\"Tools.wait/doWait\\\";\\n      if (!funcTest()) return;\\n\\n      // Test OK\\n      hack.log(\\\"test OK !\\\", flagNoLog, func);\\n      clearInterval(timerId);\\n      funcExec();\\n    };\\n    timerId = setInterval(doWait, period);\\n  };\\n\\n  exports.Tools = Tools;\\n})();\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/stats-min.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/stats-min.js\",\n            \"module-type\": \"library\",\n            \"text\": \"(function(){\\n// stats.js - http://github.com/mrdoob/stats.js\\nvar Stats=function(){var l=Date.now(),m=l,g=0,n=Infinity,o=0,h=0,p=Infinity,q=0,r=0,s=0,f=document.createElement(\\\"div\\\");f.id=\\\"stats\\\";f.addEventListener(\\\"mousedown\\\",function(b){b.preventDefault();t(++s%2)},!1);f.style.cssText=\\\"width:80px;opacity:0.9;cursor:pointer\\\";var a=document.createElement(\\\"div\\\");a.id=\\\"fps\\\";a.style.cssText=\\\"padding:0 0 3px 3px;text-align:left;background-color:#002\\\";f.appendChild(a);var i=document.createElement(\\\"div\\\");i.id=\\\"fpsText\\\";i.style.cssText=\\\"color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px\\\";\\ni.innerHTML=\\\"FPS\\\";a.appendChild(i);var c=document.createElement(\\\"div\\\");c.id=\\\"fpsGraph\\\";c.style.cssText=\\\"position:relative;width:74px;height:30px;background-color:#0ff\\\";for(a.appendChild(c);74>c.children.length;){var j=document.createElement(\\\"span\\\");j.style.cssText=\\\"width:1px;height:30px;float:left;background-color:#113\\\";c.appendChild(j)}var d=document.createElement(\\\"div\\\");d.id=\\\"ms\\\";d.style.cssText=\\\"padding:0 0 3px 3px;text-align:left;background-color:#020;display:none\\\";f.appendChild(d);var k=document.createElement(\\\"div\\\");\\nk.id=\\\"msText\\\";k.style.cssText=\\\"color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px\\\";k.innerHTML=\\\"MS\\\";d.appendChild(k);var e=document.createElement(\\\"div\\\");e.id=\\\"msGraph\\\";e.style.cssText=\\\"position:relative;width:74px;height:30px;background-color:#0f0\\\";for(d.appendChild(e);74>e.children.length;)j=document.createElement(\\\"span\\\"),j.style.cssText=\\\"width:1px;height:30px;float:left;background-color:#131\\\",e.appendChild(j);var t=function(b){s=b;switch(s){case 0:a.style.display=\\n\\\"block\\\";d.style.display=\\\"none\\\";break;case 1:a.style.display=\\\"none\\\",d.style.display=\\\"block\\\"}};return{REVISION:11,domElement:f,setMode:t,begin:function(){l=Date.now()},end:function(){var b=Date.now();g=b-l;n=Math.min(n,g);o=Math.max(o,g);k.textContent=g+\\\" MS (\\\"+n+\\\"-\\\"+o+\\\")\\\";var a=Math.min(30,30-30*(g/200));e.appendChild(e.firstChild).style.height=a+\\\"px\\\";r++;b>m+1E3&&(h=Math.round(1E3*r/(b-m)),p=Math.min(p,h),q=Math.max(q,h),i.textContent=h+\\\" FPS (\\\"+p+\\\"-\\\"+q+\\\")\\\",a=Math.min(30,30-30*(h/100)),c.appendChild(c.firstChild).style.height=\\na+\\\"px\\\",m=b,r=0);return b},update:function(){l=this.end()}}};\\n\\nexports.Stats = Stats;})();\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/dat-gui-min.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/dat-gui-min.js\",\n            \"module-type\": \"library\",\n            \"text\": \"(function(){\\n/**\\n * dat-gui JavaScript Controller Library\\n * http://code.google.com/p/dat-gui\\n *\\n * Copyright 2011 Data Arts Team, Google Creative Lab\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http://www.apache.org/licenses/LICENSE-2.0\\n */\\nvar dat=dat||{};dat.gui=dat.gui||{};dat.utils=dat.utils||{};dat.controllers=dat.controllers||{};dat.dom=dat.dom||{};dat.color=dat.color||{};dat.utils.css=function(){return{load:function(e,a){var a=a||document,c=a.createElement(\\\"link\\\");c.type=\\\"text/css\\\";c.rel=\\\"stylesheet\\\";c.href=e;a.getElementsByTagName(\\\"head\\\")[0].appendChild(c)},inject:function(e,a){var a=a||document,c=document.createElement(\\\"style\\\");c.type=\\\"text/css\\\";c.innerHTML=e;a.getElementsByTagName(\\\"head\\\")[0].appendChild(c)}}}();\\ndat.utils.common=function(){var e=Array.prototype.forEach,a=Array.prototype.slice;return{BREAK:{},extend:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(a[f])||(c[f]=a[f])},this);return c},defaults:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(c[f])&&(c[f]=a[f])},this);return c},compose:function(){var c=a.call(arguments);return function(){for(var d=a.call(arguments),f=c.length-1;f>=0;f--)d=[c[f].apply(this,d)];return d[0]}},\\neach:function(a,d,f){if(e&&a.forEach===e)a.forEach(d,f);else if(a.length===a.length+0)for(var b=0,n=a.length;b<n;b++){if(b in a&&d.call(f,a[b],b)===this.BREAK)break}else for(b in a)if(d.call(f,a[b],b)===this.BREAK)break},defer:function(a){setTimeout(a,0)},toArray:function(c){return c.toArray?c.toArray():a.call(c)},isUndefined:function(a){return a===void 0},isNull:function(a){return a===null},isNaN:function(a){return a!==a},isArray:Array.isArray||function(a){return a.constructor===Array},isObject:function(a){return a===\\nObject(a)},isNumber:function(a){return a===a+0},isString:function(a){return a===a+\\\"\\\"},isBoolean:function(a){return a===false||a===true},isFunction:function(a){return Object.prototype.toString.call(a)===\\\"[object Function]\\\"}}}();\\ndat.controllers.Controller=function(e){var a=function(a,d){this.initialValue=a[d];this.domElement=document.createElement(\\\"div\\\");this.object=a;this.property=d;this.__onFinishChange=this.__onChange=void 0};e.extend(a.prototype,{onChange:function(a){this.__onChange=a;return this},onFinishChange:function(a){this.__onFinishChange=a;return this},setValue:function(a){this.object[this.property]=a;this.__onChange&&this.__onChange.call(this,a);this.updateDisplay();return this},getValue:function(){return this.object[this.property]},\\nupdateDisplay:function(){return this},isModified:function(){return this.initialValue!==this.getValue()}});return a}(dat.utils.common);\\ndat.dom.dom=function(e){function a(b){if(b===\\\"0\\\"||e.isUndefined(b))return 0;b=b.match(d);return!e.isNull(b)?parseFloat(b[1]):0}var c={};e.each({HTMLEvents:[\\\"change\\\"],MouseEvents:[\\\"click\\\",\\\"mousemove\\\",\\\"mousedown\\\",\\\"mouseup\\\",\\\"mouseover\\\"],KeyboardEvents:[\\\"keydown\\\"]},function(b,a){e.each(b,function(b){c[b]=a})});var d=/(\\\\d+(\\\\.\\\\d+)?)px/,f={makeSelectable:function(b,a){if(!(b===void 0||b.style===void 0))b.onselectstart=a?function(){return false}:function(){},b.style.MozUserSelect=a?\\\"auto\\\":\\\"none\\\",b.style.KhtmlUserSelect=\\na?\\\"auto\\\":\\\"none\\\",b.unselectable=a?\\\"on\\\":\\\"off\\\"},makeFullscreen:function(b,a,d){e.isUndefined(a)&&(a=true);e.isUndefined(d)&&(d=true);b.style.position=\\\"absolute\\\";if(a)b.style.left=0,b.style.right=0;if(d)b.style.top=0,b.style.bottom=0},fakeEvent:function(b,a,d,f){var d=d||{},m=c[a];if(!m)throw Error(\\\"Event type \\\"+a+\\\" not supported.\\\");var l=document.createEvent(m);switch(m){case \\\"MouseEvents\\\":l.initMouseEvent(a,d.bubbles||false,d.cancelable||true,window,d.clickCount||1,0,0,d.x||d.clientX||0,d.y||d.clientY||\\n0,false,false,false,false,0,null);break;case \\\"KeyboardEvents\\\":m=l.initKeyboardEvent||l.initKeyEvent;e.defaults(d,{cancelable:true,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false,keyCode:void 0,charCode:void 0});m(a,d.bubbles||false,d.cancelable,window,d.ctrlKey,d.altKey,d.shiftKey,d.metaKey,d.keyCode,d.charCode);break;default:l.initEvent(a,d.bubbles||false,d.cancelable||true)}e.defaults(l,f);b.dispatchEvent(l)},bind:function(b,a,d,c){b.addEventListener?b.addEventListener(a,d,c||false):b.attachEvent&&\\nb.attachEvent(\\\"on\\\"+a,d);return f},unbind:function(b,a,d,c){b.removeEventListener?b.removeEventListener(a,d,c||false):b.detachEvent&&b.detachEvent(\\\"on\\\"+a,d);return f},addClass:function(b,a){if(b.className===void 0)b.className=a;else if(b.className!==a){var d=b.className.split(/ +/);if(d.indexOf(a)==-1)d.push(a),b.className=d.join(\\\" \\\").replace(/^\\\\s+/,\\\"\\\").replace(/\\\\s+$/,\\\"\\\")}return f},removeClass:function(b,a){if(a){if(b.className!==void 0)if(b.className===a)b.removeAttribute(\\\"class\\\");else{var d=b.className.split(/ +/),\\nc=d.indexOf(a);if(c!=-1)d.splice(c,1),b.className=d.join(\\\" \\\")}}else b.className=void 0;return f},hasClass:function(a,d){return RegExp(\\\"(?:^|\\\\\\\\s+)\\\"+d+\\\"(?:\\\\\\\\s+|$)\\\").test(a.className)||false},getWidth:function(b){b=getComputedStyle(b);return a(b[\\\"border-left-width\\\"])+a(b[\\\"border-right-width\\\"])+a(b[\\\"padding-left\\\"])+a(b[\\\"padding-right\\\"])+a(b.width)},getHeight:function(b){b=getComputedStyle(b);return a(b[\\\"border-top-width\\\"])+a(b[\\\"border-bottom-width\\\"])+a(b[\\\"padding-top\\\"])+a(b[\\\"padding-bottom\\\"])+a(b.height)},\\ngetOffset:function(a){var d={left:0,top:0};if(a.offsetParent){do d.left+=a.offsetLeft,d.top+=a.offsetTop;while(a=a.offsetParent)}return d},isActive:function(a){return a===document.activeElement&&(a.type||a.href)}};return f}(dat.utils.common);\\ndat.controllers.OptionController=function(e,a,c){var d=function(f,b,e){d.superclass.call(this,f,b);var h=this;this.__select=document.createElement(\\\"select\\\");if(c.isArray(e)){var j={};c.each(e,function(a){j[a]=a});e=j}c.each(e,function(a,b){var d=document.createElement(\\\"option\\\");d.innerHTML=b;d.setAttribute(\\\"value\\\",a);h.__select.appendChild(d)});this.updateDisplay();a.bind(this.__select,\\\"change\\\",function(){h.setValue(this.options[this.selectedIndex].value)});this.domElement.appendChild(this.__select)};\\nd.superclass=e;c.extend(d.prototype,e.prototype,{setValue:function(a){a=d.superclass.prototype.setValue.call(this,a);this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue());return a},updateDisplay:function(){this.__select.value=this.getValue();return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);\\ndat.controllers.NumberController=function(e,a){var c=function(d,f,b){c.superclass.call(this,d,f);b=b||{};this.__min=b.min;this.__max=b.max;this.__step=b.step;d=this.__impliedStep=a.isUndefined(this.__step)?this.initialValue==0?1:Math.pow(10,Math.floor(Math.log(this.initialValue)/Math.LN10))/10:this.__step;d=d.toString();this.__precision=d.indexOf(\\\".\\\")>-1?d.length-d.indexOf(\\\".\\\")-1:0};c.superclass=e;a.extend(c.prototype,e.prototype,{setValue:function(a){if(this.__min!==void 0&&a<this.__min)a=this.__min;\\nelse if(this.__max!==void 0&&a>this.__max)a=this.__max;this.__step!==void 0&&a%this.__step!=0&&(a=Math.round(a/this.__step)*this.__step);return c.superclass.prototype.setValue.call(this,a)},min:function(a){this.__min=a;return this},max:function(a){this.__max=a;return this},step:function(a){this.__step=a;return this}});return c}(dat.controllers.Controller,dat.utils.common);\\ndat.controllers.NumberControllerBox=function(e,a,c){var d=function(f,b,e){function h(){var a=parseFloat(l.__input.value);c.isNaN(a)||l.setValue(a)}function j(a){var b=o-a.clientY;l.setValue(l.getValue()+b*l.__impliedStep);o=a.clientY}function m(){a.unbind(window,\\\"mousemove\\\",j);a.unbind(window,\\\"mouseup\\\",m)}this.__truncationSuspended=false;d.superclass.call(this,f,b,e);var l=this,o;this.__input=document.createElement(\\\"input\\\");this.__input.setAttribute(\\\"type\\\",\\\"text\\\");a.bind(this.__input,\\\"change\\\",h);\\na.bind(this.__input,\\\"blur\\\",function(){h();l.__onFinishChange&&l.__onFinishChange.call(l,l.getValue())});a.bind(this.__input,\\\"mousedown\\\",function(b){a.bind(window,\\\"mousemove\\\",j);a.bind(window,\\\"mouseup\\\",m);o=b.clientY});a.bind(this.__input,\\\"keydown\\\",function(a){if(a.keyCode===13)l.__truncationSuspended=true,this.blur(),l.__truncationSuspended=false});this.updateDisplay();this.domElement.appendChild(this.__input)};d.superclass=e;c.extend(d.prototype,e.prototype,{updateDisplay:function(){var a=this.__input,\\nb;if(this.__truncationSuspended)b=this.getValue();else{b=this.getValue();var c=Math.pow(10,this.__precision);b=Math.round(b*c)/c}a.value=b;return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.NumberController,dat.dom.dom,dat.utils.common);\\ndat.controllers.NumberControllerSlider=function(e,a,c,d,f){var b=function(d,c,f,e,l){function o(b){b.preventDefault();var d=a.getOffset(g.__background),c=a.getWidth(g.__background);g.setValue(g.__min+(g.__max-g.__min)*((b.clientX-d.left)/(d.left+c-d.left)));return false}function y(){a.unbind(window,\\\"mousemove\\\",o);a.unbind(window,\\\"mouseup\\\",y);g.__onFinishChange&&g.__onFinishChange.call(g,g.getValue())}b.superclass.call(this,d,c,{min:f,max:e,step:l});var g=this;this.__background=document.createElement(\\\"div\\\");\\nthis.__foreground=document.createElement(\\\"div\\\");a.bind(this.__background,\\\"mousedown\\\",function(b){a.bind(window,\\\"mousemove\\\",o);a.bind(window,\\\"mouseup\\\",y);o(b)});a.addClass(this.__background,\\\"slider\\\");a.addClass(this.__foreground,\\\"slider-fg\\\");this.updateDisplay();this.__background.appendChild(this.__foreground);this.domElement.appendChild(this.__background)};b.superclass=e;b.useDefaultStyles=function(){c.inject(f)};d.extend(b.prototype,e.prototype,{updateDisplay:function(){this.__foreground.style.width=\\n(this.getValue()-this.__min)/(this.__max-this.__min)*100+\\\"%\\\";return b.superclass.prototype.updateDisplay.call(this)}});return b}(dat.controllers.NumberController,dat.dom.dom,dat.utils.css,dat.utils.common,\\\".slider {\\\\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\\\\n  height: 1em;\\\\n  border-radius: 1em;\\\\n  background-color: #eee;\\\\n  padding: 0 0.5em;\\\\n  overflow: hidden;\\\\n}\\\\n\\\\n.slider-fg {\\\\n  padding: 1px 0 2px 0;\\\\n  background-color: #aaa;\\\\n  height: 1em;\\\\n  margin-left: -0.5em;\\\\n  padding-right: 0.5em;\\\\n  border-radius: 1em 0 0 1em;\\\\n}\\\\n\\\\n.slider-fg:after {\\\\n  display: inline-block;\\\\n  border-radius: 1em;\\\\n  background-color: #fff;\\\\n  border:  1px solid #aaa;\\\\n  content: '';\\\\n  float: right;\\\\n  margin-right: -1em;\\\\n  margin-top: -1px;\\\\n  height: 0.9em;\\\\n  width: 0.9em;\\\\n}\\\");\\ndat.controllers.FunctionController=function(e,a,c){var d=function(c,b,e){d.superclass.call(this,c,b);var h=this;this.__button=document.createElement(\\\"div\\\");this.__button.innerHTML=e===void 0?\\\"Fire\\\":e;a.bind(this.__button,\\\"click\\\",function(a){a.preventDefault();h.fire();return false});a.addClass(this.__button,\\\"button\\\");this.domElement.appendChild(this.__button)};d.superclass=e;c.extend(d.prototype,e.prototype,{fire:function(){this.__onChange&&this.__onChange.call(this);this.__onFinishChange&&this.__onFinishChange.call(this,\\nthis.getValue());this.getValue().call(this.object)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);\\ndat.controllers.BooleanController=function(e,a,c){var d=function(c,b){d.superclass.call(this,c,b);var e=this;this.__prev=this.getValue();this.__checkbox=document.createElement(\\\"input\\\");this.__checkbox.setAttribute(\\\"type\\\",\\\"checkbox\\\");a.bind(this.__checkbox,\\\"change\\\",function(){e.setValue(!e.__prev)},false);this.domElement.appendChild(this.__checkbox);this.updateDisplay()};d.superclass=e;c.extend(d.prototype,e.prototype,{setValue:function(a){a=d.superclass.prototype.setValue.call(this,a);this.__onFinishChange&&\\nthis.__onFinishChange.call(this,this.getValue());this.__prev=this.getValue();return a},updateDisplay:function(){this.getValue()===true?(this.__checkbox.setAttribute(\\\"checked\\\",\\\"checked\\\"),this.__checkbox.checked=true):this.__checkbox.checked=false;return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);\\ndat.color.toString=function(e){return function(a){if(a.a==1||e.isUndefined(a.a)){for(a=a.hex.toString(16);a.length<6;)a=\\\"0\\\"+a;return\\\"#\\\"+a}else return\\\"rgba(\\\"+Math.round(a.r)+\\\",\\\"+Math.round(a.g)+\\\",\\\"+Math.round(a.b)+\\\",\\\"+a.a+\\\")\\\"}}(dat.utils.common);\\ndat.color.interpret=function(e,a){var c,d,f=[{litmus:a.isString,conversions:{THREE_CHAR_HEX:{read:function(a){a=a.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return a===null?false:{space:\\\"HEX\\\",hex:parseInt(\\\"0x\\\"+a[1].toString()+a[1].toString()+a[2].toString()+a[2].toString()+a[3].toString()+a[3].toString())}},write:e},SIX_CHAR_HEX:{read:function(a){a=a.match(/^#([A-F0-9]{6})$/i);return a===null?false:{space:\\\"HEX\\\",hex:parseInt(\\\"0x\\\"+a[1].toString())}},write:e},CSS_RGB:{read:function(a){a=a.match(/^rgb\\\\(\\\\s*(.+)\\\\s*,\\\\s*(.+)\\\\s*,\\\\s*(.+)\\\\s*\\\\)/);\\nreturn a===null?false:{space:\\\"RGB\\\",r:parseFloat(a[1]),g:parseFloat(a[2]),b:parseFloat(a[3])}},write:e},CSS_RGBA:{read:function(a){a=a.match(/^rgba\\\\(\\\\s*(.+)\\\\s*,\\\\s*(.+)\\\\s*,\\\\s*(.+)\\\\s*\\\\,\\\\s*(.+)\\\\s*\\\\)/);return a===null?false:{space:\\\"RGB\\\",r:parseFloat(a[1]),g:parseFloat(a[2]),b:parseFloat(a[3]),a:parseFloat(a[4])}},write:e}}},{litmus:a.isNumber,conversions:{HEX:{read:function(a){return{space:\\\"HEX\\\",hex:a,conversionName:\\\"HEX\\\"}},write:function(a){return a.hex}}}},{litmus:a.isArray,conversions:{RGB_ARRAY:{read:function(a){return a.length!=\\n3?false:{space:\\\"RGB\\\",r:a[0],g:a[1],b:a[2]}},write:function(a){return[a.r,a.g,a.b]}},RGBA_ARRAY:{read:function(a){return a.length!=4?false:{space:\\\"RGB\\\",r:a[0],g:a[1],b:a[2],a:a[3]}},write:function(a){return[a.r,a.g,a.b,a.a]}}}},{litmus:a.isObject,conversions:{RGBA_OBJ:{read:function(b){return a.isNumber(b.r)&&a.isNumber(b.g)&&a.isNumber(b.b)&&a.isNumber(b.a)?{space:\\\"RGB\\\",r:b.r,g:b.g,b:b.b,a:b.a}:false},write:function(a){return{r:a.r,g:a.g,b:a.b,a:a.a}}},RGB_OBJ:{read:function(b){return a.isNumber(b.r)&&\\na.isNumber(b.g)&&a.isNumber(b.b)?{space:\\\"RGB\\\",r:b.r,g:b.g,b:b.b}:false},write:function(a){return{r:a.r,g:a.g,b:a.b}}},HSVA_OBJ:{read:function(b){return a.isNumber(b.h)&&a.isNumber(b.s)&&a.isNumber(b.v)&&a.isNumber(b.a)?{space:\\\"HSV\\\",h:b.h,s:b.s,v:b.v,a:b.a}:false},write:function(a){return{h:a.h,s:a.s,v:a.v,a:a.a}}},HSV_OBJ:{read:function(b){return a.isNumber(b.h)&&a.isNumber(b.s)&&a.isNumber(b.v)?{space:\\\"HSV\\\",h:b.h,s:b.s,v:b.v}:false},write:function(a){return{h:a.h,s:a.s,v:a.v}}}}}];return function(){d=\\nfalse;var b=arguments.length>1?a.toArray(arguments):arguments[0];a.each(f,function(e){if(e.litmus(b))return a.each(e.conversions,function(e,f){c=e.read(b);if(d===false&&c!==false)return d=c,c.conversionName=f,c.conversion=e,a.BREAK}),a.BREAK});return d}}(dat.color.toString,dat.utils.common);\\ndat.GUI=dat.gui.GUI=function(e,a,c,d,f,b,n,h,j,m,l,o,y,g,i){function q(a,b,r,c){if(b[r]===void 0)throw Error(\\\"Object \\\"+b+' has no property \\\"'+r+'\\\"');c.color?b=new l(b,r):(b=[b,r].concat(c.factoryArgs),b=d.apply(a,b));if(c.before instanceof f)c.before=c.before.__li;t(a,b);g.addClass(b.domElement,\\\"c\\\");r=document.createElement(\\\"span\\\");g.addClass(r,\\\"property-name\\\");r.innerHTML=b.property;var e=document.createElement(\\\"div\\\");e.appendChild(r);e.appendChild(b.domElement);c=s(a,e,c.before);g.addClass(c,k.CLASS_CONTROLLER_ROW);\\ng.addClass(c,typeof b.getValue());p(a,c,b);a.__controllers.push(b);return b}function s(a,b,d){var c=document.createElement(\\\"li\\\");b&&c.appendChild(b);d?a.__ul.insertBefore(c,params.before):a.__ul.appendChild(c);a.onResize();return c}function p(a,d,c){c.__li=d;c.__gui=a;i.extend(c,{options:function(b){if(arguments.length>1)return c.remove(),q(a,c.object,c.property,{before:c.__li.nextElementSibling,factoryArgs:[i.toArray(arguments)]});if(i.isArray(b)||i.isObject(b))return c.remove(),q(a,c.object,c.property,\\n{before:c.__li.nextElementSibling,factoryArgs:[b]})},name:function(a){c.__li.firstElementChild.firstElementChild.innerHTML=a;return c},listen:function(){c.__gui.listen(c);return c},remove:function(){c.__gui.remove(c);return c}});if(c instanceof j){var e=new h(c.object,c.property,{min:c.__min,max:c.__max,step:c.__step});i.each([\\\"updateDisplay\\\",\\\"onChange\\\",\\\"onFinishChange\\\"],function(a){var b=c[a],H=e[a];c[a]=e[a]=function(){var a=Array.prototype.slice.call(arguments);b.apply(c,a);return H.apply(e,a)}});\\ng.addClass(d,\\\"has-slider\\\");c.domElement.insertBefore(e.domElement,c.domElement.firstElementChild)}else if(c instanceof h){var f=function(b){return i.isNumber(c.__min)&&i.isNumber(c.__max)?(c.remove(),q(a,c.object,c.property,{before:c.__li.nextElementSibling,factoryArgs:[c.__min,c.__max,c.__step]})):b};c.min=i.compose(f,c.min);c.max=i.compose(f,c.max)}else if(c instanceof b)g.bind(d,\\\"click\\\",function(){g.fakeEvent(c.__checkbox,\\\"click\\\")}),g.bind(c.__checkbox,\\\"click\\\",function(a){a.stopPropagation()});\\nelse if(c instanceof n)g.bind(d,\\\"click\\\",function(){g.fakeEvent(c.__button,\\\"click\\\")}),g.bind(d,\\\"mouseover\\\",function(){g.addClass(c.__button,\\\"hover\\\")}),g.bind(d,\\\"mouseout\\\",function(){g.removeClass(c.__button,\\\"hover\\\")});else if(c instanceof l)g.addClass(d,\\\"color\\\"),c.updateDisplay=i.compose(function(a){d.style.borderLeftColor=c.__color.toString();return a},c.updateDisplay),c.updateDisplay();c.setValue=i.compose(function(b){a.getRoot().__preset_select&&c.isModified()&&B(a.getRoot(),true);return b},c.setValue)}\\nfunction t(a,b){var c=a.getRoot(),d=c.__rememberedObjects.indexOf(b.object);if(d!=-1){var e=c.__rememberedObjectIndecesToControllers[d];e===void 0&&(e={},c.__rememberedObjectIndecesToControllers[d]=e);e[b.property]=b;if(c.load&&c.load.remembered){c=c.load.remembered;if(c[a.preset])c=c[a.preset];else if(c[w])c=c[w];else return;if(c[d]&&c[d][b.property]!==void 0)d=c[d][b.property],b.initialValue=d,b.setValue(d)}}}function I(a){var b=a.__save_row=document.createElement(\\\"li\\\");g.addClass(a.domElement,\\n\\\"has-save\\\");a.__ul.insertBefore(b,a.__ul.firstChild);g.addClass(b,\\\"save-row\\\");var c=document.createElement(\\\"span\\\");c.innerHTML=\\\"&nbsp;\\\";g.addClass(c,\\\"button gears\\\");var d=document.createElement(\\\"span\\\");d.innerHTML=\\\"Save\\\";g.addClass(d,\\\"button\\\");g.addClass(d,\\\"save\\\");var e=document.createElement(\\\"span\\\");e.innerHTML=\\\"New\\\";g.addClass(e,\\\"button\\\");g.addClass(e,\\\"save-as\\\");var f=document.createElement(\\\"span\\\");f.innerHTML=\\\"Revert\\\";g.addClass(f,\\\"button\\\");g.addClass(f,\\\"revert\\\");var m=a.__preset_select=document.createElement(\\\"select\\\");\\na.load&&a.load.remembered?i.each(a.load.remembered,function(b,c){C(a,c,c==a.preset)}):C(a,w,false);g.bind(m,\\\"change\\\",function(){for(var b=0;b<a.__preset_select.length;b++)a.__preset_select[b].innerHTML=a.__preset_select[b].value;a.preset=this.value});b.appendChild(m);b.appendChild(c);b.appendChild(d);b.appendChild(e);b.appendChild(f);if(u){var b=document.getElementById(\\\"dg-save-locally\\\"),l=document.getElementById(\\\"dg-local-explain\\\");b.style.display=\\\"block\\\";b=document.getElementById(\\\"dg-local-storage\\\");\\nlocalStorage.getItem(document.location.href+\\\".isLocal\\\")===\\\"true\\\"&&b.setAttribute(\\\"checked\\\",\\\"checked\\\");var o=function(){l.style.display=a.useLocalStorage?\\\"block\\\":\\\"none\\\"};o();g.bind(b,\\\"change\\\",function(){a.useLocalStorage=!a.useLocalStorage;o()})}var h=document.getElementById(\\\"dg-new-constructor\\\");g.bind(h,\\\"keydown\\\",function(a){a.metaKey&&(a.which===67||a.keyCode==67)&&x.hide()});g.bind(c,\\\"click\\\",function(){h.innerHTML=JSON.stringify(a.getSaveObject(),void 0,2);x.show();h.focus();h.select()});g.bind(d,\\n\\\"click\\\",function(){a.save()});g.bind(e,\\\"click\\\",function(){var b=prompt(\\\"Enter a new preset name.\\\");b&&a.saveAs(b)});g.bind(f,\\\"click\\\",function(){a.revert()})}function J(a){function b(f){f.preventDefault();e=f.clientX;g.addClass(a.__closeButton,k.CLASS_DRAG);g.bind(window,\\\"mousemove\\\",c);g.bind(window,\\\"mouseup\\\",d);return false}function c(b){b.preventDefault();a.width+=e-b.clientX;a.onResize();e=b.clientX;return false}function d(){g.removeClass(a.__closeButton,k.CLASS_DRAG);g.unbind(window,\\\"mousemove\\\",\\nc);g.unbind(window,\\\"mouseup\\\",d)}a.__resize_handle=document.createElement(\\\"div\\\");i.extend(a.__resize_handle.style,{width:\\\"6px\\\",marginLeft:\\\"-3px\\\",height:\\\"200px\\\",cursor:\\\"ew-resize\\\",position:\\\"absolute\\\"});var e;g.bind(a.__resize_handle,\\\"mousedown\\\",b);g.bind(a.__closeButton,\\\"mousedown\\\",b);a.domElement.insertBefore(a.__resize_handle,a.domElement.firstElementChild)}function D(a,b){a.domElement.style.width=b+\\\"px\\\";if(a.__save_row&&a.autoPlace)a.__save_row.style.width=b+\\\"px\\\";if(a.__closeButton)a.__closeButton.style.width=\\nb+\\\"px\\\"}function z(a,b){var c={};i.each(a.__rememberedObjects,function(d,e){var f={};i.each(a.__rememberedObjectIndecesToControllers[e],function(a,c){f[c]=b?a.initialValue:a.getValue()});c[e]=f});return c}function C(a,b,c){var d=document.createElement(\\\"option\\\");d.innerHTML=b;d.value=b;a.__preset_select.appendChild(d);if(c)a.__preset_select.selectedIndex=a.__preset_select.length-1}function B(a,b){var c=a.__preset_select[a.__preset_select.selectedIndex];c.innerHTML=b?c.value+\\\"*\\\":c.value}function E(a){a.length!=\\n0&&o(function(){E(a)});i.each(a,function(a){a.updateDisplay()})}e.inject(c);var w=\\\"Default\\\",u;try{u=\\\"localStorage\\\"in window&&window.localStorage!==null}catch(K){u=false}var x,F=true,v,A=false,G=[],k=function(a){function b(){localStorage.setItem(document.location.href+\\\".gui\\\",JSON.stringify(d.getSaveObject()))}function c(){var a=d.getRoot();a.width+=1;i.defer(function(){a.width-=1})}var d=this;this.domElement=document.createElement(\\\"div\\\");this.__ul=document.createElement(\\\"ul\\\");this.domElement.appendChild(this.__ul);\\ng.addClass(this.domElement,\\\"dg\\\");this.__folders={};this.__controllers=[];this.__rememberedObjects=[];this.__rememberedObjectIndecesToControllers=[];this.__listening=[];a=a||{};a=i.defaults(a,{autoPlace:true,width:k.DEFAULT_WIDTH});a=i.defaults(a,{resizable:a.autoPlace,hideable:a.autoPlace});if(i.isUndefined(a.load))a.load={preset:w};else if(a.preset)a.load.preset=a.preset;i.isUndefined(a.parent)&&a.hideable&&G.push(this);a.resizable=i.isUndefined(a.parent)&&a.resizable;if(a.autoPlace&&i.isUndefined(a.scrollable))a.scrollable=\\ntrue;var e=u&&localStorage.getItem(document.location.href+\\\".isLocal\\\")===\\\"true\\\";Object.defineProperties(this,{parent:{get:function(){return a.parent}},scrollable:{get:function(){return a.scrollable}},autoPlace:{get:function(){return a.autoPlace}},preset:{get:function(){return d.parent?d.getRoot().preset:a.load.preset},set:function(b){d.parent?d.getRoot().preset=b:a.load.preset=b;for(b=0;b<this.__preset_select.length;b++)if(this.__preset_select[b].value==this.preset)this.__preset_select.selectedIndex=\\nb;d.revert()}},width:{get:function(){return a.width},set:function(b){a.width=b;D(d,b)}},name:{get:function(){return a.name},set:function(b){a.name=b;if(m)m.innerHTML=a.name}},closed:{get:function(){return a.closed},set:function(b){a.closed=b;a.closed?g.addClass(d.__ul,k.CLASS_CLOSED):g.removeClass(d.__ul,k.CLASS_CLOSED);this.onResize();if(d.__closeButton)d.__closeButton.innerHTML=b?k.TEXT_OPEN:k.TEXT_CLOSED}},load:{get:function(){return a.load}},useLocalStorage:{get:function(){return e},set:function(a){u&&\\n((e=a)?g.bind(window,\\\"unload\\\",b):g.unbind(window,\\\"unload\\\",b),localStorage.setItem(document.location.href+\\\".isLocal\\\",a))}}});if(i.isUndefined(a.parent)){a.closed=false;g.addClass(this.domElement,k.CLASS_MAIN);g.makeSelectable(this.domElement,false);if(u&&e){d.useLocalStorage=true;var f=localStorage.getItem(document.location.href+\\\".gui\\\");if(f)a.load=JSON.parse(f)}this.__closeButton=document.createElement(\\\"div\\\");this.__closeButton.innerHTML=k.TEXT_CLOSED;g.addClass(this.__closeButton,k.CLASS_CLOSE_BUTTON);\\nthis.domElement.appendChild(this.__closeButton);g.bind(this.__closeButton,\\\"click\\\",function(){d.closed=!d.closed})}else{if(a.closed===void 0)a.closed=true;var m=document.createTextNode(a.name);g.addClass(m,\\\"controller-name\\\");f=s(d,m);g.addClass(this.__ul,k.CLASS_CLOSED);g.addClass(f,\\\"title\\\");g.bind(f,\\\"click\\\",function(a){a.preventDefault();d.closed=!d.closed;return false});if(!a.closed)this.closed=false}a.autoPlace&&(i.isUndefined(a.parent)&&(F&&(v=document.createElement(\\\"div\\\"),g.addClass(v,\\\"dg\\\"),g.addClass(v,\\nk.CLASS_AUTO_PLACE_CONTAINER),document.body.appendChild(v),F=false),v.appendChild(this.domElement),g.addClass(this.domElement,k.CLASS_AUTO_PLACE)),this.parent||D(d,a.width));g.bind(window,\\\"resize\\\",function(){d.onResize()});g.bind(this.__ul,\\\"webkitTransitionEnd\\\",function(){d.onResize()});g.bind(this.__ul,\\\"transitionend\\\",function(){d.onResize()});g.bind(this.__ul,\\\"oTransitionEnd\\\",function(){d.onResize()});this.onResize();a.resizable&&J(this);d.getRoot();a.parent||c()};k.toggleHide=function(){A=!A;i.each(G,\\nfunction(a){a.domElement.style.zIndex=A?-999:999;a.domElement.style.opacity=A?0:1})};k.CLASS_AUTO_PLACE=\\\"a\\\";k.CLASS_AUTO_PLACE_CONTAINER=\\\"ac\\\";k.CLASS_MAIN=\\\"main\\\";k.CLASS_CONTROLLER_ROW=\\\"cr\\\";k.CLASS_TOO_TALL=\\\"taller-than-window\\\";k.CLASS_CLOSED=\\\"closed\\\";k.CLASS_CLOSE_BUTTON=\\\"close-button\\\";k.CLASS_DRAG=\\\"drag\\\";k.DEFAULT_WIDTH=245;k.TEXT_CLOSED=\\\"Close Controls\\\";k.TEXT_OPEN=\\\"Open Controls\\\";g.bind(window,\\\"keydown\\\",function(a){document.activeElement.type!==\\\"text\\\"&&(a.which===72||a.keyCode==72)&&k.toggleHide()},\\nfalse);i.extend(k.prototype,{add:function(a,b){return q(this,a,b,{factoryArgs:Array.prototype.slice.call(arguments,2)})},addColor:function(a,b){return q(this,a,b,{color:true})},remove:function(a){this.__ul.removeChild(a.__li);this.__controllers.slice(this.__controllers.indexOf(a),1);var b=this;i.defer(function(){b.onResize()})},destroy:function(){this.autoPlace&&v.removeChild(this.domElement)},addFolder:function(a){if(this.__folders[a]!==void 0)throw Error('You already have a folder in this GUI by the name \\\"'+\\na+'\\\"');var b={name:a,parent:this};b.autoPlace=this.autoPlace;if(this.load&&this.load.folders&&this.load.folders[a])b.closed=this.load.folders[a].closed,b.load=this.load.folders[a];b=new k(b);this.__folders[a]=b;a=s(this,b.domElement);g.addClass(a,\\\"folder\\\");return b},open:function(){this.closed=false},close:function(){this.closed=true},onResize:function(){var a=this.getRoot();if(a.scrollable){var b=g.getOffset(a.__ul).top,c=0;i.each(a.__ul.childNodes,function(b){a.autoPlace&&b===a.__save_row||(c+=\\ng.getHeight(b))});window.innerHeight-b-20<c?(g.addClass(a.domElement,k.CLASS_TOO_TALL),a.__ul.style.height=window.innerHeight-b-20+\\\"px\\\"):(g.removeClass(a.domElement,k.CLASS_TOO_TALL),a.__ul.style.height=\\\"auto\\\")}a.__resize_handle&&i.defer(function(){a.__resize_handle.style.height=a.__ul.offsetHeight+\\\"px\\\"});if(a.__closeButton)a.__closeButton.style.width=a.width+\\\"px\\\"},remember:function(){if(i.isUndefined(x))x=new y,x.domElement.innerHTML=a;if(this.parent)throw Error(\\\"You can only call remember on a top level GUI.\\\");\\nvar b=this;i.each(Array.prototype.slice.call(arguments),function(a){b.__rememberedObjects.length==0&&I(b);b.__rememberedObjects.indexOf(a)==-1&&b.__rememberedObjects.push(a)});this.autoPlace&&D(this,this.width)},getRoot:function(){for(var a=this;a.parent;)a=a.parent;return a},getSaveObject:function(){var a=this.load;a.closed=this.closed;if(this.__rememberedObjects.length>0){a.preset=this.preset;if(!a.remembered)a.remembered={};a.remembered[this.preset]=z(this)}a.folders={};i.each(this.__folders,function(b,\\nc){a.folders[c]=b.getSaveObject()});return a},save:function(){if(!this.load.remembered)this.load.remembered={};this.load.remembered[this.preset]=z(this);B(this,false)},saveAs:function(a){if(!this.load.remembered)this.load.remembered={},this.load.remembered[w]=z(this,true);this.load.remembered[a]=z(this);this.preset=a;C(this,a,true)},revert:function(a){i.each(this.__controllers,function(b){this.getRoot().load.remembered?t(a||this.getRoot(),b):b.setValue(b.initialValue)},this);i.each(this.__folders,\\nfunction(a){a.revert(a)});a||B(this.getRoot(),false)},listen:function(a){var b=this.__listening.length==0;this.__listening.push(a);b&&E(this.__listening)}});return k}(dat.utils.css,'<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\\\n\\\\n  Here\\\\'s the new load parameter for your <code>GUI</code>\\\\'s constructor:\\\\n\\\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\\\n\\\\n  <div id=\\\"dg-save-locally\\\">\\\\n\\\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\\\n    values to <code>localStorage</code> on exit.\\\\n\\\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\\\n      override those passed to <code>dat.GUI</code>\\\\'s constructor. This makes it\\\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\\\n      and your friends may not see the same values you do.\\\\n      \\\\n    </div>\\\\n    \\\\n  </div>\\\\n\\\\n</div>',\\n\\\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\\\n\\\",\\ndat.controllers.factory=function(e,a,c,d,f,b,n){return function(h,j,m,l){var o=h[j];if(n.isArray(m)||n.isObject(m))return new e(h,j,m);if(n.isNumber(o))return n.isNumber(m)&&n.isNumber(l)?new c(h,j,m,l):new a(h,j,{min:m,max:l});if(n.isString(o))return new d(h,j);if(n.isFunction(o))return new f(h,j,\\\"\\\");if(n.isBoolean(o))return new b(h,j)}}(dat.controllers.OptionController,dat.controllers.NumberControllerBox,dat.controllers.NumberControllerSlider,dat.controllers.StringController=function(e,a,c){var d=\\nfunction(c,b){function e(){h.setValue(h.__input.value)}d.superclass.call(this,c,b);var h=this;this.__input=document.createElement(\\\"input\\\");this.__input.setAttribute(\\\"type\\\",\\\"text\\\");a.bind(this.__input,\\\"keyup\\\",e);a.bind(this.__input,\\\"change\\\",e);a.bind(this.__input,\\\"blur\\\",function(){h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())});a.bind(this.__input,\\\"keydown\\\",function(a){a.keyCode===13&&this.blur()});this.updateDisplay();this.domElement.appendChild(this.__input)};d.superclass=e;c.extend(d.prototype,\\ne.prototype,{updateDisplay:function(){if(!a.isActive(this.__input))this.__input.value=this.getValue();return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common),dat.controllers.FunctionController,dat.controllers.BooleanController,dat.utils.common),dat.controllers.Controller,dat.controllers.BooleanController,dat.controllers.FunctionController,dat.controllers.NumberControllerBox,dat.controllers.NumberControllerSlider,dat.controllers.OptionController,\\ndat.controllers.ColorController=function(e,a,c,d,f){function b(a,b,c,d){a.style.background=\\\"\\\";f.each(j,function(e){a.style.cssText+=\\\"background: \\\"+e+\\\"linear-gradient(\\\"+b+\\\", \\\"+c+\\\" 0%, \\\"+d+\\\" 100%); \\\"})}function n(a){a.style.background=\\\"\\\";a.style.cssText+=\\\"background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);\\\";a.style.cssText+=\\\"background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\\\";\\na.style.cssText+=\\\"background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\\\";a.style.cssText+=\\\"background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\\\";a.style.cssText+=\\\"background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\\\"}var h=function(e,l){function o(b){q(b);a.bind(window,\\\"mousemove\\\",q);a.bind(window,\\n\\\"mouseup\\\",j)}function j(){a.unbind(window,\\\"mousemove\\\",q);a.unbind(window,\\\"mouseup\\\",j)}function g(){var a=d(this.value);a!==false?(p.__color.__state=a,p.setValue(p.__color.toOriginal())):this.value=p.__color.toString()}function i(){a.unbind(window,\\\"mousemove\\\",s);a.unbind(window,\\\"mouseup\\\",i)}function q(b){b.preventDefault();var c=a.getWidth(p.__saturation_field),d=a.getOffset(p.__saturation_field),e=(b.clientX-d.left+document.body.scrollLeft)/c,b=1-(b.clientY-d.top+document.body.scrollTop)/c;b>1?b=\\n1:b<0&&(b=0);e>1?e=1:e<0&&(e=0);p.__color.v=b;p.__color.s=e;p.setValue(p.__color.toOriginal());return false}function s(b){b.preventDefault();var c=a.getHeight(p.__hue_field),d=a.getOffset(p.__hue_field),b=1-(b.clientY-d.top+document.body.scrollTop)/c;b>1?b=1:b<0&&(b=0);p.__color.h=b*360;p.setValue(p.__color.toOriginal());return false}h.superclass.call(this,e,l);this.__color=new c(this.getValue());this.__temp=new c(0);var p=this;this.domElement=document.createElement(\\\"div\\\");a.makeSelectable(this.domElement,\\nfalse);this.__selector=document.createElement(\\\"div\\\");this.__selector.className=\\\"selector\\\";this.__saturation_field=document.createElement(\\\"div\\\");this.__saturation_field.className=\\\"saturation-field\\\";this.__field_knob=document.createElement(\\\"div\\\");this.__field_knob.className=\\\"field-knob\\\";this.__field_knob_border=\\\"2px solid \\\";this.__hue_knob=document.createElement(\\\"div\\\");this.__hue_knob.className=\\\"hue-knob\\\";this.__hue_field=document.createElement(\\\"div\\\");this.__hue_field.className=\\\"hue-field\\\";this.__input=\\ndocument.createElement(\\\"input\\\");this.__input.type=\\\"text\\\";this.__input_textShadow=\\\"0 1px 1px \\\";a.bind(this.__input,\\\"keydown\\\",function(a){a.keyCode===13&&g.call(this)});a.bind(this.__input,\\\"blur\\\",g);a.bind(this.__selector,\\\"mousedown\\\",function(){a.addClass(this,\\\"drag\\\").bind(window,\\\"mouseup\\\",function(){a.removeClass(p.__selector,\\\"drag\\\")})});var t=document.createElement(\\\"div\\\");f.extend(this.__selector.style,{width:\\\"122px\\\",height:\\\"102px\\\",padding:\\\"3px\\\",backgroundColor:\\\"#222\\\",boxShadow:\\\"0px 1px 3px rgba(0,0,0,0.3)\\\"});\\nf.extend(this.__field_knob.style,{position:\\\"absolute\\\",width:\\\"12px\\\",height:\\\"12px\\\",border:this.__field_knob_border+(this.__color.v<0.5?\\\"#fff\\\":\\\"#000\\\"),boxShadow:\\\"0px 1px 3px rgba(0,0,0,0.5)\\\",borderRadius:\\\"12px\\\",zIndex:1});f.extend(this.__hue_knob.style,{position:\\\"absolute\\\",width:\\\"15px\\\",height:\\\"2px\\\",borderRight:\\\"4px solid #fff\\\",zIndex:1});f.extend(this.__saturation_field.style,{width:\\\"100px\\\",height:\\\"100px\\\",border:\\\"1px solid #555\\\",marginRight:\\\"3px\\\",display:\\\"inline-block\\\",cursor:\\\"pointer\\\"});f.extend(t.style,\\n{width:\\\"100%\\\",height:\\\"100%\\\",background:\\\"none\\\"});b(t,\\\"top\\\",\\\"rgba(0,0,0,0)\\\",\\\"#000\\\");f.extend(this.__hue_field.style,{width:\\\"15px\\\",height:\\\"100px\\\",display:\\\"inline-block\\\",border:\\\"1px solid #555\\\",cursor:\\\"ns-resize\\\"});n(this.__hue_field);f.extend(this.__input.style,{outline:\\\"none\\\",textAlign:\\\"center\\\",color:\\\"#fff\\\",border:0,fontWeight:\\\"bold\\\",textShadow:this.__input_textShadow+\\\"rgba(0,0,0,0.7)\\\"});a.bind(this.__saturation_field,\\\"mousedown\\\",o);a.bind(this.__field_knob,\\\"mousedown\\\",o);a.bind(this.__hue_field,\\\"mousedown\\\",\\nfunction(b){s(b);a.bind(window,\\\"mousemove\\\",s);a.bind(window,\\\"mouseup\\\",i)});this.__saturation_field.appendChild(t);this.__selector.appendChild(this.__field_knob);this.__selector.appendChild(this.__saturation_field);this.__selector.appendChild(this.__hue_field);this.__hue_field.appendChild(this.__hue_knob);this.domElement.appendChild(this.__input);this.domElement.appendChild(this.__selector);this.updateDisplay()};h.superclass=e;f.extend(h.prototype,e.prototype,{updateDisplay:function(){var a=d(this.getValue());\\nif(a!==false){var e=false;f.each(c.COMPONENTS,function(b){if(!f.isUndefined(a[b])&&!f.isUndefined(this.__color.__state[b])&&a[b]!==this.__color.__state[b])return e=true,{}},this);e&&f.extend(this.__color.__state,a)}f.extend(this.__temp.__state,this.__color.__state);this.__temp.a=1;var h=this.__color.v<0.5||this.__color.s>0.5?255:0,j=255-h;f.extend(this.__field_knob.style,{marginLeft:100*this.__color.s-7+\\\"px\\\",marginTop:100*(1-this.__color.v)-7+\\\"px\\\",backgroundColor:this.__temp.toString(),border:this.__field_knob_border+\\n\\\"rgb(\\\"+h+\\\",\\\"+h+\\\",\\\"+h+\\\")\\\"});this.__hue_knob.style.marginTop=(1-this.__color.h/360)*100+\\\"px\\\";this.__temp.s=1;this.__temp.v=1;b(this.__saturation_field,\\\"left\\\",\\\"#fff\\\",this.__temp.toString());f.extend(this.__input.style,{backgroundColor:this.__input.value=this.__color.toString(),color:\\\"rgb(\\\"+h+\\\",\\\"+h+\\\",\\\"+h+\\\")\\\",textShadow:this.__input_textShadow+\\\"rgba(\\\"+j+\\\",\\\"+j+\\\",\\\"+j+\\\",.7)\\\"})}});var j=[\\\"-moz-\\\",\\\"-o-\\\",\\\"-webkit-\\\",\\\"-ms-\\\",\\\"\\\"];return h}(dat.controllers.Controller,dat.dom.dom,dat.color.Color=function(e,a,c,d){function f(a,\\nb,c){Object.defineProperty(a,b,{get:function(){if(this.__state.space===\\\"RGB\\\")return this.__state[b];n(this,b,c);return this.__state[b]},set:function(a){if(this.__state.space!==\\\"RGB\\\")n(this,b,c),this.__state.space=\\\"RGB\\\";this.__state[b]=a}})}function b(a,b){Object.defineProperty(a,b,{get:function(){if(this.__state.space===\\\"HSV\\\")return this.__state[b];h(this);return this.__state[b]},set:function(a){if(this.__state.space!==\\\"HSV\\\")h(this),this.__state.space=\\\"HSV\\\";this.__state[b]=a}})}function n(b,c,e){if(b.__state.space===\\n\\\"HEX\\\")b.__state[c]=a.component_from_hex(b.__state.hex,e);else if(b.__state.space===\\\"HSV\\\")d.extend(b.__state,a.hsv_to_rgb(b.__state.h,b.__state.s,b.__state.v));else throw\\\"Corrupted color state\\\";}function h(b){var c=a.rgb_to_hsv(b.r,b.g,b.b);d.extend(b.__state,{s:c.s,v:c.v});if(d.isNaN(c.h)){if(d.isUndefined(b.__state.h))b.__state.h=0}else b.__state.h=c.h}var j=function(){this.__state=e.apply(this,arguments);if(this.__state===false)throw\\\"Failed to interpret color arguments\\\";this.__state.a=this.__state.a||\\n1};j.COMPONENTS=\\\"r,g,b,h,s,v,hex,a\\\".split(\\\",\\\");d.extend(j.prototype,{toString:function(){return c(this)},toOriginal:function(){return this.__state.conversion.write(this)}});f(j.prototype,\\\"r\\\",2);f(j.prototype,\\\"g\\\",1);f(j.prototype,\\\"b\\\",0);b(j.prototype,\\\"h\\\");b(j.prototype,\\\"s\\\");b(j.prototype,\\\"v\\\");Object.defineProperty(j.prototype,\\\"a\\\",{get:function(){return this.__state.a},set:function(a){this.__state.a=a}});Object.defineProperty(j.prototype,\\\"hex\\\",{get:function(){if(!this.__state.space!==\\\"HEX\\\")this.__state.hex=\\na.rgb_to_hex(this.r,this.g,this.b);return this.__state.hex},set:function(a){this.__state.space=\\\"HEX\\\";this.__state.hex=a}});return j}(dat.color.interpret,dat.color.math=function(){var e;return{hsv_to_rgb:function(a,c,d){var e=a/60-Math.floor(a/60),b=d*(1-c),n=d*(1-e*c),c=d*(1-(1-e)*c),a=[[d,c,b],[n,d,b],[b,d,c],[b,n,d],[c,b,d],[d,b,n]][Math.floor(a/60)%6];return{r:a[0]*255,g:a[1]*255,b:a[2]*255}},rgb_to_hsv:function(a,c,d){var e=Math.min(a,c,d),b=Math.max(a,c,d),e=b-e;if(b==0)return{h:NaN,s:0,v:0};\\na=a==b?(c-d)/e:c==b?2+(d-a)/e:4+(a-c)/e;a/=6;a<0&&(a+=1);return{h:a*360,s:e/b,v:b/255}},rgb_to_hex:function(a,c,d){a=this.hex_with_component(0,2,a);a=this.hex_with_component(a,1,c);return a=this.hex_with_component(a,0,d)},component_from_hex:function(a,c){return a>>c*8&255},hex_with_component:function(a,c,d){return d<<(e=c*8)|a&~(255<<e)}}}(),dat.color.toString,dat.utils.common),dat.color.interpret,dat.utils.common),dat.utils.requestAnimationFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||\\nwindow.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(e,1E3/60)}}(),dat.dom.CenteredDiv=function(e,a){var c=function(){this.backgroundElement=document.createElement(\\\"div\\\");a.extend(this.backgroundElement.style,{backgroundColor:\\\"rgba(0,0,0,0.8)\\\",top:0,left:0,display:\\\"none\\\",zIndex:\\\"1000\\\",opacity:0,WebkitTransition:\\\"opacity 0.2s linear\\\"});e.makeFullscreen(this.backgroundElement);this.backgroundElement.style.position=\\\"fixed\\\";this.domElement=\\ndocument.createElement(\\\"div\\\");a.extend(this.domElement.style,{position:\\\"fixed\\\",display:\\\"none\\\",zIndex:\\\"1001\\\",opacity:0,WebkitTransition:\\\"-webkit-transform 0.2s ease-out, opacity 0.2s linear\\\"});document.body.appendChild(this.backgroundElement);document.body.appendChild(this.domElement);var c=this;e.bind(this.backgroundElement,\\\"click\\\",function(){c.hide()})};c.prototype.show=function(){var c=this;this.backgroundElement.style.display=\\\"block\\\";this.domElement.style.display=\\\"block\\\";this.domElement.style.opacity=\\n0;this.domElement.style.webkitTransform=\\\"scale(1.1)\\\";this.layout();a.defer(function(){c.backgroundElement.style.opacity=1;c.domElement.style.opacity=1;c.domElement.style.webkitTransform=\\\"scale(1)\\\"})};c.prototype.hide=function(){var a=this,c=function(){a.domElement.style.display=\\\"none\\\";a.backgroundElement.style.display=\\\"none\\\";e.unbind(a.domElement,\\\"webkitTransitionEnd\\\",c);e.unbind(a.domElement,\\\"transitionend\\\",c);e.unbind(a.domElement,\\\"oTransitionEnd\\\",c)};e.bind(this.domElement,\\\"webkitTransitionEnd\\\",\\nc);e.bind(this.domElement,\\\"transitionend\\\",c);e.bind(this.domElement,\\\"oTransitionEnd\\\",c);this.backgroundElement.style.opacity=0;this.domElement.style.opacity=0;this.domElement.style.webkitTransform=\\\"scale(1.1)\\\"};c.prototype.layout=function(){this.domElement.style.left=window.innerWidth/2-e.getWidth(this.domElement)/2+\\\"px\\\";this.domElement.style.top=window.innerHeight/2-e.getHeight(this.domElement)/2+\\\"px\\\"};return c}(dat.dom.dom,dat.utils.common),dat.dom.dom,dat.utils.common);\\nexports.dat = dat;})();\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/AssimpJSONLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/AssimpJSONLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author Alexander Gessler / http://www.greentoken.de/\\n * https://github.com/acgessler\\n *\\n * Loader for models imported with Open Asset Import Library (http://assimp.sf.net)\\n * through assimp2json (https://github.com/acgessler/assimp2json).\\n *\\n * Supports any input format that assimp supports, including 3ds, obj, dae, blend,\\n * fbx, x, ms3d, lwo (and many more).\\n *\\n * See webgl_loader_assimp2json example.\\n */\\n\\nTHREE.AssimpJSONLoader = function ( manager ) {\\n\\n\\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\\n};\\n\\nTHREE.AssimpJSONLoader.prototype = {\\n\\n\\tconstructor: THREE.AssimpJSONLoader,\\n\\n\\ttexturePath : '',\\n\\n\\tload: function ( url, onLoad, onProgress, onError, texturePath ) {\\n          var fonc = \\\"THREE.AssimpJSONLoader.load\\\";\\n          hack.log(\\\"url: \\\"+url+\\\": crossOrigin = \\\"+this.crossOrigin, hack.loader, fonc);\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tthis.texturePath = texturePath && ( typeof texturePath === \\\"string\\\" ) ? texturePath : this.extractUrlBase( url );\\n\\n\\t\\tvar loader = new THREE.XHRLoader( this.manager );\\n\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\tloader.load( url, function ( text ) {\\n\\t\\t\\tvar scene = scope.parse( JSON.parse( text ) );\\n\\t\\t\\tonLoad( scene );\\n\\t\\t} );\\n\\t},\\n\\n\\tsetCrossOrigin: function ( value ) {\\n\\t\\tthis.crossOrigin = value;\\n\\t},\\n\\n\\textractUrlBase: function ( url ) { // from three/src/loaders/Loader.js\\n\\t\\tvar parts = url.split( '/' );\\n\\t\\tparts.pop();\\n\\t\\treturn ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\\n\\t},\\n\\n\\tparse: function ( json ) {\\n\\t\\tvar meshes = this.parseList ( json.meshes, this.parseMesh );\\n\\t\\tvar materials = this.parseList ( json.materials, this.parseMaterial );\\n\\t\\treturn this.parseObject( json, json.rootnode, meshes, materials );\\n\\t},\\n\\n\\tparseList : function(json, handler) {\\n\\t\\tvar meshes = new Array(json.length);\\n\\t\\tfor(var i = 0; i < json.length; ++i) {\\n\\t\\t\\tmeshes[i] = handler.call(this, json[i]);\\n\\t\\t}\\n\\t\\treturn meshes;\\n\\t},\\n\\n\\tparseMesh : function(json) {\\n\\t\\tvar vertex, geometry, i, e, in_data, src;\\n\\n\\n\\t\\tgeometry = new THREE.Geometry();\\n\\n\\t\\t// read vertex positions\\n\\t\\tfor(in_data = json.vertices, i = 0, e = in_data.length; i < e; ) {\\n\\t\\t\\tgeometry.vertices.push( new THREE.Vector3( in_data[ i++ ], in_data[ i++ ], in_data[ i++ ] ) );\\n\\t\\t}\\n\\n\\t\\t// read faces\\n\\t\\tvar cnt = 0;\\n\\t\\tfor(in_data = json.faces, i = 0, e = in_data.length; i < e; ++i) {\\n\\t\\t\\tface = new THREE.Face3();\\n\\t\\t\\tsrc = in_data[i];\\n\\t\\t\\tface.a = src[0];\\n\\t\\t\\tface.b = src[1];\\n\\t\\t\\tface.c = src[2];\\n\\n\\t\\t\\tface.materialIndex = 0; //json.materialindex;\\n\\t\\t\\tgeometry.faces.push(face);\\n\\t\\t}\\n\\n\\t\\t// read texture coordinates - three.js attaches them to its faces\\n\\t\\tjson.texturecoords = json.texturecoords || [];\\n\\t\\tfor(i = 0, e = json.texturecoords.length; i < e; ++i) {\\n\\n\\t\\t\\tfunction convertTextureCoords(in_uv, out_faces, out_vertex_uvs) {\\n\\t\\t\\t\\tvar i, e, face, a, b, c;\\n\\n\\t\\t\\t\\tfor(i = 0, e = out_faces.length; i < e; ++i) {\\n\\t\\t\\t\\t\\tface = out_faces[i];\\n\\t\\t\\t\\t\\ta = face.a * 2;\\n\\t\\t\\t\\t\\tb = face.b * 2;\\n\\t\\t\\t\\t\\tc = face.c * 2;\\n\\t\\t\\t\\t\\tout_vertex_uvs.push([\\n\\t\\t\\t\\t\\t\\tnew THREE.Vector2( in_uv[ a ], in_uv[ a + 1 ] ),\\n\\t\\t\\t\\t\\t\\tnew THREE.Vector2( in_uv[ b ], in_uv[ b + 1 ] ),\\n\\t\\t\\t\\t\\t\\tnew THREE.Vector2( in_uv[ c ], in_uv[ c + 1 ] )\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tconvertTextureCoords(json.texturecoords[i], geometry.faces, geometry.faceVertexUvs[i]);\\n\\t\\t}\\n\\n\\t\\t// read normals - three.js also attaches them to its faces\\n\\t\\tif(json.normals) {\\n\\n\\t\\t\\tfunction convertNormals(in_nor, out_faces) {\\n\\t\\t\\t\\tvar i, e, face, a, b, c;\\n\\n\\t\\t\\t\\tfor(i = 0, e = out_faces.length; i < e; ++i) {\\n\\t\\t\\t\\t\\tface = out_faces[i];\\n\\t\\t\\t\\t\\ta = face.a * 3;\\n\\t\\t\\t\\t\\tb = face.b * 3;\\n\\t\\t\\t\\t\\tc = face.c * 3;\\n\\t\\t\\t\\t\\tface.vertexNormals = [\\n\\t\\t\\t\\t\\t\\tnew THREE.Vector3( in_nor[ a ], in_nor[ a + 1 ], in_nor[ a + 2 ] ),\\n\\t\\t\\t\\t\\t\\tnew THREE.Vector3( in_nor[ b ], in_nor[ b + 1 ], in_nor[ b + 2 ] ),\\n\\t\\t\\t\\t\\t\\tnew THREE.Vector3( in_nor[ c ], in_nor[ c + 1 ], in_nor[ c + 2 ] )\\n\\t\\t\\t\\t\\t];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tconvertNormals(json.normals, geometry.faces);\\n\\t\\t}\\n\\n\\t\\t// read vertex colors - three.js also attaches them to its faces\\n\\t\\tif(json.colors && json.colors[0]) {\\n\\n\\t\\t\\tfunction convertColors(in_color, out_faces) {\\n\\t\\t\\t\\tvar i, e, face, a, b, c;\\n\\n\\t\\t\\t\\tfunction makeColor(start) {\\n\\t\\t\\t\\t\\tvar col = new THREE.Color( );\\n\\t\\t\\t\\t\\tcol.setRGB( arr[0], arr[1], arr[2] );\\n\\t\\t\\t\\t\\t// TODO: what about alpha?\\n\\t\\t\\t\\t\\treturn col;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(i = 0, e = out_faces.length; i < e; ++i) {\\n\\t\\t\\t\\t\\tface = out_faces[i];\\n\\t\\t\\t\\t\\ta = face.a * 4;\\n\\t\\t\\t\\t\\tb = face.b * 4;\\n\\t\\t\\t\\t\\tc = face.c * 4;\\n\\t\\t\\t\\t\\tface.vertexColors = [\\n\\t\\t\\t\\t\\t\\tmakeColor( a ),\\n\\t\\t\\t\\t\\t\\tmakeColor( b ),\\n\\t\\t\\t\\t\\t\\tmakeColor( c )\\n\\t\\t\\t\\t\\t];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tconvertColors(json.colors[0], geometry.faces);\\n\\t\\t}\\n\\n\\n\\t\\t//geometry.computeFaceNormals();\\n\\t\\t//geometry.computeVertexNormals();\\n\\t\\t//geometry.computeTangents();\\n\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t// TODO: tangents\\n\\t\\treturn geometry;\\n\\t},\\n\\n\\tparseMaterial : function(json) {\\n          var func = \\\"THREE.AssimpJSONLoader.parseMaterial\\\";\\n          // *tiddlywiki*\\n          // It seems that this algorithm has bugs !\\n          // Due to the fact that images are asynchronously loaded, it made the assumption\\n          // that textures are loaded after all json is parsed. With TiddlyWiki, it's not the\\n          // case because image Tiddler's file are immediately and synchronously loaded.\\n          // The result is that <mat> variable is null and clashes when the onLoad() callback of the\\n          // image loader tries to make something of the texture with <mat>.\\n          //\\n          // The fix : cancel the texture loading and wait till all json is parsed\\n          // and <mat> is initialized with a coherent THREE.MeshPhongMaterial instance. After\\n          // that, a second pass resumes the normal loading of the textures.\\n\\n\\t\\tvar mat = null, \\n\\t\\tscope = this, i, prop, has_textures = [],\\n\\n\\t\\tinit_props = {\\n\\t\\t\\tshading : THREE.SmoothShading\\n\\t\\t};\\n\\n\\t\\tfunction toColor(value_arr) {\\n\\t\\t\\tvar col = new THREE.Color();\\n\\t\\t\\tcol.setRGB(value_arr[0],value_arr[1],value_arr[2]);\\n\\t\\t\\treturn col;\\n\\t\\t}\\n\\n\\t\\tfunction defaultTexture() {\\n\\t\\t\\tvar im = new Image();\\n\\t\\t\\tim.width = 1;\\n\\t\\t\\tim.height = 1;\\n\\t\\t\\treturn new THREE.Texture(im);\\n\\t\\t}\\n\\n          // *tiddlywiki*\\n          var flagTiddler = false;\\n\\n\\t\\tfor (var i in json.properties) {\\n\\t\\t\\tprop = json.properties[i];\\n\\n\\t\\t\\tif(prop.key === '$tex.file') {\\n\\t\\t\\t\\t// prop.semantic gives the type of the texture\\n\\t\\t\\t\\t// 1: diffuse\\n\\t\\t\\t\\t// 2: specular mao\\n\\t\\t\\t\\t// 5: height map (bumps)\\n\\t\\t\\t\\t// 6: normal map\\n\\t\\t\\t\\t// more values (i.e. emissive, environment) are known by assimp and may be relevant\\n\\t\\t\\t\\tif(prop.semantic === 1 || prop.semantic === 5 || prop.semantic === 6 || prop.semantic === 2) {\\n\\t\\t\\t\\t\\t(function(semantic) {\\n\\t\\t\\t\\t\\t\\tvar loader = new THREE.TextureLoader(scope.manager),\\n\\t\\t\\t\\t\\t\\tkeyname;\\n\\n\\t\\t\\t\\t\\t\\tif(semantic === 1) {\\n\\t\\t\\t\\t\\t\\t\\tkeyname = 'map';\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(semantic === 5) {\\n\\t\\t\\t\\t\\t\\t\\tkeyname = 'bumpMap';\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(semantic === 6) {\\n\\t\\t\\t\\t\\t\\t\\tkeyname = 'normalMap';\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(semantic === 2) {\\n\\t\\t\\t\\t\\t\\t\\tkeyname = 'specularMap';\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\thas_textures.push(keyname);\\n\\n\\t\\t\\t\\t\\t\\tloader.setCrossOrigin(this.crossOrigin);\\n\\t\\t\\t\\t\\t\\tvar material_url = scope.texturePath + '/' + prop.value\\n\\t\\t\\t\\t\\t\\tmaterial_url = material_url.replace(/\\\\\\\\/g, '/');\\n\\n                                          if (TiddlyWiki && material_url.match(/^tw:/)) {\\n                                            flagTiddler = true;\\n                                            hack.log(\\\"PASS 1: ignoring textures in tiddler's file\\\", hack.loader, func);\\n                                            return;\\n                                          }\\n\\t\\t\\t\\t\\t\\tloader.load(material_url, function(tex) {\\n\\t\\t\\t\\t\\t\\t\\tif(tex) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// TODO: read texture settings from assimp.\\n\\t\\t\\t\\t\\t\\t\\t\\t// Wrapping is the default, though.\\n\\t\\t\\t\\t\\t\\t\\t\\ttex.wrapS = tex.wrapT = THREE.RepeatWrapping;\\n\\n                                                          if (TiddlyWiki) {\\n                                                            if (mat) {\\n\\t\\t\\t\\t\\t\\t\\t      mat[keyname] = tex;\\n\\t\\t\\t\\t\\t\\t\\t      mat.needsUpdate = true;\\n                                                            }\\n                                                          } else {\\n\\t\\t\\t\\t\\t\\t\\t\\tmat[keyname] = tex;\\n\\t\\t\\t\\t\\t\\t\\t\\tmat.needsUpdate = true;\\n                                                          }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t})(prop.semantic);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(prop.key === '?mat.name') {\\n\\t\\t\\t\\tinit_props.name = prop.value;\\n\\t\\t\\t}\\n\\t\\t\\telse if(prop.key === '$clr.diffuse') {\\n\\t\\t\\t\\tinit_props.color = toColor(prop.value);\\n\\t\\t\\t}\\n\\t\\t\\telse if(prop.key === '$clr.specular') {\\n\\t\\t\\t\\tinit_props.specular = toColor(prop.value);\\n\\t\\t\\t}\\n\\t\\t\\telse if(prop.key === '$clr.ambient') {\\n\\t\\t\\t\\tinit_props.ambient = toColor(prop.value);\\n\\t\\t\\t}\\n\\t\\t\\telse if(prop.key === '$clr.emissive') {\\n\\t\\t\\t\\tinit_props.emissive = toColor(prop.value);\\n\\t\\t\\t}\\n\\t\\t\\telse if(prop.key === '$mat.shadingm') {\\n\\t\\t\\t\\t// aiShadingMode_Flat\\n\\t\\t\\t\\tif (prop.value === 1) {\\n\\t\\t\\t\\t\\tinit_props.shading = THREE.FlatShading;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (prop.key === '$mat.shininess') {\\n\\t\\t\\t\\tinit_props.shininess = prop.value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(!init_props.ambient) {\\n\\t\\t\\tinit_props.ambient = init_props.color;\\n\\t\\t}\\n\\n\\t\\t// note: three.js does not like it when a texture is added after the geometry\\n\\t\\t// has been rendered once, see http://stackoverflow.com/questions/16531759/.\\n\\t\\t// for this reason we fill all slots upfront with default textures\\n\\t\\tif(has_textures.length) {\\n\\t\\t\\tfor(i = has_textures.length-1; i >= 0; --i) {\\n\\t\\t\\t\\tinit_props[has_textures[i]] = defaultTexture();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n                mat = new THREE.MeshPhongMaterial( init_props );\\n\\n          if (TiddlyWiki && flagTiddler) {\\n            // New pass to handle tiddler files\\n            hack.log(\\\"PASS 2: loading textures in tiddler's file\\\", hack.loader, func);\\n\\n\\t    has_textures = [];\\n\\n\\t    for (var i in json.properties) {\\n\\t      prop = json.properties[i];\\n\\t      if(prop.key === '$tex.file') {\\n\\t\\t// prop.semantic gives the type of the texture\\n\\t\\t// 1: diffuse\\n\\t\\t// 2: specular mao\\n\\t\\t// 5: height map (bumps)\\n\\t\\t// 6: normal map\\n\\t\\t// more values (i.e. emissive, environment) are known by assimp and may be relevant\\n\\t\\tif(prop.semantic === 1 || prop.semantic === 5 || prop.semantic === 6 || prop.semantic === 2) {\\n\\t\\t  (function(semantic) {\\n\\t\\t    var loader = new THREE.TextureLoader(scope.manager), keyname;\\n\\t\\t    if(semantic === 1) keyname = 'map';\\n\\t\\t    else if(semantic === 5) keyname = 'bumpMap';\\n\\t\\t    else if(semantic === 6) keyname = 'normalMap';\\n\\t\\t    else if(semantic === 2) keyname = 'specularMap';\\n\\t\\t    has_textures.push(keyname);\\n\\t\\t    loader.setCrossOrigin(this.crossOrigin);\\n\\t\\t    var material_url = scope.texturePath + '/' + prop.value\\n\\t\\t    material_url = material_url.replace(/\\\\\\\\/g, '/');\\n\\t\\t    loader.load(material_url, function(tex) {\\n\\t\\t      if(tex) {\\n\\t\\t\\t// TODO: read texture settings from assimp.\\n\\t\\t\\t// Wrapping is the default, though.\\n\\t\\t\\ttex.wrapS = tex.wrapT = THREE.RepeatWrapping;\\n                        if (mat) {\\n\\t\\t\\t  mat[keyname] = tex;\\n\\t\\t\\t  mat.needsUpdate = true;\\n                        }\\n\\t\\t      }\\n\\t\\t    });\\n\\t\\t  })(prop.semantic);\\n\\t\\t}\\n\\t      }\\n            }\\n          }\\n              \\n\\t      return mat;\\n\\t},\\n\\n\\tparseObject : function(json, node, meshes, materials) {\\n\\t\\tvar obj = new THREE.Object3D()\\n\\t\\t,\\ti\\n\\t\\t,\\tidx\\n\\t\\t;\\n\\n\\t\\tobj.name = node.name || \\\"\\\";\\n\\t\\tobj.matrix = new THREE.Matrix4().fromArray(node.transformation).transpose();\\n\\t\\tobj.matrix.decompose( obj.position, obj.quaternion, obj.scale );\\n\\n\\t\\tfor(i = 0; node.meshes && i < node.meshes.length; ++i) {\\n\\t\\t\\tidx = node.meshes[i];\\n\\t\\t\\tobj.add(new THREE.Mesh( meshes[idx], materials[json.meshes[idx].materialindex] ));\\n\\t\\t}\\n\\n\\t\\tfor(i = 0; node.children && i < node.children.length; ++i) {\\n\\t\\t\\tobj.add(this.parseObject(json, node.children[i], meshes, materials));\\n\\t\\t}\\n\\n\\t\\treturn obj;\\n\\t},\\n};\\n\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/AWDLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/AWDLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * Author: Pierre Lepers\\n * Date: 09/12/2013 17:21\\n */\\n\\nTHREE.AWDLoader = (function (){\\n\\n\\n\\n  var UNCOMPRESSED  = 0,\\n      DEFLATE       = 1,\\n      LZMA          = 2,\\n\\n      AWD_FIELD_INT8      = 1,\\n      AWD_FIELD_INT16     = 2,\\n      AWD_FIELD_INT32     = 3,\\n      AWD_FIELD_UINT8     = 4,\\n      AWD_FIELD_UINT16    = 5,\\n      AWD_FIELD_UINT32    = 6,\\n      AWD_FIELD_FLOAT32   = 7,\\n      AWD_FIELD_FLOAT64   = 8,\\n      AWD_FIELD_BOOL      = 21,\\n      AWD_FIELD_COLOR     = 22,\\n      AWD_FIELD_BADDR     = 23,\\n      AWD_FIELD_STRING    = 31,\\n      AWD_FIELD_BYTEARRAY = 32,\\n      AWD_FIELD_VECTOR2x1 = 41,\\n      AWD_FIELD_VECTOR3x1 = 42,\\n      AWD_FIELD_VECTOR4x1 = 43,\\n      AWD_FIELD_MTX3x2    = 44,\\n      AWD_FIELD_MTX3x3    = 45,\\n      AWD_FIELD_MTX4x3    = 46,\\n      AWD_FIELD_MTX4x4    = 47,\\n\\n      BOOL       = 21,\\n      COLOR      = 22,\\n      BADDR      = 23,\\n\\n      INT8    = 1,\\n      INT16   = 2,\\n      INT32   = 3,\\n      UINT8   = 4,\\n      UINT16  = 5,\\n      UINT32  = 6,\\n      FLOAT32 = 7,\\n      FLOAT64 = 8;\\n\\n\\n  var littleEndian = true;\\n\\n  // ResourcesLoader\\n  // =============\\n  // handle loading for external resources\\n  function ResourcesLoader( awdUrl ){\\n    var func = \\\"THREE.AWDLoader.ResourcesLoader\\\";\\n\\n    this._baseDir = awdUrl.substr( 0, awdUrl.lastIndexOf( '/' )+1 );\\n\\n    this._loadingManager = new THREE.LoadingManager();\\n\\n  }\\n\\n  ResourcesLoader.prototype = {\\n\\n    loadTexture : function( path ){\\n      var tex = new THREE.Texture();\\n\\n      var loader = new THREE.ImageLoader( this._loadingManager );\\n\\n      loader.load( this._baseDir+path, function( image ) {\\n        tex.image = image;\\n        tex.needsUpdate = true;\\n      });\\n\\n      return tex;\\n\\n    }\\n  }\\n\\n\\n\\n  function Block(){\\n    this.id = 0;\\n    this.data = null;\\n  }\\n\\n\\n\\n  function AWDLoader( showStatus ) {\\n\\n    THREE.Loader.call( this, showStatus );\\n\\n    this.trunk = new THREE.Object3D();\\n\\n    this.materialFactory = undefined;\\n\\n    this._resourceLoader = null;\\n    this._url = null;\\n\\n    this._data;\\n    this._ptr = 0;\\n\\n    this._version =  [];\\n    this._streaming = false;\\n    this._optimized_for_accuracy = false;\\n    this._compression = 0;\\n    this._bodylen = 0xFFFFFFFF;\\n\\n\\n    this._blocks = [ new Block() ];\\n\\n    this._accuracyMatrix  = false;\\n    this._accuracyGeo     = false;\\n    this._accuracyProps   = false;\\n\\n\\n  };\\n\\n\\n  AWDLoader.prototype = new THREE.Loader();\\n\\n  AWDLoader.prototype.constructor = AWDLoader;\\n\\n  AWDLoader.prototype.load = function ( url, callback ) {\\n    var func = \\\"THREE.AWDLoader.load\\\";\\n\\n    if (TiddlyWiki && url.match(/^tw:/)) {\\n      this._url = url;\\n      var res = TiddlyWiki.load(url);\\n      //hack.log(\\\"res.byteLength = \\\"+res.byteLength, hack.loader, func);\\n      this.parse(res);\\n      callback(this.trunk);\\n      hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n      return;\\n    }\\n\\n    var that = this;\\n    this._url = url;\\n    var xhr = new XMLHttpRequest();\\n    xhr.open( \\\"GET\\\", url, true );\\n    xhr.responseType = 'arraybuffer';\\n\\n    xhr.onreadystatechange = function () {\\n\\n      if ( xhr.readyState == 4 ) {\\n\\n        if ( xhr.status == 200 || xhr.status == 0 ) {\\n          that.parse( xhr.response );\\n          callback( that.trunk );\\n\\n        } else {\\n\\n          console.error( 'AWDLoader: Couldn\\\\'t load ' + url + ' (' + xhr.status + ')' );\\n\\n        }\\n\\n      }\\n\\n    };\\n\\n    xhr.send( null );\\n\\n  };\\n\\n  AWDLoader.prototype.parse = function ( data ) {\\n    var func = \\\"THREE.AWDLoader.parse\\\";\\n\\n    var blen = data.byteLength;\\n\\n    this._ptr = 0;\\n    this._data = new DataView( data );\\n\\n    this._parseHeader( );\\n\\n    if( this._compression != 0  ) {\\n      console.error( 'compressed AWD not supported' );\\n    }\\n\\n    if (!this._streaming && this._bodylen != data.byteLength - this._ptr ) {\\n      console.error('AWDLoader: body len does not match file length', this._bodylen ,  blen - this._ptr);\\n    }\\n\\n    while ( this._ptr < blen ) {\\n      this.parseNextBlock();\\n    }\\n\\n  }\\n\\n\\n\\n  AWDLoader.prototype.parseNextBlock = function ( ) {\\n\\n    var assetData,\\n        ns, type, len, block,\\n        blockId = this.readU32(),\\n        ns      = this.readU8(),\\n        type    = this.readU8(),\\n        flags   = this.readU8(),\\n        len     = this.readU32();\\n\\n\\n    switch (type) {\\n      case 1:\\n        assetData = this.parseMeshData(len);\\n        break;\\n      case 22:\\n        assetData = this.parseContainer(len);\\n        break;\\n      case 23:\\n        assetData = this.parseMeshInstance(len);\\n        break;\\n      case 81:\\n        assetData = this.parseMaterial(len);\\n        break;\\n      case 82:\\n        assetData = this.parseTexture(len);\\n        break;\\n      case 101:\\n        assetData = this.parseSkeleton(len);\\n        break;\\n\\n//      case 111:\\n//        assetData = this.parseMeshPoseAnimation(len, true);\\n//        break;\\n      case 112:\\n        assetData = this.parseMeshPoseAnimation(len, false);\\n        break;\\n      case 113:\\n        assetData = this.parseVertexAnimationSet(len);\\n        break;\\n      case 102:\\n      \\tassetData = this.parseSkeletonPose(len);\\n      \\tbreak;\\n      case 103:\\n      \\tassetData = this.parseSkeletonAnimation(len);\\n      \\tbreak;\\n      case 122:\\n        assetData = this.parseAnimatorSet(len);\\n        break;\\n      // case 121:\\n      // \\tassetData = parseUVAnimation(len);\\n      // \\tbreak;\\n      default:\\n        //debug('Ignoring block!',type, len);\\n        this._ptr += len;\\n        break;\\n    }\\n\\n\\n    // Store block reference for later use\\n    this._blocks[blockId] = block = new Block();\\n    block.data = assetData;\\n    block.id = blockId;\\n\\n  }\\n\\n\\n  AWDLoader.prototype._parseHeader = function () {\\n\\n    var version = this._version,\\n        awdmagic =\\n            ( this.readU8()<<16)\\n        |   ( this.readU8()<<8 )\\n        |     this.readU8();\\n\\n    if( awdmagic != 4282180 )\\n      throw new Error( \\\"AWDLoader - bad magic\\\" );\\n\\n    version[0] = this.readU8();\\n    version[1] = this.readU8();\\n\\n    var flags = this.readU16();\\n\\n    this._streaming = (flags & 0x1) == 0x1;\\n\\n    if ((version[0] === 2) && (version[1] === 1)) {\\n      this._accuracyMatrix =  (flags & 0x2) === 0x2;\\n      this._accuracyGeo =     (flags & 0x4) === 0x4;\\n      this._accuracyProps =   (flags & 0x8) === 0x8;\\n    }\\n\\n    this._geoNrType     = this._accuracyGeo     ? FLOAT64 : FLOAT32;\\n    this._matrixNrType  = this._accuracyMatrix  ? FLOAT64 : FLOAT32;\\n    this._propsNrType   = this._accuracyProps   ? FLOAT64 : FLOAT32;\\n\\n    this._optimized_for_accuracy \\t= (flags & 0x2) === 0x2;\\n\\n    this._compression = this.readU8();\\n    this._bodylen = this.readU32();\\n\\n\\n  }\\n\\n\\n  AWDLoader.prototype.parseContainer = function ( len ) {\\n    var parent,\\n        ctr     = new THREE.Object3D(),\\n        par_id  = this.readU32(),\\n        mtx     = this.parseMatrix4();\\n\\n    ctr.name = this.readUTF();\\n    ctr.applyMatrix( mtx );\\n\\n    parent = this._blocks[par_id].data || this.trunk;\\n    parent.add(ctr);\\n\\n    this.parseProperties({\\n      1:this._matrixNrType,\\n      2:this._matrixNrType,\\n      3:this._matrixNrType,\\n      4:UINT8\\n    });\\n\\n    ctr.extra = this.parseUserAttributes();\\n\\n    return ctr;\\n  }\\n\\n\\n\\n  AWDLoader.prototype.parseMeshInstance = function ( len ) {\\n    var name,\\n        mesh, geometries, meshLen, meshes,\\n        par_id, data_id,\\n        mtx,\\n        materials, mat, mat_id,\\n        num_materials,\\n        materials_parsed,\\n        parent,\\n        i;\\n\\n    par_id        = this.readU32();\\n    mtx           = this.parseMatrix4();\\n    name          = this.readUTF();\\n    data_id       = this.readU32();\\n    num_materials = this.readU16();\\n\\n    geometries = this.getBlock( data_id );\\n\\n    materials = [];\\n    materials_parsed = 0;\\n\\n    for ( i = 0; i < num_materials; i++) {\\n      mat_id = this.readU32();\\n      mat = this.getBlock( mat_id );\\n      materials.push( mat );\\n    }\\n\\n\\n\\n    meshLen = geometries.length\\n    meshes = [];\\n\\n    // TODO : BufferGeometry don't support \\\"geometryGroups\\\" for now.\\n    // so we create sub meshes for each groups\\n    if( meshLen  > 1 ) {\\n      mesh = new THREE.Object3D()\\n      for ( i = 0; i < meshLen; i++) {\\n        var sm = new THREE.Mesh( geometries[i] );\\n        meshes.push( sm );\\n        mesh.add( sm );\\n      }\\n    }\\n    else {\\n      mesh = new THREE.Mesh( geometries[0] );\\n      meshes.push( mesh );\\n    }\\n\\n    mesh.applyMatrix( mtx );\\n    mesh.name = name;\\n\\n\\n    parent = this.getBlock( par_id ) || this.trunk;\\n    parent.add( mesh );\\n\\n\\n    var matLen = materials.length;\\n    var maxLen = Math.max( meshLen, matLen);\\n    for( i = 0; i< maxLen; i++ )\\n      meshes[ i%meshLen ].material = materials[ i % matLen ];\\n\\n\\n    // Ignore for now\\n    this.parseProperties( null );\\n    mesh.extra = this.parseUserAttributes();\\n\\n    return mesh;\\n  }\\n\\n\\n\\n  AWDLoader.prototype.parseMaterial = function ( len ) {\\n    var name,\\n        type,\\n        props,\\n        mat,\\n        attributes,\\n        finalize,\\n        num_methods,\\n        methods_parsed;\\n\\n    name        = this.readUTF();\\n    type        = this.readU8();\\n    num_methods = this.readU8();\\n\\n    //log( \\\"AWDLoader parseMaterial \\\",name )\\n\\n    // Read material numerical properties\\n    // (1=color, 2=bitmap url, 11=alpha_blending, 12=alpha_threshold, 13=repeat)\\n    props = this.parseProperties({\\n      1:  AWD_FIELD_INT32,\\n      2:  AWD_FIELD_BADDR,\\n      11: AWD_FIELD_BOOL,\\n      12: AWD_FIELD_FLOAT32,\\n      13: AWD_FIELD_BOOL\\n    });\\n\\n    methods_parsed = 0;\\n\\n    while( methods_parsed < num_methods ) {\\n      var method_type = this.readU16();\\n      this.parseProperties( null );\\n      this.parseUserAttributes();\\n    }\\n\\n    attributes = this.parseUserAttributes();\\n\\n    if( this.materialFactory !== undefined ) {\\n      mat = this.materialFactory( name );\\n      if( mat ) return mat;\\n    }\\n\\n    mat = new THREE.MeshPhongMaterial();\\n\\n    if (type === 1) { // Color material\\n      mat.color.setHex( props.get(1, 0xcccccc) );\\n    }\\n    else if (type === 2) { // Bitmap material\\n      var tex_addr = props.get(2, 0);\\n      mat.map = this.getBlock( tex_addr );\\n    }\\n\\n    mat.extra = attributes;\\n    mat.alphaThreshold = props.get(12, 0.0);\\n    mat.repeat = props.get(13, false);\\n\\n\\n    return mat;\\n  }\\n\\n\\n\\n\\n  AWDLoader.prototype.parseTexture = function( len ) {\\n\\n\\n    var name = this.readUTF(),\\n        type = this.readU8(),\\n        asset,\\n        data_len;\\n\\n    // External\\n    if (type === 0) {\\n      data_len = this.readU32();\\n      var url = this.readUTFBytes(data_len);\\n      console.log( url );\\n\\n      asset = this.loadTexture( url );\\n    } else {\\n      // embed texture not supported\\n    }\\n    // Ignore for now\\n    this.parseProperties( null );\\n\\n    this.parseUserAttributes();\\n    return asset;\\n  }\\n\\n  AWDLoader.prototype.loadTexture = function( url ) {\\n    var func = \\\"AWDLoader.loadTexture\\\";\\n\\n    if( null === this._resourceLoader )\\n      this._resourceLoader = new ResourcesLoader( this._url );\\n\\n    return this._resourceLoader.loadTexture( url );\\n  }\\n\\n  // broken : skeleton pose format is different than threejs one\\n  AWDLoader.prototype.parseSkeleton = function(len) // Array<Bone>\\n  {\\n    var name          = this.readUTF(),\\n        num_joints    = this.readU16(),\\n        skeleton      = [],\\n        joints_parsed = 0;\\n\\n    this.parseProperties( null );\\n\\n    while (joints_parsed < num_joints) {\\n      var joint, ibp;\\n\\n      // Ignore joint id\\n      this.readU16();\\n\\n      joint = new THREE.Bone();\\n      joint.parent = this.readU16() - 1; // 0=null in AWD\\n      joint.name = this.readUTF();\\n\\n      ibp = this.parseMatrix4();\\n      joint.skinMatrix = ibp;\\n\\n      // Ignore joint props/attributes for now\\n      this.parseProperties(null);\\n      this.parseUserAttributes();\\n\\n      skeleton.push(joint);\\n      joints_parsed++;\\n    }\\n\\n    // Discard attributes for now\\n    this.parseUserAttributes();\\n\\n\\n    return skeleton;\\n  }\\n\\n\\n\\n  AWDLoader.prototype.parseSkeletonPose = function(blockID)\\n  {\\n    var name = this.readUTF();\\n\\n\\n    var num_joints = this.readU16();\\n    this.parseProperties(null);\\n\\n    // debug( 'parse Skeleton Pose. joints : ' + num_joints);\\n\\n    var pose = [];\\n\\n    var joints_parsed = 0;\\n\\n    while (joints_parsed < num_joints) {\\n\\n      var joint_pose;\\n\\n      var has_transform; //:uint;\\n      var mtx_data;\\n\\n      has_transform = this.readU8();\\n\\n      if (has_transform === 1) {\\n        mtx_data = this.parseMatrix4();\\n      } else\\n      {\\n        mtx_data = new THREE.Matrix4();\\n      }\\n      pose[joints_parsed] = mtx_data;\\n      joints_parsed++;\\n    }\\n    // Skip attributes for now\\n    this.parseUserAttributes();\\n\\n    return pose\\n  }\\n\\n  AWDLoader.prototype.parseSkeletonAnimation = function(blockID)\\n  {\\n    var frame_dur;\\n    var pose_addr;\\n    var pose;\\n\\n    var name = this.readUTF();\\n\\n    var clip = [];\\n\\n    var num_frames = this.readU16();\\n    this.parseProperties(null);\\n\\n    var frames_parsed = 0;\\n    var returnedArray;\\n\\n\\n    // debug( 'parse Skeleton Animation. frames : ' + num_frames);\\n\\n    while (frames_parsed < num_frames) {\\n      pose_addr = this.readU32();\\n      frame_dur = this.readU16();\\n\\n      pose = this._blocks[pose_addr].data\\n      // debug( 'pose address ',pose[2].elements[12],pose[2].elements[13],pose[2].elements[14] );\\n      clip.push( {\\n        pose : pose,\\n        duration : frame_dur\\n      } );\\n\\n      frames_parsed++;\\n    }\\n    if (clip.length == 0) {\\n      // debug(\\\"Could not this SkeletonClipNode, because no Frames where set.\\\");\\n      return;\\n    }\\n    // Ignore attributes for now\\n    this.parseUserAttributes();\\n    return clip;\\n  }\\n\\n\\n\\n  AWDLoader.prototype.parseVertexAnimationSet = function(len)\\n  {\\n    var poseBlockAdress,\\n        name           = this.readUTF(),\\n        num_frames     = this.readU16(),\\n        props          = this.parseProperties({1:UINT16}),\\n        frames_parsed  = 0,\\n        skeletonFrames = [];\\n\\n    while (frames_parsed < num_frames) {\\n      poseBlockAdress = this.readU32();\\n      skeletonFrames.push(this._blocks[poseBlockAdress].data);\\n      frames_parsed++;\\n    }\\n\\n    this.parseUserAttributes();\\n\\n\\n    return skeletonFrames;\\n  }\\n\\n\\n  AWDLoader.prototype.parseAnimatorSet = function(len)\\n  {\\n    var targetMesh;\\n\\n    var animSetBlockAdress; //:int\\n\\n    var targetAnimationSet; //:AnimationSetBase;\\n    var outputString = \\\"\\\"; //:String = \\\"\\\";\\n    var name = this.readUTF();\\n    var type = this.readU16();\\n\\n    var props = this.parseProperties({1:BADDR});\\n\\n    animSetBlockAdress = this.readU32();\\n    var targetMeshLength = this.readU16();\\n\\n    var meshAdresses = []; //:Vector.<uint> = new Vector.<uint>;\\n\\n    for (var i = 0; i < targetMeshLength; i++)\\n      meshAdresses.push( this.readU32() );\\n\\n    var activeState = this.readU16();\\n    var autoplay = Boolean(this.readU8());\\n    this.parseUserAttributes();\\n    this.parseUserAttributes();\\n\\n    var returnedArray;\\n    var targetMeshes = []; //:Vector.<Mesh> = new Vector.<Mesh>;\\n\\n    for (i = 0; i < meshAdresses.length; i++) {\\n//      returnedArray = getAssetByID(meshAdresses[i], [AssetType.MESH]);\\n//      if (returnedArray[0])\\n        targetMeshes.push(this._blocks[meshAdresses[i]].data);\\n    }\\n\\n    targetAnimationSet = this._blocks[animSetBlockAdress].data\\n    var thisAnimator;\\n\\n    if (type == 1) {\\n\\n\\n      thisAnimator = {\\n        animationSet : targetAnimationSet,\\n        skeleton : this._blocks[props.get(1, 0)].data\\n      };\\n\\n    } else if (type == 2) {\\n      // debug( \\\"vertex Anim???\\\");\\n    }\\n\\n\\n    for (i = 0; i < targetMeshes.length; i++) {\\n        targetMeshes[i].animator = thisAnimator;\\n    }\\n    // debug(\\\"Parsed a Animator: Name = \\\" + name);\\n\\n    return thisAnimator;\\n  }\\n\\n\\n\\n\\n\\n\\n\\n  AWDLoader.prototype.parseMeshData = function ( len ) {\\n\\n    var name      = this.readUTF(),\\n        num_subs  = this.readU16(),\\n        geom,\\n        subs_parsed = 0,\\n        props,\\n        buffer,\\n        skinW, skinI,\\n        geometries = [];\\n\\n\\n\\n\\n    props = this.parseProperties({\\n      1: this._geoNrType,\\n      2: this._geoNrType\\n    });\\n\\n\\n\\n    // Loop through sub meshes\\n    while (subs_parsed < num_subs) {\\n\\n      var sm_len, sm_end, attrib;\\n\\n      geom = new THREE.BufferGeometry();\\n      geom.name = name;\\n      geometries.push( geom );\\n\\n\\n      sm_len = this.readU32();\\n      sm_end = this._ptr + sm_len;\\n\\n\\n      // Ignore for now\\n      this.parseProperties({1:this._geoNrType, 2:this._geoNrType});\\n\\n      // Loop through data streams\\n      while ( this._ptr < sm_end ) {\\n\\n\\n        var idx = 0,\\n            str_type  = this.readU8(),\\n            str_ftype = this.readU8(),\\n            str_len   = this.readU32(),\\n            str_end   = str_len + this._ptr;\\n\\n\\n\\n\\n\\n        // VERTICES\\n        // ------------------\\n        if ( str_type === 1 ) {\\n\\n          buffer = new Float32Array( ( str_len / 12 ) * 3 );\\n          attrib = new THREE.BufferAttribute( buffer, 3 );\\n\\n          geom.addAttribute( 'position', attrib );\\n          idx = 0;\\n\\n          while (this._ptr < str_end) {\\n            buffer[idx]   = -this.readF32();\\n            buffer[idx+1] = this.readF32();\\n            buffer[idx+2] = this.readF32();\\n            idx+=3;\\n          }\\n        }\\n\\n\\n        // INDICES\\n        // -----------------\\n        else if (str_type === 2) {\\n\\n          buffer = new Uint16Array( str_len / 2 );\\n          attrib = new THREE.BufferAttribute( buffer, 1 );\\n          geom.addAttribute( 'index', attrib );\\n\\n          geom.offsets.push({\\n            start: 0,\\n            index: 0,\\n            count: str_len/2\\n          });\\n\\n          idx = 0;\\n\\n          while (this._ptr < str_end) {\\n            buffer[idx+1]   = this.readU16();\\n            buffer[idx]     = this.readU16();\\n            buffer[idx+2]   = this.readU16();\\n            idx+=3;\\n          }\\n        }\\n\\n        // UVS\\n        // -------------------\\n        else if (str_type === 3) {\\n\\n          buffer = new Float32Array( ( str_len / 8 ) * 2 );\\n          attrib = new THREE.BufferAttribute( buffer, 2 );\\n\\n          geom.addAttribute( 'uv', attrib );\\n          idx = 0;\\n\\n          while (this._ptr < str_end) {\\n            buffer[idx]   = this.readF32();\\n            buffer[idx+1] = 1.0-this.readF32();\\n            idx+=2;\\n          }\\n        }\\n\\n        // NORMALS\\n        else if (str_type === 4) {\\n\\n          buffer = new Float32Array( ( str_len / 12 ) * 3 );\\n          attrib = new THREE.BufferAttribute( buffer, 3 );\\n          geom.addAttribute( 'normal', attrib );\\n          idx = 0;\\n\\n          while (this._ptr < str_end) {\\n            buffer[idx]   = -this.readF32();\\n            buffer[idx+1] = this.readF32();\\n            buffer[idx+2] = this.readF32();\\n            idx+=3;\\n          }\\n\\n        }\\n\\n        // else if (str_type == 6) {\\n        //   skinI = new Float32Array( str_len>>1 );\\n        //   idx = 0\\n\\n        //   while (this._ptr < str_end) {\\n        //     skinI[idx]   = this.readU16();\\n        //     idx++;\\n        //   }\\n\\n        // }\\n        // else if (str_type == 7) {\\n        //   skinW = new Float32Array( str_len>>2 );\\n        //   idx = 0;\\n\\n        //   while (this._ptr < str_end) {\\n        //     skinW[idx]   = this.readF32();\\n        //     idx++;\\n        //   }\\n        // }\\n        else {\\n          this._ptr = str_end;\\n        }\\n\\n\\n\\n      }\\n\\n      this.parseUserAttributes();\\n\\n\\n      geom.computeBoundingSphere();\\n      subs_parsed++;\\n    }\\n\\n\\n    //geom.computeFaceNormals();\\n\\n\\n    this.parseUserAttributes();\\n    //finalizeAsset(geom, name);\\n\\n    return geometries;\\n  }\\n\\n  AWDLoader.prototype.parseMeshPoseAnimation = function(len, poseOnly)\\n  {\\n    var num_frames = 1,\\n        num_submeshes,\\n        frames_parsed,\\n        subMeshParsed,\\n        frame_dur,\\n        x, y, z,\\n\\n        str_len,\\n        str_end,\\n        geom,\\n        subGeom,\\n        idx = 0,\\n        clip = {},\\n        indices,\\n        verts,\\n        num_Streams,\\n        streamsParsed,\\n        streamtypes = [],\\n\\n        props,\\n        thisGeo,\\n        name = this.readUTF(),\\n        geoAdress = this.readU32();\\n\\n\\n    var mesh = this.getBlock( geoAdress );\\n\\n    if (mesh == null) {\\n      console.log( \\\"parseMeshPoseAnimation target mesh not found at:\\\", geoAdress );\\n      return;\\n    }\\n\\n    geom = mesh.geometry;\\n    geom.morphTargets = [];\\n\\n    if (!poseOnly)\\n      num_frames = this.readU16();\\n\\n    num_submeshes = this.readU16();\\n    num_Streams = this.readU16();\\n\\n    // debug(\\\"VA num_frames : \\\", num_frames );\\n    // debug(\\\"VA num_submeshes : \\\", num_submeshes );\\n    // debug(\\\"VA numstreams : \\\", num_Streams );\\n\\n    streamsParsed = 0;\\n    while (streamsParsed < num_Streams) {\\n      streamtypes.push(this.readU16());\\n      streamsParsed++;\\n    }\\n    props = this.parseProperties({1:BOOL, 2:BOOL});\\n\\n    clip.looping = props.get(1, true);\\n    clip.stitchFinalFrame = props.get(2, false);\\n\\n    frames_parsed = 0;\\n\\n    while (frames_parsed < num_frames) {\\n\\n      frame_dur = this.readU16();\\n      subMeshParsed = 0;\\n\\n      while (subMeshParsed < num_submeshes) {\\n\\n        streamsParsed = 0;\\n        str_len = this.readU32();\\n        str_end = this._ptr + str_len;\\n\\n        while (streamsParsed < num_Streams) {\\n\\n          if (streamtypes[streamsParsed] == 1) {\\n\\n            //geom.addAttribute( 'morphTarget'+frames_parsed, Float32Array, str_len/12, 3 );\\n            var buffer = new Float32Array(str_len/4);\\n            geom.morphTargets.push( {\\n              array : buffer\\n            });\\n\\n            //buffer = geom.attributes['morphTarget'+frames_parsed].array\\n            idx = 0;\\n\\n            while ( this._ptr < str_end ) {\\n              buffer[idx]     = this.readF32();\\n              buffer[idx+1]   = this.readF32();\\n              buffer[idx+2]   = this.readF32();\\n              idx += 3;\\n            }\\n\\n\\n            subMeshParsed++;\\n          } else\\n            this._ptr = str_end;\\n          streamsParsed++;\\n        }\\n      }\\n\\n\\n      frames_parsed++;\\n    }\\n    this.parseUserAttributes();\\n\\n    return null;\\n  }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  AWDLoader.prototype.getBlock = function ( id ) {\\n    return this._blocks[id].data;\\n  },\\n\\n\\n  AWDLoader.prototype.parseMatrix4 = function ( ) {\\n    var mtx = new THREE.Matrix4();\\n    var e = mtx.elements;\\n\\n    e[0] = this.readF32();\\n    e[1] = this.readF32();\\n    e[2] = this.readF32();\\n    e[3] = 0.0;\\n    //e[3] = 0.0;\\n\\n    e[4] = this.readF32();\\n    e[5] = this.readF32();\\n    e[6] = this.readF32();\\n    //e[7] = this.readF32();\\n    e[7] = 0.0;\\n\\n    e[8] = this.readF32();\\n    e[9] = this.readF32();\\n    e[10] = this.readF32();\\n    //e[11] = this.readF32();\\n    e[11] = 0.0;\\n\\n    e[12] = -this.readF32();\\n    e[13] = this.readF32();\\n    e[14] = this.readF32();\\n    //e[15] = this.readF32();\\n    e[15] = 1.0;\\n    return mtx;\\n  }\\n\\n\\n  AWDLoader.prototype.parseProperties = function ( expected ) {\\n    var list_len = this.readU32();\\n    var list_end = this._ptr + list_len;\\n\\n    var props = new AWDProperties();\\n\\n    if( expected ) {\\n\\n      while( this._ptr < list_end ) {\\n\\n        var key = this.readU16();\\n        var len = this.readU32();\\n        var type;\\n\\n        if( expected.hasOwnProperty( key ) ) {\\n          type = expected[ key ];\\n          props.set( key, this.parseAttrValue( type, len ) );\\n        } else {\\n          this._ptr += len;\\n        }\\n      }\\n\\n    }\\n\\n    return props;\\n\\n  };\\n\\n\\n  AWDLoader.prototype.parseUserAttributes = function ( ) {\\n    // skip for now\\n    this._ptr = this.readU32() + this._ptr;\\n    return null;\\n  };\\n\\n\\n  AWDLoader.prototype.parseAttrValue = function ( type, len ) {\\n\\n    var elem_len;\\n    var read_func;\\n\\n    switch (type) {\\n      case AWD_FIELD_INT8:\\n        elem_len = 1;\\n        read_func = this.readI8;\\n        break;\\n      case AWD_FIELD_INT16:\\n        elem_len = 2;\\n        read_func = this.readI16;\\n        break;\\n      case AWD_FIELD_INT32:\\n        elem_len = 4;\\n        read_func = this.readI32;\\n        break;\\n      case AWD_FIELD_BOOL:\\n      case AWD_FIELD_UINT8:\\n        elem_len = 1;\\n        read_func = this.readU8;\\n        break;\\n      case AWD_FIELD_UINT16:\\n        elem_len = 2;\\n        read_func = this.readU16;\\n        break;\\n      case AWD_FIELD_UINT32:\\n      case AWD_FIELD_BADDR:\\n        elem_len = 4;\\n        read_func = this.readU32;\\n        break;\\n      case AWD_FIELD_FLOAT32:\\n        elem_len = 4;\\n        read_func = this.readF32;\\n        break;\\n      case AWD_FIELD_FLOAT64:\\n        elem_len = 8;\\n        read_func = this.readF64;\\n        break;\\n      case AWD_FIELD_VECTOR2x1:\\n      case AWD_FIELD_VECTOR3x1:\\n      case AWD_FIELD_VECTOR4x1:\\n      case AWD_FIELD_MTX3x2:\\n      case AWD_FIELD_MTX3x3:\\n      case AWD_FIELD_MTX4x3:\\n      case AWD_FIELD_MTX4x4:\\n        elem_len = 8;\\n        read_func = this.readF64;\\n        break;\\n    }\\n\\n    if (elem_len < len) {\\n      var list;\\n      var num_read;\\n      var num_elems;\\n\\n      list = [];\\n      num_read = 0;\\n      num_elems = len / elem_len;\\n\\n      while (num_read < num_elems) {\\n        list.push(read_func.call( this ) );\\n        num_read++;\\n      }\\n\\n      return list;\\n    }\\n    else {\\n      return read_func.call( this );\\n    }\\n\\n  }\\n\\n\\n  AWDLoader.prototype.readU8 = function () {\\n    return this._data.getUint8( this._ptr++ );\\n  }\\n  AWDLoader.prototype.readI8 = function () {\\n    return this._data.getInt8( this._ptr++ );\\n  }\\n\\n  AWDLoader.prototype.readU16 = function () {\\n    var a = this._data.getUint16( this._ptr, littleEndian );\\n    this._ptr += 2;\\n    return a;\\n  }\\n  AWDLoader.prototype.readI16 = function () {\\n    var a = this._data.getInt16( this._ptr, littleEndian );\\n    this._ptr += 2;\\n    return a;\\n  }\\n\\n  AWDLoader.prototype.readU32 = function () {\\n    var a = this._data.getUint32( this._ptr, littleEndian );\\n    this._ptr += 4;\\n    return a;\\n  }\\n  AWDLoader.prototype.readI32 = function () {\\n    var a = this._data.getInt32( this._ptr, littleEndian );\\n    this._ptr += 4;\\n    return a;\\n  }\\n  AWDLoader.prototype.readF32 = function () {\\n    var a = this._data.getFloat32( this._ptr, littleEndian );\\n    this._ptr += 4;\\n    return a;\\n  }\\n  AWDLoader.prototype.readF64 = function () {\\n    var a = this._data.getFloat64( this._ptr, littleEndian );\\n    this._ptr += 8;\\n    return a;\\n  }\\n\\n\\n  /**\\n   * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.\\n   * @param {Array.<number>} bytes UTF-8 byte array.\\n   * @return {string} 16-bit Unicode string.\\n   */\\n  AWDLoader.prototype.readUTF = function () {\\n    var len = this.readU16();\\n\\n    return this.readUTFBytes( len );\\n  };\\n\\n  /**\\n   * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.\\n   * @param {Array.<number>} bytes UTF-8 byte array.\\n   * @return {string} 16-bit Unicode string.\\n   */\\n  AWDLoader.prototype.readUTFBytes = function ( len ) {\\n\\n\\n    // TODO(user): Use native implementations if/when available\\n\\n    var out = [], c = 0;\\n\\n    while ( out.length < len ) {\\n      var c1 = this._data.getUint8( this._ptr++, littleEndian );\\n      if (c1 < 128) {\\n        out[c++] = String.fromCharCode(c1);\\n      } else if (c1 > 191 && c1 < 224) {\\n        var c2 = this._data.getUint8( this._ptr++, littleEndian );\\n        out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\\n      } else {\\n        var c2 = this._data.getUint8( this._ptr++, littleEndian );\\n        var c3 = this._data.getUint8( this._ptr++, littleEndian );\\n        out[c++] = String.fromCharCode(\\n            (c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63\\n        );\\n      }\\n    }\\n    return out.join('');\\n  };\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  AWDProperties = function(){}\\n\\n  AWDProperties.prototype = {\\n\\n\\n    set : function(key, value)\\n    {\\n      this[key] = value;\\n    },\\n\\n    get : function(key, fallback)\\n    {\\n      if ( this.hasOwnProperty(key) )\\n        return this[key];\\n      else return fallback;\\n    }\\n  }\\n\\n  return AWDLoader;\\n\\n})();\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/BinaryLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/BinaryLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.BinaryLoader = function ( showStatus ) {\\n\\n\\tTHREE.Loader.call( this, showStatus );\\n\\n};\\n\\nTHREE.BinaryLoader.prototype = Object.create( THREE.Loader.prototype );\\n\\n// Load models generated by slim OBJ converter with BINARY option (converter_obj_three_slim.py -t binary)\\n//  - binary models consist of two files: JS and BIN\\n//  - parameters\\n//\\t\\t- url (required)\\n//\\t\\t- callback (required)\\n//\\t\\t- texturePath (optional: if not specified, textures will be assumed to be in the same folder as JS model file)\\n//\\t\\t- binaryPath (optional: if not specified, binary file will be assumed to be in the same folder as JS model file)\\n\\nTHREE.BinaryLoader.prototype.load = function ( url, callback, texturePath, binaryPath ) {\\n\\n\\t// todo: unify load API to for easier SceneLoader use\\n\\n\\ttexturePath = texturePath || this.extractUrlBase( url );\\n\\tbinaryPath = binaryPath || this.extractUrlBase( url );\\n\\n\\tvar callbackProgress = this.showProgress ? THREE.Loader.prototype.updateProgress : undefined;\\n\\n\\tthis.onLoadStart();\\n\\n\\t// #1 load JS part via web worker\\n\\n\\tthis.loadAjaxJSON( this, url, callback, texturePath, binaryPath, callbackProgress );\\n\\n};\\n\\nTHREE.BinaryLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, binaryPath, callbackProgress ) {\\n  var func = \\\"THREE.BinaryLoader.loadAjaxJSON\\\";\\n\\n\\ttexturePath = texturePath && ( typeof texturePath === \\\"string\\\" ) ? texturePath : this.extractUrlBase( url );\\n\\tbinaryPath = binaryPath && ( typeof binaryPath === \\\"string\\\" ) ? binaryPath : this.extractUrlBase( url );\\n\\n  if (TiddlyWiki && url.match(/^tw:/)) {\\n    var res = TiddlyWiki.load(url);\\n    //hack.log(\\\"res.length = \\\"+res.length, hack.loader, func);\\n\\n    var json = JSON.parse(res);\\n    context.loadAjaxBuffers(json, callback, binaryPath, texturePath, callbackProgress);\\n\\n    hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n    return;\\n  }\\n\\n\\tvar xhr = new XMLHttpRequest();\\n\\n\\txhr.onreadystatechange = function () {\\n\\n\\t\\tif ( xhr.readyState == 4 ) {\\n\\n\\t\\t\\tif ( xhr.status == 200 || xhr.status == 0 ) {\\n\\n\\t\\t\\t\\tvar json = JSON.parse( xhr.responseText );\\n\\t\\t\\t\\tcontext.loadAjaxBuffers( json, callback, binaryPath, texturePath, callbackProgress );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.error( \\\"THREE.BinaryLoader: Couldn't load [\\\" + url + \\\"] [\\\" + xhr.status + \\\"]\\\" );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\txhr.open( \\\"GET\\\", url, true );\\n\\txhr.send( null );\\n\\n};\\n\\nTHREE.BinaryLoader.prototype.loadAjaxBuffers = function ( json, callback, binaryPath, texturePath, callbackProgress ) {\\n  var func = \\\"THREE.BinaryLoader.loadAjaxBuffers\\\";\\n\\n  var url = binaryPath + json.buffers;\\n\\n  if (TiddlyWiki && url.match(/^tw:/)) {\\n    var res = TiddlyWiki.load(url);\\n    //hack.log(\\\"res.length = \\\"+res.length, hack.loader, func);\\n\\n    this.createBinModel(res, callback, texturePath, json.materials);\\n\\n    hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n    return;\\n  }\\n\\n\\tvar scope = this;\\n\\n\\tvar xhr = new XMLHttpRequest(),\\n\\t\\turl = binaryPath + json.buffers;\\n\\n\\txhr.addEventListener( 'load', function ( event ) {\\n\\n\\t\\tvar buffer = xhr.response;\\n\\n\\t\\tif ( buffer === undefined ) {\\n\\n\\t\\t\\t// IEWEBGL needs this\\n\\t\\t\\tbuffer = ( new Uint8Array( xhr.responseBody ) ).buffer;\\n\\n\\t\\t}\\n\\n\\t\\tif ( buffer.byteLength == 0 ) {  // iOS and other XMLHttpRequest level 1\\n\\n\\t\\t\\tvar buffer = new ArrayBuffer( xhr.responseText.length );\\n\\n\\t\\t\\tvar bufView = new Uint8Array( buffer );\\n\\n\\t\\t\\tfor ( var i = 0, l = xhr.responseText.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tbufView[ i ] = xhr.responseText.charCodeAt( i ) & 0xff;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tscope.createBinModel( buffer, callback, texturePath, json.materials );\\n\\n\\t}, false );\\n\\n\\tif ( callbackProgress !== undefined ) {\\n\\n\\t\\txhr.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\t\\tif ( event.lengthComputable ) {\\n\\n\\t\\t\\t\\tcallbackProgress( event );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}, false );\\n\\n\\t}\\n\\n\\txhr.addEventListener( 'error', function ( event ) {\\n\\n\\t\\tconsole.error( \\\"THREE.BinaryLoader: Couldn't load [\\\" + url + \\\"] [\\\" + xhr.status + \\\"]\\\" );\\n\\n\\t}, false );\\n\\n\\n\\txhr.open( \\\"GET\\\", url, true );\\n\\txhr.responseType = \\\"arraybuffer\\\";\\n\\tif ( xhr.overrideMimeType ) xhr.overrideMimeType( \\\"text/plain; charset=x-user-defined\\\" );\\n\\txhr.send( null );\\n\\n};\\n\\n// Binary AJAX parser\\n\\nTHREE.BinaryLoader.prototype.createBinModel = function ( data, callback, texturePath, jsonMaterials ) {\\n\\n\\tvar Model = function ( texturePath ) {\\n\\n\\t\\tvar scope = this,\\n\\t\\t\\tcurrentOffset = 0,\\n\\t\\t\\tmd,\\n\\t\\t\\tnormals = [],\\n\\t\\t\\tuvs = [],\\n\\t\\t\\tstart_tri_flat, start_tri_smooth, start_tri_flat_uv, start_tri_smooth_uv,\\n\\t\\t\\tstart_quad_flat, start_quad_smooth, start_quad_flat_uv, start_quad_smooth_uv,\\n\\t\\t\\ttri_size, quad_size,\\n\\t\\t\\tlen_tri_flat, len_tri_smooth, len_tri_flat_uv, len_tri_smooth_uv,\\n\\t\\t\\tlen_quad_flat, len_quad_smooth, len_quad_flat_uv, len_quad_smooth_uv;\\n\\n\\n\\t\\tTHREE.Geometry.call( this );\\n\\n\\t\\tmd = parseMetaData( data, currentOffset );\\n\\n\\t\\tcurrentOffset += md.header_bytes;\\n/*\\n\\t\\tmd.vertex_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\\n\\t\\tmd.material_index_bytes = Uint16Array.BYTES_PER_ELEMENT;\\n\\t\\tmd.normal_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\\n\\t\\tmd.uv_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\\n*/\\n\\t\\t// buffers sizes\\n\\n\\t\\ttri_size =  md.vertex_index_bytes * 3 + md.material_index_bytes;\\n\\t\\tquad_size = md.vertex_index_bytes * 4 + md.material_index_bytes;\\n\\n\\t\\tlen_tri_flat      = md.ntri_flat      * ( tri_size );\\n\\t\\tlen_tri_smooth    = md.ntri_smooth    * ( tri_size + md.normal_index_bytes * 3 );\\n\\t\\tlen_tri_flat_uv   = md.ntri_flat_uv   * ( tri_size + md.uv_index_bytes * 3 );\\n\\t\\tlen_tri_smooth_uv = md.ntri_smooth_uv * ( tri_size + md.normal_index_bytes * 3 + md.uv_index_bytes * 3 );\\n\\n\\t\\tlen_quad_flat      = md.nquad_flat      * ( quad_size );\\n\\t\\tlen_quad_smooth    = md.nquad_smooth    * ( quad_size + md.normal_index_bytes * 4 );\\n\\t\\tlen_quad_flat_uv   = md.nquad_flat_uv   * ( quad_size + md.uv_index_bytes * 4 );\\n\\t\\tlen_quad_smooth_uv = md.nquad_smooth_uv * ( quad_size + md.normal_index_bytes * 4 + md.uv_index_bytes * 4 );\\n\\n\\t\\t// read buffers\\n\\n\\t\\tcurrentOffset += init_vertices( currentOffset );\\n\\n\\t\\tcurrentOffset += init_normals( currentOffset );\\n\\t\\tcurrentOffset += handlePadding( md.nnormals * 3 );\\n\\n\\t\\tcurrentOffset += init_uvs( currentOffset );\\n\\n\\t\\tstart_tri_flat \\t\\t= currentOffset;\\n\\t\\tstart_tri_smooth    = start_tri_flat    + len_tri_flat    + handlePadding( md.ntri_flat * 2 );\\n\\t\\tstart_tri_flat_uv   = start_tri_smooth  + len_tri_smooth  + handlePadding( md.ntri_smooth * 2 );\\n\\t\\tstart_tri_smooth_uv = start_tri_flat_uv + len_tri_flat_uv + handlePadding( md.ntri_flat_uv * 2 );\\n\\n\\t\\tstart_quad_flat     = start_tri_smooth_uv + len_tri_smooth_uv  + handlePadding( md.ntri_smooth_uv * 2 );\\n\\t\\tstart_quad_smooth   = start_quad_flat     + len_quad_flat\\t   + handlePadding( md.nquad_flat * 2 );\\n\\t\\tstart_quad_flat_uv  = start_quad_smooth   + len_quad_smooth    + handlePadding( md.nquad_smooth * 2 );\\n\\t\\tstart_quad_smooth_uv= start_quad_flat_uv  + len_quad_flat_uv   + handlePadding( md.nquad_flat_uv * 2 );\\n\\n\\t\\t// have to first process faces with uvs\\n\\t\\t// so that face and uv indices match\\n\\n\\t\\tinit_triangles_flat_uv( start_tri_flat_uv );\\n\\t\\tinit_triangles_smooth_uv( start_tri_smooth_uv );\\n\\n\\t\\tinit_quads_flat_uv( start_quad_flat_uv );\\n\\t\\tinit_quads_smooth_uv( start_quad_smooth_uv );\\n\\n\\t\\t// now we can process untextured faces\\n\\n\\t\\tinit_triangles_flat( start_tri_flat );\\n\\t\\tinit_triangles_smooth( start_tri_smooth );\\n\\n\\t\\tinit_quads_flat( start_quad_flat );\\n\\t\\tinit_quads_smooth( start_quad_smooth );\\n\\n\\t\\tthis.computeFaceNormals();\\n\\n\\t\\tfunction handlePadding( n ) {\\n\\n\\t\\t\\treturn ( n % 4 ) ? ( 4 - n % 4 ) : 0;\\n\\n\\t\\t};\\n\\n\\t\\tfunction parseMetaData( data, offset ) {\\n\\n\\t\\t\\tvar metaData = {\\n\\n\\t\\t\\t\\t'signature'               :parseString( data, offset,  12 ),\\n\\t\\t\\t\\t'header_bytes'            :parseUChar8( data, offset + 12 ),\\n\\n\\t\\t\\t\\t'vertex_coordinate_bytes' :parseUChar8( data, offset + 13 ),\\n\\t\\t\\t\\t'normal_coordinate_bytes' :parseUChar8( data, offset + 14 ),\\n\\t\\t\\t\\t'uv_coordinate_bytes'     :parseUChar8( data, offset + 15 ),\\n\\n\\t\\t\\t\\t'vertex_index_bytes'      :parseUChar8( data, offset + 16 ),\\n\\t\\t\\t\\t'normal_index_bytes'      :parseUChar8( data, offset + 17 ),\\n\\t\\t\\t\\t'uv_index_bytes'          :parseUChar8( data, offset + 18 ),\\n\\t\\t\\t\\t'material_index_bytes'    :parseUChar8( data, offset + 19 ),\\n\\n\\t\\t\\t\\t'nvertices'    :parseUInt32( data, offset + 20 ),\\n\\t\\t\\t\\t'nnormals'     :parseUInt32( data, offset + 20 + 4*1 ),\\n\\t\\t\\t\\t'nuvs'         :parseUInt32( data, offset + 20 + 4*2 ),\\n\\n\\t\\t\\t\\t'ntri_flat'      :parseUInt32( data, offset + 20 + 4*3 ),\\n\\t\\t\\t\\t'ntri_smooth'    :parseUInt32( data, offset + 20 + 4*4 ),\\n\\t\\t\\t\\t'ntri_flat_uv'   :parseUInt32( data, offset + 20 + 4*5 ),\\n\\t\\t\\t\\t'ntri_smooth_uv' :parseUInt32( data, offset + 20 + 4*6 ),\\n\\n\\t\\t\\t\\t'nquad_flat'      :parseUInt32( data, offset + 20 + 4*7 ),\\n\\t\\t\\t\\t'nquad_smooth'    :parseUInt32( data, offset + 20 + 4*8 ),\\n\\t\\t\\t\\t'nquad_flat_uv'   :parseUInt32( data, offset + 20 + 4*9 ),\\n\\t\\t\\t\\t'nquad_smooth_uv' :parseUInt32( data, offset + 20 + 4*10 )\\n\\n\\t\\t\\t};\\n/*\\n\\t\\t\\tconsole.log( \\\"signature: \\\" + metaData.signature );\\n\\n\\t\\t\\tconsole.log( \\\"header_bytes: \\\" + metaData.header_bytes );\\n\\t\\t\\tconsole.log( \\\"vertex_coordinate_bytes: \\\" + metaData.vertex_coordinate_bytes );\\n\\t\\t\\tconsole.log( \\\"normal_coordinate_bytes: \\\" + metaData.normal_coordinate_bytes );\\n\\t\\t\\tconsole.log( \\\"uv_coordinate_bytes: \\\" + metaData.uv_coordinate_bytes );\\n\\n\\t\\t\\tconsole.log( \\\"vertex_index_bytes: \\\" + metaData.vertex_index_bytes );\\n\\t\\t\\tconsole.log( \\\"normal_index_bytes: \\\" + metaData.normal_index_bytes );\\n\\t\\t\\tconsole.log( \\\"uv_index_bytes: \\\" + metaData.uv_index_bytes );\\n\\t\\t\\tconsole.log( \\\"material_index_bytes: \\\" + metaData.material_index_bytes );\\n\\n\\t\\t\\tconsole.log( \\\"nvertices: \\\" + metaData.nvertices );\\n\\t\\t\\tconsole.log( \\\"nnormals: \\\" + metaData.nnormals );\\n\\t\\t\\tconsole.log( \\\"nuvs: \\\" + metaData.nuvs );\\n\\n\\t\\t\\tconsole.log( \\\"ntri_flat: \\\" + metaData.ntri_flat );\\n\\t\\t\\tconsole.log( \\\"ntri_smooth: \\\" + metaData.ntri_smooth );\\n\\t\\t\\tconsole.log( \\\"ntri_flat_uv: \\\" + metaData.ntri_flat_uv );\\n\\t\\t\\tconsole.log( \\\"ntri_smooth_uv: \\\" + metaData.ntri_smooth_uv );\\n\\n\\t\\t\\tconsole.log( \\\"nquad_flat: \\\" + metaData.nquad_flat );\\n\\t\\t\\tconsole.log( \\\"nquad_smooth: \\\" + metaData.nquad_smooth );\\n\\t\\t\\tconsole.log( \\\"nquad_flat_uv: \\\" + metaData.nquad_flat_uv );\\n\\t\\t\\tconsole.log( \\\"nquad_smooth_uv: \\\" + metaData.nquad_smooth_uv );\\n\\n\\t\\t\\tvar total = metaData.header_bytes\\n\\t\\t\\t\\t\\t  + metaData.nvertices * metaData.vertex_coordinate_bytes * 3\\n\\t\\t\\t\\t\\t  + metaData.nnormals * metaData.normal_coordinate_bytes * 3\\n\\t\\t\\t\\t\\t  + metaData.nuvs * metaData.uv_coordinate_bytes * 2\\n\\t\\t\\t\\t\\t  + metaData.ntri_flat * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes )\\n\\t\\t\\t\\t\\t  + metaData.ntri_smooth * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 )\\n\\t\\t\\t\\t\\t  + metaData.ntri_flat_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.uv_index_bytes*3 )\\n\\t\\t\\t\\t\\t  + metaData.ntri_smooth_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 + metaData.uv_index_bytes*3 )\\n\\t\\t\\t\\t\\t  + metaData.nquad_flat * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes )\\n\\t\\t\\t\\t\\t  + metaData.nquad_smooth * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 )\\n\\t\\t\\t\\t\\t  + metaData.nquad_flat_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.uv_index_bytes*4 )\\n\\t\\t\\t\\t\\t  + metaData.nquad_smooth_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 + metaData.uv_index_bytes*4 );\\n\\t\\t\\tconsole.log( \\\"total bytes: \\\" + total );\\n*/\\n\\n\\t\\t\\treturn metaData;\\n\\n\\t\\t};\\n\\n\\t\\tfunction parseString( data, offset, length ) {\\n\\n\\t\\t\\tvar charArray = new Uint8Array( data, offset, length );\\n\\n\\t\\t\\tvar text = \\\"\\\";\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\ttext += String.fromCharCode( charArray[ offset + i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn text;\\n\\n\\t\\t};\\n\\n\\t\\tfunction parseUChar8( data, offset ) {\\n\\n\\t\\t\\tvar charArray = new Uint8Array( data, offset, 1 );\\n\\n\\t\\t\\treturn charArray[ 0 ];\\n\\n\\t\\t};\\n\\n\\t\\tfunction parseUInt32( data, offset ) {\\n\\n\\t\\t\\tvar intArray = new Uint32Array( data, offset, 1 );\\n\\n\\t\\t\\treturn intArray[ 0 ];\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_vertices( start ) {\\n\\n\\t\\t\\tvar nElements = md.nvertices;\\n\\n\\t\\t\\tvar coordArray = new Float32Array( data, start, nElements * 3 );\\n\\n\\t\\t\\tvar i, x, y, z;\\n\\n\\t\\t\\tfor( i = 0; i < nElements; i ++ ) {\\n\\n\\t\\t\\t\\tx = coordArray[ i * 3 ];\\n\\t\\t\\t\\ty = coordArray[ i * 3 + 1 ];\\n\\t\\t\\t\\tz = coordArray[ i * 3 + 2 ];\\n\\n\\t\\t\\t\\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn nElements * 3 * Float32Array.BYTES_PER_ELEMENT;\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_normals( start ) {\\n\\n\\t\\t\\tvar nElements = md.nnormals;\\n\\n\\t\\t\\tif ( nElements ) {\\n\\n\\t\\t\\t\\tvar normalArray = new Int8Array( data, start, nElements * 3 );\\n\\n\\t\\t\\t\\tvar i, x, y, z;\\n\\n\\t\\t\\t\\tfor( i = 0; i < nElements; i ++ ) {\\n\\n\\t\\t\\t\\t\\tx = normalArray[ i * 3 ];\\n\\t\\t\\t\\t\\ty = normalArray[ i * 3 + 1 ];\\n\\t\\t\\t\\t\\tz = normalArray[ i * 3 + 2 ];\\n\\n\\t\\t\\t\\t\\tnormals.push( x/127, y/127, z/127 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn nElements * 3 * Int8Array.BYTES_PER_ELEMENT;\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_uvs( start ) {\\n\\n\\t\\t\\tvar nElements = md.nuvs;\\n\\n\\t\\t\\tif ( nElements ) {\\n\\n\\t\\t\\t\\tvar uvArray = new Float32Array( data, start, nElements * 2 );\\n\\n\\t\\t\\t\\tvar i, u, v;\\n\\n\\t\\t\\t\\tfor( i = 0; i < nElements; i ++ ) {\\n\\n\\t\\t\\t\\t\\tu = uvArray[ i * 2 ];\\n\\t\\t\\t\\t\\tv = uvArray[ i * 2 + 1 ];\\n\\n\\t\\t\\t\\t\\tuvs.push( u, v );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn nElements * 2 * Float32Array.BYTES_PER_ELEMENT;\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_uvs3( nElements, offset ) {\\n\\n\\t\\t\\tvar i, uva, uvb, uvc, u1, u2, u3, v1, v2, v3;\\n\\n\\t\\t\\tvar uvIndexBuffer = new Uint32Array( data, offset, 3 * nElements );\\n\\n\\t\\t\\tfor( i = 0; i < nElements; i ++ ) {\\n\\n\\t\\t\\t\\tuva = uvIndexBuffer[ i * 3 ];\\n\\t\\t\\t\\tuvb = uvIndexBuffer[ i * 3 + 1 ];\\n\\t\\t\\t\\tuvc = uvIndexBuffer[ i * 3 + 2 ];\\n\\n\\t\\t\\t\\tu1 = uvs[ uva*2 ];\\n\\t\\t\\t\\tv1 = uvs[ uva*2 + 1 ];\\n\\n\\t\\t\\t\\tu2 = uvs[ uvb*2 ];\\n\\t\\t\\t\\tv2 = uvs[ uvb*2 + 1 ];\\n\\n\\t\\t\\t\\tu3 = uvs[ uvc*2 ];\\n\\t\\t\\t\\tv3 = uvs[ uvc*2 + 1 ];\\n\\n\\t\\t\\t\\tscope.faceVertexUvs[ 0 ].push( [\\n\\t\\t\\t\\t\\tnew THREE.Vector2( u1, v1 ),\\n\\t\\t\\t\\t\\tnew THREE.Vector2( u2, v2 ),\\n\\t\\t\\t\\t\\tnew THREE.Vector2( u3, v3 )\\n\\t\\t\\t\\t] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_uvs4( nElements, offset ) {\\n\\n\\t\\t\\tvar i, uva, uvb, uvc, uvd, u1, u2, u3, u4, v1, v2, v3, v4;\\n\\n\\t\\t\\tvar uvIndexBuffer = new Uint32Array( data, offset, 4 * nElements );\\n\\n\\t\\t\\tfor( i = 0; i < nElements; i ++ ) {\\n\\n\\t\\t\\t\\tuva = uvIndexBuffer[ i * 4 ];\\n\\t\\t\\t\\tuvb = uvIndexBuffer[ i * 4 + 1 ];\\n\\t\\t\\t\\tuvc = uvIndexBuffer[ i * 4 + 2 ];\\n\\t\\t\\t\\tuvd = uvIndexBuffer[ i * 4 + 3 ];\\n\\n\\t\\t\\t\\tu1 = uvs[ uva*2 ];\\n\\t\\t\\t\\tv1 = uvs[ uva*2 + 1 ];\\n\\n\\t\\t\\t\\tu2 = uvs[ uvb*2 ];\\n\\t\\t\\t\\tv2 = uvs[ uvb*2 + 1 ];\\n\\n\\t\\t\\t\\tu3 = uvs[ uvc*2 ];\\n\\t\\t\\t\\tv3 = uvs[ uvc*2 + 1 ];\\n\\n\\t\\t\\t\\tu4 = uvs[ uvd*2 ];\\n\\t\\t\\t\\tv4 = uvs[ uvd*2 + 1 ];\\n\\n\\t\\t\\t\\tscope.faceVertexUvs[ 0 ].push( [\\n\\t\\t\\t\\t\\tnew THREE.Vector2( u1, v1 ),\\n\\t\\t\\t\\t\\tnew THREE.Vector2( u2, v2 ),\\n\\t\\t\\t\\t\\tnew THREE.Vector2( u4, v4 )\\n\\t\\t\\t\\t] );\\n\\n\\t\\t\\t\\tscope.faceVertexUvs[ 0 ].push( [\\n\\t\\t\\t\\t\\tnew THREE.Vector2( u2, v2 ),\\n\\t\\t\\t\\t\\tnew THREE.Vector2( u3, v3 ),\\n\\t\\t\\t\\t\\tnew THREE.Vector2( u4, v4 )\\n\\t\\t\\t\\t] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_faces3_flat( nElements, offsetVertices, offsetMaterials ) {\\n\\n\\t\\t\\tvar i, a, b, c, m;\\n\\n\\t\\t\\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 3 * nElements );\\n\\t\\t\\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\\n\\n\\t\\t\\tfor( i = 0; i < nElements; i ++ ) {\\n\\n\\t\\t\\t\\ta = vertexIndexBuffer[ i * 3 ];\\n\\t\\t\\t\\tb = vertexIndexBuffer[ i * 3 + 1 ];\\n\\t\\t\\t\\tc = vertexIndexBuffer[ i * 3 + 2 ];\\n\\n\\t\\t\\t\\tm = materialIndexBuffer[ i ];\\n\\n\\t\\t\\t\\tscope.faces.push( new THREE.Face3( a, b, c, null, null, m ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_faces4_flat( nElements, offsetVertices, offsetMaterials ) {\\n\\n\\t\\t\\tvar i, a, b, c, d, m;\\n\\n\\t\\t\\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 4 * nElements );\\n\\t\\t\\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\\n\\n\\t\\t\\tfor( i = 0; i < nElements; i ++ ) {\\n\\n\\t\\t\\t\\ta = vertexIndexBuffer[ i * 4 ];\\n\\t\\t\\t\\tb = vertexIndexBuffer[ i * 4 + 1 ];\\n\\t\\t\\t\\tc = vertexIndexBuffer[ i * 4 + 2 ];\\n\\t\\t\\t\\td = vertexIndexBuffer[ i * 4 + 3 ];\\n\\n\\t\\t\\t\\tm = materialIndexBuffer[ i ];\\n\\n\\t\\t\\t\\tscope.faces.push( new THREE.Face3( a, b, d, null, null, m ) );\\n\\t\\t\\t\\tscope.faces.push( new THREE.Face3( b, c, d, null, null, m ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_faces3_smooth( nElements, offsetVertices, offsetNormals, offsetMaterials ) {\\n\\n\\t\\t\\tvar i, a, b, c, m;\\n\\t\\t\\tvar na, nb, nc;\\n\\n\\t\\t\\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 3 * nElements );\\n\\t\\t\\tvar normalIndexBuffer = new Uint32Array( data, offsetNormals, 3 * nElements );\\n\\t\\t\\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\\n\\n\\t\\t\\tfor( i = 0; i < nElements; i ++ ) {\\n\\n\\t\\t\\t\\ta = vertexIndexBuffer[ i * 3 ];\\n\\t\\t\\t\\tb = vertexIndexBuffer[ i * 3 + 1 ];\\n\\t\\t\\t\\tc = vertexIndexBuffer[ i * 3 + 2 ];\\n\\n\\t\\t\\t\\tna = normalIndexBuffer[ i * 3 ];\\n\\t\\t\\t\\tnb = normalIndexBuffer[ i * 3 + 1 ];\\n\\t\\t\\t\\tnc = normalIndexBuffer[ i * 3 + 2 ];\\n\\n\\t\\t\\t\\tm = materialIndexBuffer[ i ];\\n\\n\\t\\t\\t\\tvar nax = normals[ na*3     ],\\n\\t\\t\\t\\t\\tnay = normals[ na*3 + 1 ],\\n\\t\\t\\t\\t\\tnaz = normals[ na*3 + 2 ],\\n\\n\\t\\t\\t\\t\\tnbx = normals[ nb*3     ],\\n\\t\\t\\t\\t\\tnby = normals[ nb*3 + 1 ],\\n\\t\\t\\t\\t\\tnbz = normals[ nb*3 + 2 ],\\n\\n\\t\\t\\t\\t\\tncx = normals[ nc*3     ],\\n\\t\\t\\t\\t\\tncy = normals[ nc*3 + 1 ],\\n\\t\\t\\t\\t\\tncz = normals[ nc*3 + 2 ];\\n\\n\\t\\t\\t\\tscope.faces.push( new THREE.Face3( a, b, c, [\\n\\t\\t\\t\\t\\tnew THREE.Vector3( nax, nay, naz ),\\n\\t\\t\\t\\t\\tnew THREE.Vector3( nbx, nby, nbz ),\\n\\t\\t\\t\\t\\tnew THREE.Vector3( ncx, ncy, ncz )\\n\\t\\t\\t\\t], null, m ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_faces4_smooth( nElements, offsetVertices, offsetNormals, offsetMaterials ) {\\n\\n\\t\\t\\tvar i, a, b, c, d, m;\\n\\t\\t\\tvar na, nb, nc, nd;\\n\\n\\t\\t\\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 4 * nElements );\\n\\t\\t\\tvar normalIndexBuffer = new Uint32Array( data, offsetNormals, 4 * nElements );\\n\\t\\t\\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\\n\\n\\t\\t\\tfor( i = 0; i < nElements; i ++ ) {\\n\\n\\t\\t\\t\\ta = vertexIndexBuffer[ i * 4 ];\\n\\t\\t\\t\\tb = vertexIndexBuffer[ i * 4 + 1 ];\\n\\t\\t\\t\\tc = vertexIndexBuffer[ i * 4 + 2 ];\\n\\t\\t\\t\\td = vertexIndexBuffer[ i * 4 + 3 ];\\n\\n\\t\\t\\t\\tna = normalIndexBuffer[ i * 4 ];\\n\\t\\t\\t\\tnb = normalIndexBuffer[ i * 4 + 1 ];\\n\\t\\t\\t\\tnc = normalIndexBuffer[ i * 4 + 2 ];\\n\\t\\t\\t\\tnd = normalIndexBuffer[ i * 4 + 3 ];\\n\\n\\t\\t\\t\\tm = materialIndexBuffer[ i ];\\n\\n\\t\\t\\t\\tvar nax = normals[ na*3     ],\\n\\t\\t\\t\\t\\tnay = normals[ na*3 + 1 ],\\n\\t\\t\\t\\t\\tnaz = normals[ na*3 + 2 ],\\n\\n\\t\\t\\t\\t\\tnbx = normals[ nb*3     ],\\n\\t\\t\\t\\t\\tnby = normals[ nb*3 + 1 ],\\n\\t\\t\\t\\t\\tnbz = normals[ nb*3 + 2 ],\\n\\n\\t\\t\\t\\t\\tncx = normals[ nc*3     ],\\n\\t\\t\\t\\t\\tncy = normals[ nc*3 + 1 ],\\n\\t\\t\\t\\t\\tncz = normals[ nc*3 + 2 ],\\n\\n\\t\\t\\t\\t\\tndx = normals[ nd*3     ],\\n\\t\\t\\t\\t\\tndy = normals[ nd*3 + 1 ],\\n\\t\\t\\t\\t\\tndz = normals[ nd*3 + 2 ];\\n\\n\\t\\t\\t\\tscope.faces.push( new THREE.Face3( a, b, d, [\\n\\t\\t\\t\\t\\tnew THREE.Vector3( nax, nay, naz ),\\n\\t\\t\\t\\t\\tnew THREE.Vector3( nbx, nby, nbz ),\\n\\t\\t\\t\\t\\tnew THREE.Vector3( ndx, ndy, ndz )\\n\\t\\t\\t\\t], null, m ) );\\n\\n\\t\\t\\t\\tscope.faces.push( new THREE.Face3( b, c, d, [\\n\\t\\t\\t\\t\\tnew THREE.Vector3( nbx, nby, nbz ),\\n\\t\\t\\t\\t\\tnew THREE.Vector3( ncx, ncy, ncz ),\\n\\t\\t\\t\\t\\tnew THREE.Vector3( ndx, ndy, ndz )\\n\\t\\t\\t\\t], null, m ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_triangles_flat( start ) {\\n\\n\\t\\t\\tvar nElements = md.ntri_flat;\\n\\n\\t\\t\\tif ( nElements ) {\\n\\n\\t\\t\\t\\tvar offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\\n\\t\\t\\t\\tinit_faces3_flat( nElements, start, offsetMaterials );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_triangles_flat_uv( start ) {\\n\\n\\t\\t\\tvar nElements = md.ntri_flat_uv;\\n\\n\\t\\t\\tif ( nElements ) {\\n\\n\\t\\t\\t\\tvar offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\\n\\t\\t\\t\\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\\n\\n\\t\\t\\t\\tinit_faces3_flat( nElements, start, offsetMaterials );\\n\\t\\t\\t\\tinit_uvs3( nElements, offsetUvs );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_triangles_smooth( start ) {\\n\\n\\t\\t\\tvar nElements = md.ntri_smooth;\\n\\n\\t\\t\\tif ( nElements ) {\\n\\n\\t\\t\\t\\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\\n\\t\\t\\t\\tvar offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\\n\\n\\t\\t\\t\\tinit_faces3_smooth( nElements, start, offsetNormals, offsetMaterials );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_triangles_smooth_uv( start ) {\\n\\n\\t\\t\\tvar nElements = md.ntri_smooth_uv;\\n\\n\\t\\t\\tif ( nElements ) {\\n\\n\\t\\t\\t\\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\\n\\t\\t\\t\\tvar offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\\n\\t\\t\\t\\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\\n\\n\\t\\t\\t\\tinit_faces3_smooth( nElements, start, offsetNormals, offsetMaterials );\\n\\t\\t\\t\\tinit_uvs3( nElements, offsetUvs );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_quads_flat( start ) {\\n\\n\\t\\t\\tvar nElements = md.nquad_flat;\\n\\n\\t\\t\\tif ( nElements ) {\\n\\n\\t\\t\\t\\tvar offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\\n\\t\\t\\t\\tinit_faces4_flat( nElements, start, offsetMaterials );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_quads_flat_uv( start ) {\\n\\n\\t\\t\\tvar nElements = md.nquad_flat_uv;\\n\\n\\t\\t\\tif ( nElements ) {\\n\\n\\t\\t\\t\\tvar offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\\n\\t\\t\\t\\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\\n\\n\\t\\t\\t\\tinit_faces4_flat( nElements, start, offsetMaterials );\\n\\t\\t\\t\\tinit_uvs4( nElements, offsetUvs );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_quads_smooth( start ) {\\n\\n\\t\\t\\tvar nElements = md.nquad_smooth;\\n\\n\\t\\t\\tif ( nElements ) {\\n\\n\\t\\t\\t\\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\\n\\t\\t\\t\\tvar offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\\n\\n\\t\\t\\t\\tinit_faces4_smooth( nElements, start, offsetNormals, offsetMaterials );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction init_quads_smooth_uv( start ) {\\n\\n\\t\\t\\tvar nElements = md.nquad_smooth_uv;\\n\\n\\t\\t\\tif ( nElements ) {\\n\\n\\t\\t\\t\\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\\n\\t\\t\\t\\tvar offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\\n\\t\\t\\t\\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\\n\\n\\t\\t\\t\\tinit_faces4_smooth( nElements, start, offsetNormals, offsetMaterials );\\n\\t\\t\\t\\tinit_uvs4( nElements, offsetUvs );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t};\\n\\n\\tModel.prototype = Object.create( THREE.Geometry.prototype );\\n\\n\\tvar geometry = new Model( texturePath );\\n\\tvar materials = this.initMaterials( jsonMaterials, texturePath );\\n\\n\\tif ( this.needsTangents( materials ) ) geometry.computeTangents();\\n\\n\\tcallback( geometry, materials );\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/ColladaLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/ColladaLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n* @author Tim Knip / http://www.floorplanner.com/ / tim at floorplanner.com\\n* @author Tony Parisi / http://www.tonyparisi.com/\\n*/\\n\\nTHREE.ColladaLoader = function () {\\n\\n\\tvar COLLADA = null;\\n\\tvar scene = null;\\n\\tvar daeScene;\\n\\n\\tvar readyCallbackFunc = null;\\n\\n\\tvar sources = {};\\n\\tvar images = {};\\n\\tvar animations = {};\\n\\tvar controllers = {};\\n\\tvar geometries = {};\\n\\tvar materials = {};\\n\\tvar effects = {};\\n\\tvar cameras = {};\\n\\tvar lights = {};\\n\\n\\tvar animData;\\n\\tvar visualScenes;\\n\\tvar baseUrl;\\n\\tvar morphs;\\n\\tvar skins;\\n\\n\\tvar flip_uv = true;\\n\\tvar preferredShading = THREE.SmoothShading;\\n\\n\\tvar options = {\\n\\t\\t// Force Geometry to always be centered at the local origin of the\\n\\t\\t// containing Mesh.\\n\\t\\tcenterGeometry: false,\\n\\n\\t\\t// Axis conversion is done for geometries, animations, and controllers.\\n\\t\\t// If we ever pull cameras or lights out of the COLLADA file, they'll\\n\\t\\t// need extra work.\\n\\t\\tconvertUpAxis: false,\\n\\n\\t\\tsubdivideFaces: true,\\n\\n\\t\\tupAxis: 'Y',\\n\\n\\t\\t// For reflective or refractive materials we'll use this cubemap\\n\\t\\tdefaultEnvMap: null\\n\\n\\t};\\n\\n\\tvar colladaUnit = 1.0;\\n\\tvar colladaUp = 'Y';\\n\\tvar upConversion = null;\\n\\n\\tfunction load ( url, readyCallback, progressCallback ) {\\n          var func = \\\"THREE.ColladaLoader.load\\\";\\n\\n\\t\\tvar length = 0;\\n\\n\\t\\tif ( document.implementation && document.implementation.createDocument ) {\\n\\n                  if (TiddlyWiki && url.match(/^tw:/)) {\\n                    this._url = url;\\n                    var res = TiddlyWiki.load(url);\\n                    //hack.log(\\\"res.byteLength = \\\"+res.byteLength, hack.loader, func);\\n                    //hack.log(\\\"res = \\\"+res, hack.loader, func);\\n\\t\\t    readyCallbackFunc = readyCallback;\\n\\t\\t    var xmlParser = new DOMParser();\\n\\t\\t    var responseXML = xmlParser.parseFromString(res, \\\"application/xml\\\" );\\n\\t\\t    parse(responseXML, undefined, url);\\n                    hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n                    return;\\n                  }\\n\\n\\t\\t\\tvar request = new XMLHttpRequest();\\n\\n\\t\\t\\trequest.onreadystatechange = function() {\\n\\n\\t\\t\\t\\tif( request.readyState == 4 ) {\\n\\n\\t\\t\\t\\t\\tif( request.status == 0 || request.status == 200 ) {\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( request.responseXML ) {\\n\\n\\t\\t\\t\\t\\t\\t\\treadyCallbackFunc = readyCallback;\\n\\t\\t\\t\\t\\t\\t\\tparse( request.responseXML, undefined, url );\\n\\n\\t\\t\\t\\t\\t\\t} else if ( request.responseText ) {\\n\\n\\t\\t\\t\\t\\t\\t\\treadyCallbackFunc = readyCallback;\\n\\t\\t\\t\\t\\t\\t\\tvar xmlParser = new DOMParser();\\n\\t\\t\\t\\t\\t\\t\\tvar responseXML = xmlParser.parseFromString( request.responseText, \\\"application/xml\\\" );\\n\\t\\t\\t\\t\\t\\t\\tparse( responseXML, undefined, url );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( \\\"ColladaLoader: Empty or non-existing file (\\\" + url + \\\")\\\" );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( request.readyState == 3 ) {\\n\\n\\t\\t\\t\\t\\tif ( progressCallback ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( length == 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tlength = request.getResponseHeader( \\\"Content-Length\\\" );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tprogressCallback( { total: length, loaded: request.responseText.length } );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\trequest.open( \\\"GET\\\", url, true );\\n\\t\\t\\trequest.send( null );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\talert( \\\"Don't know how to parse XML!\\\" );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction parse( doc, callBack, url ) {\\n\\n\\t\\tCOLLADA = doc;\\n\\t\\tcallBack = callBack || readyCallbackFunc;\\n\\n\\t\\tif ( url !== undefined ) {\\n\\n\\t\\t\\tvar parts = url.split( '/' );\\n\\t\\t\\tparts.pop();\\n\\t\\t\\tbaseUrl = ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\\n\\n\\t\\t}\\n\\n\\t\\tparseAsset();\\n\\t\\tsetUpConversion();\\n\\t\\timages = parseLib( \\\"library_images image\\\", _Image, \\\"image\\\" );\\n\\t\\tmaterials = parseLib( \\\"library_materials material\\\", Material, \\\"material\\\" );\\n\\t\\teffects = parseLib( \\\"library_effects effect\\\", Effect, \\\"effect\\\" );\\n\\t\\tgeometries = parseLib( \\\"library_geometries geometry\\\", Geometry, \\\"geometry\\\" );\\n\\t\\tcameras = parseLib( \\\"library_cameras camera\\\", Camera, \\\"camera\\\" );\\n\\t\\tlights = parseLib( \\\"library_lights light\\\", Light, \\\"light\\\" );\\n\\t\\tcontrollers = parseLib( \\\"library_controllers controller\\\", Controller, \\\"controller\\\" );\\n\\t\\tanimations = parseLib( \\\"library_animations animation\\\", Animation, \\\"animation\\\" );\\n\\t\\tvisualScenes = parseLib( \\\"library_visual_scenes visual_scene\\\", VisualScene, \\\"visual_scene\\\" );\\n\\n\\t\\tmorphs = [];\\n\\t\\tskins = [];\\n\\n\\t\\tdaeScene = parseScene();\\n\\t\\tscene = new THREE.Object3D();\\n\\n\\t\\tfor ( var i = 0; i < daeScene.nodes.length; i ++ ) {\\n\\n\\t\\t\\tscene.add( createSceneGraph( daeScene.nodes[ i ] ) );\\n\\n\\t\\t}\\n\\n\\t\\t// unit conversion\\n\\t\\tscene.scale.multiplyScalar( colladaUnit );\\n\\n\\t\\tcreateAnimations();\\n\\n\\t\\tvar result = {\\n\\n\\t\\t\\tscene: scene,\\n\\t\\t\\tmorphs: morphs,\\n\\t\\t\\tskins: skins,\\n\\t\\t\\tanimations: animData,\\n\\t\\t\\tdae: {\\n\\t\\t\\t\\timages: images,\\n\\t\\t\\t\\tmaterials: materials,\\n\\t\\t\\t\\tcameras: cameras,\\n\\t\\t\\t\\tlights: lights,\\n\\t\\t\\t\\teffects: effects,\\n\\t\\t\\t\\tgeometries: geometries,\\n\\t\\t\\t\\tcontrollers: controllers,\\n\\t\\t\\t\\tanimations: animations,\\n\\t\\t\\t\\tvisualScenes: visualScenes,\\n\\t\\t\\t\\tscene: daeScene\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tif ( callBack ) {\\n\\n\\t\\t\\tcallBack( result );\\n\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\n\\t}\\n\\n\\tfunction setPreferredShading ( shading ) {\\n\\n\\t\\tpreferredShading = shading;\\n\\n\\t}\\n\\n\\tfunction parseAsset () {\\n\\n\\t\\tvar elements = COLLADA.querySelectorAll('asset');\\n\\n\\t\\tvar element = elements[0];\\n\\n\\t\\tif ( element && element.childNodes ) {\\n\\n\\t\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar child = element.childNodes[ i ];\\n\\n\\t\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\t\\tcase 'unit':\\n\\n\\t\\t\\t\\t\\t\\tvar meter = child.getAttribute( 'meter' );\\n\\n\\t\\t\\t\\t\\t\\tif ( meter ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcolladaUnit = parseFloat( meter );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'up_axis':\\n\\n\\t\\t\\t\\t\\t\\tcolladaUp = child.textContent.charAt(0);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction parseLib ( q, classSpec, prefix ) {\\n\\n\\t\\tvar elements = COLLADA.querySelectorAll(q);\\n\\n\\t\\tvar lib = {};\\n\\n\\t\\tvar i = 0;\\n\\n\\t\\tvar elementsLength = elements.length;\\n\\n\\t\\tfor ( var j = 0; j < elementsLength; j ++ ) {\\n\\n\\t\\t\\tvar element = elements[j];\\n\\t\\t\\tvar daeElement = ( new classSpec() ).parse( element );\\n\\n\\t\\t\\tif ( !daeElement.id || daeElement.id.length == 0 ) daeElement.id = prefix + ( i ++ );\\n\\t\\t\\tlib[ daeElement.id ] = daeElement;\\n\\n\\t\\t}\\n\\n\\t\\treturn lib;\\n\\n\\t}\\n\\n\\tfunction parseScene() {\\n\\n\\t\\tvar sceneElement = COLLADA.querySelectorAll('scene instance_visual_scene')[0];\\n\\t\\tif ( sceneElement ) {\\n\\n\\t\\t\\tvar url = sceneElement.getAttribute( 'url' ).replace( /^#/, '' );\\n\\t\\t\\treturn visualScenes[ url.length > 0 ? url : 'visual_scene0' ];\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction createAnimations() {\\n\\n\\t\\tanimData = [];\\n\\n\\t\\t// fill in the keys\\n\\t\\trecurseHierarchy( scene );\\n\\n\\t}\\n\\n\\tfunction recurseHierarchy( node ) {\\n\\n\\t\\tvar n = daeScene.getChildById( node.id, true ),\\n\\t\\t\\tnewData = null;\\n\\n\\t\\tif ( n && n.keys ) {\\n\\n\\t\\t\\tnewData = {\\n\\t\\t\\t\\tfps: 60,\\n\\t\\t\\t\\thierarchy: [ {\\n\\t\\t\\t\\t\\tnode: n,\\n\\t\\t\\t\\t\\tkeys: n.keys,\\n\\t\\t\\t\\t\\tsids: n.sids\\n\\t\\t\\t\\t} ],\\n\\t\\t\\t\\tnode: node,\\n\\t\\t\\t\\tname: 'animation_' + node.name,\\n\\t\\t\\t\\tlength: 0\\n\\t\\t\\t};\\n\\n\\t\\t\\tanimData.push(newData);\\n\\n\\t\\t\\tfor ( var i = 0, il = n.keys.length; i < il; i++ ) {\\n\\n\\t\\t\\t\\tnewData.length = Math.max( newData.length, n.keys[i].time );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else  {\\n\\n\\t\\t\\tnewData = {\\n\\t\\t\\t\\thierarchy: [ {\\n\\t\\t\\t\\t\\tkeys: [],\\n\\t\\t\\t\\t\\tsids: []\\n\\t\\t\\t\\t} ]\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0, il = node.children.length; i < il; i++ ) {\\n\\n\\t\\t\\tvar d = recurseHierarchy( node.children[i] );\\n\\n\\t\\t\\tfor ( var j = 0, jl = d.hierarchy.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\tnewData.hierarchy.push( {\\n\\t\\t\\t\\t\\tkeys: [],\\n\\t\\t\\t\\t\\tsids: []\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn newData;\\n\\n\\t}\\n\\n\\tfunction calcAnimationBounds () {\\n\\n\\t\\tvar start = 1000000;\\n\\t\\tvar end = -start;\\n\\t\\tvar frames = 0;\\n\\t\\tvar ID;\\n\\t\\tfor ( var id in animations ) {\\n\\n\\t\\t\\tvar animation = animations[ id ];\\n\\t\\t\\tID = ID || animation.id;\\n\\t\\t\\tfor ( var i = 0; i < animation.sampler.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar sampler = animation.sampler[ i ];\\n\\n\\t\\t\\t\\tsampler.create();\\n\\n\\t\\t\\t\\tstart = Math.min( start, sampler.startTime );\\n\\t\\t\\t\\tend = Math.max( end, sampler.endTime );\\n\\t\\t\\t\\tframes = Math.max( frames, sampler.input.length );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn { start:start, end:end, frames:frames,ID:ID };\\n\\n\\t}\\n\\n\\tfunction createMorph ( geometry, ctrl ) {\\n\\n\\t\\tvar morphCtrl = ctrl instanceof InstanceController ? controllers[ ctrl.url ] : ctrl;\\n\\n\\t\\tif ( !morphCtrl || !morphCtrl.morph ) {\\n\\n\\t\\t\\tconsole.log(\\\"could not find morph controller!\\\");\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tvar morph = morphCtrl.morph;\\n\\n\\t\\tfor ( var i = 0; i < morph.targets.length; i ++ ) {\\n\\n\\t\\t\\tvar target_id = morph.targets[ i ];\\n\\t\\t\\tvar daeGeometry = geometries[ target_id ];\\n\\n\\t\\t\\tif ( !daeGeometry.mesh ||\\n\\t\\t\\t\\t !daeGeometry.mesh.primitives ||\\n\\t\\t\\t\\t !daeGeometry.mesh.primitives.length ) {\\n\\t\\t\\t\\t continue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar target = daeGeometry.mesh.primitives[ 0 ].geometry;\\n\\n\\t\\t\\tif ( target.vertices.length === geometry.vertices.length ) {\\n\\n\\t\\t\\t\\tgeometry.morphTargets.push( { name: \\\"target_1\\\", vertices: target.vertices } );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.morphTargets.push( { name: \\\"target_Z\\\", vertices: geometry.vertices } );\\n\\n\\t};\\n\\n\\tfunction createSkin ( geometry, ctrl, applyBindShape ) {\\n\\n\\t\\tvar skinCtrl = controllers[ ctrl.url ];\\n\\n\\t\\tif ( !skinCtrl || !skinCtrl.skin ) {\\n\\n\\t\\t\\tconsole.log( \\\"could not find skin controller!\\\" );\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tif ( !ctrl.skeleton || !ctrl.skeleton.length ) {\\n\\n\\t\\t\\tconsole.log( \\\"could not find the skeleton for the skin!\\\" );\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tvar skin = skinCtrl.skin;\\n\\t\\tvar skeleton = daeScene.getChildById( ctrl.skeleton[ 0 ] );\\n\\t\\tvar hierarchy = [];\\n\\n\\t\\tapplyBindShape = applyBindShape !== undefined ? applyBindShape : true;\\n\\n\\t\\tvar bones = [];\\n\\t\\tgeometry.skinWeights = [];\\n\\t\\tgeometry.skinIndices = [];\\n\\n\\t\\t//createBones( geometry.bones, skin, hierarchy, skeleton, null, -1 );\\n\\t\\t//createWeights( skin, geometry.bones, geometry.skinIndices, geometry.skinWeights );\\n\\n\\t\\t/*\\n\\t\\tgeometry.animation = {\\n\\t\\t\\tname: 'take_001',\\n\\t\\t\\tfps: 30,\\n\\t\\t\\tlength: 2,\\n\\t\\t\\tJIT: true,\\n\\t\\t\\thierarchy: hierarchy\\n\\t\\t};\\n\\t\\t*/\\n\\n\\t\\tif ( applyBindShape ) {\\n\\n\\t\\t\\tfor ( var i = 0; i < geometry.vertices.length; i ++ ) {\\n\\n\\t\\t\\t\\tgeometry.vertices[ i ].applyMatrix4( skin.bindShapeMatrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setupSkeleton ( node, bones, frame, parent ) {\\n\\n\\t\\tnode.world = node.world || new THREE.Matrix4();\\n\\t\\tnode.localworld = node.localworld || new THREE.Matrix4();\\n\\t\\tnode.world.copy( node.matrix );\\n\\t\\tnode.localworld.copy( node.matrix );\\n\\n\\t\\tif ( node.channels && node.channels.length ) {\\n\\n\\t\\t\\tvar channel = node.channels[ 0 ];\\n\\t\\t\\tvar m = channel.sampler.output[ frame ];\\n\\n\\t\\t\\tif ( m instanceof THREE.Matrix4 ) {\\n\\n\\t\\t\\t\\tnode.world.copy( m );\\n\\t\\t\\t\\tnode.localworld.copy(m);\\n\\t\\t\\t\\tif(frame == 0)\\n\\t\\t\\t\\t\\tnode.matrix.copy(m);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( parent ) {\\n\\n\\t\\t\\tnode.world.multiplyMatrices( parent, node.world );\\n\\n\\t\\t}\\n\\n\\t\\tbones.push( node );\\n\\n\\t\\tfor ( var i = 0; i < node.nodes.length; i ++ ) {\\n\\n\\t\\t\\tsetupSkeleton( node.nodes[ i ], bones, frame, node.world );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setupSkinningMatrices ( bones, skin ) {\\n\\n\\t\\t// FIXME: this is dumb...\\n\\n\\t\\tfor ( var i = 0; i < bones.length; i ++ ) {\\n\\n\\t\\t\\tvar bone = bones[ i ];\\n\\t\\t\\tvar found = -1;\\n\\n\\t\\t\\tif ( bone.type != 'JOINT' ) continue;\\n\\n\\t\\t\\tfor ( var j = 0; j < skin.joints.length; j ++ ) {\\n\\n\\t\\t\\t\\tif ( bone.sid == skin.joints[ j ] ) {\\n\\n\\t\\t\\t\\t\\tfound = j;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( found >= 0 ) {\\n\\n\\t\\t\\t\\tvar inv = skin.invBindMatrices[ found ];\\n\\n\\t\\t\\t\\tbone.invBindMatrix = inv;\\n\\t\\t\\t\\tbone.skinningMatrix = new THREE.Matrix4();\\n\\t\\t\\t\\tbone.skinningMatrix.multiplyMatrices(bone.world, inv); // (IBMi * JMi)\\n\\t\\t\\t\\tbone.animatrix = new THREE.Matrix4();\\n\\n\\t\\t\\t\\tbone.animatrix.copy(bone.localworld);\\n\\t\\t\\t\\tbone.weights = [];\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < skin.weights.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\tfor (var k = 0; k < skin.weights[ j ].length; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar w = skin.weights[ j ][ k ];\\n\\n\\t\\t\\t\\t\\t\\tif ( w.joint == found ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tbone.weights.push( w );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.warn( \\\"ColladaLoader: Could not find joint '\\\" + bone.sid + \\\"'.\\\" );\\n\\n\\t\\t\\t\\tbone.skinningMatrix = new THREE.Matrix4();\\n\\t\\t\\t\\tbone.weights = [];\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\n\\t//Walk the Collada tree and flatten the bones into a list, extract the position, quat and scale from the matrix\\n\\tfunction flattenSkeleton(skeleton) {\\n\\n\\t\\tvar list = [];\\n\\t\\tvar walk = function(parentid, node, list) {\\n\\n\\t\\t\\tvar bone = {};\\n\\t\\t\\tbone.name = node.sid;\\n\\t\\t\\tbone.parent = parentid;\\n\\t\\t\\tbone.matrix = node.matrix;\\n\\t\\t\\tvar data = [new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3()];\\n\\t\\t\\tbone.matrix.decompose(data[0],data[1],data[2]);\\n\\n\\t\\t\\tbone.pos = [data[0].x,data[0].y,data[0].z];\\n\\n\\t\\t\\tbone.scl = [data[2].x,data[2].y,data[2].z];\\n\\t\\t\\tbone.rotq = [data[1].x,data[1].y,data[1].z,data[1].w];\\n\\t\\t\\tlist.push(bone);\\n\\n\\t\\t\\tfor(var i in node.nodes) {\\n\\n\\t\\t\\t\\twalk(node.sid,node.nodes[i],list);\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\twalk(-1,skeleton,list);\\n\\t\\treturn list;\\n\\n\\t}\\n\\n\\t//Move the vertices into the pose that is proper for the start of the animation\\n\\tfunction skinToBindPose(geometry,skeleton,skinController) {\\n\\n\\t\\tvar bones = [];\\n\\t\\tsetupSkeleton( skeleton, bones, -1 );\\n\\t\\tsetupSkinningMatrices( bones, skinController.skin );\\n\\t\\tv = new THREE.Vector3();\\n\\t\\tvar skinned = [];\\n\\n\\t\\tfor(var i =0; i < geometry.vertices.length; i++) {\\n\\n\\t\\t\\tskinned.push(new THREE.Vector3());\\n\\n\\t\\t}\\n\\n\\t\\tfor ( i = 0; i < bones.length; i ++ ) {\\n\\n\\t\\t\\tif ( bones[ i ].type != 'JOINT' ) continue;\\n\\n\\t\\t\\tfor ( j = 0; j < bones[ i ].weights.length; j ++ ) {\\n\\n\\t\\t\\t\\tw = bones[ i ].weights[ j ];\\n\\t\\t\\t\\tvidx = w.index;\\n\\t\\t\\t\\tweight = w.weight;\\n\\n\\t\\t\\t\\to = geometry.vertices[vidx];\\n\\t\\t\\t\\ts = skinned[vidx];\\n\\n\\t\\t\\t\\tv.x = o.x;\\n\\t\\t\\t\\tv.y = o.y;\\n\\t\\t\\t\\tv.z = o.z;\\n\\n\\t\\t\\t\\tv.applyMatrix4( bones[i].skinningMatrix );\\n\\n\\t\\t\\t\\ts.x += (v.x * weight);\\n\\t\\t\\t\\ts.y += (v.y * weight);\\n\\t\\t\\t\\ts.z += (v.z * weight);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfor(var i =0; i < geometry.vertices.length; i++) {\\n\\n\\t\\t\\tgeometry.vertices[i] = skinned[i];\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction applySkin ( geometry, instanceCtrl, frame ) {\\n\\n\\t\\tvar skinController = controllers[ instanceCtrl.url ];\\n\\n\\t\\tframe = frame !== undefined ? frame : 40;\\n\\n\\t\\tif ( !skinController || !skinController.skin ) {\\n\\n\\t\\t\\tconsole.log( 'ColladaLoader: Could not find skin controller.' );\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tif ( !instanceCtrl.skeleton || !instanceCtrl.skeleton.length ) {\\n\\n\\t\\t\\tconsole.log( 'ColladaLoader: Could not find the skeleton for the skin. ' );\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tvar animationBounds = calcAnimationBounds();\\n\\t\\tvar skeleton = daeScene.getChildById( instanceCtrl.skeleton[0], true ) ||\\n\\t\\t\\t\\t\\t   daeScene.getChildBySid( instanceCtrl.skeleton[0], true );\\n\\n\\t\\t//flatten the skeleton into a list of bones\\n\\t\\tvar bonelist = flattenSkeleton(skeleton);\\n\\t\\tvar joints = skinController.skin.joints;\\n\\n\\t\\t//sort that list so that the order reflects the order in the joint list\\n\\t\\tvar sortedbones = [];\\n\\t\\tfor(var i = 0; i < joints.length; i++) {\\n\\n\\t\\t\\tfor(var j =0; j < bonelist.length; j++) {\\n\\n\\t\\t\\t\\tif(bonelist[j].name == joints[i]) {\\n\\n\\t\\t\\t\\t\\tsortedbones[i] = bonelist[j];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t//hook up the parents by index instead of name\\n\\t\\tfor(var i = 0; i < sortedbones.length; i++) {\\n\\n\\t\\t\\tfor(var j =0; j < sortedbones.length; j++) {\\n\\n\\t\\t\\t\\tif(sortedbones[i].parent == sortedbones[j].name) {\\n\\n\\t\\t\\t\\t\\tsortedbones[i].parent = j;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\n\\t\\tvar i, j, w, vidx, weight;\\n\\t\\tvar v = new THREE.Vector3(), o, s;\\n\\n\\t\\t// move vertices to bind shape\\n\\t\\tfor ( i = 0; i < geometry.vertices.length; i ++ ) {\\n\\t\\t\\t\\t\\tgeometry.vertices[i].applyMatrix4( skinController.skin.bindShapeMatrix );\\n\\t\\t}\\n\\n\\t\\tvar skinIndices = [];\\n\\t\\tvar skinWeights = [];\\n\\t\\tvar weights = skinController.skin.weights;\\n\\n\\t\\t//hook up the skin weights\\n\\t\\t// TODO -  this might be a good place to choose greatest 4 weights\\n\\t\\tfor(var i =0; i < weights.length; i++) {\\n\\n\\t\\t\\tvar indicies = new THREE.Vector4(weights[i][0]?weights[i][0].joint:0,weights[i][1]?weights[i][1].joint:0,weights[i][2]?weights[i][2].joint:0,weights[i][3]?weights[i][3].joint:0);\\n\\t\\t\\tvar weight = new THREE.Vector4(weights[i][0]?weights[i][0].weight:0,weights[i][1]?weights[i][1].weight:0,weights[i][2]?weights[i][2].weight:0,weights[i][3]?weights[i][3].weight:0);\\n\\n\\t\\t\\tskinIndices.push(indicies);\\n\\t\\t\\tskinWeights.push(weight);\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.skinIndices = skinIndices;\\n\\t\\tgeometry.skinWeights = skinWeights;\\n\\t\\tgeometry.bones = sortedbones;\\n\\t\\t// process animation, or simply pose the rig if no animation\\n\\n\\t\\t//create an animation for the animated bones\\n\\t\\t//NOTE: this has no effect when using morphtargets\\n\\t\\tvar animationdata = {\\\"name\\\":animationBounds.ID,\\\"fps\\\":30,\\\"length\\\":animationBounds.frames/30,\\\"hierarchy\\\":[]};\\n\\n\\t\\tfor(var j =0; j < sortedbones.length; j++) {\\n\\n\\t\\t\\tanimationdata.hierarchy.push({parent:sortedbones[j].parent, name:sortedbones[j].name, keys:[]});\\n\\n\\t\\t}\\n\\n\\t\\tconsole.log( 'ColladaLoader:', animationBounds.ID + ' has ' + sortedbones.length + ' bones.' );\\n\\n\\n\\n\\t\\tskinToBindPose(geometry,skeleton,skinController);\\n\\n\\n\\t\\tfor ( frame = 0; frame < animationBounds.frames; frame ++ ) {\\n\\n\\t\\t\\tvar bones = [];\\n\\t\\t\\tvar skinned = [];\\n\\t\\t\\t// process the frame and setup the rig with a fresh\\n\\t\\t\\t// transform, possibly from the bone's animation channel(s)\\n\\n\\t\\t\\tsetupSkeleton( skeleton, bones, frame );\\n\\t\\t\\tsetupSkinningMatrices( bones, skinController.skin );\\n\\n\\t\\t\\tfor(var i = 0; i < bones.length; i ++) {\\n\\n\\t\\t\\t\\tfor(var j = 0; j < animationdata.hierarchy.length; j ++) {\\n\\n\\t\\t\\t\\t\\tif(animationdata.hierarchy[j].name == bones[i].sid) {\\n\\n\\t\\t\\t\\t\\t\\tvar key = {};\\n\\t\\t\\t\\t\\t\\tkey.time = (frame/30);\\n\\t\\t\\t\\t\\t\\tkey.matrix = bones[i].animatrix;\\n\\n\\t\\t\\t\\t\\t\\tif(frame == 0)\\n\\t\\t\\t\\t\\t\\t\\tbones[i].matrix = key.matrix;\\n\\n\\t\\t\\t\\t\\t\\tvar data = [new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3()];\\n\\t\\t\\t\\t\\t\\tkey.matrix.decompose(data[0],data[1],data[2]);\\n\\n\\t\\t\\t\\t\\t\\tkey.pos = [data[0].x,data[0].y,data[0].z];\\n\\n\\t\\t\\t\\t\\t\\tkey.scl = [data[2].x,data[2].y,data[2].z];\\n\\t\\t\\t\\t\\t\\tkey.rot = data[1];\\n\\n\\t\\t\\t\\t\\t\\tanimationdata.hierarchy[j].keys.push(key);\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry.animation = animationdata;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction createSceneGraph ( node, parent ) {\\n\\n\\t\\tvar obj = new THREE.Object3D();\\n\\t\\tvar skinned = false;\\n\\t\\tvar skinController;\\n\\t\\tvar morphController;\\n\\t\\tvar i, j;\\n\\n\\t\\t// FIXME: controllers\\n\\n\\t\\tfor ( i = 0; i < node.controllers.length; i ++ ) {\\n\\n\\t\\t\\tvar controller = controllers[ node.controllers[ i ].url ];\\n\\n\\t\\t\\tswitch ( controller.type ) {\\n\\n\\t\\t\\t\\tcase 'skin':\\n\\n\\t\\t\\t\\t\\tif ( geometries[ controller.skin.source ] ) {\\n\\n\\t\\t\\t\\t\\t\\tvar inst_geom = new InstanceGeometry();\\n\\n\\t\\t\\t\\t\\t\\tinst_geom.url = controller.skin.source;\\n\\t\\t\\t\\t\\t\\tinst_geom.instance_material = node.controllers[ i ].instance_material;\\n\\n\\t\\t\\t\\t\\t\\tnode.geometries.push( inst_geom );\\n\\t\\t\\t\\t\\t\\tskinned = true;\\n\\t\\t\\t\\t\\t\\tskinController = node.controllers[ i ];\\n\\n\\t\\t\\t\\t\\t} else if ( controllers[ controller.skin.source ] ) {\\n\\n\\t\\t\\t\\t\\t\\t// urgh: controller can be chained\\n\\t\\t\\t\\t\\t\\t// handle the most basic case...\\n\\n\\t\\t\\t\\t\\t\\tvar second = controllers[ controller.skin.source ];\\n\\t\\t\\t\\t\\t\\tmorphController = second;\\n\\t\\t\\t\\t\\t//\\tskinController = node.controllers[i];\\n\\n\\t\\t\\t\\t\\t\\tif ( second.morph && geometries[ second.morph.source ] ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar inst_geom = new InstanceGeometry();\\n\\n\\t\\t\\t\\t\\t\\t\\tinst_geom.url = second.morph.source;\\n\\t\\t\\t\\t\\t\\t\\tinst_geom.instance_material = node.controllers[ i ].instance_material;\\n\\n\\t\\t\\t\\t\\t\\t\\tnode.geometries.push( inst_geom );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'morph':\\n\\n\\t\\t\\t\\t\\tif ( geometries[ controller.morph.source ] ) {\\n\\n\\t\\t\\t\\t\\t\\tvar inst_geom = new InstanceGeometry();\\n\\n\\t\\t\\t\\t\\t\\tinst_geom.url = controller.morph.source;\\n\\t\\t\\t\\t\\t\\tinst_geom.instance_material = node.controllers[ i ].instance_material;\\n\\n\\t\\t\\t\\t\\t\\tnode.geometries.push( inst_geom );\\n\\t\\t\\t\\t\\t\\tmorphController = node.controllers[ i ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tconsole.log( 'ColladaLoader: Morph-controller partially supported.' );\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// geometries\\n\\n\\t\\tvar double_sided_materials = {};\\n\\n\\t\\tfor ( i = 0; i < node.geometries.length; i ++ ) {\\n\\n\\t\\t\\tvar instance_geometry = node.geometries[i];\\n\\t\\t\\tvar instance_materials = instance_geometry.instance_material;\\n\\t\\t\\tvar geometry = geometries[ instance_geometry.url ];\\n\\t\\t\\tvar used_materials = {};\\n\\t\\t\\tvar used_materials_array = [];\\n\\t\\t\\tvar num_materials = 0;\\n\\t\\t\\tvar first_material;\\n\\n\\t\\t\\tif ( geometry ) {\\n\\n\\t\\t\\t\\tif ( !geometry.mesh || !geometry.mesh.primitives )\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif ( obj.name.length == 0 ) {\\n\\n\\t\\t\\t\\t\\tobj.name = geometry.id;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// collect used fx for this geometry-instance\\n\\n\\t\\t\\t\\tif ( instance_materials ) {\\n\\n\\t\\t\\t\\t\\tfor ( j = 0; j < instance_materials.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar instance_material = instance_materials[ j ];\\n\\t\\t\\t\\t\\t\\tvar mat = materials[ instance_material.target ];\\n\\t\\t\\t\\t\\t\\tvar effect_id = mat.instance_effect.url;\\n\\t\\t\\t\\t\\t\\tvar shader = effects[ effect_id ].shader;\\n\\t\\t\\t\\t\\t\\tvar material3js = shader.material;\\n\\n\\t\\t\\t\\t\\t\\tif ( geometry.doubleSided ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( !( instance_material.symbol in double_sided_materials ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar _copied_material = material3js.clone();\\n\\t\\t\\t\\t\\t\\t\\t\\t_copied_material.side = THREE.DoubleSide;\\n\\t\\t\\t\\t\\t\\t\\t\\tdouble_sided_materials[ instance_material.symbol ] = _copied_material;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tmaterial3js = double_sided_materials[ instance_material.symbol ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tmaterial3js.opacity = !material3js.opacity ? 1 : material3js.opacity;\\n\\t\\t\\t\\t\\t\\tused_materials[ instance_material.symbol ] = num_materials;\\n\\t\\t\\t\\t\\t\\tused_materials_array.push( material3js );\\n\\t\\t\\t\\t\\t\\tfirst_material = material3js;\\n\\t\\t\\t\\t\\t\\tfirst_material.name = mat.name == null || mat.name === '' ? mat.id : mat.name;\\n\\t\\t\\t\\t\\t\\tnum_materials ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar mesh;\\n\\t\\t\\t\\tvar material = first_material || new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.FlatShading, side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide } );\\n\\t\\t\\t\\tvar geom = geometry.mesh.geometry3js;\\n\\n\\t\\t\\t\\tif ( num_materials > 1 ) {\\n\\n\\t\\t\\t\\t\\tmaterial = new THREE.MeshFaceMaterial( used_materials_array );\\n\\n\\t\\t\\t\\t\\tfor ( j = 0; j < geom.faces.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar face = geom.faces[ j ];\\n\\t\\t\\t\\t\\t\\tface.materialIndex = used_materials[ face.daeMaterial ]\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( skinController !== undefined ) {\\n\\n\\n\\t\\t\\t\\t\\tapplySkin( geom, skinController );\\n\\n\\t\\t\\t\\t\\tif(geom.morphTargets.length > 0) {\\n\\n\\t\\t\\t\\t\\t\\tmaterial.morphTargets = true;\\n\\t\\t\\t\\t\\t\\tmaterial.skinning = false;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tmaterial.morphTargets = false;\\n\\t\\t\\t\\t\\t\\tmaterial.skinning = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\tmesh = new THREE.SkinnedMesh( geom, material, false );\\n\\n\\n\\t\\t\\t\\t\\t//mesh.skeleton = skinController.skeleton;\\n\\t\\t\\t\\t\\t//mesh.skinController = controllers[ skinController.url ];\\n\\t\\t\\t\\t\\t//mesh.skinInstanceController = skinController;\\n\\t\\t\\t\\t\\tmesh.name = 'skin_' + skins.length;\\n\\n\\n\\n\\t\\t\\t\\t\\t//mesh.animationHandle.setKey(0);\\n\\t\\t\\t\\t\\tskins.push( mesh );\\n\\n\\t\\t\\t\\t} else if ( morphController !== undefined ) {\\n\\n\\t\\t\\t\\t\\tcreateMorph( geom, morphController );\\n\\n\\t\\t\\t\\t\\tmaterial.morphTargets = true;\\n\\n\\t\\t\\t\\t\\tmesh = new THREE.Mesh( geom, material );\\n\\t\\t\\t\\t\\tmesh.name = 'morph_' + morphs.length;\\n\\n\\t\\t\\t\\t\\tmorphs.push( mesh );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tmesh = new THREE.Mesh( geom, material );\\n\\t\\t\\t\\t\\t// mesh.geom.name = geometry.id;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// N.B.: TP says this is not a great default behavior. It's a nice\\n\\t\\t\\t\\t// optimization to flatten the hierarchy but this should be done\\n\\t\\t\\t\\t// only if requested by the user via a flag. For now I undid it\\n\\t\\t\\t\\t// and fixed the character animation example that uses it\\n\\t\\t\\t\\t// node.geometries.length > 1 ? obj.add( mesh ) : obj = mesh;\\n\\t\\t\\t\\tobj.add(mesh);\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfor ( i = 0; i < node.cameras.length; i ++ ) {\\n\\n\\t\\t\\tvar instance_camera = node.cameras[i];\\n\\t\\t\\tvar cparams = cameras[instance_camera.url];\\n\\n\\t\\t\\tvar cam = new THREE.PerspectiveCamera(cparams.yfov, parseFloat(cparams.aspect_ratio),\\n\\t\\t\\t\\t\\tparseFloat(cparams.znear), parseFloat(cparams.zfar));\\n\\n\\t\\t\\tobj.add(cam);\\n\\t\\t}\\n\\n\\t\\tfor ( i = 0; i < node.lights.length; i ++ ) {\\n\\n\\t\\t\\tvar light = null;\\n\\t\\t\\tvar instance_light = node.lights[i];\\n\\t\\t\\tvar lparams = lights[instance_light.url];\\n\\n\\t\\t\\tif ( lparams && lparams.technique ) {\\n\\n\\t\\t\\t\\tvar color = lparams.color.getHex();\\n\\t\\t\\t\\tvar intensity = lparams.intensity;\\n\\t\\t\\t\\tvar distance = lparams.distance;\\n\\t\\t\\t\\tvar angle = lparams.falloff_angle;\\n\\t\\t\\t\\tvar exponent; // Intentionally undefined, don't know what this is yet\\n\\n\\t\\t\\t\\tswitch ( lparams.technique ) {\\n\\n\\t\\t\\t\\t\\tcase 'directional':\\n\\n\\t\\t\\t\\t\\t\\tlight = new THREE.DirectionalLight( color, intensity, distance );\\n\\t\\t\\t\\t\\t\\tlight.position.set(0, 0, 1);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'point':\\n\\n\\t\\t\\t\\t\\t\\tlight = new THREE.PointLight( color, intensity, distance );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'spot':\\n\\n\\t\\t\\t\\t\\t\\tlight = new THREE.SpotLight( color, intensity, distance, angle, exponent );\\n\\t\\t\\t\\t\\t\\tlight.position.set(0, 0, 1);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'ambient':\\n\\n\\t\\t\\t\\t\\t\\tlight = new THREE.AmbientLight( color );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (light) {\\n\\t\\t\\t\\tobj.add(light);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tobj.name = node.name || node.id || \\\"\\\";\\n\\t\\tobj.id = node.id || \\\"\\\";\\n\\t\\tobj.layer = node.layer || \\\"\\\";\\n\\t\\tobj.matrix = node.matrix;\\n\\t\\tobj.matrix.decompose( obj.position, obj.quaternion, obj.scale );\\n\\n\\t\\tif ( options.centerGeometry && obj.geometry ) {\\n\\n\\t\\t\\tvar delta = obj.geometry.center();\\n\\t\\t\\tdelta.multiply( obj.scale );\\n\\t\\t\\tdelta.applyQuaternion( obj.quaternion );\\n\\n\\t\\t\\tobj.position.sub( delta );\\n\\n\\t\\t}\\n\\n\\t\\tfor ( i = 0; i < node.nodes.length; i ++ ) {\\n\\n\\t\\t\\tobj.add( createSceneGraph( node.nodes[i], node ) );\\n\\n\\t\\t}\\n\\n\\t\\treturn obj;\\n\\n\\t};\\n\\n\\tfunction getJointId( skin, id ) {\\n\\n\\t\\tfor ( var i = 0; i < skin.joints.length; i ++ ) {\\n\\n\\t\\t\\tif ( skin.joints[ i ] == id ) {\\n\\n\\t\\t\\t\\treturn i;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction getLibraryNode( id ) {\\n\\n        var nodes = COLLADA.querySelectorAll('library_nodes node');\\n\\n        for ( var i = 0; i < nodes.length; i++ ) {\\n\\n            var attObj = nodes[i].attributes.getNamedItem('id');\\n            if ( attObj && attObj.value === id ) {\\n                return nodes[i];\\n        }\\n        }\\n\\n        return undefined;\\n\\n\\t};\\n\\n\\tfunction getChannelsForNode (node ) {\\n\\n\\t\\tvar channels = [];\\n\\t\\tvar startTime = 1000000;\\n\\t\\tvar endTime = -1000000;\\n\\n\\t\\tfor ( var id in animations ) {\\n\\n\\t\\t\\tvar animation = animations[id];\\n\\n\\t\\t\\tfor ( var i = 0; i < animation.channel.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar channel = animation.channel[i];\\n\\t\\t\\t\\tvar sampler = animation.sampler[i];\\n\\t\\t\\t\\tvar id = channel.target.split('/')[0];\\n\\n\\t\\t\\t\\tif ( id == node.id ) {\\n\\n\\t\\t\\t\\t\\tsampler.create();\\n\\t\\t\\t\\t\\tchannel.sampler = sampler;\\n\\t\\t\\t\\t\\tstartTime = Math.min(startTime, sampler.startTime);\\n\\t\\t\\t\\t\\tendTime = Math.max(endTime, sampler.endTime);\\n\\t\\t\\t\\t\\tchannels.push(channel);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( channels.length ) {\\n\\n\\t\\t\\tnode.startTime = startTime;\\n\\t\\t\\tnode.endTime = endTime;\\n\\n\\t\\t}\\n\\n\\t\\treturn channels;\\n\\n\\t};\\n\\n\\tfunction calcFrameDuration( node ) {\\n\\n\\t\\tvar minT = 10000000;\\n\\n\\t\\tfor ( var i = 0; i < node.channels.length; i ++ ) {\\n\\n\\t\\t\\tvar sampler = node.channels[i].sampler;\\n\\n\\t\\t\\tfor ( var j = 0; j < sampler.input.length - 1; j ++ ) {\\n\\n\\t\\t\\t\\tvar t0 = sampler.input[ j ];\\n\\t\\t\\t\\tvar t1 = sampler.input[ j + 1 ];\\n\\t\\t\\t\\tminT = Math.min( minT, t1 - t0 );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn minT;\\n\\n\\t};\\n\\n\\tfunction calcMatrixAt( node, t ) {\\n\\n\\t\\tvar animated = {};\\n\\n\\t\\tvar i, j;\\n\\n\\t\\tfor ( i = 0; i < node.channels.length; i ++ ) {\\n\\n\\t\\t\\tvar channel = node.channels[ i ];\\n\\t\\t\\tanimated[ channel.sid ] = channel;\\n\\n\\t\\t}\\n\\n\\t\\tvar matrix = new THREE.Matrix4();\\n\\n\\t\\tfor ( i = 0; i < node.transforms.length; i ++ ) {\\n\\n\\t\\t\\tvar transform = node.transforms[ i ];\\n\\t\\t\\tvar channel = animated[ transform.sid ];\\n\\n\\t\\t\\tif ( channel !== undefined ) {\\n\\n\\t\\t\\t\\tvar sampler = channel.sampler;\\n\\t\\t\\t\\tvar value;\\n\\n\\t\\t\\t\\tfor ( j = 0; j < sampler.input.length - 1; j ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( sampler.input[ j + 1 ] > t ) {\\n\\n\\t\\t\\t\\t\\t\\tvalue = sampler.output[ j ];\\n\\t\\t\\t\\t\\t\\t//console.log(value.flatten)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\tif ( value instanceof THREE.Matrix4 ) {\\n\\n\\t\\t\\t\\t\\t\\tmatrix.multiplyMatrices( matrix, value );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// FIXME: handle other types\\n\\n\\t\\t\\t\\t\\t\\tmatrix.multiplyMatrices( matrix, transform.matrix );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tmatrix.multiplyMatrices( matrix, transform.matrix );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmatrix.multiplyMatrices( matrix, transform.matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn matrix;\\n\\n\\t};\\n\\n\\tfunction bakeAnimations ( node ) {\\n\\n\\t\\tif ( node.channels && node.channels.length ) {\\n\\n\\t\\t\\tvar keys = [],\\n\\t\\t\\t\\tsids = [];\\n\\n\\t\\t\\tfor ( var i = 0, il = node.channels.length; i < il; i++ ) {\\n\\n\\t\\t\\t\\tvar channel = node.channels[i],\\n\\t\\t\\t\\t\\tfullSid = channel.fullSid,\\n\\t\\t\\t\\t\\tsampler = channel.sampler,\\n\\t\\t\\t\\t\\tinput = sampler.input,\\n\\t\\t\\t\\t\\ttransform = node.getTransformBySid( channel.sid ),\\n\\t\\t\\t\\t\\tmember;\\n\\n\\t\\t\\t\\tif ( channel.arrIndices ) {\\n\\n\\t\\t\\t\\t\\tmember = [];\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = channel.arrIndices.length; j < jl; j++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmember[ j ] = getConvertedIndex( channel.arrIndices[ j ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tmember = getConvertedMember( channel.member );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( transform ) {\\n\\n\\t\\t\\t\\t\\tif ( sids.indexOf( fullSid ) === -1 ) {\\n\\n\\t\\t\\t\\t\\t\\tsids.push( fullSid );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = input.length; j < jl; j++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar time = input[j],\\n\\t\\t\\t\\t\\t\\t\\tdata = sampler.getData( transform.type, j, member ),\\n\\t\\t\\t\\t\\t\\t\\tkey = findKey( keys, time );\\n\\n\\t\\t\\t\\t\\t\\tif ( !key ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tkey = new Key( time );\\n\\t\\t\\t\\t\\t\\t\\tvar timeNdx = findTimeNdx( keys, time );\\n\\t\\t\\t\\t\\t\\t\\tkeys.splice( timeNdx == -1 ? keys.length : timeNdx, 0, key );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tkey.addTarget( fullSid, transform, member, data );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tconsole.log( 'Could not find transform \\\"' + channel.sid + '\\\" in node ' + node.id );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// post process\\n\\t\\t\\tfor ( var i = 0; i < sids.length; i++ ) {\\n\\n\\t\\t\\t\\tvar sid = sids[ i ];\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < keys.length; j++ ) {\\n\\n\\t\\t\\t\\t\\tvar key = keys[ j ];\\n\\n\\t\\t\\t\\t\\tif ( !key.hasTarget( sid ) ) {\\n\\n\\t\\t\\t\\t\\t\\tinterpolateKeys( keys, key, j, sid );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tnode.keys = keys;\\n\\t\\t\\tnode.sids = sids;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction findKey ( keys, time) {\\n\\n\\t\\tvar retVal = null;\\n\\n\\t\\tfor ( var i = 0, il = keys.length; i < il && retVal == null; i++ ) {\\n\\n\\t\\t\\tvar key = keys[i];\\n\\n\\t\\t\\tif ( key.time === time ) {\\n\\n\\t\\t\\t\\tretVal = key;\\n\\n\\t\\t\\t} else if ( key.time > time ) {\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn retVal;\\n\\n\\t};\\n\\n\\tfunction findTimeNdx ( keys, time) {\\n\\n\\t\\tvar ndx = -1;\\n\\n\\t\\tfor ( var i = 0, il = keys.length; i < il && ndx == -1; i++ ) {\\n\\n\\t\\t\\tvar key = keys[i];\\n\\n\\t\\t\\tif ( key.time >= time ) {\\n\\n\\t\\t\\t\\tndx = i;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ndx;\\n\\n\\t};\\n\\n\\tfunction interpolateKeys ( keys, key, ndx, fullSid ) {\\n\\n\\t\\tvar prevKey = getPrevKeyWith( keys, fullSid, ndx ? ndx-1 : 0 ),\\n\\t\\t\\tnextKey = getNextKeyWith( keys, fullSid, ndx+1 );\\n\\n\\t\\tif ( prevKey && nextKey ) {\\n\\n\\t\\t\\tvar scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time),\\n\\t\\t\\t\\tprevTarget = prevKey.getTarget( fullSid ),\\n\\t\\t\\t\\tnextData = nextKey.getTarget( fullSid ).data,\\n\\t\\t\\t\\tprevData = prevTarget.data,\\n\\t\\t\\t\\tdata;\\n\\n\\t\\t\\tif ( prevTarget.type === 'matrix' ) {\\n\\n\\t\\t\\t\\tdata = prevData;\\n\\n\\t\\t\\t} else if ( prevData.length ) {\\n\\n\\t\\t\\t\\tdata = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < prevData.length; ++i ) {\\n\\n\\t\\t\\t\\t\\tdata[ i ] = prevData[ i ] + ( nextData[ i ] - prevData[ i ] ) * scale;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdata = prevData + ( nextData - prevData ) * scale;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tkey.addTarget( fullSid, prevTarget.transform, prevTarget.member, data );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// Get next key with given sid\\n\\n\\tfunction getNextKeyWith( keys, fullSid, ndx ) {\\n\\n\\t\\tfor ( ; ndx < keys.length; ndx++ ) {\\n\\n\\t\\t\\tvar key = keys[ ndx ];\\n\\n\\t\\t\\tif ( key.hasTarget( fullSid ) ) {\\n\\n\\t\\t\\t\\treturn key;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\n\\t};\\n\\n\\t// Get previous key with given sid\\n\\n\\tfunction getPrevKeyWith( keys, fullSid, ndx ) {\\n\\n\\t\\tndx = ndx >= 0 ? ndx : ndx + keys.length;\\n\\n\\t\\tfor ( ; ndx >= 0; ndx-- ) {\\n\\n\\t\\t\\tvar key = keys[ ndx ];\\n\\n\\t\\t\\tif ( key.hasTarget( fullSid ) ) {\\n\\n\\t\\t\\t\\treturn key;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\n\\t};\\n\\n\\tfunction _Image() {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.init_from = \\\"\\\";\\n\\n\\t};\\n\\n\\t_Image.prototype.parse = function(element) {\\n\\n\\t\\tthis.id = element.getAttribute('id');\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\n\\t\\t\\tif ( child.nodeName == 'init_from' ) {\\n\\n\\t\\t\\t\\tthis.init_from = child.textContent;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Controller() {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.name = \\\"\\\";\\n\\t\\tthis.type = \\\"\\\";\\n\\t\\tthis.skin = null;\\n\\t\\tthis.morph = null;\\n\\n\\t};\\n\\n\\tController.prototype.parse = function( element ) {\\n\\n\\t\\tthis.id = element.getAttribute('id');\\n\\t\\tthis.name = element.getAttribute('name');\\n\\t\\tthis.type = \\\"none\\\";\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'skin':\\n\\n\\t\\t\\t\\t\\tthis.skin = (new Skin()).parse(child);\\n\\t\\t\\t\\t\\tthis.type = child.nodeName;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'morph':\\n\\n\\t\\t\\t\\t\\tthis.morph = (new Morph()).parse(child);\\n\\t\\t\\t\\t\\tthis.type = child.nodeName;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Morph() {\\n\\n\\t\\tthis.method = null;\\n\\t\\tthis.source = null;\\n\\t\\tthis.targets = null;\\n\\t\\tthis.weights = null;\\n\\n\\t};\\n\\n\\tMorph.prototype.parse = function( element ) {\\n\\n\\t\\tvar sources = {};\\n\\t\\tvar inputs = [];\\n\\t\\tvar i;\\n\\n\\t\\tthis.method = element.getAttribute( 'method' );\\n\\t\\tthis.source = element.getAttribute( 'source' ).replace( /^#/, '' );\\n\\n\\t\\tfor ( i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'source':\\n\\n\\t\\t\\t\\t\\tvar source = ( new Source() ).parse( child );\\n\\t\\t\\t\\t\\tsources[ source.id ] = source;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'targets':\\n\\n\\t\\t\\t\\t\\tinputs = this.parseInputs( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\tconsole.log( child.nodeName );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfor ( i = 0; i < inputs.length; i ++ ) {\\n\\n\\t\\t\\tvar input = inputs[ i ];\\n\\t\\t\\tvar source = sources[ input.source ];\\n\\n\\t\\t\\tswitch ( input.semantic ) {\\n\\n\\t\\t\\t\\tcase 'MORPH_TARGET':\\n\\n\\t\\t\\t\\t\\tthis.targets = source.read();\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'MORPH_WEIGHT':\\n\\n\\t\\t\\t\\t\\tthis.weights = source.read();\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tMorph.prototype.parseInputs = function(element) {\\n\\n\\t\\tvar inputs = [];\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[i];\\n\\t\\t\\tif ( child.nodeType != 1) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'input':\\n\\n\\t\\t\\t\\t\\tinputs.push( (new Input()).parse(child) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn inputs;\\n\\n\\t};\\n\\n\\tfunction Skin() {\\n\\n\\t\\tthis.source = \\\"\\\";\\n\\t\\tthis.bindShapeMatrix = null;\\n\\t\\tthis.invBindMatrices = [];\\n\\t\\tthis.joints = [];\\n\\t\\tthis.weights = [];\\n\\n\\t};\\n\\n\\tSkin.prototype.parse = function( element ) {\\n\\n\\t\\tvar sources = {};\\n\\t\\tvar joints, weights;\\n\\n\\t\\tthis.source = element.getAttribute( 'source' ).replace( /^#/, '' );\\n\\t\\tthis.invBindMatrices = [];\\n\\t\\tthis.joints = [];\\n\\t\\tthis.weights = [];\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[i];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'bind_shape_matrix':\\n\\n\\t\\t\\t\\t\\tvar f = _floats(child.textContent);\\n\\t\\t\\t\\t\\tthis.bindShapeMatrix = getConvertedMat4( f );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'source':\\n\\n\\t\\t\\t\\t\\tvar src = new Source().parse(child);\\n\\t\\t\\t\\t\\tsources[ src.id ] = src;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'joints':\\n\\n\\t\\t\\t\\t\\tjoints = child;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'vertex_weights':\\n\\n\\t\\t\\t\\t\\tweights = child;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\tconsole.log( child.nodeName );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.parseJoints( joints, sources );\\n\\t\\tthis.parseWeights( weights, sources );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tSkin.prototype.parseJoints = function ( element, sources ) {\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'input':\\n\\n\\t\\t\\t\\t\\tvar input = ( new Input() ).parse( child );\\n\\t\\t\\t\\t\\tvar source = sources[ input.source ];\\n\\n\\t\\t\\t\\t\\tif ( input.semantic == 'JOINT' ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.joints = source.read();\\n\\n\\t\\t\\t\\t\\t} else if ( input.semantic == 'INV_BIND_MATRIX' ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.invBindMatrices = source.read();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tSkin.prototype.parseWeights = function ( element, sources ) {\\n\\n\\t\\tvar v, vcount, inputs = [];\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'input':\\n\\n\\t\\t\\t\\t\\tinputs.push( ( new Input() ).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'v':\\n\\n\\t\\t\\t\\t\\tv = _ints( child.textContent );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'vcount':\\n\\n\\t\\t\\t\\t\\tvcount = _ints( child.textContent );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar index = 0;\\n\\n\\t\\tfor ( var i = 0; i < vcount.length; i ++ ) {\\n\\n\\t\\t\\tvar numBones = vcount[i];\\n\\t\\t\\tvar vertex_weights = [];\\n\\n\\t\\t\\tfor ( var j = 0; j < numBones; j++ ) {\\n\\n\\t\\t\\t\\tvar influence = {};\\n\\n\\t\\t\\t\\tfor ( var k = 0; k < inputs.length; k ++ ) {\\n\\n\\t\\t\\t\\t\\tvar input = inputs[ k ];\\n\\t\\t\\t\\t\\tvar value = v[ index + input.offset ];\\n\\n\\t\\t\\t\\t\\tswitch ( input.semantic ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'JOINT':\\n\\n\\t\\t\\t\\t\\t\\t\\tinfluence.joint = value;//this.joints[value];\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'WEIGHT':\\n\\n\\t\\t\\t\\t\\t\\t\\tinfluence.weight = sources[ input.source ].data[ value ];\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvertex_weights.push( influence );\\n\\t\\t\\t\\tindex += inputs.length;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var j = 0; j < vertex_weights.length; j ++ ) {\\n\\n\\t\\t\\t\\tvertex_weights[ j ].index = i;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.weights.push( vertex_weights );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction VisualScene () {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.name = \\\"\\\";\\n\\t\\tthis.nodes = [];\\n\\t\\tthis.scene = new THREE.Object3D();\\n\\n\\t};\\n\\n\\tVisualScene.prototype.getChildById = function( id, recursive ) {\\n\\n\\t\\tfor ( var i = 0; i < this.nodes.length; i ++ ) {\\n\\n\\t\\t\\tvar node = this.nodes[ i ].getChildById( id, recursive );\\n\\n\\t\\t\\tif ( node ) {\\n\\n\\t\\t\\t\\treturn node;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\n\\t};\\n\\n\\tVisualScene.prototype.getChildBySid = function( sid, recursive ) {\\n\\n\\t\\tfor ( var i = 0; i < this.nodes.length; i ++ ) {\\n\\n\\t\\t\\tvar node = this.nodes[ i ].getChildBySid( sid, recursive );\\n\\n\\t\\t\\tif ( node ) {\\n\\n\\t\\t\\t\\treturn node;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\n\\t};\\n\\n\\tVisualScene.prototype.parse = function( element ) {\\n\\n\\t\\tthis.id = element.getAttribute( 'id' );\\n\\t\\tthis.name = element.getAttribute( 'name' );\\n\\t\\tthis.nodes = [];\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'node':\\n\\n\\t\\t\\t\\t\\tthis.nodes.push( ( new Node() ).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Node() {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.name = \\\"\\\";\\n\\t\\tthis.sid = \\\"\\\";\\n\\t\\tthis.nodes = [];\\n\\t\\tthis.controllers = [];\\n\\t\\tthis.transforms = [];\\n\\t\\tthis.geometries = [];\\n\\t\\tthis.channels = [];\\n\\t\\tthis.matrix = new THREE.Matrix4();\\n\\n\\t};\\n\\n\\tNode.prototype.getChannelForTransform = function( transformSid ) {\\n\\n\\t\\tfor ( var i = 0; i < this.channels.length; i ++ ) {\\n\\n\\t\\t\\tvar channel = this.channels[i];\\n\\t\\t\\tvar parts = channel.target.split('/');\\n\\t\\t\\tvar id = parts.shift();\\n\\t\\t\\tvar sid = parts.shift();\\n\\t\\t\\tvar dotSyntax = (sid.indexOf(\\\".\\\") >= 0);\\n\\t\\t\\tvar arrSyntax = (sid.indexOf(\\\"(\\\") >= 0);\\n\\t\\t\\tvar arrIndices;\\n\\t\\t\\tvar member;\\n\\n\\t\\t\\tif ( dotSyntax ) {\\n\\n\\t\\t\\t\\tparts = sid.split(\\\".\\\");\\n\\t\\t\\t\\tsid = parts.shift();\\n\\t\\t\\t\\tmember = parts.shift();\\n\\n\\t\\t\\t} else if ( arrSyntax ) {\\n\\n\\t\\t\\t\\tarrIndices = sid.split(\\\"(\\\");\\n\\t\\t\\t\\tsid = arrIndices.shift();\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < arrIndices.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\tarrIndices[ j ] = parseInt( arrIndices[ j ].replace( /\\\\)/, '' ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( sid == transformSid ) {\\n\\n\\t\\t\\t\\tchannel.info = { sid: sid, dotSyntax: dotSyntax, arrSyntax: arrSyntax, arrIndices: arrIndices };\\n\\t\\t\\t\\treturn channel;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\n\\t};\\n\\n\\tNode.prototype.getChildById = function ( id, recursive ) {\\n\\n\\t\\tif ( this.id == id ) {\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t\\tif ( recursive ) {\\n\\n\\t\\t\\tfor ( var i = 0; i < this.nodes.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar n = this.nodes[ i ].getChildById( id, recursive );\\n\\n\\t\\t\\t\\tif ( n ) {\\n\\n\\t\\t\\t\\t\\treturn n;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\n\\t};\\n\\n\\tNode.prototype.getChildBySid = function ( sid, recursive ) {\\n\\n\\t\\tif ( this.sid == sid ) {\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t\\tif ( recursive ) {\\n\\n\\t\\t\\tfor ( var i = 0; i < this.nodes.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar n = this.nodes[ i ].getChildBySid( sid, recursive );\\n\\n\\t\\t\\t\\tif ( n ) {\\n\\n\\t\\t\\t\\t\\treturn n;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\n\\t};\\n\\n\\tNode.prototype.getTransformBySid = function ( sid ) {\\n\\n\\t\\tfor ( var i = 0; i < this.transforms.length; i ++ ) {\\n\\n\\t\\t\\tif ( this.transforms[ i ].sid == sid ) return this.transforms[ i ];\\n\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\n\\t};\\n\\n\\tNode.prototype.parse = function( element ) {\\n\\n\\t\\tvar url;\\n\\n\\t\\tthis.id = element.getAttribute('id');\\n\\t\\tthis.sid = element.getAttribute('sid');\\n\\t\\tthis.name = element.getAttribute('name');\\n\\t\\tthis.type = element.getAttribute('type');\\n\\t\\tthis.layer = element.getAttribute('layer');\\n\\n\\t\\tthis.type = this.type == 'JOINT' ? this.type : 'NODE';\\n\\n\\t\\tthis.nodes = [];\\n\\t\\tthis.transforms = [];\\n\\t\\tthis.geometries = [];\\n\\t\\tthis.cameras = [];\\n\\t\\tthis.lights = [];\\n\\t\\tthis.controllers = [];\\n\\t\\tthis.matrix = new THREE.Matrix4();\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'node':\\n\\n\\t\\t\\t\\t\\tthis.nodes.push( ( new Node() ).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'instance_camera':\\n\\n\\t\\t\\t\\t\\tthis.cameras.push( ( new InstanceCamera() ).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'instance_controller':\\n\\n\\t\\t\\t\\t\\tthis.controllers.push( ( new InstanceController() ).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'instance_geometry':\\n\\n\\t\\t\\t\\t\\tthis.geometries.push( ( new InstanceGeometry() ).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'instance_light':\\n\\n\\t\\t\\t\\t\\tthis.lights.push( ( new InstanceLight() ).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'instance_node':\\n\\n\\t\\t\\t\\t\\turl = child.getAttribute( 'url' ).replace( /^#/, '' );\\n\\t\\t\\t\\t\\tvar iNode = getLibraryNode( url );\\n\\n\\t\\t\\t\\t\\tif ( iNode ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.nodes.push( ( new Node() ).parse( iNode )) ;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'rotate':\\n\\t\\t\\t\\tcase 'translate':\\n\\t\\t\\t\\tcase 'scale':\\n\\t\\t\\t\\tcase 'matrix':\\n\\t\\t\\t\\tcase 'lookat':\\n\\t\\t\\t\\tcase 'skew':\\n\\n\\t\\t\\t\\t\\tthis.transforms.push( ( new Transform() ).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'extra':\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\tconsole.log( child.nodeName );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.channels = getChannelsForNode( this );\\n\\t\\tbakeAnimations( this );\\n\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tNode.prototype.updateMatrix = function () {\\n\\n\\t\\tthis.matrix.identity();\\n\\n\\t\\tfor ( var i = 0; i < this.transforms.length; i ++ ) {\\n\\n\\t\\t\\tthis.transforms[ i ].apply( this.matrix );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction Transform () {\\n\\n\\t\\tthis.sid = \\\"\\\";\\n\\t\\tthis.type = \\\"\\\";\\n\\t\\tthis.data = [];\\n\\t\\tthis.obj = null;\\n\\n\\t};\\n\\n\\tTransform.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.sid = element.getAttribute( 'sid' );\\n\\t\\tthis.type = element.nodeName;\\n\\t\\tthis.data = _floats( element.textContent );\\n\\t\\tthis.convert();\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tTransform.prototype.convert = function () {\\n\\n\\t\\tswitch ( this.type ) {\\n\\n\\t\\t\\tcase 'matrix':\\n\\n\\t\\t\\t\\tthis.obj = getConvertedMat4( this.data );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'rotate':\\n\\n\\t\\t\\t\\tthis.angle = THREE.Math.degToRad( this.data[3] );\\n\\n\\t\\t\\tcase 'translate':\\n\\n\\t\\t\\t\\tfixCoords( this.data, -1 );\\n\\t\\t\\t\\tthis.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'scale':\\n\\n\\t\\t\\t\\tfixCoords( this.data, 1 );\\n\\t\\t\\t\\tthis.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tconsole.log( 'Can not convert Transform of type ' + this.type );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tTransform.prototype.apply = function () {\\n\\n\\t\\tvar m1 = new THREE.Matrix4();\\n\\n\\t\\treturn function ( matrix ) {\\n\\n\\t\\t\\tswitch ( this.type ) {\\n\\n\\t\\t\\t\\tcase 'matrix':\\n\\n\\t\\t\\t\\t\\tmatrix.multiply( this.obj );\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'translate':\\n\\n\\t\\t\\t\\t\\tmatrix.multiply( m1.makeTranslation( this.obj.x, this.obj.y, this.obj.z ) );\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'rotate':\\n\\n\\t\\t\\t\\t\\tmatrix.multiply( m1.makeRotationAxis( this.obj, this.angle ) );\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'scale':\\n\\n\\t\\t\\t\\t\\tmatrix.scale( this.obj );\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tTransform.prototype.update = function ( data, member ) {\\n\\n\\t\\tvar members = [ 'X', 'Y', 'Z', 'ANGLE' ];\\n\\n\\t\\tswitch ( this.type ) {\\n\\n\\t\\t\\tcase 'matrix':\\n\\n\\t\\t\\t\\tif ( ! member ) {\\n\\n\\t\\t\\t\\t\\tthis.obj.copy( data );\\n\\n\\t\\t\\t\\t} else if ( member.length === 1 ) {\\n\\n\\t\\t\\t\\t\\tswitch ( member[ 0 ] ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 0:\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n11 = data[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n21 = data[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n31 = data[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n41 = data[ 3 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 1:\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n12 = data[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n22 = data[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n32 = data[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n42 = data[ 3 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 2:\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n13 = data[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n23 = data[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n33 = data[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n43 = data[ 3 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 3:\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n14 = data[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n24 = data[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n34 = data[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tthis.obj.n44 = data[ 3 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( member.length === 2 ) {\\n\\n\\t\\t\\t\\t\\tvar propName = 'n' + ( member[ 0 ] + 1 ) + ( member[ 1 ] + 1 );\\n\\t\\t\\t\\t\\tthis.obj[ propName ] = data;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tconsole.log('Incorrect addressing of matrix in transform.');\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'translate':\\n\\t\\t\\tcase 'scale':\\n\\n\\t\\t\\t\\tif ( Object.prototype.toString.call( member ) === '[object Array]' ) {\\n\\n\\t\\t\\t\\t\\tmember = members[ member[ 0 ] ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tswitch ( member ) {\\n\\n\\t\\t\\t\\t\\tcase 'X':\\n\\n\\t\\t\\t\\t\\t\\tthis.obj.x = data;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Y':\\n\\n\\t\\t\\t\\t\\t\\tthis.obj.y = data;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Z':\\n\\n\\t\\t\\t\\t\\t\\tthis.obj.z = data;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\tthis.obj.x = data[ 0 ];\\n\\t\\t\\t\\t\\t\\tthis.obj.y = data[ 1 ];\\n\\t\\t\\t\\t\\t\\tthis.obj.z = data[ 2 ];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'rotate':\\n\\n\\t\\t\\t\\tif ( Object.prototype.toString.call( member ) === '[object Array]' ) {\\n\\n\\t\\t\\t\\t\\tmember = members[ member[ 0 ] ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tswitch ( member ) {\\n\\n\\t\\t\\t\\t\\tcase 'X':\\n\\n\\t\\t\\t\\t\\t\\tthis.obj.x = data;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Y':\\n\\n\\t\\t\\t\\t\\t\\tthis.obj.y = data;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Z':\\n\\n\\t\\t\\t\\t\\t\\tthis.obj.z = data;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'ANGLE':\\n\\n\\t\\t\\t\\t\\t\\tthis.angle = THREE.Math.degToRad( data );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\tthis.obj.x = data[ 0 ];\\n\\t\\t\\t\\t\\t\\tthis.obj.y = data[ 1 ];\\n\\t\\t\\t\\t\\t\\tthis.obj.z = data[ 2 ];\\n\\t\\t\\t\\t\\t\\tthis.angle = THREE.Math.degToRad( data[ 3 ] );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction InstanceController() {\\n\\n\\t\\tthis.url = \\\"\\\";\\n\\t\\tthis.skeleton = [];\\n\\t\\tthis.instance_material = [];\\n\\n\\t};\\n\\n\\tInstanceController.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.url = element.getAttribute('url').replace(/^#/, '');\\n\\t\\tthis.skeleton = [];\\n\\t\\tthis.instance_material = [];\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType !== 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'skeleton':\\n\\n\\t\\t\\t\\t\\tthis.skeleton.push( child.textContent.replace(/^#/, '') );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'bind_material':\\n\\n\\t\\t\\t\\t\\tvar instances = child.querySelectorAll('instance_material');\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < instances.length; j ++ ){\\n\\n\\t\\t\\t\\t\\t\\tvar instance = instances[j];\\n\\t\\t\\t\\t\\t\\tthis.instance_material.push( (new InstanceMaterial()).parse(instance) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'extra':\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction InstanceMaterial () {\\n\\n\\t\\tthis.symbol = \\\"\\\";\\n\\t\\tthis.target = \\\"\\\";\\n\\n\\t};\\n\\n\\tInstanceMaterial.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.symbol = element.getAttribute('symbol');\\n\\t\\tthis.target = element.getAttribute('target').replace(/^#/, '');\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction InstanceGeometry() {\\n\\n\\t\\tthis.url = \\\"\\\";\\n\\t\\tthis.instance_material = [];\\n\\n\\t};\\n\\n\\tInstanceGeometry.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.url = element.getAttribute('url').replace(/^#/, '');\\n\\t\\tthis.instance_material = [];\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[i];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tif ( child.nodeName == 'bind_material' ) {\\n\\n\\t\\t\\t\\tvar instances = child.querySelectorAll('instance_material');\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < instances.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar instance = instances[j];\\n\\t\\t\\t\\t\\tthis.instance_material.push( (new InstanceMaterial()).parse(instance) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Geometry() {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.mesh = null;\\n\\n\\t};\\n\\n\\tGeometry.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.id = element.getAttribute('id');\\n\\n\\t\\textractDoubleSided( this, element );\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[i];\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'mesh':\\n\\n\\t\\t\\t\\t\\tthis.mesh = (new Mesh(this)).parse(child);\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'extra':\\n\\n\\t\\t\\t\\t\\t// console.log( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Mesh( geometry ) {\\n\\n\\t\\tthis.geometry = geometry.id;\\n\\t\\tthis.primitives = [];\\n\\t\\tthis.vertices = null;\\n\\t\\tthis.geometry3js = null;\\n\\n\\t};\\n\\n\\tMesh.prototype.parse = function( element ) {\\n\\n\\t\\tthis.primitives = [];\\n\\n\\t\\tvar i, j;\\n\\n\\t\\tfor ( i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'source':\\n\\n\\t\\t\\t\\t\\t_source( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'vertices':\\n\\n\\t\\t\\t\\t\\tthis.vertices = ( new Vertices() ).parse( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'triangles':\\n\\n\\t\\t\\t\\t\\tthis.primitives.push( ( new Triangles().parse( child ) ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'polygons':\\n\\n\\t\\t\\t\\t\\tthis.primitives.push( ( new Polygons().parse( child ) ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'polylist':\\n\\n\\t\\t\\t\\t\\tthis.primitives.push( ( new Polylist().parse( child ) ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.geometry3js = new THREE.Geometry();\\n\\n\\t\\tvar vertexData = sources[ this.vertices.input['POSITION'].source ].data;\\n\\n\\t\\tfor ( i = 0; i < vertexData.length; i += 3 ) {\\n\\n\\t\\t\\tthis.geometry3js.vertices.push( getConvertedVec3( vertexData, i ).clone() );\\n\\n\\t\\t}\\n\\n\\t\\tfor ( i = 0; i < this.primitives.length; i ++ ) {\\n\\n\\t\\t\\tvar primitive = this.primitives[ i ];\\n\\t\\t\\tprimitive.setVertices( this.vertices );\\n\\t\\t\\tthis.handlePrimitive( primitive, this.geometry3js );\\n\\n\\t\\t}\\n\\n\\t\\tthis.geometry3js.computeFaceNormals();\\n\\n\\t\\tif ( this.geometry3js.calcNormals ) {\\n\\n\\t\\t\\tthis.geometry3js.computeVertexNormals();\\n\\t\\t\\tdelete this.geometry3js.calcNormals;\\n\\n\\t\\t}\\n\\n\\t\\t// this.geometry3js.computeBoundingBox();\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tMesh.prototype.handlePrimitive = function( primitive, geom ) {\\n\\n\\t\\tvar j, k, pList = primitive.p, inputs = primitive.inputs;\\n\\t\\tvar input, index, idx32;\\n\\t\\tvar source, numParams;\\n\\t\\tvar vcIndex = 0, vcount = 3, maxOffset = 0;\\n\\t\\tvar texture_sets = [];\\n\\n\\t\\tfor ( j = 0; j < inputs.length; j ++ ) {\\n\\n\\t\\t\\tinput = inputs[ j ];\\n\\n\\t\\t\\tvar offset = input.offset + 1;\\n\\t\\t\\tmaxOffset = (maxOffset < offset)? offset : maxOffset;\\n\\n\\t\\t\\tswitch ( input.semantic ) {\\n\\n\\t\\t\\t\\tcase 'TEXCOORD':\\n\\t\\t\\t\\t\\ttexture_sets.push( input.set );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var pCount = 0; pCount < pList.length; ++pCount ) {\\n\\n\\t\\t\\tvar p = pList[ pCount ], i = 0;\\n\\n\\t\\t\\twhile ( i < p.length ) {\\n\\n\\t\\t\\t\\tvar vs = [];\\n\\t\\t\\t\\tvar ns = [];\\n\\t\\t\\t\\tvar ts = null;\\n\\t\\t\\t\\tvar cs = [];\\n\\n\\t\\t\\t\\tif ( primitive.vcount ) {\\n\\n\\t\\t\\t\\t\\tvcount = primitive.vcount.length ? primitive.vcount[ vcIndex ++ ] : primitive.vcount;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvcount = p.length / maxOffset;\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tfor ( j = 0; j < vcount; j ++ ) {\\n\\n\\t\\t\\t\\t\\tfor ( k = 0; k < inputs.length; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tinput = inputs[ k ];\\n\\t\\t\\t\\t\\t\\tsource = sources[ input.source ];\\n\\n\\t\\t\\t\\t\\t\\tindex = p[ i + ( j * maxOffset ) + input.offset ];\\n\\t\\t\\t\\t\\t\\tnumParams = source.accessor.params.length;\\n\\t\\t\\t\\t\\t\\tidx32 = index * numParams;\\n\\n\\t\\t\\t\\t\\t\\tswitch ( input.semantic ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'VERTEX':\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvs.push( index );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'NORMAL':\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tns.push( getConvertedVec3( source.data, idx32 ) );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'TEXCOORD':\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tts = ts || { };\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( ts[ input.set ] === undefined ) ts[ input.set ] = [];\\n\\t\\t\\t\\t\\t\\t\\t\\t// invert the V\\n\\t\\t\\t\\t\\t\\t\\t\\tts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], source.data[ idx32 + 1 ] ) );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'COLOR':\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( ns.length == 0 ) {\\n\\n\\t\\t\\t\\t\\t// check the vertices inputs\\n\\t\\t\\t\\t\\tinput = this.vertices.input.NORMAL;\\n\\n\\t\\t\\t\\t\\tif ( input ) {\\n\\n\\t\\t\\t\\t\\t\\tsource = sources[ input.source ];\\n\\t\\t\\t\\t\\t\\tnumParams = source.accessor.params.length;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var ndx = 0, len = vs.length; ndx < len; ndx++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tns.push( getConvertedVec3( source.data, vs[ ndx ] * numParams ) );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tgeom.calcNormals = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( !ts ) {\\n\\n\\t\\t\\t\\t\\tts = { };\\n\\t\\t\\t\\t\\t// check the vertices inputs\\n\\t\\t\\t\\t\\tinput = this.vertices.input.TEXCOORD;\\n\\n\\t\\t\\t\\t\\tif ( input ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture_sets.push( input.set );\\n\\t\\t\\t\\t\\t\\tsource = sources[ input.source ];\\n\\t\\t\\t\\t\\t\\tnumParams = source.accessor.params.length;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var ndx = 0, len = vs.length; ndx < len; ndx++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tidx32 = vs[ ndx ] * numParams;\\n\\t\\t\\t\\t\\t\\t\\tif ( ts[ input.set ] === undefined ) ts[ input.set ] = [ ];\\n\\t\\t\\t\\t\\t\\t\\t// invert the V\\n\\t\\t\\t\\t\\t\\t\\tts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], 1.0 - source.data[ idx32 + 1 ] ) );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( cs.length == 0 ) {\\n\\n\\t\\t\\t\\t\\t// check the vertices inputs\\n\\t\\t\\t\\t\\tinput = this.vertices.input.COLOR;\\n\\n\\t\\t\\t\\t\\tif ( input ) {\\n\\n\\t\\t\\t\\t\\t\\tsource = sources[ input.source ];\\n\\t\\t\\t\\t\\t\\tnumParams = source.accessor.params.length;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var ndx = 0, len = vs.length; ndx < len; ndx++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tidx32 = vs[ ndx ] * numParams;\\n\\t\\t\\t\\t\\t\\t\\tcs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar face = null, faces = [], uv, uvArr;\\n\\n\\t\\t\\t\\tif ( vcount === 3 ) {\\n\\n\\t\\t\\t\\t\\tfaces.push( new THREE.Face3( vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color() ) );\\n\\n\\t\\t\\t\\t} else if ( vcount === 4 ) {\\n\\n\\t\\t\\t\\t\\tfaces.push( new THREE.Face3( vs[0], vs[1], vs[3], [ns[0], ns[1], ns[3]], cs.length ? [cs[0], cs[1], cs[3]] : new THREE.Color() ) );\\n\\n\\t\\t\\t\\t\\tfaces.push( new THREE.Face3( vs[1], vs[2], vs[3], [ns[1], ns[2], ns[3]], cs.length ? [cs[1], cs[2], cs[3]] : new THREE.Color() ) );\\n\\n\\t\\t\\t\\t} else if ( vcount > 4 && options.subdivideFaces ) {\\n\\n\\t\\t\\t\\t\\tvar clr = cs.length ? cs : new THREE.Color(),\\n\\t\\t\\t\\t\\t\\tvec1, vec2, vec3, v1, v2, norm;\\n\\n\\t\\t\\t\\t\\t// subdivide into multiple Face3s\\n\\n\\t\\t\\t\\t\\tfor ( k = 1; k < vcount - 1; ) {\\n\\n\\t\\t\\t\\t\\t\\t// FIXME: normals don't seem to be quite right\\n\\n\\t\\t\\t\\t\\t\\tfaces.push( new THREE.Face3( vs[0], vs[k], vs[k+1], [ ns[0], ns[k++], ns[k] ],  clr ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( faces.length ) {\\n\\n\\t\\t\\t\\t\\tfor ( var ndx = 0, len = faces.length; ndx < len; ndx ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tface = faces[ndx];\\n\\t\\t\\t\\t\\t\\tface.daeMaterial = primitive.material;\\n\\t\\t\\t\\t\\t\\tgeom.faces.push( face );\\n\\n\\t\\t\\t\\t\\t\\tfor ( k = 0; k < texture_sets.length; k++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv = ts[ texture_sets[k] ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( vcount > 4 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Grab the right UVs for the vertices in this face\\n\\t\\t\\t\\t\\t\\t\\t\\tuvArr = [ uv[0], uv[ndx+1], uv[ndx+2] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t} else if ( vcount === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( ndx === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuvArr = [ uv[0], uv[1], uv[3] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuvArr = [ uv[1].clone(), uv[2], uv[3].clone() ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tuvArr = [ uv[0], uv[1], uv[2] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( geom.faceVertexUvs[k] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeom.faceVertexUvs[k] = [];\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tgeom.faceVertexUvs[k].push( uvArr );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tconsole.log( 'dropped face with vcount ' + vcount + ' for geometry with id: ' + geom.id );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ti += maxOffset * vcount;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction Polygons () {\\n\\n\\t\\tthis.material = \\\"\\\";\\n\\t\\tthis.count = 0;\\n\\t\\tthis.inputs = [];\\n\\t\\tthis.vcount = null;\\n\\t\\tthis.p = [];\\n\\t\\tthis.geometry = new THREE.Geometry();\\n\\n\\t};\\n\\n\\tPolygons.prototype.setVertices = function ( vertices ) {\\n\\n\\t\\tfor ( var i = 0; i < this.inputs.length; i ++ ) {\\n\\n\\t\\t\\tif ( this.inputs[ i ].source == vertices.id ) {\\n\\n\\t\\t\\t\\tthis.inputs[ i ].source = vertices.input[ 'POSITION' ].source;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tPolygons.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.material = element.getAttribute( 'material' );\\n\\t\\tthis.count = _attr_as_int( element, 'count', 0 );\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'input':\\n\\n\\t\\t\\t\\t\\tthis.inputs.push( ( new Input() ).parse( element.childNodes[ i ] ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'vcount':\\n\\n\\t\\t\\t\\t\\tthis.vcount = _ints( child.textContent );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'p':\\n\\n\\t\\t\\t\\t\\tthis.p.push( _ints( child.textContent ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'ph':\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'polygon holes not yet supported!' );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Polylist () {\\n\\n\\t\\tPolygons.call( this );\\n\\n\\t\\tthis.vcount = [];\\n\\n\\t};\\n\\n\\tPolylist.prototype = Object.create( Polygons.prototype );\\n\\n\\tfunction Triangles () {\\n\\n\\t\\tPolygons.call( this );\\n\\n\\t\\tthis.vcount = 3;\\n\\n\\t};\\n\\n\\tTriangles.prototype = Object.create( Polygons.prototype );\\n\\n\\tfunction Accessor() {\\n\\n\\t\\tthis.source = \\\"\\\";\\n\\t\\tthis.count = 0;\\n\\t\\tthis.stride = 0;\\n\\t\\tthis.params = [];\\n\\n\\t};\\n\\n\\tAccessor.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.params = [];\\n\\t\\tthis.source = element.getAttribute( 'source' );\\n\\t\\tthis.count = _attr_as_int( element, 'count', 0 );\\n\\t\\tthis.stride = _attr_as_int( element, 'stride', 0 );\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\n\\t\\t\\tif ( child.nodeName == 'param' ) {\\n\\n\\t\\t\\t\\tvar param = {};\\n\\t\\t\\t\\tparam[ 'name' ] = child.getAttribute( 'name' );\\n\\t\\t\\t\\tparam[ 'type' ] = child.getAttribute( 'type' );\\n\\t\\t\\t\\tthis.params.push( param );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Vertices() {\\n\\n\\t\\tthis.input = {};\\n\\n\\t};\\n\\n\\tVertices.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.id = element.getAttribute('id');\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tif ( element.childNodes[i].nodeName == 'input' ) {\\n\\n\\t\\t\\t\\tvar input = ( new Input() ).parse( element.childNodes[ i ] );\\n\\t\\t\\t\\tthis.input[ input.semantic ] = input;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Input () {\\n\\n\\t\\tthis.semantic = \\\"\\\";\\n\\t\\tthis.offset = 0;\\n\\t\\tthis.source = \\\"\\\";\\n\\t\\tthis.set = 0;\\n\\n\\t};\\n\\n\\tInput.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.semantic = element.getAttribute('semantic');\\n\\t\\tthis.source = element.getAttribute('source').replace(/^#/, '');\\n\\t\\tthis.set = _attr_as_int(element, 'set', -1);\\n\\t\\tthis.offset = _attr_as_int(element, 'offset', 0);\\n\\n\\t\\tif ( this.semantic == 'TEXCOORD' && this.set < 0 ) {\\n\\n\\t\\t\\tthis.set = 0;\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Source ( id ) {\\n\\n\\t\\tthis.id = id;\\n\\t\\tthis.type = null;\\n\\n\\t};\\n\\n\\tSource.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.id = element.getAttribute( 'id' );\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[i];\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'bool_array':\\n\\n\\t\\t\\t\\t\\tthis.data = _bools( child.textContent );\\n\\t\\t\\t\\t\\tthis.type = child.nodeName;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'float_array':\\n\\n\\t\\t\\t\\t\\tthis.data = _floats( child.textContent );\\n\\t\\t\\t\\t\\tthis.type = child.nodeName;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'int_array':\\n\\n\\t\\t\\t\\t\\tthis.data = _ints( child.textContent );\\n\\t\\t\\t\\t\\tthis.type = child.nodeName;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'IDREF_array':\\n\\t\\t\\t\\tcase 'Name_array':\\n\\n\\t\\t\\t\\t\\tthis.data = _strings( child.textContent );\\n\\t\\t\\t\\t\\tthis.type = child.nodeName;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'technique_common':\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < child.childNodes.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( child.childNodes[ j ].nodeName == 'accessor' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.accessor = ( new Accessor() ).parse( child.childNodes[ j ] );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t// console.log(child.nodeName);\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tSource.prototype.read = function () {\\n\\n\\t\\tvar result = [];\\n\\n\\t\\t//for (var i = 0; i < this.accessor.params.length; i++) {\\n\\n\\t\\t\\tvar param = this.accessor.params[ 0 ];\\n\\n\\t\\t\\t//console.log(param.name + \\\" \\\" + param.type);\\n\\n\\t\\t\\tswitch ( param.type ) {\\n\\n\\t\\t\\t\\tcase 'IDREF':\\n\\t\\t\\t\\tcase 'Name': case 'name':\\n\\t\\t\\t\\tcase 'float':\\n\\n\\t\\t\\t\\t\\treturn this.data;\\n\\n\\t\\t\\t\\tcase 'float4x4':\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < this.data.length; j += 16 ) {\\n\\n\\t\\t\\t\\t\\t\\tvar s = this.data.slice( j, j + 16 );\\n\\t\\t\\t\\t\\t\\tvar m = getConvertedMat4( s );\\n\\t\\t\\t\\t\\t\\tresult.push( m );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\tconsole.log( 'ColladaLoader: Source: Read dont know how to read ' + param.type + '.' );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t//}\\n\\n\\t\\treturn result;\\n\\n\\t};\\n\\n\\tfunction Material () {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.name = \\\"\\\";\\n\\t\\tthis.instance_effect = null;\\n\\n\\t};\\n\\n\\tMaterial.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.id = element.getAttribute( 'id' );\\n\\t\\tthis.name = element.getAttribute( 'name' );\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tif ( element.childNodes[ i ].nodeName == 'instance_effect' ) {\\n\\n\\t\\t\\t\\tthis.instance_effect = ( new InstanceEffect() ).parse( element.childNodes[ i ] );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction ColorOrTexture () {\\n\\n\\t\\tthis.color = new THREE.Color();\\n\\t\\tthis.color.setRGB( Math.random(), Math.random(), Math.random() );\\n\\t\\tthis.color.a = 1.0;\\n\\n\\t\\tthis.texture = null;\\n\\t\\tthis.texcoord = null;\\n\\t\\tthis.texOpts = null;\\n\\n\\t};\\n\\n\\tColorOrTexture.prototype.isColor = function () {\\n\\n\\t\\treturn ( this.texture == null );\\n\\n\\t};\\n\\n\\tColorOrTexture.prototype.isTexture = function () {\\n\\n\\t\\treturn ( this.texture != null );\\n\\n\\t};\\n\\n\\tColorOrTexture.prototype.parse = function ( element ) {\\n\\n\\t\\tif (element.nodeName == 'transparent') {\\n\\n\\t\\t\\tthis.opaque = element.getAttribute('opaque');\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'color':\\n\\n\\t\\t\\t\\t\\tvar rgba = _floats( child.textContent );\\n\\t\\t\\t\\t\\tthis.color = new THREE.Color();\\n\\t\\t\\t\\t\\tthis.color.setRGB( rgba[0], rgba[1], rgba[2] );\\n\\t\\t\\t\\t\\tthis.color.a = rgba[3];\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'texture':\\n\\n\\t\\t\\t\\t\\tthis.texture = child.getAttribute('texture');\\n\\t\\t\\t\\t\\tthis.texcoord = child.getAttribute('texcoord');\\n\\t\\t\\t\\t\\t// Defaults from:\\n\\t\\t\\t\\t\\t// https://collada.org/mediawiki/index.php/Maya_texture_placement_MAYA_extension\\n\\t\\t\\t\\t\\tthis.texOpts = {\\n\\t\\t\\t\\t\\t\\toffsetU: 0,\\n\\t\\t\\t\\t\\t\\toffsetV: 0,\\n\\t\\t\\t\\t\\t\\trepeatU: 1,\\n\\t\\t\\t\\t\\t\\trepeatV: 1,\\n\\t\\t\\t\\t\\t\\twrapU: 1,\\n\\t\\t\\t\\t\\t\\twrapV: 1\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\tthis.parseTexture( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tColorOrTexture.prototype.parseTexture = function ( element ) {\\n\\n\\t\\tif ( ! element.childNodes ) return this;\\n\\n\\t\\t// This should be supported by Maya, 3dsMax, and MotionBuilder\\n\\n\\t\\tif ( element.childNodes[1] && element.childNodes[1].nodeName === 'extra' ) {\\n\\n\\t\\t\\telement = element.childNodes[1];\\n\\n\\t\\t\\tif ( element.childNodes[1] && element.childNodes[1].nodeName === 'technique' ) {\\n\\n\\t\\t\\t\\telement = element.childNodes[1];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'offsetU':\\n\\t\\t\\t\\tcase 'offsetV':\\n\\t\\t\\t\\tcase 'repeatU':\\n\\t\\t\\t\\tcase 'repeatV':\\n\\n\\t\\t\\t\\t\\tthis.texOpts[ child.nodeName ] = parseFloat( child.textContent );\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'wrapU':\\n\\t\\t\\t\\tcase 'wrapV':\\n\\n\\t\\t\\t\\t\\t// some dae have a value of true which becomes NaN via parseInt\\n\\n\\t\\t\\t\\t\\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.texOpts[ child.nodeName ] = 1;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tthis.texOpts[ child.nodeName ] = parseInt( child.textContent );\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\tthis.texOpts[ child.nodeName ] = child.textContent;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Shader ( type, effect ) {\\n\\n\\t\\tthis.type = type;\\n\\t\\tthis.effect = effect;\\n\\t\\tthis.material = null;\\n\\n\\t};\\n\\n\\tShader.prototype.parse = function ( element ) {\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'ambient':\\n\\t\\t\\t\\tcase 'emission':\\n\\t\\t\\t\\tcase 'diffuse':\\n\\t\\t\\t\\tcase 'specular':\\n\\t\\t\\t\\tcase 'transparent':\\n\\n\\t\\t\\t\\t\\tthis[ child.nodeName ] = ( new ColorOrTexture() ).parse( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'bump':\\n\\n\\t\\t\\t\\t\\t// If 'bumptype' is 'heightfield', create a 'bump' property\\n\\t\\t\\t\\t\\t// Else if 'bumptype' is 'normalmap', create a 'normal' property\\n\\t\\t\\t\\t\\t// (Default to 'bump')\\n\\t\\t\\t\\t\\tvar bumpType = child.getAttribute( 'bumptype' );\\n\\t\\t\\t\\t\\tif ( bumpType ) {\\n\\t\\t\\t\\t\\t\\tif ( bumpType.toLowerCase() === \\\"heightfield\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\tthis[ 'bump' ] = ( new ColorOrTexture() ).parse( child );\\n\\t\\t\\t\\t\\t\\t} else if ( bumpType.toLowerCase() === \\\"normalmap\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\tthis[ 'normal' ] = ( new ColorOrTexture() ).parse( child );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( \\\"Shader.prototype.parse: Invalid value for attribute 'bumptype' (\\\" + bumpType +\\n\\t\\t\\t\\t\\t\\t\\t\\t           \\\") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'\\\" );\\n\\t\\t\\t\\t\\t\\t\\tthis[ 'bump' ] = ( new ColorOrTexture() ).parse( child );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tconsole.warn( \\\"Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'\\\" );\\n\\t\\t\\t\\t\\t\\tthis[ 'bump' ] = ( new ColorOrTexture() ).parse( child );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'shininess':\\n\\t\\t\\t\\tcase 'reflectivity':\\n\\t\\t\\t\\tcase 'index_of_refraction':\\n\\t\\t\\t\\tcase 'transparency':\\n\\n\\t\\t\\t\\t\\tvar f = child.querySelectorAll('float');\\n\\n\\t\\t\\t\\t\\tif ( f.length > 0 )\\n\\t\\t\\t\\t\\t\\tthis[ child.nodeName ] = parseFloat( f[ 0 ].textContent );\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.create();\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tShader.prototype.create = function() {\\n\\n\\t\\tvar props = {};\\n\\n\\t\\tvar transparent = false;\\n\\n\\t\\tif (this['transparency'] !== undefined && this['transparent'] !== undefined) {\\n\\t\\t\\t// convert transparent color RBG to average value\\n\\t\\t\\tvar transparentColor = this['transparent'];\\n\\t\\t\\tvar transparencyLevel = (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency;\\n\\n\\t\\t\\tif (transparencyLevel > 0) {\\n\\t\\t\\t\\ttransparent = true;\\n\\t\\t\\t\\tprops[ 'transparent' ] = true;\\n\\t\\t\\t\\tprops[ 'opacity' ] = 1 - transparencyLevel;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar keys = {\\n\\t\\t\\t'diffuse':'map',\\n\\t\\t\\t'ambient':'lightMap' ,\\n\\t\\t\\t'specular':'specularMap',\\n\\t\\t\\t'emission':'emissionMap',\\n\\t\\t\\t'bump':'bumpMap',\\n\\t\\t\\t'normal':'normalMap'\\n\\t\\t\\t};\\n\\n\\t\\tfor ( var prop in this ) {\\n\\n\\t\\t\\tswitch ( prop ) {\\n\\n\\t\\t\\t\\tcase 'ambient':\\n\\t\\t\\t\\tcase 'emission':\\n\\t\\t\\t\\tcase 'diffuse':\\n\\t\\t\\t\\tcase 'specular':\\n\\t\\t\\t\\tcase 'bump':\\n\\t\\t\\t\\tcase 'normal':\\n\\n\\t\\t\\t\\t\\tvar cot = this[ prop ];\\n\\n\\t\\t\\t\\t\\tif ( cot instanceof ColorOrTexture ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( cot.isTexture() ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar samplerId = cot.texture;\\n\\t\\t\\t\\t\\t\\t\\tvar surfaceId = this.effect.sampler[samplerId];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( surfaceId !== undefined && surfaceId.source !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar surface = this.effect.surface[surfaceId.source];\\n\\t\\t\\t\\t\\t\\t\\t\\tvar image = images[surface.init_from];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (image) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar url = baseUrl + image.init_from;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar texture;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar loader = THREE.Loader.Handlers.get( url );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( loader !== null ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttexture = loader.load( url );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttexture = new THREE.Texture();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tloader = new THREE.ImageLoader();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tloader.load( url, function ( image ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttexture.image = image;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttexture.wrapS = cot.texOpts.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttexture.wrapT = cot.texOpts.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttexture.offset.x = cot.texOpts.offsetU;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttexture.offset.y = cot.texOpts.offsetV;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttexture.repeat.x = cot.texOpts.repeatU;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttexture.repeat.y = cot.texOpts.repeatV;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprops[keys[prop]] = texture;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Texture with baked lighting?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (prop === 'emission') props['emissive'] = 0xffffff;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else if ( prop === 'diffuse' || !transparent ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( prop === 'emission' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tprops[ 'emissive' ] = cot.color.getHex();\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tprops[ prop ] = cot.color.getHex();\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'shininess':\\n\\n\\t\\t\\t\\t\\tprops[ prop ] = this[ prop ];\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'reflectivity':\\n\\n\\t\\t\\t\\t\\tprops[ prop ] = this[ prop ];\\n\\t\\t\\t\\t\\tif( props[ prop ] > 0.0 ) props['envMap'] = options.defaultEnvMap;\\n\\t\\t\\t\\t\\tprops['combine'] = THREE.MixOperation;\\t//mix regular shading with reflective component\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'index_of_refraction':\\n\\n\\t\\t\\t\\t\\tprops[ 'refractionRatio' ] = this[ prop ]; //TODO: \\\"index_of_refraction\\\" becomes \\\"refractionRatio\\\" in shader, but I'm not sure if the two are actually comparable\\n\\t\\t\\t\\t\\tif ( this[ prop ] !== 1.0 ) props['envMap'] = options.defaultEnvMap;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'transparency':\\n\\t\\t\\t\\t\\t// gets figured out up top\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprops[ 'shading' ] = preferredShading;\\n\\t\\tprops[ 'side' ] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;\\n\\n\\t\\tswitch ( this.type ) {\\n\\n\\t\\t\\tcase 'constant':\\n\\n\\t\\t\\t\\tif (props.emissive != undefined) props.color = props.emissive;\\n\\t\\t\\t\\tthis.material = new THREE.MeshBasicMaterial( props );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'phong':\\n\\t\\t\\tcase 'blinn':\\n\\n\\t\\t\\t\\tif (props.diffuse != undefined) props.color = props.diffuse;\\n\\t\\t\\t\\tthis.material = new THREE.MeshPhongMaterial( props );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'lambert':\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tif (props.diffuse != undefined) props.color = props.diffuse;\\n\\t\\t\\t\\tthis.material = new THREE.MeshLambertMaterial( props );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t\\treturn this.material;\\n\\n\\t};\\n\\n\\tfunction Surface ( effect ) {\\n\\n\\t\\tthis.effect = effect;\\n\\t\\tthis.init_from = null;\\n\\t\\tthis.format = null;\\n\\n\\t};\\n\\n\\tSurface.prototype.parse = function ( element ) {\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'init_from':\\n\\n\\t\\t\\t\\t\\tthis.init_from = child.textContent;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'format':\\n\\n\\t\\t\\t\\t\\tthis.format = child.textContent;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\tconsole.log( \\\"unhandled Surface prop: \\\" + child.nodeName );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Sampler2D ( effect ) {\\n\\n\\t\\tthis.effect = effect;\\n\\t\\tthis.source = null;\\n\\t\\tthis.wrap_s = null;\\n\\t\\tthis.wrap_t = null;\\n\\t\\tthis.minfilter = null;\\n\\t\\tthis.magfilter = null;\\n\\t\\tthis.mipfilter = null;\\n\\n\\t};\\n\\n\\tSampler2D.prototype.parse = function ( element ) {\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'source':\\n\\n\\t\\t\\t\\t\\tthis.source = child.textContent;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'minfilter':\\n\\n\\t\\t\\t\\t\\tthis.minfilter = child.textContent;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'magfilter':\\n\\n\\t\\t\\t\\t\\tthis.magfilter = child.textContent;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'mipfilter':\\n\\n\\t\\t\\t\\t\\tthis.mipfilter = child.textContent;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'wrap_s':\\n\\n\\t\\t\\t\\t\\tthis.wrap_s = child.textContent;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'wrap_t':\\n\\n\\t\\t\\t\\t\\tthis.wrap_t = child.textContent;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\tconsole.log( \\\"unhandled Sampler2D prop: \\\" + child.nodeName );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Effect () {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.name = \\\"\\\";\\n\\t\\tthis.shader = null;\\n\\t\\tthis.surface = {};\\n\\t\\tthis.sampler = {};\\n\\n\\t};\\n\\n\\tEffect.prototype.create = function () {\\n\\n\\t\\tif ( this.shader == null ) {\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tEffect.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.id = element.getAttribute( 'id' );\\n\\t\\tthis.name = element.getAttribute( 'name' );\\n\\n\\t\\textractDoubleSided( this, element );\\n\\n\\t\\tthis.shader = null;\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'profile_COMMON':\\n\\n\\t\\t\\t\\t\\tthis.parseTechnique( this.parseProfileCOMMON( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tEffect.prototype.parseNewparam = function ( element ) {\\n\\n\\t\\tvar sid = element.getAttribute( 'sid' );\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'surface':\\n\\n\\t\\t\\t\\t\\tthis.surface[sid] = ( new Surface( this ) ).parse( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'sampler2D':\\n\\n\\t\\t\\t\\t\\tthis.sampler[sid] = ( new Sampler2D( this ) ).parse( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'extra':\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\tconsole.log( child.nodeName );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tEffect.prototype.parseProfileCOMMON = function ( element ) {\\n\\n\\t\\tvar technique;\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'profile_COMMON':\\n\\n\\t\\t\\t\\t\\tthis.parseProfileCOMMON( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'technique':\\n\\n\\t\\t\\t\\t\\ttechnique = child;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'newparam':\\n\\n\\t\\t\\t\\t\\tthis.parseNewparam( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'image':\\n\\n\\t\\t\\t\\t\\tvar _image = ( new _Image() ).parse( child );\\n\\t\\t\\t\\t\\timages[ _image.id ] = _image;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'extra':\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\tconsole.log( child.nodeName );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn technique;\\n\\n\\t};\\n\\n\\tEffect.prototype.parseTechnique= function ( element ) {\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[i];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'constant':\\n\\t\\t\\t\\tcase 'lambert':\\n\\t\\t\\t\\tcase 'blinn':\\n\\t\\t\\t\\tcase 'phong':\\n\\n\\t\\t\\t\\t\\tthis.shader = ( new Shader( child.nodeName, this ) ).parse( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 'extra':\\n\\t\\t\\t\\t\\tthis.parseExtra(child);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tEffect.prototype.parseExtra = function ( element ) {\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[i];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'technique':\\n\\t\\t\\t\\t\\tthis.parseExtraTechnique( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tEffect.prototype.parseExtraTechnique= function ( element ) {\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[i];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'bump':\\n\\t\\t\\t\\t\\tthis.shader.parse( element );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction InstanceEffect () {\\n\\n\\t\\tthis.url = \\\"\\\";\\n\\n\\t};\\n\\n\\tInstanceEffect.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.url = element.getAttribute( 'url' ).replace( /^#/, '' );\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Animation() {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.name = \\\"\\\";\\n\\t\\tthis.source = {};\\n\\t\\tthis.sampler = [];\\n\\t\\tthis.channel = [];\\n\\n\\t};\\n\\n\\tAnimation.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.id = element.getAttribute( 'id' );\\n\\t\\tthis.name = element.getAttribute( 'name' );\\n\\t\\tthis.source = {};\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'animation':\\n\\n\\t\\t\\t\\t\\tvar anim = ( new Animation() ).parse( child );\\n\\n\\t\\t\\t\\t\\tfor ( var src in anim.source ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.source[ src ] = anim.source[ src ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < anim.channel.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.channel.push( anim.channel[ j ] );\\n\\t\\t\\t\\t\\t\\tthis.sampler.push( anim.sampler[ j ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'source':\\n\\n\\t\\t\\t\\t\\tvar src = ( new Source() ).parse( child );\\n\\t\\t\\t\\t\\tthis.source[ src.id ] = src;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'sampler':\\n\\n\\t\\t\\t\\t\\tthis.sampler.push( ( new Sampler( this ) ).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'channel':\\n\\n\\t\\t\\t\\t\\tthis.channel.push( ( new Channel( this ) ).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Channel( animation ) {\\n\\n\\t\\tthis.animation = animation;\\n\\t\\tthis.source = \\\"\\\";\\n\\t\\tthis.target = \\\"\\\";\\n\\t\\tthis.fullSid = null;\\n\\t\\tthis.sid = null;\\n\\t\\tthis.dotSyntax = null;\\n\\t\\tthis.arrSyntax = null;\\n\\t\\tthis.arrIndices = null;\\n\\t\\tthis.member = null;\\n\\n\\t};\\n\\n\\tChannel.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.source = element.getAttribute( 'source' ).replace( /^#/, '' );\\n\\t\\tthis.target = element.getAttribute( 'target' );\\n\\n\\t\\tvar parts = this.target.split( '/' );\\n\\n\\t\\tvar id = parts.shift();\\n\\t\\tvar sid = parts.shift();\\n\\n\\t\\tvar dotSyntax = ( sid.indexOf(\\\".\\\") >= 0 );\\n\\t\\tvar arrSyntax = ( sid.indexOf(\\\"(\\\") >= 0 );\\n\\n\\t\\tif ( dotSyntax ) {\\n\\n\\t\\t\\tparts = sid.split(\\\".\\\");\\n\\t\\t\\tthis.sid = parts.shift();\\n\\t\\t\\tthis.member = parts.shift();\\n\\n\\t\\t} else if ( arrSyntax ) {\\n\\n\\t\\t\\tvar arrIndices = sid.split(\\\"(\\\");\\n\\t\\t\\tthis.sid = arrIndices.shift();\\n\\n\\t\\t\\tfor (var j = 0; j < arrIndices.length; j ++ ) {\\n\\n\\t\\t\\t\\tarrIndices[j] = parseInt( arrIndices[j].replace(/\\\\)/, '') );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.arrIndices = arrIndices;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.sid = sid;\\n\\n\\t\\t}\\n\\n\\t\\tthis.fullSid = sid;\\n\\t\\tthis.dotSyntax = dotSyntax;\\n\\t\\tthis.arrSyntax = arrSyntax;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction Sampler ( animation ) {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.animation = animation;\\n\\t\\tthis.inputs = [];\\n\\t\\tthis.input = null;\\n\\t\\tthis.output = null;\\n\\t\\tthis.strideOut = null;\\n\\t\\tthis.interpolation = null;\\n\\t\\tthis.startTime = null;\\n\\t\\tthis.endTime = null;\\n\\t\\tthis.duration = 0;\\n\\n\\t};\\n\\n\\tSampler.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.id = element.getAttribute( 'id' );\\n\\t\\tthis.inputs = [];\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'input':\\n\\n\\t\\t\\t\\t\\tthis.inputs.push( (new Input()).parse( child ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tSampler.prototype.create = function () {\\n\\n\\t\\tfor ( var i = 0; i < this.inputs.length; i ++ ) {\\n\\n\\t\\t\\tvar input = this.inputs[ i ];\\n\\t\\t\\tvar source = this.animation.source[ input.source ];\\n\\n\\t\\t\\tswitch ( input.semantic ) {\\n\\n\\t\\t\\t\\tcase 'INPUT':\\n\\n\\t\\t\\t\\t\\tthis.input = source.read();\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'OUTPUT':\\n\\n\\t\\t\\t\\t\\tthis.output = source.read();\\n\\t\\t\\t\\t\\tthis.strideOut = source.accessor.stride;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'INTERPOLATION':\\n\\n\\t\\t\\t\\t\\tthis.interpolation = source.read();\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'IN_TANGENT':\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'OUT_TANGENT':\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\tconsole.log(input.semantic);\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.startTime = 0;\\n\\t\\tthis.endTime = 0;\\n\\t\\tthis.duration = 0;\\n\\n\\t\\tif ( this.input.length ) {\\n\\n\\t\\t\\tthis.startTime = 100000000;\\n\\t\\t\\tthis.endTime = -100000000;\\n\\n\\t\\t\\tfor ( var i = 0; i < this.input.length; i ++ ) {\\n\\n\\t\\t\\t\\tthis.startTime = Math.min( this.startTime, this.input[ i ] );\\n\\t\\t\\t\\tthis.endTime = Math.max( this.endTime, this.input[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.duration = this.endTime - this.startTime;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tSampler.prototype.getData = function ( type, ndx, member ) {\\n\\n\\t\\tvar data;\\n\\n\\t\\tif ( type === 'matrix' && this.strideOut === 16 ) {\\n\\n\\t\\t\\tdata = this.output[ ndx ];\\n\\n\\t\\t} else if ( this.strideOut > 1 ) {\\n\\n\\t\\t\\tdata = [];\\n\\t\\t\\tndx *= this.strideOut;\\n\\n\\t\\t\\tfor ( var i = 0; i < this.strideOut; ++i ) {\\n\\n\\t\\t\\t\\tdata[ i ] = this.output[ ndx + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.strideOut === 3 ) {\\n\\n\\t\\t\\t\\tswitch ( type ) {\\n\\n\\t\\t\\t\\t\\tcase 'rotate':\\n\\t\\t\\t\\t\\tcase 'translate':\\n\\n\\t\\t\\t\\t\\t\\tfixCoords( data, -1 );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'scale':\\n\\n\\t\\t\\t\\t\\t\\tfixCoords( data, 1 );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( this.strideOut === 4 && type === 'matrix' ) {\\n\\n\\t\\t\\t\\tfixCoords( data, -1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tdata = this.output[ ndx ];\\n\\n\\t\\t\\tif ( member && type == 'translate' ) {\\n\\t\\t\\t\\tdata = getConvertedTranslation( member, data );\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tfunction Key ( time ) {\\n\\n\\t\\tthis.targets = [];\\n\\t\\tthis.time = time;\\n\\n\\t};\\n\\n\\tKey.prototype.addTarget = function ( fullSid, transform, member, data ) {\\n\\n\\t\\tthis.targets.push( {\\n\\t\\t\\tsid: fullSid,\\n\\t\\t\\tmember: member,\\n\\t\\t\\ttransform: transform,\\n\\t\\t\\tdata: data\\n\\t\\t} );\\n\\n\\t};\\n\\n\\tKey.prototype.apply = function ( opt_sid ) {\\n\\n\\t\\tfor ( var i = 0; i < this.targets.length; ++i ) {\\n\\n\\t\\t\\tvar target = this.targets[ i ];\\n\\n\\t\\t\\tif ( !opt_sid || target.sid === opt_sid ) {\\n\\n\\t\\t\\t\\ttarget.transform.update( target.data, target.member );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tKey.prototype.getTarget = function ( fullSid ) {\\n\\n\\t\\tfor ( var i = 0; i < this.targets.length; ++i ) {\\n\\n\\t\\t\\tif ( this.targets[ i ].sid === fullSid ) {\\n\\n\\t\\t\\t\\treturn this.targets[ i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\n\\t};\\n\\n\\tKey.prototype.hasTarget = function ( fullSid ) {\\n\\n\\t\\tfor ( var i = 0; i < this.targets.length; ++i ) {\\n\\n\\t\\t\\tif ( this.targets[ i ].sid === fullSid ) {\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\n\\t};\\n\\n\\t// TODO: Currently only doing linear interpolation. Should support full COLLADA spec.\\n\\tKey.prototype.interpolate = function ( nextKey, time ) {\\n\\n\\t\\tfor ( var i = 0, l = this.targets.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar target = this.targets[ i ],\\n\\t\\t\\t\\tnextTarget = nextKey.getTarget( target.sid ),\\n\\t\\t\\t\\tdata;\\n\\n\\t\\t\\tif ( target.transform.type !== 'matrix' && nextTarget ) {\\n\\n\\t\\t\\t\\tvar scale = ( time - this.time ) / ( nextKey.time - this.time ),\\n\\t\\t\\t\\t\\tnextData = nextTarget.data,\\n\\t\\t\\t\\t\\tprevData = target.data;\\n\\n\\t\\t\\t\\tif ( scale < 0 ) scale = 0;\\n\\t\\t\\t\\tif ( scale > 1 ) scale = 1;\\n\\n\\t\\t\\t\\tif ( prevData.length ) {\\n\\n\\t\\t\\t\\t\\tdata = [];\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < prevData.length; ++j ) {\\n\\n\\t\\t\\t\\t\\t\\tdata[ j ] = prevData[ j ] + ( nextData[ j ] - prevData[ j ] ) * scale;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tdata = prevData + ( nextData - prevData ) * scale;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdata = target.data;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ttarget.transform.update( data, target.member );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// Camera\\n\\tfunction Camera() {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.name = \\\"\\\";\\n\\t\\tthis.technique = \\\"\\\";\\n\\n\\t};\\n\\n\\tCamera.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.id = element.getAttribute( 'id' );\\n\\t\\tthis.name = element.getAttribute( 'name' );\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'optics':\\n\\n\\t\\t\\t\\t\\tthis.parseOptics( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tCamera.prototype.parseOptics = function ( element ) {\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tif ( element.childNodes[ i ].nodeName == 'technique_common' ) {\\n\\n\\t\\t\\t\\tvar technique = element.childNodes[ i ];\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < technique.childNodes.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.technique = technique.childNodes[ j ].nodeName;\\n\\n\\t\\t\\t\\t\\tif ( this.technique == 'perspective' ) {\\n\\n\\t\\t\\t\\t\\t\\tvar perspective = technique.childNodes[ j ];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var k = 0; k < perspective.childNodes.length; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar param = perspective.childNodes[ k ];\\n\\n\\t\\t\\t\\t\\t\\t\\tswitch ( param.nodeName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 'yfov':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.yfov = param.textContent;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 'xfov':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.xfov = param.textContent;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 'znear':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.znear = param.textContent;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 'zfar':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.zfar = param.textContent;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 'aspect_ratio':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.aspect_ratio = param.textContent;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( this.technique == 'orthographic' ) {\\n\\n\\t\\t\\t\\t\\t\\tvar orthographic = technique.childNodes[ j ];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var k = 0; k < orthographic.childNodes.length; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar param = orthographic.childNodes[ k ];\\n\\n\\t\\t\\t\\t\\t\\t\\tswitch ( param.nodeName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 'xmag':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.xmag = param.textContent;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 'ymag':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.ymag = param.textContent;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 'znear':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.znear = param.textContent;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 'zfar':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.zfar = param.textContent;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 'aspect_ratio':\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.aspect_ratio = param.textContent;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction InstanceCamera() {\\n\\n\\t\\tthis.url = \\\"\\\";\\n\\n\\t};\\n\\n\\tInstanceCamera.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.url = element.getAttribute('url').replace(/^#/, '');\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t// Light\\n\\n\\tfunction Light() {\\n\\n\\t\\tthis.id = \\\"\\\";\\n\\t\\tthis.name = \\\"\\\";\\n\\t\\tthis.technique = \\\"\\\";\\n\\n\\t};\\n\\n\\tLight.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.id = element.getAttribute( 'id' );\\n\\t\\tthis.name = element.getAttribute( 'name' );\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\t\\t\\tif ( child.nodeType != 1 ) continue;\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'technique_common':\\n\\n\\t\\t\\t\\t\\tthis.parseCommon( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'technique':\\n\\n\\t\\t\\t\\t\\tthis.parseTechnique( child );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tLight.prototype.parseCommon = function ( element ) {\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tswitch ( element.childNodes[ i ].nodeName ) {\\n\\n\\t\\t\\t\\tcase 'directional':\\n\\t\\t\\t\\tcase 'point':\\n\\t\\t\\t\\tcase 'spot':\\n\\t\\t\\t\\tcase 'ambient':\\n\\n\\t\\t\\t\\t\\tthis.technique = element.childNodes[ i ].nodeName;\\n\\n\\t\\t\\t\\t\\tvar light = element.childNodes[ i ];\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < light.childNodes.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar child = light.childNodes[j];\\n\\n\\t\\t\\t\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'color':\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar rgba = _floats( child.textContent );\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.color = new THREE.Color(0);\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.color.setRGB( rgba[0], rgba[1], rgba[2] );\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.color.a = rgba[3];\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'falloff_angle':\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.falloff_angle = parseFloat( child.textContent );\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'quadratic_attenuation':\\n\\t\\t\\t\\t\\t\\t\\t\\tvar f = parseFloat( child.textContent );\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.distance = f ? Math.sqrt( 1/f ) : 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tLight.prototype.parseTechnique = function ( element ) {\\n\\n\\t\\tthis.profile = element.getAttribute( 'profile' );\\n\\n\\t\\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\\n\\n\\t\\t\\tvar child = element.childNodes[ i ];\\n\\n\\t\\t\\tswitch ( child.nodeName ) {\\n\\n\\t\\t\\t\\tcase 'intensity':\\n\\n\\t\\t\\t\\t\\tthis.intensity = parseFloat(child.textContent);\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction InstanceLight() {\\n\\n\\t\\tthis.url = \\\"\\\";\\n\\n\\t};\\n\\n\\tInstanceLight.prototype.parse = function ( element ) {\\n\\n\\t\\tthis.url = element.getAttribute('url').replace(/^#/, '');\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction _source( element ) {\\n\\n\\t\\tvar id = element.getAttribute( 'id' );\\n\\n\\t\\tif ( sources[ id ] != undefined ) {\\n\\n\\t\\t\\treturn sources[ id ];\\n\\n\\t\\t}\\n\\n\\t\\tsources[ id ] = ( new Source(id )).parse( element );\\n\\t\\treturn sources[ id ];\\n\\n\\t};\\n\\n\\tfunction _nsResolver( nsPrefix ) {\\n\\n\\t\\tif ( nsPrefix == \\\"dae\\\" ) {\\n\\n\\t\\t\\treturn \\\"http://www.collada.org/2005/11/COLLADASchema\\\";\\n\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\n\\t};\\n\\n\\tfunction _bools( str ) {\\n\\n\\t\\tvar raw = _strings( str );\\n\\t\\tvar data = [];\\n\\n\\t\\tfor ( var i = 0, l = raw.length; i < l; i ++ ) {\\n\\n\\t\\t\\tdata.push( (raw[i] == 'true' || raw[i] == '1') ? true : false );\\n\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tfunction _floats( str ) {\\n\\n\\t\\tvar raw = _strings(str);\\n\\t\\tvar data = [];\\n\\n\\t\\tfor ( var i = 0, l = raw.length; i < l; i ++ ) {\\n\\n\\t\\t\\tdata.push( parseFloat( raw[ i ] ) );\\n\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tfunction _ints( str ) {\\n\\n\\t\\tvar raw = _strings( str );\\n\\t\\tvar data = [];\\n\\n\\t\\tfor ( var i = 0, l = raw.length; i < l; i ++ ) {\\n\\n\\t\\t\\tdata.push( parseInt( raw[ i ], 10 ) );\\n\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tfunction _strings( str ) {\\n\\n\\t\\treturn ( str.length > 0 ) ? _trimString( str ).split( /\\\\s+/ ) : [];\\n\\n\\t};\\n\\n\\tfunction _trimString( str ) {\\n\\n\\t\\treturn str.replace( /^\\\\s+/, \\\"\\\" ).replace( /\\\\s+$/, \\\"\\\" );\\n\\n\\t};\\n\\n\\tfunction _attr_as_float( element, name, defaultValue ) {\\n\\n\\t\\tif ( element.hasAttribute( name ) ) {\\n\\n\\t\\t\\treturn parseFloat( element.getAttribute( name ) );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn defaultValue;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction _attr_as_int( element, name, defaultValue ) {\\n\\n\\t\\tif ( element.hasAttribute( name ) ) {\\n\\n\\t\\t\\treturn parseInt( element.getAttribute( name ), 10) ;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn defaultValue;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction _attr_as_string( element, name, defaultValue ) {\\n\\n\\t\\tif ( element.hasAttribute( name ) ) {\\n\\n\\t\\t\\treturn element.getAttribute( name );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn defaultValue;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction _format_float( f, num ) {\\n\\n\\t\\tif ( f === undefined ) {\\n\\n\\t\\t\\tvar s = '0.';\\n\\n\\t\\t\\twhile ( s.length < num + 2 ) {\\n\\n\\t\\t\\t\\ts += '0';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s;\\n\\n\\t\\t}\\n\\n\\t\\tnum = num || 2;\\n\\n\\t\\tvar parts = f.toString().split( '.' );\\n\\t\\tparts[ 1 ] = parts.length > 1 ? parts[ 1 ].substr( 0, num ) : \\\"0\\\";\\n\\n\\t\\twhile( parts[ 1 ].length < num ) {\\n\\n\\t\\t\\tparts[ 1 ] += '0';\\n\\n\\t\\t}\\n\\n\\t\\treturn parts.join( '.' );\\n\\n\\t};\\n\\n\\tfunction extractDoubleSided( obj, element ) {\\n\\n\\t\\tobj.doubleSided = false;\\n\\n\\t\\tvar node = element.querySelectorAll('extra double_sided')[0];\\n\\n\\t\\tif ( node ) {\\n\\n\\t\\t\\tif ( node && parseInt( node.textContent, 10 ) === 1 ) {\\n\\n\\t\\t\\t\\tobj.doubleSided = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// Up axis conversion\\n\\n\\tfunction setUpConversion() {\\n\\n\\t\\tif ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {\\n\\n\\t\\t\\tupConversion = null;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tswitch ( colladaUp ) {\\n\\n\\t\\t\\t\\tcase 'X':\\n\\n\\t\\t\\t\\t\\tupConversion = options.upAxis === 'Y' ? 'XtoY' : 'XtoZ';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'Y':\\n\\n\\t\\t\\t\\t\\tupConversion = options.upAxis === 'X' ? 'YtoX' : 'YtoZ';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'Z':\\n\\n\\t\\t\\t\\t\\tupConversion = options.upAxis === 'X' ? 'ZtoX' : 'ZtoY';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction fixCoords( data, sign ) {\\n\\n\\t\\tif ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {\\n\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tswitch ( upConversion ) {\\n\\n\\t\\t\\tcase 'XtoY':\\n\\n\\t\\t\\t\\tvar tmp = data[ 0 ];\\n\\t\\t\\t\\tdata[ 0 ] = sign * data[ 1 ];\\n\\t\\t\\t\\tdata[ 1 ] = tmp;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'XtoZ':\\n\\n\\t\\t\\t\\tvar tmp = data[ 2 ];\\n\\t\\t\\t\\tdata[ 2 ] = data[ 1 ];\\n\\t\\t\\t\\tdata[ 1 ] = data[ 0 ];\\n\\t\\t\\t\\tdata[ 0 ] = tmp;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'YtoX':\\n\\n\\t\\t\\t\\tvar tmp = data[ 0 ];\\n\\t\\t\\t\\tdata[ 0 ] = data[ 1 ];\\n\\t\\t\\t\\tdata[ 1 ] = sign * tmp;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'YtoZ':\\n\\n\\t\\t\\t\\tvar tmp = data[ 1 ];\\n\\t\\t\\t\\tdata[ 1 ] = sign * data[ 2 ];\\n\\t\\t\\t\\tdata[ 2 ] = tmp;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'ZtoX':\\n\\n\\t\\t\\t\\tvar tmp = data[ 0 ];\\n\\t\\t\\t\\tdata[ 0 ] = data[ 1 ];\\n\\t\\t\\t\\tdata[ 1 ] = data[ 2 ];\\n\\t\\t\\t\\tdata[ 2 ] = tmp;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'ZtoY':\\n\\n\\t\\t\\t\\tvar tmp = data[ 1 ];\\n\\t\\t\\t\\tdata[ 1 ] = data[ 2 ];\\n\\t\\t\\t\\tdata[ 2 ] = sign * tmp;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction getConvertedTranslation( axis, data ) {\\n\\n\\t\\tif ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t\\tswitch ( axis ) {\\n\\t\\t\\tcase 'X':\\n\\t\\t\\t\\tdata = upConversion == 'XtoY' ? data * -1 : data;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'Y':\\n\\t\\t\\t\\tdata = upConversion == 'YtoZ' || upConversion == 'YtoX' ? data * -1 : data;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase 'Z':\\n\\t\\t\\t\\tdata = upConversion == 'ZtoY' ? data * -1 : data ;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\t};\\n\\n\\tfunction getConvertedVec3( data, offset ) {\\n\\n\\t\\tvar arr = [ data[ offset ], data[ offset + 1 ], data[ offset + 2 ] ];\\n\\t\\tfixCoords( arr, -1 );\\n\\t\\treturn new THREE.Vector3( arr[ 0 ], arr[ 1 ], arr[ 2 ] );\\n\\n\\t};\\n\\n\\tfunction getConvertedMat4( data ) {\\n\\n\\t\\tif ( options.convertUpAxis ) {\\n\\n\\t\\t\\t// First fix rotation and scale\\n\\n\\t\\t\\t// Columns first\\n\\t\\t\\tvar arr = [ data[ 0 ], data[ 4 ], data[ 8 ] ];\\n\\t\\t\\tfixCoords( arr, -1 );\\n\\t\\t\\tdata[ 0 ] = arr[ 0 ];\\n\\t\\t\\tdata[ 4 ] = arr[ 1 ];\\n\\t\\t\\tdata[ 8 ] = arr[ 2 ];\\n\\t\\t\\tarr = [ data[ 1 ], data[ 5 ], data[ 9 ] ];\\n\\t\\t\\tfixCoords( arr, -1 );\\n\\t\\t\\tdata[ 1 ] = arr[ 0 ];\\n\\t\\t\\tdata[ 5 ] = arr[ 1 ];\\n\\t\\t\\tdata[ 9 ] = arr[ 2 ];\\n\\t\\t\\tarr = [ data[ 2 ], data[ 6 ], data[ 10 ] ];\\n\\t\\t\\tfixCoords( arr, -1 );\\n\\t\\t\\tdata[ 2 ] = arr[ 0 ];\\n\\t\\t\\tdata[ 6 ] = arr[ 1 ];\\n\\t\\t\\tdata[ 10 ] = arr[ 2 ];\\n\\t\\t\\t// Rows second\\n\\t\\t\\tarr = [ data[ 0 ], data[ 1 ], data[ 2 ] ];\\n\\t\\t\\tfixCoords( arr, -1 );\\n\\t\\t\\tdata[ 0 ] = arr[ 0 ];\\n\\t\\t\\tdata[ 1 ] = arr[ 1 ];\\n\\t\\t\\tdata[ 2 ] = arr[ 2 ];\\n\\t\\t\\tarr = [ data[ 4 ], data[ 5 ], data[ 6 ] ];\\n\\t\\t\\tfixCoords( arr, -1 );\\n\\t\\t\\tdata[ 4 ] = arr[ 0 ];\\n\\t\\t\\tdata[ 5 ] = arr[ 1 ];\\n\\t\\t\\tdata[ 6 ] = arr[ 2 ];\\n\\t\\t\\tarr = [ data[ 8 ], data[ 9 ], data[ 10 ] ];\\n\\t\\t\\tfixCoords( arr, -1 );\\n\\t\\t\\tdata[ 8 ] = arr[ 0 ];\\n\\t\\t\\tdata[ 9 ] = arr[ 1 ];\\n\\t\\t\\tdata[ 10 ] = arr[ 2 ];\\n\\n\\t\\t\\t// Now fix translation\\n\\t\\t\\tarr = [ data[ 3 ], data[ 7 ], data[ 11 ] ];\\n\\t\\t\\tfixCoords( arr, -1 );\\n\\t\\t\\tdata[ 3 ] = arr[ 0 ];\\n\\t\\t\\tdata[ 7 ] = arr[ 1 ];\\n\\t\\t\\tdata[ 11 ] = arr[ 2 ];\\n\\n\\t\\t}\\n\\n\\t\\treturn new THREE.Matrix4(\\n\\t\\t\\tdata[0], data[1], data[2], data[3],\\n\\t\\t\\tdata[4], data[5], data[6], data[7],\\n\\t\\t\\tdata[8], data[9], data[10], data[11],\\n\\t\\t\\tdata[12], data[13], data[14], data[15]\\n\\t\\t\\t);\\n\\n\\t};\\n\\n\\tfunction getConvertedIndex( index ) {\\n\\n\\t\\tif ( index > -1 && index < 3 ) {\\n\\n\\t\\t\\tvar members = ['X', 'Y', 'Z'],\\n\\t\\t\\t\\tindices = { X: 0, Y: 1, Z: 2 };\\n\\n\\t\\t\\tindex = getConvertedMember( members[ index ] );\\n\\t\\t\\tindex = indices[ index ];\\n\\n\\t\\t}\\n\\n\\t\\treturn index;\\n\\n\\t};\\n\\n\\tfunction getConvertedMember( member ) {\\n\\n\\t\\tif ( options.convertUpAxis ) {\\n\\n\\t\\t\\tswitch ( member ) {\\n\\n\\t\\t\\t\\tcase 'X':\\n\\n\\t\\t\\t\\t\\tswitch ( upConversion ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'XtoY':\\n\\t\\t\\t\\t\\t\\tcase 'XtoZ':\\n\\t\\t\\t\\t\\t\\tcase 'YtoX':\\n\\n\\t\\t\\t\\t\\t\\t\\tmember = 'Y';\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'ZtoX':\\n\\n\\t\\t\\t\\t\\t\\t\\tmember = 'Z';\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'Y':\\n\\n\\t\\t\\t\\t\\tswitch ( upConversion ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'XtoY':\\n\\t\\t\\t\\t\\t\\tcase 'YtoX':\\n\\t\\t\\t\\t\\t\\tcase 'ZtoX':\\n\\n\\t\\t\\t\\t\\t\\t\\tmember = 'X';\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'XtoZ':\\n\\t\\t\\t\\t\\t\\tcase 'YtoZ':\\n\\t\\t\\t\\t\\t\\tcase 'ZtoY':\\n\\n\\t\\t\\t\\t\\t\\t\\tmember = 'Z';\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'Z':\\n\\n\\t\\t\\t\\t\\tswitch ( upConversion ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'XtoZ':\\n\\n\\t\\t\\t\\t\\t\\t\\tmember = 'X';\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'YtoZ':\\n\\t\\t\\t\\t\\t\\tcase 'ZtoX':\\n\\t\\t\\t\\t\\t\\tcase 'ZtoY':\\n\\n\\t\\t\\t\\t\\t\\t\\tmember = 'Y';\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn member;\\n\\n\\t};\\n\\n\\treturn {\\n\\n\\t\\tload: load,\\n\\t\\tparse: parse,\\n\\t\\tsetPreferredShading: setPreferredShading,\\n\\t\\tapplySkin: applySkin,\\n\\t\\tgeometries : geometries,\\n\\t\\toptions: options\\n\\n\\t};\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/DDSLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/DDSLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/*\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.DDSLoader = function () {};\\n\\nTHREE.DDSLoader.prototype = {\\n\\n\\tconstructor: THREE.DDSLoader,\\n\\n\\tload: function ( url, onLoad, onError ) {\\n          var func = \\\"THREE.DDSLoader.load\\\";\\n          hack.log(\\\"url: \\\"+url, hack.loader, func);\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar images = [];\\n\\n\\t\\tvar texture = new THREE.CompressedTexture();\\n\\t\\ttexture.image = images;\\n\\n\\t\\t// no flipping for cube textures\\n\\t\\t// (also flipping doesn't work for compressed textures )\\n\\n\\t\\ttexture.flipY = false;\\n\\n\\t\\t// can't generate mipmaps for compressed textures\\n\\t\\t// mips must be embedded in DDS files\\n\\n\\t\\ttexture.generateMipmaps = false;\\n\\n\\t\\tif ( url instanceof Array ) {\\n\\n\\t\\t\\tvar loaded = 0;\\n\\n\\t\\t\\tvar loader = new THREE.XHRLoader();\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\n\\t\\t\\tvar loadTexture = function ( i ) {\\n\\t\\t\\n\\t\\t\\t\\tloader.load( url[ i ], function ( buffer ) {\\n\\n\\t\\t\\t\\t\\tvar dds = scope.parse( buffer, true );\\n\\n\\t\\t\\t\\t\\timages[ i ] = {\\n\\t\\t\\t\\t\\t\\twidth: dds.width,\\n\\t\\t\\t\\t\\t\\theight: dds.height,\\n\\t\\t\\t\\t\\t\\tformat: dds.format,\\n\\t\\t\\t\\t\\t\\tmipmaps: dds.mipmaps\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tloaded += 1;\\n\\n\\t\\t\\t\\t\\tif ( loaded === 6 ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.format = dds.format;\\n\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\\n\\n\\t\\t\\t\\tloadTexture( i );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// compressed cubemap texture stored in a single DDS file\\n\\n\\t\\t\\tvar loader = new THREE.XHRLoader();\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\t\\t\\tloader.load( url, function ( buffer ) {\\n\\n\\t\\t\\t\\tvar dds = scope.parse( buffer, true );\\n\\n\\t\\t\\t\\tif ( dds.isCubemap ) {\\n\\n\\t\\t\\t\\t\\tvar faces = dds.mipmaps.length / dds.mipmapCount;\\n\\n\\t\\t\\t\\t\\tfor ( var f = 0; f < faces; f ++ ) {\\n\\n\\t\\t\\t\\t\\t\\timages[ f ] = { mipmaps : [] };\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\\n\\t\\t\\t\\t\\t\\t\\timages[ f ].format = dds.format;\\n\\t\\t\\t\\t\\t\\t\\timages[ f ].width = dds.width;\\n\\t\\t\\t\\t\\t\\t\\timages[ f ].height = dds.height;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\ttexture.image.width = dds.width;\\n\\t\\t\\t\\t\\ttexture.image.height = dds.height;\\n\\t\\t\\t\\t\\ttexture.mipmaps = dds.mipmaps;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttexture.format = dds.format;\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t}\\n          hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n\\n\\t\\treturn texture;\\n\\n\\t},\\n\\n\\tparse: function ( buffer, loadMipmaps ) {\\n\\n\\t\\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\\n\\n\\t\\t// Adapted from @toji's DDS utils\\n\\t\\t//\\thttps://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\\n\\n\\t\\t// All values and structures referenced from:\\n\\t\\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\\n\\n\\t\\tvar DDS_MAGIC = 0x20534444;\\n\\n\\t\\tvar DDSD_CAPS = 0x1,\\n\\t\\t\\tDDSD_HEIGHT = 0x2,\\n\\t\\t\\tDDSD_WIDTH = 0x4,\\n\\t\\t\\tDDSD_PITCH = 0x8,\\n\\t\\t\\tDDSD_PIXELFORMAT = 0x1000,\\n\\t\\t\\tDDSD_MIPMAPCOUNT = 0x20000,\\n\\t\\t\\tDDSD_LINEARSIZE = 0x80000,\\n\\t\\t\\tDDSD_DEPTH = 0x800000;\\n\\n\\t\\tvar DDSCAPS_COMPLEX = 0x8,\\n\\t\\t\\tDDSCAPS_MIPMAP = 0x400000,\\n\\t\\t\\tDDSCAPS_TEXTURE = 0x1000;\\n\\n\\t\\tvar DDSCAPS2_CUBEMAP = 0x200,\\n\\t\\t\\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\\n\\t\\t\\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\\n\\t\\t\\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\\n\\t\\t\\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\\n\\t\\t\\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\\n\\t\\t\\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\\n\\t\\t\\tDDSCAPS2_VOLUME = 0x200000;\\n\\n\\t\\tvar DDPF_ALPHAPIXELS = 0x1,\\n\\t\\t\\tDDPF_ALPHA = 0x2,\\n\\t\\t\\tDDPF_FOURCC = 0x4,\\n\\t\\t\\tDDPF_RGB = 0x40,\\n\\t\\t\\tDDPF_YUV = 0x200,\\n\\t\\t\\tDDPF_LUMINANCE = 0x20000;\\n\\n\\t\\tfunction fourCCToInt32( value ) {\\n\\n\\t\\t\\treturn value.charCodeAt(0) +\\n\\t\\t\\t\\t(value.charCodeAt(1) << 8) +\\n\\t\\t\\t\\t(value.charCodeAt(2) << 16) +\\n\\t\\t\\t\\t(value.charCodeAt(3) << 24);\\n\\n\\t\\t}\\n\\n\\t\\tfunction int32ToFourCC( value ) {\\n\\n\\t\\t\\treturn String.fromCharCode(\\n\\t\\t\\t\\tvalue & 0xff,\\n\\t\\t\\t\\t(value >> 8) & 0xff,\\n\\t\\t\\t\\t(value >> 16) & 0xff,\\n\\t\\t\\t\\t(value >> 24) & 0xff\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\\n\\t\\t\\tvar dataLength = width*height*4;\\n\\t\\t\\tvar srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\\n\\t\\t\\tvar byteArray = new Uint8Array( dataLength );\\n\\t\\t\\tvar dst = 0;\\n\\t\\t\\tvar src = 0;\\n\\t\\t\\tfor ( var y = 0; y < height; y++ ) {\\n\\t\\t\\t\\tfor ( var x = 0; x < width; x++ ) {\\n\\t\\t\\t\\t\\tvar b = srcBuffer[src]; src++;\\n\\t\\t\\t\\t\\tvar g = srcBuffer[src]; src++;\\n\\t\\t\\t\\t\\tvar r = srcBuffer[src]; src++;\\n\\t\\t\\t\\t\\tvar a = srcBuffer[src]; src++;\\n\\t\\t\\t\\t\\tbyteArray[dst] = r; dst++;\\t//r\\n\\t\\t\\t\\t\\tbyteArray[dst] = g; dst++;\\t//g\\n\\t\\t\\t\\t\\tbyteArray[dst] = b; dst++;\\t//b\\n\\t\\t\\t\\t\\tbyteArray[dst] = a; dst++;\\t//a\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn byteArray;\\n\\t\\t}\\n\\n\\t\\tvar FOURCC_DXT1 = fourCCToInt32(\\\"DXT1\\\");\\n\\t\\tvar FOURCC_DXT3 = fourCCToInt32(\\\"DXT3\\\");\\n\\t\\tvar FOURCC_DXT5 = fourCCToInt32(\\\"DXT5\\\");\\n\\n\\t\\tvar headerLengthInt = 31; // The header length in 32 bit ints\\n\\n\\t\\t// Offsets into the header array\\n\\n\\t\\tvar off_magic = 0;\\n\\n\\t\\tvar off_size = 1;\\n\\t\\tvar off_flags = 2;\\n\\t\\tvar off_height = 3;\\n\\t\\tvar off_width = 4;\\n\\n\\t\\tvar off_mipmapCount = 7;\\n\\n\\t\\tvar off_pfFlags = 20;\\n\\t\\tvar off_pfFourCC = 21;\\n\\t\\tvar off_RGBBitCount = 22;\\n\\t\\tvar off_RBitMask = 23;\\n\\t\\tvar off_GBitMask = 24;\\n\\t\\tvar off_BBitMask = 25;\\n\\t\\tvar off_ABitMask = 26;\\n\\n\\t\\tvar off_caps = 27;\\n\\t\\tvar off_caps2 = 28;\\n\\t\\tvar off_caps3 = 29;\\n\\t\\tvar off_caps4 = 30;\\n\\n\\t\\t// Parse header\\n\\n\\t\\tvar header = new Int32Array( buffer, 0, headerLengthInt );\\n\\n\\t\\tif ( header[ off_magic ] !== DDS_MAGIC ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );\\n\\t\\t\\treturn dds;\\n\\n\\t\\t}\\n\\n\\t\\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.' );\\n\\t\\t\\treturn dds;\\n\\n\\t\\t}\\n\\n\\t\\tvar blockBytes;\\n\\n\\t\\tvar fourCC = header[ off_pfFourCC ];\\n\\n\\t\\tvar isRGBAUncompressed = false;\\n\\n\\t\\tswitch ( fourCC ) {\\n\\n\\t\\t\\tcase FOURCC_DXT1:\\n\\n\\t\\t\\t\\tblockBytes = 8;\\n\\t\\t\\t\\tdds.format = THREE.RGB_S3TC_DXT1_Format;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase FOURCC_DXT3:\\n\\n\\t\\t\\t\\tblockBytes = 16;\\n\\t\\t\\t\\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase FOURCC_DXT5:\\n\\n\\t\\t\\t\\tblockBytes = 16;\\n\\t\\t\\t\\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tif( header[off_RGBBitCount] ==32 \\n\\t\\t\\t\\t\\t&& header[off_RBitMask]&0xff0000\\n\\t\\t\\t\\t\\t&& header[off_GBitMask]&0xff00 \\n\\t\\t\\t\\t\\t&& header[off_BBitMask]&0xff\\n\\t\\t\\t\\t\\t&& header[off_ABitMask]&0xff000000  ) {\\n\\t\\t\\t\\t\\tisRGBAUncompressed = true;\\n\\t\\t\\t\\t\\tblockBytes = 64;\\n\\t\\t\\t\\t\\tdds.format = THREE.RGBAFormat;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );\\n\\t\\t\\t\\t\\treturn dds;\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tdds.mipmapCount = 1;\\n\\n\\t\\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\\n\\n\\t\\t\\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\\n\\n\\t\\t}\\n\\n\\t\\t//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.\\n\\n\\t\\tdds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;\\n\\n\\t\\tdds.width = header[ off_width ];\\n\\t\\tdds.height = header[ off_height ];\\n\\n\\t\\tvar dataOffset = header[ off_size ] + 4;\\n\\n\\t\\t// Extract mipmaps buffers\\n\\n\\t\\tvar width = dds.width;\\n\\t\\tvar height = dds.height;\\n\\n\\t\\tvar faces = dds.isCubemap ? 6 : 1;\\n\\n\\t\\tfor ( var face = 0; face < faces; face ++ ) {\\n\\n\\t\\t\\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\\n\\n\\t\\t\\t\\tif( isRGBAUncompressed ) {\\n\\t\\t\\t\\t\\tvar byteArray = loadARGBMip( buffer, dataOffset, width, height );\\n\\t\\t\\t\\t\\tvar dataLength = byteArray.length;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\\n\\t\\t\\t\\t\\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvar mipmap = { \\\"data\\\": byteArray, \\\"width\\\": width, \\\"height\\\": height };\\n\\t\\t\\t\\tdds.mipmaps.push( mipmap );\\n\\n\\t\\t\\t\\tdataOffset += dataLength;\\n\\n\\t\\t\\t\\twidth = Math.max( width * 0.5, 1 );\\n\\t\\t\\t\\theight = Math.max( height * 0.5, 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\twidth = dds.width;\\n\\t\\t\\theight = dds.height;\\n\\n\\t\\t}\\n\\n\\t\\treturn dds;\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/MTLLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/MTLLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * Loads a Wavefront .mtl file specifying materials\\n *\\n * @author angelxuanchang\\n */\\n\\nTHREE.MTLLoader = function( baseUrl, options, crossOrigin ) {\\n\\n\\tthis.baseUrl = baseUrl;\\n\\tthis.options = options;\\n\\tthis.crossOrigin = crossOrigin;\\n\\n};\\n\\nTHREE.MTLLoader.prototype = {\\n\\n\\tconstructor: THREE.MTLLoader,\\n\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar loader = new THREE.XHRLoader();\\n\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\tonLoad( scope.parse( text ) );\\n\\n\\t\\t} );\\n\\n\\t},\\n\\n\\t/**\\n\\t * Parses loaded MTL file\\n\\t * @param text - Content of MTL file\\n\\t * @return {THREE.MTLLoader.MaterialCreator}\\n\\t */\\n\\tparse: function ( text ) {\\n\\n\\t\\tvar lines = text.split( \\\"\\\\n\\\" );\\n\\t\\tvar info = {};\\n\\t\\tvar delimiter_pattern = /\\\\s+/;\\n\\t\\tvar materialsInfo = {};\\n\\n\\t\\tfor ( var i = 0; i < lines.length; i ++ ) {\\n\\n\\t\\t\\tvar line = lines[ i ];\\n\\t\\t\\tline = line.trim();\\n\\n\\t\\t\\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\\n\\n\\t\\t\\t\\t// Blank line or comment ignore\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar pos = line.indexOf( ' ' );\\n\\n\\t\\t\\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\\n\\t\\t\\tkey = key.toLowerCase();\\n\\n\\t\\t\\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : \\\"\\\";\\n\\t\\t\\tvalue = value.trim();\\n\\n\\t\\t\\tif ( key === \\\"newmtl\\\" ) {\\n\\n\\t\\t\\t\\t// New material\\n\\n\\t\\t\\t\\tinfo = { name: value };\\n\\t\\t\\t\\tmaterialsInfo[ value ] = info;\\n\\n\\t\\t\\t} else if ( info ) {\\n\\n\\t\\t\\t\\tif ( key === \\\"ka\\\" || key === \\\"kd\\\" || key === \\\"ks\\\" ) {\\n\\n\\t\\t\\t\\t\\tvar ss = value.split( delimiter_pattern, 3 );\\n\\t\\t\\t\\t\\tinfo[ key ] = [ parseFloat( ss[0] ), parseFloat( ss[1] ), parseFloat( ss[2] ) ];\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tinfo[ key ] = value;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar materialCreator = new THREE.MTLLoader.MaterialCreator( this.baseUrl, this.options );\\n\\t\\tmaterialCreator.setMaterials( materialsInfo );\\n\\t\\treturn materialCreator;\\n\\n\\t}\\n\\n};\\n\\n/**\\n * Create a new THREE-MTLLoader.MaterialCreator\\n * @param baseUrl - Url relative to which textures are loaded\\n * @param options - Set of options on how to construct the materials\\n *                  side: Which side to apply the material\\n *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\\n *                  wrap: What type of wrapping to apply for textures\\n *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\\n *                                Default: false, assumed to be already normalized\\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\\n *                                  Default: false\\n *                  invertTransparency: If transparency need to be inverted (inversion is needed if d = 0 is fully opaque)\\n *                                      Default: false (d = 1 is fully opaque)\\n * @constructor\\n */\\n\\nTHREE.MTLLoader.MaterialCreator = function( baseUrl, options ) {\\n\\n\\tthis.baseUrl = baseUrl;\\n\\tthis.options = options;\\n\\tthis.materialsInfo = {};\\n\\tthis.materials = {};\\n\\tthis.materialsArray = [];\\n\\tthis.nameLookup = {};\\n\\n\\tthis.side = ( this.options && this.options.side )? this.options.side: THREE.FrontSide;\\n\\tthis.wrap = ( this.options && this.options.wrap )? this.options.wrap: THREE.RepeatWrapping;\\n\\n};\\n\\nTHREE.MTLLoader.MaterialCreator.prototype = {\\n\\n\\tconstructor: THREE.MTLLoader.MaterialCreator,\\n\\n\\tsetMaterials: function( materialsInfo ) {\\n\\n\\t\\tthis.materialsInfo = this.convert( materialsInfo );\\n\\t\\tthis.materials = {};\\n\\t\\tthis.materialsArray = [];\\n\\t\\tthis.nameLookup = {};\\n\\n\\t},\\n\\n\\tconvert: function( materialsInfo ) {\\n\\n\\t\\tif ( !this.options ) return materialsInfo;\\n\\n\\t\\tvar converted = {};\\n\\n\\t\\tfor ( var mn in materialsInfo ) {\\n\\n\\t\\t\\t// Convert materials info into normalized form based on options\\n\\n\\t\\t\\tvar mat = materialsInfo[ mn ];\\n\\n\\t\\t\\tvar covmat = {};\\n\\n\\t\\t\\tconverted[ mn ] = covmat;\\n\\n\\t\\t\\tfor ( var prop in mat ) {\\n\\n\\t\\t\\t\\tvar save = true;\\n\\t\\t\\t\\tvar value = mat[ prop ];\\n\\t\\t\\t\\tvar lprop = prop.toLowerCase();\\n\\n\\t\\t\\t\\tswitch ( lprop ) {\\n\\n\\t\\t\\t\\t\\tcase 'kd':\\n\\t\\t\\t\\t\\tcase 'ka':\\n\\t\\t\\t\\t\\tcase 'ks':\\n\\n\\t\\t\\t\\t\\t\\t// Diffuse color (color under white light) using RGB values\\n\\n\\t\\t\\t\\t\\t\\tif ( this.options && this.options.normalizeRGB ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( this.options && this.options.ignoreZeroRGBs ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 1 ] === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// ignore\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tsave = false;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'd':\\n\\n\\t\\t\\t\\t\\t\\t// According to MTL format (http://paulbourke.net/dataformats/mtl/):\\n\\t\\t\\t\\t\\t\\t//   d is dissolve for current material\\n\\t\\t\\t\\t\\t\\t//   factor of 1.0 is fully opaque, a factor of 0 is fully dissolved (completely transparent)\\n\\n\\t\\t\\t\\t\\t\\tif ( this.options && this.options.invertTransparency ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvalue = 1 - value;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( save ) {\\n\\n\\t\\t\\t\\t\\tcovmat[ lprop ] = value;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn converted;\\n\\n\\t},\\n\\n\\tpreload: function () {\\n\\n\\t\\tfor ( var mn in this.materialsInfo ) {\\n\\n\\t\\t\\tthis.create( mn );\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tgetIndex: function( materialName ) {\\n\\n\\t\\treturn this.nameLookup[ materialName ];\\n\\n\\t},\\n\\n\\tgetAsArray: function() {\\n\\n\\t\\tvar index = 0;\\n\\n\\t\\tfor ( var mn in this.materialsInfo ) {\\n\\n\\t\\t\\tthis.materialsArray[ index ] = this.create( mn );\\n\\t\\t\\tthis.nameLookup[ mn ] = index;\\n\\t\\t\\tindex ++;\\n\\n\\t\\t}\\n\\n\\t\\treturn this.materialsArray;\\n\\n\\t},\\n\\n\\tcreate: function ( materialName ) {\\n\\n\\t\\tif ( this.materials[ materialName ] === undefined ) {\\n\\n\\t\\t\\tthis.createMaterial_( materialName );\\n\\n\\t\\t}\\n\\n\\t\\treturn this.materials[ materialName ];\\n\\n\\t},\\n\\n\\tcreateMaterial_: function ( materialName ) {\\n\\n\\t\\t// Create material\\n\\n\\t\\tvar mat = this.materialsInfo[ materialName ];\\n\\t\\tvar params = {\\n\\n\\t\\t\\tname: materialName,\\n\\t\\t\\tside: this.side\\n\\n\\t\\t};\\n\\n\\t\\tfor ( var prop in mat ) {\\n\\n\\t\\t\\tvar value = mat[ prop ];\\n\\n\\t\\t\\tswitch ( prop.toLowerCase() ) {\\n\\n\\t\\t\\t\\t// Ns is material specular exponent\\n\\n\\t\\t\\t\\tcase 'kd':\\n\\n\\t\\t\\t\\t\\t// Diffuse color (color under white light) using RGB values\\n\\n\\t\\t\\t\\t\\tparams[ 'diffuse' ] = new THREE.Color().fromArray( value );\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'ka':\\n\\n\\t\\t\\t\\t\\t// Ambient color (color under shadow) using RGB values\\n\\n\\t\\t\\t\\t\\tparams[ 'ambient' ] = new THREE.Color().fromArray( value );\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'ks':\\n\\n\\t\\t\\t\\t\\t// Specular color (color when light is reflected from shiny surface) using RGB values\\n\\t\\t\\t\\t\\tparams[ 'specular' ] = new THREE.Color().fromArray( value );\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'map_kd':\\n\\n\\t\\t\\t\\t\\t// Diffuse texture map\\n\\n\\t\\t\\t\\t\\tparams[ 'map' ] = this.loadTexture( this.baseUrl + value );\\n\\t\\t\\t\\t\\tparams[ 'map' ].wrapS = this.wrap;\\n\\t\\t\\t\\t\\tparams[ 'map' ].wrapT = this.wrap;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'ns':\\n\\n\\t\\t\\t\\t\\t// The specular exponent (defines the focus of the specular highlight)\\n\\t\\t\\t\\t\\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\\n\\n\\t\\t\\t\\t\\tparams['shininess'] = value;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 'd':\\n\\n\\t\\t\\t\\t\\t// According to MTL format (http://paulbourke.net/dataformats/mtl/):\\n\\t\\t\\t\\t\\t//   d is dissolve for current material\\n\\t\\t\\t\\t\\t//   factor of 1.0 is fully opaque, a factor of 0 is fully dissolved (completely transparent)\\n\\n\\t\\t\\t\\t\\tif ( value < 1 ) {\\n\\n\\t\\t\\t\\t\\t\\tparams['transparent'] = true;\\n\\t\\t\\t\\t\\t\\tparams['opacity'] = value;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( params[ 'diffuse' ] ) {\\n\\n\\t\\t\\tif ( !params[ 'ambient' ]) params[ 'ambient' ] = params[ 'diffuse' ];\\n\\t\\t\\tparams[ 'color' ] = params[ 'diffuse' ];\\n\\n\\t\\t}\\n\\n\\t\\tthis.materials[ materialName ] = new THREE.MeshPhongMaterial( params );\\n\\t\\treturn this.materials[ materialName ];\\n\\n\\t},\\n\\n\\n\\tloadTexture: function ( url, mapping, onLoad, onError ) {\\n\\n\\t\\tvar texture;\\n\\t\\tvar loader = THREE.Loader.Handlers.get( url );\\n\\n\\t\\tif ( loader !== null ) {\\n\\n\\t\\t\\ttexture = loader.load( url, onLoad );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\ttexture = new THREE.Texture();\\n\\n\\t\\t\\tloader = new THREE.ImageLoader();\\n\\t\\t\\tloader.crossOrigin = this.crossOrigin;\\n\\t\\t\\tloader.load( url, function ( image ) {\\n\\n\\t\\t\\t\\ttexture.image = THREE.MTLLoader.ensurePowerOfTwo_( image );\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t}\\n\\n\\t\\ttexture.mapping = mapping;\\n\\n\\t\\treturn texture;\\n\\n\\t}\\n\\n};\\n\\nTHREE.MTLLoader.ensurePowerOfTwo_ = function ( image ) {\\n\\n\\tif ( ! THREE.Math.isPowerOfTwo( image.width ) || ! THREE.Math.isPowerOfTwo( image.height ) ) {\\n\\n\\t\\tvar canvas = document.createElement( \\\"canvas\\\" );\\n\\t\\tcanvas.width = THREE.MTLLoader.nextHighestPowerOfTwo_( image.width );\\n\\t\\tcanvas.height = THREE.MTLLoader.nextHighestPowerOfTwo_( image.height );\\n\\n\\t\\tvar ctx = canvas.getContext(\\\"2d\\\");\\n\\t\\tctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\\n\\t\\treturn canvas;\\n\\n\\t}\\n\\n\\treturn image;\\n\\n};\\n\\nTHREE.MTLLoader.nextHighestPowerOfTwo_ = function( x ) {\\n\\n\\t--x;\\n\\n\\tfor ( var i = 1; i < 32; i <<= 1 ) {\\n\\n\\t\\tx = x | x >> i;\\n\\n\\t}\\n\\n\\treturn x + 1;\\n\\n};\\n\\nTHREE.EventDispatcher.prototype.apply( THREE.MTLLoader.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/OBJLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/OBJLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.OBJLoader = function ( manager ) {\\n\\n\\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\\n\\n};\\n\\nTHREE.OBJLoader.prototype = {\\n\\n\\tconstructor: THREE.OBJLoader,\\n\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar loader = new THREE.XHRLoader( scope.manager );\\n\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\tonLoad( scope.parse( text ) );\\n\\n\\t\\t} );\\n\\n\\t},\\n\\n\\tparse: function ( text ) {\\n          var func = \\\"THREE.OBJLoader.parse\\\";\\n\\n\\t\\tfunction vector( x, y, z ) {\\n\\n\\t\\t\\treturn new THREE.Vector3( parseFloat( x ), parseFloat( y ), parseFloat( z ) );\\n\\n\\t\\t}\\n\\n\\t\\tfunction uv( u, v ) {\\n\\n\\t\\t\\treturn new THREE.Vector2( parseFloat( u ), parseFloat( v ) );\\n\\n\\t\\t}\\n\\n\\t\\tfunction face3( a, b, c, normals ) {\\n\\n\\t\\t\\treturn new THREE.Face3( a, b, c, normals );\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\tvar object = new THREE.Object3D();\\n\\t\\tvar geometry, material, mesh;\\n\\n\\t\\tfunction parseVertexIndex( index ) {\\n\\n\\t\\t\\tindex = parseInt( index );\\n\\n\\t\\t\\treturn index >= 0 ? index - 1 : index + vertices.length;\\n\\n\\t\\t}\\n\\n\\t\\tfunction parseNormalIndex( index ) {\\n\\n\\t\\t\\tindex = parseInt( index );\\n\\n\\t\\t\\treturn index >= 0 ? index - 1 : index + normals.length;\\n\\n\\t\\t}\\n\\n\\t\\tfunction parseUVIndex( index ) {\\n\\n\\t\\t\\tindex = parseInt( index );\\n\\n\\t\\t\\treturn index >= 0 ? index - 1 : index + uvs.length;\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\tfunction add_face( a, b, c, normals_inds ) {\\n\\n\\t\\t\\tif ( normals_inds === undefined ) {\\n\\n\\t\\t\\t\\tgeometry.faces.push( face3(\\n\\t\\t\\t\\t\\tvertices[ parseVertexIndex( a ) ] - 1,\\n\\t\\t\\t\\t\\tvertices[ parseVertexIndex( b ) ] - 1,\\n\\t\\t\\t\\t\\tvertices[ parseVertexIndex( c ) ] - 1\\n\\t\\t\\t\\t) );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tgeometry.faces.push( face3(\\n\\t\\t\\t\\t\\tvertices[ parseVertexIndex( a ) ] - 1,\\n\\t\\t\\t\\t\\tvertices[ parseVertexIndex( b ) ] - 1,\\n\\t\\t\\t\\t\\tvertices[ parseVertexIndex( c ) ] - 1,\\n\\t\\t\\t\\t\\t[\\n\\t\\t\\t\\t\\t\\tnormals[ parseNormalIndex( normals_inds[ 0 ] ) ].clone(),\\n\\t\\t\\t\\t\\t\\tnormals[ parseNormalIndex( normals_inds[ 1 ] ) ].clone(),\\n\\t\\t\\t\\t\\t\\tnormals[ parseNormalIndex( normals_inds[ 2 ] ) ].clone()\\n\\t\\t\\t\\t\\t]\\n\\t\\t\\t\\t) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\tfunction add_uvs( a, b, c ) {\\n\\t  \\n\\t\\t\\tgeometry.faceVertexUvs[ 0 ].push( [\\n\\t\\t\\t\\tuvs[ parseUVIndex( a ) ].clone(),\\n\\t\\t\\t\\tuvs[ parseUVIndex( b ) ].clone(),\\n\\t\\t\\t\\tuvs[ parseUVIndex( c ) ].clone()\\n\\t\\t\\t] );\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\tfunction handle_face_line(faces, uvs, normals_inds) {\\n\\n\\t\\t\\tif ( faces[ 3 ] === undefined ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tadd_face( faces[ 0 ], faces[ 1 ], faces[ 2 ], normals_inds );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( uvs !== undefined && uvs.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tadd_uvs( uvs[ 0 ], uvs[ 1 ], uvs[ 2 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( normals_inds !== undefined && normals_inds.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tadd_face( faces[ 0 ], faces[ 1 ], faces[ 3 ], [ normals_inds[ 0 ], normals_inds[ 1 ], normals_inds[ 3 ] ] );\\n\\t\\t\\t\\t\\tadd_face( faces[ 1 ], faces[ 2 ], faces[ 3 ], [ normals_inds[ 1 ], normals_inds[ 2 ], normals_inds[ 3 ] ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tadd_face( faces[ 0 ], faces[ 1 ], faces[ 3 ] );\\n\\t\\t\\t\\t\\tadd_face( faces[ 1 ], faces[ 2 ], faces[ 3 ] );\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( uvs !== undefined && uvs.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tadd_uvs( uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] );\\n\\t\\t\\t\\t\\tadd_uvs( uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\n\\t\\t// create mesh if no objects in text\\n\\n\\t\\tif ( /^o /gm.test( text ) === false ) {\\n\\n\\t\\t\\tgeometry = new THREE.Geometry();\\n\\t\\t\\tmaterial = new THREE.MeshLambertMaterial();\\n\\t\\t\\tmesh = new THREE.Mesh( geometry, material );\\n\\t\\t\\tobject.add( mesh );\\n\\n\\t\\t}\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// v float float float\\n\\n\\t\\tvar vertex_pattern = /v( +[\\\\d|\\\\.|\\\\+|\\\\-|e]+)( +[\\\\d|\\\\.|\\\\+|\\\\-|e]+)( +[\\\\d|\\\\.|\\\\+|\\\\-|e]+)/;\\n\\n\\t\\t// vn float float float\\n\\n\\t\\tvar normal_pattern = /vn( +[\\\\d|\\\\.|\\\\+|\\\\-|e]+)( +[\\\\d|\\\\.|\\\\+|\\\\-|e]+)( +[\\\\d|\\\\.|\\\\+|\\\\-|e]+)/;\\n\\n\\t\\t// vt float float\\n\\n\\t\\tvar uv_pattern = /vt( +[\\\\d|\\\\.|\\\\+|\\\\-|e]+)( +[\\\\d|\\\\.|\\\\+|\\\\-|e]+)/;\\n\\n\\t\\t// f vertex vertex vertex ...\\n\\n\\t\\tvar face_pattern1 = /f( +-?\\\\d+)( +-?\\\\d+)( +-?\\\\d+)( +-?\\\\d+)?/;\\n\\n\\t\\t// f vertex/uv vertex/uv vertex/uv ...\\n\\n\\t\\tvar face_pattern2 = /f( +(-?\\\\d+)\\\\/(-?\\\\d+))( +(-?\\\\d+)\\\\/(-?\\\\d+))( +(-?\\\\d+)\\\\/(-?\\\\d+))( +(-?\\\\d+)\\\\/(-?\\\\d+))?/;\\n\\n\\t\\t// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...\\n\\n\\t\\tvar face_pattern3 = /f( +(-?\\\\d+)\\\\/(-?\\\\d+)\\\\/(-?\\\\d+))( +(-?\\\\d+)\\\\/(-?\\\\d+)\\\\/(-?\\\\d+))( +(-?\\\\d+)\\\\/(-?\\\\d+)\\\\/(-?\\\\d+))( +(-?\\\\d+)\\\\/(-?\\\\d+)\\\\/(-?\\\\d+))?/;\\n\\n\\t\\t// f vertex//normal vertex//normal vertex//normal ... \\n\\n\\t\\tvar face_pattern4 = /f( +(-?\\\\d+)\\\\/\\\\/(-?\\\\d+))( +(-?\\\\d+)\\\\/\\\\/(-?\\\\d+))( +(-?\\\\d+)\\\\/\\\\/(-?\\\\d+))( +(-?\\\\d+)\\\\/\\\\/(-?\\\\d+))?/\\n\\n\\t\\t// fixes\\n\\n\\t\\ttext = text.replace( /\\\\\\\\\\\\r\\\\n/g, '' ); // handles line continuations \\\\\\n\\n\\t\\tvar lines = text.split( '\\\\n' );\\n\\n\\t\\tfor ( var i = 0; i < lines.length; i ++ ) {\\n\\n\\t\\t\\tvar line = lines[ i ];\\n\\t\\t\\tline = line.trim();\\n\\n\\t\\t\\tvar result;\\n\\n\\t\\t\\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\\n\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t} else if ( ( result = vertex_pattern.exec( line ) ) !== null ) {\\n\\n\\t\\t\\t\\t// [\\\"v 1.0 2.0 3.0\\\", \\\"1.0\\\", \\\"2.0\\\", \\\"3.0\\\"]\\n\\n\\t\\t\\t\\tvertices.push( \\n\\t\\t\\t\\t\\tgeometry.vertices.push(\\n\\t\\t\\t\\t\\t\\tvector(\\n\\t\\t\\t\\t\\t\\t\\tresult[ 1 ], result[ 2 ], result[ 3 ]\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else if ( ( result = normal_pattern.exec( line ) ) !== null ) {\\n\\n\\t\\t\\t\\t// [\\\"vn 1.0 2.0 3.0\\\", \\\"1.0\\\", \\\"2.0\\\", \\\"3.0\\\"]\\n\\n\\t\\t\\t\\tnormals.push(\\n\\t\\t\\t\\t\\tvector(\\n\\t\\t\\t\\t\\t\\tresult[ 1 ], result[ 2 ], result[ 3 ]\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else if ( ( result = uv_pattern.exec( line ) ) !== null ) {\\n\\n\\t\\t\\t\\t// [\\\"vt 0.1 0.2\\\", \\\"0.1\\\", \\\"0.2\\\"]\\n\\n\\t\\t\\t\\tuvs.push(\\n\\t\\t\\t\\t\\tuv(\\n\\t\\t\\t\\t\\t\\tresult[ 1 ], result[ 2 ]\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else if ( ( result = face_pattern1.exec( line ) ) !== null ) {\\n\\n\\t\\t\\t\\t// [\\\"f 1 2 3\\\", \\\"1\\\", \\\"2\\\", \\\"3\\\", undefined]\\n\\n\\t\\t\\t\\thandle_face_line(\\n\\t\\t\\t\\t\\t[ result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ] ]\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else if ( ( result = face_pattern2.exec( line ) ) !== null ) {\\n\\n\\t\\t\\t\\t// [\\\"f 1/1 2/2 3/3\\\", \\\" 1/1\\\", \\\"1\\\", \\\"1\\\", \\\" 2/2\\\", \\\"2\\\", \\\"2\\\", \\\" 3/3\\\", \\\"3\\\", \\\"3\\\", undefined, undefined, undefined]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\thandle_face_line(\\n\\t\\t\\t\\t\\t[ result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ] ], //faces\\n\\t\\t\\t\\t\\t[ result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ] //uv\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else if ( ( result = face_pattern3.exec( line ) ) !== null ) {\\n\\n\\t\\t\\t\\t// [\\\"f 1/1/1 2/2/2 3/3/3\\\", \\\" 1/1/1\\\", \\\"1\\\", \\\"1\\\", \\\"1\\\", \\\" 2/2/2\\\", \\\"2\\\", \\\"2\\\", \\\"2\\\", \\\" 3/3/3\\\", \\\"3\\\", \\\"3\\\", \\\"3\\\", undefined, undefined, undefined, undefined]\\n\\n\\t\\t\\t\\thandle_face_line(\\n\\t\\t\\t\\t\\t[ result[ 2 ], result[ 6 ], result[ 10 ], result[ 14 ] ], //faces\\n\\t\\t\\t\\t\\t[ result[ 3 ], result[ 7 ], result[ 11 ], result[ 15 ] ], //uv\\n\\t\\t\\t\\t\\t[ result[ 4 ], result[ 8 ], result[ 12 ], result[ 16 ] ] //normal\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else if ( ( result = face_pattern4.exec( line ) ) !== null ) {\\n\\n\\t\\t\\t\\t// [\\\"f 1//1 2//2 3//3\\\", \\\" 1//1\\\", \\\"1\\\", \\\"1\\\", \\\" 2//2\\\", \\\"2\\\", \\\"2\\\", \\\" 3//3\\\", \\\"3\\\", \\\"3\\\", undefined, undefined, undefined]\\n\\n\\t\\t\\t\\thandle_face_line(\\n\\t\\t\\t\\t\\t[ result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ] ], //faces\\n\\t\\t\\t\\t\\t[ ], //uv\\n\\t\\t\\t\\t\\t[ result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ] //normal\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else if ( /^o /.test( line ) ) {\\n\\n\\t\\t\\t\\tgeometry = new THREE.Geometry();\\n\\t\\t\\t\\tmaterial = new THREE.MeshLambertMaterial();\\n\\n\\t\\t\\t\\tmesh = new THREE.Mesh( geometry, material );\\n\\t\\t\\t\\tmesh.name = line.substring( 2 ).trim();\\n\\t\\t\\t\\tobject.add( mesh );\\n\\n\\t\\t\\t} else if ( /^g /.test( line ) ) {\\n\\n\\t\\t\\t\\t// group\\n\\n\\t\\t\\t} else if ( /^usemtl /.test( line ) ) {\\n\\n\\t\\t\\t\\t// material\\n\\n\\t\\t\\t\\tmaterial.name = line.substring( 7 ).trim();\\n\\n\\t\\t\\t} else if ( /^mtllib /.test( line ) ) {\\n\\n\\t\\t\\t\\t// mtl file\\n\\n\\t\\t\\t} else if ( /^s /.test( line ) ) {\\n\\n\\t\\t\\t\\t// smooth shading\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// console.log( \\\"THREE.OBJLoader: Unhandled line \\\" + line );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar children = object.children;\\n\\n\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar geometry = children[ i ].geometry;\\n\\n\\t\\t\\tgeometry.computeFaceNormals();\\n\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn object;\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/PDBLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/PDBLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.PDBLoader = function ( manager ) {\\n\\n\\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\\n\\n};\\n\\nTHREE.PDBLoader.prototype = {\\n\\n\\tconstructor: THREE.PDBLoader,\\n\\n\\tload: function ( url, onLoad ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar loader = new THREE.XHRLoader( scope.manager );\\n\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\tvar json = scope.parsePDB( text );\\n\\t\\t\\tscope.createModel( json, onLoad );\\n\\n\\t\\t} );\\n\\n\\t},\\n\\n\\t// Based on CanvasMol PDB parser\\n\\n\\tparsePDB: function ( text ) {\\n\\n\\t\\tfunction trim( text ) {\\n\\n\\t\\t\\treturn text.replace(/^\\\\s\\\\s*/, '').replace(/\\\\s\\\\s*$/, '');\\n\\n\\t\\t}\\n\\n\\t\\tfunction capitalize( text ) {\\n\\n\\t\\t\\treturn text.charAt(0).toUpperCase() + text.substr(1).toLowerCase();\\n\\n\\t\\t}\\n\\n\\t\\tfunction hash( s, e ) {\\n\\n\\t\\t\\treturn \\\"s\\\" + Math.min( s, e ) + \\\"e\\\" + Math.max( s, e );\\n\\n\\t\\t}\\n\\n\\t\\tfunction parseBond( start, length ) {\\n\\n\\t\\t\\tvar eatom = parseInt( lines[ i ].substr( start, length ) );\\n\\n\\t\\t\\tif( eatom ) {\\n\\n\\t\\t\\t\\tvar h = hash( satom, eatom );\\n\\n\\t\\t\\t\\tif ( bhash[ h ] == undefined ) {\\n\\n\\t\\t\\t\\t\\tbonds.push( [ satom - 1, eatom - 1, 1 ] );\\n\\t\\t\\t\\t\\tbhash[ h ] = bonds.length - 1;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// doesn't really work as almost all PDBs\\n\\t\\t\\t\\t\\t// have just normal bonds appearing multiple\\n\\t\\t\\t\\t\\t// times instead of being double/triple bonds\\n\\t\\t\\t\\t\\t// bonds[bhash[h]][2] += 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar CPK = {\\\"h\\\":[255,255,255],\\\"he\\\":[217,255,255],\\\"li\\\":[204,128,255],\\\"be\\\":[194,255,0],\\\"b\\\":[255,181,181],\\\"c\\\":[144,144,144],\\\"n\\\":[48,80,248],\\\"o\\\":[255,13,13],\\\"f\\\":[144,224,80],\\\"ne\\\":[179,227,245],\\\"na\\\":[171,92,242],\\\"mg\\\":[138,255,0],\\\"al\\\":[191,166,166],\\\"si\\\":[240,200,160],\\\"p\\\":[255,128,0],\\\"s\\\":[255,255,48],\\\"cl\\\":[31,240,31],\\\"ar\\\":[128,209,227],\\\"k\\\":[143,64,212],\\\"ca\\\":[61,255,0],\\\"sc\\\":[230,230,230],\\\"ti\\\":[191,194,199],\\\"v\\\":[166,166,171],\\\"cr\\\":[138,153,199],\\\"mn\\\":[156,122,199],\\\"fe\\\":[224,102,51],\\\"co\\\":[240,144,160],\\\"ni\\\":[80,208,80],\\\"cu\\\":[200,128,51],\\\"zn\\\":[125,128,176],\\\"ga\\\":[194,143,143],\\\"ge\\\":[102,143,143],\\\"as\\\":[189,128,227],\\\"se\\\":[255,161,0],\\\"br\\\":[166,41,41],\\\"kr\\\":[92,184,209],\\\"rb\\\":[112,46,176],\\\"sr\\\":[0,255,0],\\\"y\\\":[148,255,255],\\\"zr\\\":[148,224,224],\\\"nb\\\":[115,194,201],\\\"mo\\\":[84,181,181],\\\"tc\\\":[59,158,158],\\\"ru\\\":[36,143,143],\\\"rh\\\":[10,125,140],\\\"pd\\\":[0,105,133],\\\"ag\\\":[192,192,192],\\\"cd\\\":[255,217,143],\\\"in\\\":[166,117,115],\\\"sn\\\":[102,128,128],\\\"sb\\\":[158,99,181],\\\"te\\\":[212,122,0],\\\"i\\\":[148,0,148],\\\"xe\\\":[66,158,176],\\\"cs\\\":[87,23,143],\\\"ba\\\":[0,201,0],\\\"la\\\":[112,212,255],\\\"ce\\\":[255,255,199],\\\"pr\\\":[217,255,199],\\\"nd\\\":[199,255,199],\\\"pm\\\":[163,255,199],\\\"sm\\\":[143,255,199],\\\"eu\\\":[97,255,199],\\\"gd\\\":[69,255,199],\\\"tb\\\":[48,255,199],\\\"dy\\\":[31,255,199],\\\"ho\\\":[0,255,156],\\\"er\\\":[0,230,117],\\\"tm\\\":[0,212,82],\\\"yb\\\":[0,191,56],\\\"lu\\\":[0,171,36],\\\"hf\\\":[77,194,255],\\\"ta\\\":[77,166,255],\\\"w\\\":[33,148,214],\\\"re\\\":[38,125,171],\\\"os\\\":[38,102,150],\\\"ir\\\":[23,84,135],\\\"pt\\\":[208,208,224],\\\"au\\\":[255,209,35],\\\"hg\\\":[184,184,208],\\\"tl\\\":[166,84,77],\\\"pb\\\":[87,89,97],\\\"bi\\\":[158,79,181],\\\"po\\\":[171,92,0],\\\"at\\\":[117,79,69],\\\"rn\\\":[66,130,150],\\\"fr\\\":[66,0,102],\\\"ra\\\":[0,125,0],\\\"ac\\\":[112,171,250],\\\"th\\\":[0,186,255],\\\"pa\\\":[0,161,255],\\\"u\\\":[0,143,255],\\\"np\\\":[0,128,255],\\\"pu\\\":[0,107,255],\\\"am\\\":[84,92,242],\\\"cm\\\":[120,92,227],\\\"bk\\\":[138,79,227],\\\"cf\\\":[161,54,212],\\\"es\\\":[179,31,212],\\\"fm\\\":[179,31,186],\\\"md\\\":[179,13,166],\\\"no\\\":[189,13,135],\\\"lr\\\":[199,0,102],\\\"rf\\\":[204,0,89],\\\"db\\\":[209,0,79],\\\"sg\\\":[217,0,69],\\\"bh\\\":[224,0,56],\\\"hs\\\":[230,0,46],\\\"mt\\\":[235,0,38],\\n\\t\\t\\t   \\\"ds\\\":[235,0,38],\\\"rg\\\":[235,0,38],\\\"cn\\\":[235,0,38],\\\"uut\\\":[235,0,38],\\\"uuq\\\":[235,0,38],\\\"uup\\\":[235,0,38],\\\"uuh\\\":[235,0,38],\\\"uus\\\":[235,0,38],\\\"uuo\\\":[235,0,38]};\\n\\n\\n\\t\\tvar atoms = [];\\n\\t\\tvar bonds = [];\\n\\t\\tvar histogram = {};\\n\\n\\t\\tvar bhash = {};\\n\\n\\t\\tvar lines = text.split( \\\"\\\\n\\\" );\\n\\n\\t\\tvar x, y, z, e;\\n\\n\\t\\tfor( var i = 0, il = lines.length; i < il; ++ i ) {\\n\\n\\t\\t\\tif( lines[i].substr(0,4)==\\\"ATOM\\\" || lines[i].substr(0,6)==\\\"HETATM\\\" ) {\\n\\n\\t\\t\\t\\tx = parseFloat( lines[i].substr(30,7) );\\n\\t\\t\\t\\ty = parseFloat( lines[i].substr(38,7) );\\n\\t\\t\\t\\tz = parseFloat( lines[i].substr(46,7) );\\n\\n\\t\\t\\t\\te = trim( lines[i].substr(76,2) ).toLowerCase();\\n\\n\\t\\t\\t\\tif ( e==\\\"\\\" ) e = trim(lines[i].substr(12,2)).toLowerCase();\\n\\t\\t\\t\\tatoms.push( [ x,y,z, CPK[e], capitalize(e) ] );\\n\\n\\t\\t\\t\\tif (histogram[e]==undefined) histogram[e] = 1;\\n\\t\\t\\t\\telse histogram[e] += 1;\\n\\n\\t\\t\\t} else if(lines[i].substr(0,6)==\\\"CONECT\\\") {\\n\\n\\t\\t\\t\\tvar satom = parseInt( lines[i].substr(6,5) );\\n\\n\\t\\t\\t\\tparseBond(11,5);\\n\\t\\t\\t\\tparseBond(16,5);\\n\\t\\t\\t\\tparseBond(21,5);\\n\\t\\t\\t\\tparseBond(26,5);\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn { \\\"ok\\\": true, \\\"atoms\\\": atoms, \\\"bonds\\\": bonds, \\\"histogram\\\": histogram };\\n\\n\\t},\\n\\n\\tcreateModel: function ( json, callback ) {\\n\\n\\t\\tvar scope = this,\\n\\t\\tgeometryAtoms = new THREE.Geometry(),\\n\\t\\tgeometryBonds = new THREE.Geometry();\\n\\n\\t\\tgeometryAtoms.elements = [];\\n\\n\\t\\tvar atoms = json.atoms;\\n\\t\\tvar bonds = json.bonds;\\n\\n\\t\\tfor ( var i = 0; i < atoms.length; i ++ ) {\\n\\n\\t\\t\\tvar atom = atoms[ i ];\\n\\n\\t\\t\\tvar x = atom[ 0 ];\\n\\t\\t\\tvar y = atom[ 1 ];\\n\\t\\t\\tvar z = atom[ 2 ];\\n\\n\\t\\t\\tvar position = new THREE.Vector3( x, y, z );\\n\\t\\t\\tgeometryAtoms.vertices.push( position );\\n\\n\\t\\t\\tvar r = atom[ 3 ][ 0 ] / 255;\\n\\t\\t\\tvar g = atom[ 3 ][ 1 ] / 255;\\n\\t\\t\\tvar b = atom[ 3 ][ 2 ] / 255;\\n\\n\\t\\t\\tvar color = new THREE.Color();\\n\\t\\t\\tcolor.setRGB( r, g, b );\\n\\n\\t\\t\\tgeometryAtoms.colors.push( color );\\n\\n\\t\\t\\tgeometryAtoms.elements.push( atom[ 4 ] );\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0; i < bonds.length; i ++ ) {\\n\\n\\t\\t\\tvar bond = bonds[ i ];\\n\\n\\t\\t\\tvar start = bond[ 0 ];\\n\\t\\t\\tvar end = bond[ 1 ];\\n\\n\\t\\t\\tvar vertex1 = geometryAtoms.vertices[ start ];\\n\\t\\t\\tvar vertex2 = geometryAtoms.vertices[ end ];\\n\\n\\t\\t\\tgeometryBonds.vertices.push( vertex1.clone() );\\n\\t\\t\\tgeometryBonds.vertices.push( vertex2.clone() );\\n\\n\\t\\t}\\n\\n\\t\\tcallback( geometryAtoms, geometryBonds, json );\\n\\n\\t}\\n\\n}\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/PLYLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/PLYLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author Wei Meng / http://about.me/menway\\n *\\n * Description: A THREE loader for PLY ASCII files (known as the Polygon File Format or the Stanford Triangle Format).\\n *\\n * Currently only supports ASCII encoded files.\\n *\\n * Limitations: ASCII decoding assumes file is UTF-8.\\n *\\n * Usage:\\n *\\tvar loader = new THREE.PLYLoader();\\n *\\tloader.addEventListener( 'load', function ( event ) {\\n *\\n *\\t\\tvar geometry = event.content;\\n *\\t\\tscene.add( new THREE.Mesh( geometry ) );\\n *\\n *\\t} );\\n *\\tloader.load( './models/ply/ascii/dolphins.ply' );\\n */\\n\\n\\nTHREE.PLYLoader = function () {};\\n\\nTHREE.PLYLoader.prototype = {\\n\\n\\tconstructor: THREE.PLYLoader,\\n\\n\\tload: function ( url, callback ) {\\n          var func = \\\"THREE.PLYLoader.load\\\";\\n\\n          if (TiddlyWiki && url.match(/^tw:/)) {\\n            var res = TiddlyWiki.load(url);\\n            //hack.log(\\\"res.length = \\\"+res.length, hack.loader, func);\\n\\t    var geometry = this.parse(res);\\n\\t    this.dispatchEvent({type: 'load', content: geometry});\\n\\t    if (callback) callback(geometry);\\n            hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n\\t    return;\\n          }\\n\\n\\t\\tvar scope = this;\\n\\t\\tvar request = new XMLHttpRequest();\\n\\n\\t\\trequest.addEventListener( 'load', function ( event ) {\\n\\n\\t\\t\\tvar geometry = scope.parse( event.target.response );\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'load', content: geometry } );\\n\\n\\t\\t\\tif ( callback ) callback( geometry );\\n\\n\\t\\t}, false );\\n\\n\\t\\trequest.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'progress', loaded: event.loaded, total: event.total } );\\n\\n\\t\\t}, false );\\n\\n\\t\\trequest.addEventListener( 'error', function () {\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\\\'t load URL [' + url + ']' } );\\n\\n\\t\\t}, false );\\n\\n\\t\\trequest.open( 'GET', url, true );\\n\\t\\trequest.responseType = \\\"arraybuffer\\\";\\n\\t\\trequest.send( null );\\n\\n\\t},\\n\\n\\tbin2str: function (buf) {\\n\\n\\t\\tvar array_buffer = new Uint8Array(buf);\\n\\t\\tvar str = '';\\n\\t\\tfor(var i = 0; i < buf.byteLength; i++) {\\n\\t\\t\\tstr += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\\n\\t\\t}\\n\\n\\t\\treturn str;\\n\\n\\t},\\n\\n\\tisASCII: function( data ){\\n\\n\\t\\tvar header = this.parseHeader( this.bin2str( data ) );\\n\\t\\t\\n\\t\\treturn header.format === \\\"ascii\\\";\\n\\n\\t},\\n\\n\\tparse: function ( data ) {\\n\\n\\t\\tif ( data instanceof ArrayBuffer ) {\\n\\n\\t\\t\\treturn this.isASCII( data )\\n\\t\\t\\t\\t? this.parseASCII( this.bin2str( data ) )\\n\\t\\t\\t\\t: this.parseBinary( data );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn this.parseASCII( data );\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tparseHeader: function ( data ) {\\n\\t\\t\\n\\t\\tvar patternHeader = /ply([\\\\s\\\\S]*)end_header\\\\n/;\\n\\t\\tvar headerText = \\\"\\\";\\n\\t\\tif ( ( result = patternHeader.exec( data ) ) != null ) {\\n\\t\\t\\theaderText = result [ 1 ];\\n\\t\\t}\\n\\t\\t\\n\\t\\tvar header = new Object();\\n\\t\\theader.comments = [];\\n\\t\\theader.elements = [];\\n\\t\\theader.headerLength = result[0].length;\\n\\t\\t\\n\\t\\tvar lines = headerText.split( '\\\\n' );\\n\\t\\tvar currentElement = undefined;\\n\\t\\tvar lineType, lineValues;\\n\\n\\t\\tfunction make_ply_element_property(propertValues) {\\n\\t\\t\\t\\n\\t\\t\\tvar property = Object();\\n\\n\\t\\t\\tproperty.type = propertValues[0]\\n\\t\\t\\t\\n\\t\\t\\tif ( property.type === \\\"list\\\" ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tproperty.name = propertValues[3]\\n\\t\\t\\t\\tproperty.countType = propertValues[1]\\n\\t\\t\\t\\tproperty.itemType = propertValues[2]\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tproperty.name = propertValues[1]\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn property\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor ( var i = 0; i < lines.length; i ++ ) {\\n\\n\\t\\t\\tvar line = lines[ i ];\\n\\t\\t\\tline = line.trim()\\n\\t\\t\\tif ( line === \\\"\\\" ) { continue; }\\n\\t\\t\\tlineValues = line.split( /\\\\s+/ );\\n\\t\\t\\tlineType = lineValues.shift()\\n\\t\\t\\tline = lineValues.join(\\\" \\\")\\n\\t\\t\\t\\n\\t\\t\\tswitch( lineType ) {\\n\\t\\t\\t\\t\\n\\t\\t\\tcase \\\"format\\\":\\n\\n\\t\\t\\t\\theader.format = lineValues[0];\\n\\t\\t\\t\\theader.version = lineValues[1];\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\\"comment\\\":\\n\\n\\t\\t\\t\\theader.comments.push(line);\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\\"element\\\":\\n\\n\\t\\t\\t\\tif ( !(currentElement === undefined) ) {\\n\\n\\t\\t\\t\\t\\theader.elements.push(currentElement);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrentElement = Object();\\n\\t\\t\\t\\tcurrentElement.name = lineValues[0];\\n\\t\\t\\t\\tcurrentElement.count = parseInt( lineValues[1] );\\n\\t\\t\\t\\tcurrentElement.properties = [];\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\n\\t\\t\\tcase \\\"property\\\":\\n\\n\\t\\t\\t\\tcurrentElement.properties.push( make_ply_element_property( lineValues ) );\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tconsole.log(\\\"unhandled\\\", lineType, lineValues);\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\tif ( !(currentElement === undefined) ) {\\n\\n\\t\\t\\theader.elements.push(currentElement);\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn header;\\n\\t\\t\\n\\t},\\n\\n\\tparseASCIINumber: function ( n, type ) {\\n\\t\\t\\n\\t\\tswitch( type ) {\\n\\t\\t\\t\\n\\t\\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\\n\\t\\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\\n\\n\\t\\t\\treturn parseInt( n );\\n\\n\\t\\tcase 'float': case 'double': case 'float32': case 'float64':\\n\\n\\t\\t\\treturn parseFloat( n );\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t},\\n\\n\\tparseASCIIElement: function ( properties, line ) {\\n\\n\\t\\tvalues = line.split( /\\\\s+/ );\\n\\t\\t\\n\\t\\tvar element = Object();\\n\\t\\t\\n\\t\\tfor ( var i = 0; i < properties.length; i ++ ) {\\n\\t\\t\\t\\n\\t\\t\\tif ( properties[i].type === \\\"list\\\" ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvar list = [];\\n\\t\\t\\t\\tvar n = this.parseASCIINumber( values.shift(), properties[i].countType );\\n\\n\\t\\t\\t\\tfor ( j = 0; j < n; j ++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tlist.push( this.parseASCIINumber( values.shift(), properties[i].itemType ) );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telement[ properties[i].name ] = list;\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telement[ properties[i].name ] = this.parseASCIINumber( values.shift(), properties[i].type );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn element;\\n\\t\\t\\n\\t},\\n\\n\\tparseASCII: function ( data ) {\\n\\n\\t\\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\\n\\n\\t\\tvar geometry = new THREE.Geometry();\\n\\n\\t\\tvar result;\\n\\n\\t\\tvar header = this.parseHeader( data );\\n\\n\\t\\tvar patternBody = /end_header\\\\n([\\\\s\\\\S]*)$/;\\n\\t\\tvar body = \\\"\\\";\\n\\t\\tif ( ( result = patternBody.exec( data ) ) != null ) {\\n\\t\\t\\tbody = result [ 1 ];\\n\\t\\t}\\n\\t\\t\\n\\t\\tvar lines = body.split( '\\\\n' );\\n\\t\\tvar currentElement = 0;\\n\\t\\tvar currentElementCount = 0;\\n\\t\\tgeometry.useColor = false;\\n\\t\\t\\n\\t\\tfor ( var i = 0; i < lines.length; i ++ ) {\\n\\n\\t\\t\\tvar line = lines[ i ];\\n\\t\\t\\tline = line.trim()\\n\\t\\t\\tif ( line === \\\"\\\" ) { continue; }\\n\\t\\t\\t\\n\\t\\t\\tif ( currentElementCount >= header.elements[currentElement].count ) {\\n\\n\\t\\t\\t\\tcurrentElement++;\\n\\t\\t\\t\\tcurrentElementCount = 0;\\n\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tvar element = this.parseASCIIElement( header.elements[currentElement].properties, line );\\n\\t\\t\\t\\n\\t\\t\\tthis.handleElement( geometry, header.elements[currentElement].name, element );\\n\\t\\t\\t\\n\\t\\t\\tcurrentElementCount++;\\n\\t\\t\\t\\n\\t\\t}\\n\\n\\t\\treturn this.postProcess( geometry );\\n\\n\\t},\\n\\n\\tpostProcess: function ( geometry ) {\\n\\t\\t\\n\\t\\tif ( geometry.useColor ) {\\n\\t\\t\\t\\n\\t\\t\\tfor ( var i = 0; i < geometry.faces.length; i ++ ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tgeometry.faces[i].vertexColors = [\\n\\t\\t\\t\\t\\tgeometry.colors[geometry.faces[i].a],\\n\\t\\t\\t\\t\\tgeometry.colors[geometry.faces[i].b],\\n\\t\\t\\t\\t\\tgeometry.colors[geometry.faces[i].c]\\n\\t\\t\\t\\t];\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tgeometry.elementsNeedUpdate = true;\\n\\t\\t\\t\\n\\t\\t}\\n\\n\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\treturn geometry;\\n\\t\\t\\n\\t},\\n\\n\\thandleElement: function ( geometry, elementName, element ) {\\n\\t\\t\\n\\t\\tif ( elementName === \\\"vertex\\\" ) {\\n\\n\\t\\t\\tgeometry.vertices.push(\\n\\t\\t\\t\\tnew THREE.Vector3( element.x, element.y, element.z )\\n\\t\\t\\t);\\n\\t\\t\\t\\n\\t\\t\\tif ( 'red' in element && 'green' in element && 'blue' in element ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tgeometry.useColor = true;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcolor = new THREE.Color();\\n\\t\\t\\t\\tcolor.setRGB( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\\n\\t\\t\\t\\tgeometry.colors.push( color );\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\n\\t\\t} else if ( elementName === \\\"face\\\" ) {\\n\\n\\t\\t\\tgeometry.faces.push(\\n\\t\\t\\t\\tnew THREE.Face3( element.vertex_indices[0], element.vertex_indices[1], element.vertex_indices[2] )\\n\\t\\t\\t);\\n\\n\\t\\t}\\n\\t\\t\\n\\t},\\n\\n\\tbinaryRead: function ( dataview, at, type, little_endian ) {\\n\\n\\t\\tswitch( type ) {\\n\\n\\t\\t\\t// corespondences for non-specific length types here match rply:\\n\\t\\tcase 'int8':\\t\\tcase 'char':\\t return [ dataview.getInt8( at ), 1 ];\\n\\n\\t\\tcase 'uint8':\\t\\tcase 'uchar':\\t return [ dataview.getUint8( at ), 1 ];\\n\\n\\t\\tcase 'int16':\\t\\tcase 'short':\\t return [ dataview.getInt16( at, little_endian ), 2 ];\\n\\n\\t\\tcase 'uint16':\\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\\n\\n\\t\\tcase 'int32':\\t\\tcase 'int':\\t\\t return [ dataview.getInt32( at, little_endian ), 4 ];\\n\\n\\t\\tcase 'uint32':\\tcase 'uint':\\t return [ dataview.getUint32( at, little_endian ), 4 ];\\n\\n\\t\\tcase 'float32': case 'float':\\t return [ dataview.getFloat32( at, little_endian ), 4 ];\\n\\n\\t\\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t},\\n\\n\\tbinaryReadElement: function ( dataview, at, properties, little_endian ) {\\n\\t\\t\\n\\t\\tvar element = Object();\\n\\t\\tvar result, read = 0;\\n\\t\\t\\n\\t\\tfor ( var i = 0; i < properties.length; i ++ ) {\\n\\t\\t \\n\\t\\t\\tif ( properties[i].type === \\\"list\\\" ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvar list = [];\\n\\n\\t\\t\\t\\tresult = this.binaryRead( dataview, at+read, properties[i].countType, little_endian );\\n\\t\\t\\t\\tvar n = result[0];\\n\\t\\t\\t\\tread += result[1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor ( j = 0; j < n; j ++ ) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tresult = this.binaryRead( dataview, at+read, properties[i].itemType, little_endian );\\n\\t\\t\\t\\t\\tlist.push( result[0] );\\n\\t\\t\\t\\t\\tread += result[1];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telement[ properties[i].name ] = list;\\n\\t\\t\\t\\t\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tresult = this.binaryRead( dataview, at+read, properties[i].type, little_endian );\\n\\t\\t\\t\\telement[ properties[i].name ] = result[0];\\n\\t\\t\\t\\tread += result[1];\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn [ element, read ];\\n\\t\\t\\n\\t},\\n\\n\\tparseBinary: function ( data ) {\\n\\n\\t\\tvar geometry = new THREE.Geometry();\\n\\n\\t\\tvar header = this.parseHeader( this.bin2str( data ) );\\n\\t\\tvar little_endian = (header.format === \\\"binary_little_endian\\\");\\n\\t\\tvar body = new DataView( data, header.headerLength );\\n\\t\\tvar result, loc = 0;\\n\\n\\t\\tfor ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\\n\\t\\t\\t\\n\\t\\t\\tfor ( var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount ++ ) {\\n\\t\\t\\t\\n\\t\\t\\t\\tresult = this.binaryReadElement( body, loc, header.elements[currentElement].properties, little_endian );\\n\\t\\t\\t\\tloc += result[1];\\n\\t\\t\\t\\tvar element = result[0];\\n\\t\\t\\t\\n\\t\\t\\t\\tthis.handleElement( geometry, header.elements[currentElement].name, element );\\n\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn this.postProcess( geometry );\\n\\t\\t\\n\\t}\\n\\n};\\n\\nTHREE.EventDispatcher.prototype.apply( THREE.PLYLoader.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/SceneLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/SceneLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.SceneLoader = function () {\\n\\n\\tthis.onLoadStart = function () {};\\n\\tthis.onLoadProgress = function() {};\\n\\tthis.onLoadComplete = function () {};\\n\\n\\tthis.callbackSync = function () {};\\n\\tthis.callbackProgress = function () {};\\n\\n\\tthis.geometryHandlers = {};\\n\\tthis.hierarchyHandlers = {};\\n\\n\\tthis.addGeometryHandler( \\\"ascii\\\", THREE.JSONLoader );\\n\\n};\\n\\nTHREE.SceneLoader.prototype = {\\n\\n\\tconstructor: THREE.SceneLoader,\\n\\n\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar loader = new THREE.XHRLoader( scope.manager );\\n\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\tscope.parse( JSON.parse( text ), onLoad, url );\\n\\n\\t\\t} );\\n\\n\\t},\\n\\n\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\tthis.crossOrigin = value;\\n\\n\\t},\\n\\n\\taddGeometryHandler: function ( typeID, loaderClass ) {\\n\\n\\t\\tthis.geometryHandlers[ typeID ] = { \\\"loaderClass\\\": loaderClass };\\n\\n\\t},\\n\\n\\taddHierarchyHandler: function ( typeID, loaderClass ) {\\n\\n\\t\\tthis.hierarchyHandlers[ typeID ] = { \\\"loaderClass\\\": loaderClass };\\n\\n\\t},\\n\\n\\tparse: function ( json, callbackFinished, url ) {\\n          var func = \\\"THREE.SceneLoader.parse\\\";\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar urlBase = THREE.Loader.prototype.extractUrlBase( url );\\n\\n\\t\\tvar geometry, material, camera, fog,\\n\\t\\t\\ttexture, images, color,\\n\\t\\t\\tlight, hex, intensity,\\n\\t\\t\\tcounter_models, counter_textures,\\n\\t\\t\\ttotal_models, total_textures,\\n\\t\\t\\tresult;\\n\\n\\t\\tvar target_array = [];\\n\\n\\t\\tvar data = json;\\n\\n\\t\\t// async geometry loaders\\n\\n\\t\\tfor ( var typeID in this.geometryHandlers ) {\\n\\n\\t\\t\\tvar loaderClass = this.geometryHandlers[ typeID ][ \\\"loaderClass\\\" ];\\n\\t\\t\\tthis.geometryHandlers[ typeID ][ \\\"loaderObject\\\" ] = new loaderClass();\\n\\n\\t\\t}\\n\\n\\t\\t// async hierachy loaders\\n\\n\\t\\tfor ( var typeID in this.hierarchyHandlers ) {\\n\\n\\t\\t\\tvar loaderClass = this.hierarchyHandlers[ typeID ][ \\\"loaderClass\\\" ];\\n\\t\\t\\tthis.hierarchyHandlers[ typeID ][ \\\"loaderObject\\\" ] = new loaderClass();\\n\\n\\t\\t}\\n\\n\\t\\tcounter_models = 0;\\n\\t\\tcounter_textures = 0;\\n\\n\\t\\tresult = {\\n\\n\\t\\t\\tscene: new THREE.Scene(),\\n\\t\\t\\tgeometries: {},\\n\\t\\t\\tface_materials: {},\\n\\t\\t\\tmaterials: {},\\n\\t\\t\\ttextures: {},\\n\\t\\t\\tobjects: {},\\n\\t\\t\\tcameras: {},\\n\\t\\t\\tlights: {},\\n\\t\\t\\tfogs: {},\\n\\t\\t\\tempties: {},\\n\\t\\t\\tgroups: {}\\n\\n\\t\\t};\\n\\n\\t\\tif ( data.transform ) {\\n\\n\\t\\t\\tvar position = data.transform.position,\\n\\t\\t\\t\\trotation = data.transform.rotation,\\n\\t\\t\\t\\tscale = data.transform.scale;\\n\\n\\t\\t\\tif ( position ) {\\n\\n\\t\\t\\t\\tresult.scene.position.fromArray( position );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( rotation ) {\\n\\n\\t\\t\\t\\tresult.scene.rotation.fromArray( rotation );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( scale ) {\\n\\n\\t\\t\\t\\tresult.scene.scale.fromArray( scale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( position || rotation || scale ) {\\n\\n\\t\\t\\t\\tresult.scene.updateMatrix();\\n\\t\\t\\t\\tresult.scene.updateMatrixWorld();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction get_url( source_url, url_type ) {\\n\\n\\t\\t\\tif ( url_type == \\\"relativeToHTML\\\" ) {\\n\\n\\t\\t\\t\\treturn source_url;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn urlBase + source_url;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\t// toplevel loader function, delegates to handle_children\\n\\n\\t\\tfunction handle_objects() {\\n                  var func = \\\"THREE.SceneLoader.parse.handle_objects\\\";\\n\\n\\t\\t\\thandle_children( result.scene, data.objects );\\n\\n\\t\\t}\\n\\n\\t\\t// handle all the children from the loaded json and attach them to given parent\\n\\n\\t\\tfunction handle_children( parent, children ) {\\n                  var func = \\\"THREE.SceneLoader.parse.handle_children\\\";\\n                  hack.log(\\\"\\\", hack.sceneLoader, func);\\n\\n\\t\\t\\tvar mat, dst, pos, rot, scl, quat;\\n\\n\\t\\t\\tfor ( var objID in children ) {\\n\\n\\t\\t\\t\\t// check by id if child has already been handled,\\n\\t\\t\\t\\t// if not, create new object\\n\\n\\t\\t\\t\\tvar object = result.objects[ objID ];\\n\\t\\t\\t\\tvar objJSON = children[ objID ];\\n\\n                          hack.log(\\\"objID = <\\\"+objID+\\\">, object = \\\"+object, hack.sceneLoader, func);\\n                          hack.log(\\\"  geometry = \\\"+objJSON.geometry, hack.sceneLoader, func);\\n                          hack.log(\\\"  material = \\\"+objJSON.material, hack.sceneLoader, func);\\n\\n\\t\\t\\t\\tif ( object === undefined ) {\\n\\n\\t\\t\\t\\t\\t// meshes\\n\\n\\t\\t\\t\\t\\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( objJSON.loading === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar reservedTypes = {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\\"type\\\": 1, \\\"url\\\": 1, \\\"material\\\": 1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\\"position\\\": 1, \\\"rotation\\\": 1, \\\"scale\\\" : 1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\\"visible\\\": 1, \\\"children\\\": 1, \\\"userData\\\": 1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\\"skin\\\": 1, \\\"morph\\\": 1, \\\"mirroredLoop\\\": 1, \\\"duration\\\": 1\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t\\tvar loaderParameters = {};\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var parType in objJSON ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( ! ( parType in reservedTypes ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tloaderParameters[ parType ] = objJSON[ parType ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tmaterial = result.materials[ objJSON.material ];\\n\\n\\t\\t\\t\\t\\t\\t\\tobjJSON.loading = true;\\n\\n\\t\\t\\t\\t\\t\\t\\tvar loader = scope.hierarchyHandlers[ objJSON.type ][ \\\"loaderObject\\\" ];\\n\\n\\t\\t\\t\\t\\t\\t\\t// ColladaLoader\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( loader.options ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );\\n\\n\\t\\t\\t\\t\\t\\t\\t// UTF8Loader\\n\\t\\t\\t\\t\\t\\t\\t// OBJLoader\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( objJSON.geometry !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tgeometry = result.geometries[ objJSON.geometry ];\\n\\n\\t\\t\\t\\t\\t\\t// geometry already loaded\\n\\n\\t\\t\\t\\t\\t\\tif ( geometry ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar needsTangents = false;\\n\\n\\t\\t\\t\\t\\t\\t\\tmaterial = result.materials[ objJSON.material ];\\n\\t\\t\\t\\t\\t\\t\\tneedsTangents = material instanceof THREE.ShaderMaterial;\\n\\n\\t\\t\\t\\t\\t\\t\\tpos = objJSON.position;\\n\\t\\t\\t\\t\\t\\t\\trot = objJSON.rotation;\\n\\t\\t\\t\\t\\t\\t\\tscl = objJSON.scale;\\n\\t\\t\\t\\t\\t\\t\\tmat = objJSON.matrix;\\n\\t\\t\\t\\t\\t\\t\\tquat = objJSON.quaternion;\\n\\n\\t\\t\\t\\t\\t\\t\\t// use materials from the model file\\n\\t\\t\\t\\t\\t\\t\\t// if there is no material specified in the object\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( ! objJSON.material ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// use materials from the model file\\n\\t\\t\\t\\t\\t\\t\\t// if there is just empty face material\\n\\t\\t\\t\\t\\t\\t\\t// (must create new material as each model has its own face material)\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( material instanceof THREE.MeshFaceMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < material.materials.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tneedsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( needsTangents ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.computeTangents();\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( objJSON.skin ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject = new THREE.SkinnedMesh( geometry, material );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else if ( objJSON.morph ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject = new THREE.MorphAnimMesh( geometry, material );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( objJSON.duration !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tobject.duration = objJSON.duration;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( objJSON.time !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tobject.time = objJSON.time;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( objJSON.mirroredLoop !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tobject.mirroredLoop = objJSON.mirroredLoop;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( material.morphNormals ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.computeMorphNormals();\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject = new THREE.Mesh( geometry, material );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tobject.name = objID;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( mat ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.matrixAutoUpdate = false;\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.matrix.set(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmat[0],  mat[1],  mat[2],  mat[3],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmat[4],  mat[5],  mat[6],  mat[7],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmat[8],  mat[9],  mat[10], mat[11],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmat[12], mat[13], mat[14], mat[15]\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.position.fromArray( pos );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( quat ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tobject.quaternion.fromArray( quat );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tobject.rotation.fromArray( rot );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.scale.fromArray( scl );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tobject.visible = objJSON.visible;\\n\\t\\t\\t\\t\\t\\t\\tobject.castShadow = objJSON.castShadow;\\n\\t\\t\\t\\t\\t\\t\\tobject.receiveShadow = objJSON.receiveShadow;\\n\\n\\t\\t\\t\\t\\t\\t\\tparent.add( object );\\n\\n\\t\\t\\t\\t\\t\\t\\tresult.objects[ objID ] = object;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// lights\\n\\n\\t\\t\\t\\t\\t} else if ( objJSON.type === \\\"AmbientLight\\\" || objJSON.type === \\\"PointLight\\\" ||\\n\\t\\t\\t\\t\\t\\tobjJSON.type === \\\"DirectionalLight\\\" || objJSON.type === \\\"SpotLight\\\" ||\\n\\t\\t\\t\\t\\t\\tobjJSON.type === \\\"HemisphereLight\\\" || objJSON.type === \\\"AreaLight\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\tvar color = objJSON.color;\\n\\t\\t\\t\\t\\t\\tvar intensity = objJSON.intensity;\\n\\t\\t\\t\\t\\t\\tvar distance = objJSON.distance;\\n\\t\\t\\t\\t\\t\\tvar position = objJSON.position;\\n\\t\\t\\t\\t\\t\\tvar rotation = objJSON.rotation;\\n\\n\\t\\t\\t\\t\\t\\tswitch ( objJSON.type ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'AmbientLight':\\n\\t\\t\\t\\t\\t\\t\\t\\tlight = new THREE.AmbientLight( color );\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'PointLight':\\n\\t\\t\\t\\t\\t\\t\\t\\tlight = new THREE.PointLight( color, intensity, distance );\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.position.fromArray( position );\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'DirectionalLight':\\n\\t\\t\\t\\t\\t\\t\\t\\tlight = new THREE.DirectionalLight( color, intensity );\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.position.fromArray( objJSON.direction );\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'SpotLight':\\n\\t\\t\\t\\t\\t\\t\\t\\tlight = new THREE.SpotLight( color, intensity, distance, 1 );\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.angle = objJSON.angle;\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.position.fromArray( position );\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'HemisphereLight':\\n\\t\\t\\t\\t\\t\\t\\t\\tlight = new THREE.DirectionalLight( color, intensity, distance );\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'AreaLight':\\n\\t\\t\\t\\t\\t\\t\\t\\tlight = new THREE.AreaLight(color, intensity);\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.position.fromArray( position );\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.width = objJSON.size;\\n\\t\\t\\t\\t\\t\\t\\t\\tlight.height = objJSON.size_y;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tparent.add( light );\\n\\n\\t\\t\\t\\t\\t\\tlight.name = objID;\\n\\t\\t\\t\\t\\t\\tresult.lights[ objID ] = light;\\n\\t\\t\\t\\t\\t\\tresult.objects[ objID ] = light;\\n\\n\\t\\t\\t\\t\\t// cameras\\n\\n\\t\\t\\t\\t\\t} else if ( objJSON.type === \\\"PerspectiveCamera\\\" || objJSON.type === \\\"OrthographicCamera\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\tpos = objJSON.position;\\n\\t\\t\\t\\t\\t\\trot = objJSON.rotation;\\n\\t\\t\\t\\t\\t\\tquat = objJSON.quaternion;\\n\\n\\t\\t\\t\\t\\t\\tif ( objJSON.type === \\\"PerspectiveCamera\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcamera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );\\n\\n\\t\\t\\t\\t\\t\\t} else if ( objJSON.type === \\\"OrthographicCamera\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcamera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tcamera.name = objID;\\n\\t\\t\\t\\t\\t\\tcamera.position.fromArray( pos );\\n\\n\\t\\t\\t\\t\\t\\tif ( quat !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcamera.quaternion.fromArray( quat );\\n\\n\\t\\t\\t\\t\\t\\t} else if ( rot !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcamera.rotation.fromArray( rot );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tparent.add( camera );\\n\\n\\t\\t\\t\\t\\t\\tresult.cameras[ objID ] = camera;\\n\\t\\t\\t\\t\\t\\tresult.objects[ objID ] = camera;\\n\\n\\t\\t\\t\\t\\t// pure Object3D\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tpos = objJSON.position;\\n\\t\\t\\t\\t\\t\\trot = objJSON.rotation;\\n\\t\\t\\t\\t\\t\\tscl = objJSON.scale;\\n\\t\\t\\t\\t\\t\\tquat = objJSON.quaternion;\\n\\n\\t\\t\\t\\t\\t\\tobject = new THREE.Object3D();\\n\\t\\t\\t\\t\\t\\tobject.name = objID;\\n\\t\\t\\t\\t\\t\\tobject.position.fromArray( pos );\\n\\n\\t\\t\\t\\t\\t\\tif ( quat ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject.quaternion.fromArray( quat );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject.rotation.fromArray( rot );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tobject.scale.fromArray( scl );\\n\\t\\t\\t\\t\\t\\tobject.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;\\n\\n\\t\\t\\t\\t\\t\\tparent.add( object );\\n\\n\\t\\t\\t\\t\\t\\tresult.objects[ objID ] = object;\\n\\t\\t\\t\\t\\t\\tresult.empties[ objID ] = object;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( object ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( objJSON.userData !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var key in objJSON.userData ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar value = objJSON.userData[ key ];\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.userData[ key ] = value;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( objJSON.groups !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < objJSON.groups.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar groupID = objJSON.groups[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( result.groups[ groupID ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tresult.groups[ groupID ] = [];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tresult.groups[ groupID ].push( objID );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( object !== undefined && objJSON.children !== undefined ) {\\n\\n\\t\\t\\t\\t\\thandle_children( object, objJSON.children );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction handle_mesh( geo, mat, id ) {\\n                  var func = \\\"THREE.SceneLoader.parse.handle_mesh\\\";\\n                  hack.log(\\\"id = \\\"+id+\\\", mat = \\\"+mat, hack.sceneLoader, func);\\n\\n\\t\\t\\tresult.geometries[ id ] = geo;\\n\\t\\t        result.face_materials[ id ] = mat;\\n\\t\\t\\thandle_objects();\\n\\n\\t\\t};\\n\\n\\t\\tfunction handle_hierarchy( node, id, parent, material, obj ) {\\n\\n\\t\\t\\tvar p = obj.position;\\n\\t\\t\\tvar r = obj.rotation;\\n\\t\\t\\tvar q = obj.quaternion;\\n\\t\\t\\tvar s = obj.scale;\\n\\n\\t\\t\\tnode.position.fromArray( p );\\n\\n\\t\\t\\tif ( q ) {\\n\\n\\t\\t\\t\\tnode.quaternion.fromArray( q );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tnode.rotation.fromArray( r );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tnode.scale.fromArray( s );\\n\\n\\t\\t\\t// override children materials\\n\\t\\t\\t// if object material was specified in JSON explicitly\\n\\n\\t\\t\\tif ( material ) {\\n\\n\\t\\t\\t\\tnode.traverse( function ( child ) {\\n\\n\\t\\t\\t\\t\\tchild.material = material;\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// override children visibility\\n\\t\\t\\t// with root node visibility as specified in JSON\\n\\n\\t\\t\\tvar visible = ( obj.visible !== undefined ) ? obj.visible : true;\\n\\n\\t\\t\\tnode.traverse( function ( child ) {\\n\\n\\t\\t\\t\\tchild.visible = visible;\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\tparent.add( node );\\n\\n\\t\\t\\tnode.name = id;\\n\\n\\t\\t\\tresult.objects[ id ] = node;\\n\\t\\t\\thandle_objects();\\n\\n\\t\\t};\\n\\n\\t\\tfunction create_callback_geometry( id ) {\\n\\n\\t\\t\\treturn function ( geo, mat ) {\\n                          var func = \\\"THREE.SceneLoader.parse.create_callback_geometry.function\\\";\\n \\n\\t\\t\\t\\tgeo.name = id;\\n\\n                                handle_mesh( geo, mat, id );\\n\\n\\t\\t\\t\\tcounter_models -= 1;\\n\\n\\t\\t\\t\\tscope.onLoadComplete();\\n\\n\\t\\t\\t\\tasync_callback_gate();\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n          if (TiddlyWiki) {\\n\\t    function create_callback_geometry_for_tiddlywiki_url(id) {\\n\\t      return function (geo, mat) {\\n                var func = \\\"THREE.SceneLoader.parse.create_callback_geometry_for_tiddlywiki_url.function\\\";\\n                hack.log(\\\"id = \\\"+id, hack.sceneLoader, func);\\n\\t\\tgeo.name = id;\\n\\n                // Simply register geometry but don't try to handle all objects because\\n                // it's too early in the load process.\\n                // It seems there is a bug in the load process algorithm. It\\n                // assumes that most of objecs are already loaded when the current geometry\\n                // ends it's loading, because this callback is always called by a\\n                // geometryHandler which loads a remote URL. It's not the case with\\n                // TiddlyWiki URL : loading is immediate !\\n \\t\\tresult.geometries[ id ] = geo;\\n\\t\\tresult.face_materials[ id ] = mat;\\n\\t\\t\\n                counter_models -= 1;\\n\\t\\tscope.onLoadComplete();\\n\\t\\tasync_callback_gate();\\n\\t      }\\n\\t    };\\n          }\\n\\n\\t\\tfunction create_callback_hierachy( id, parent, material, obj ) {\\n\\n\\t\\t\\treturn function ( event ) {\\n\\n\\t\\t\\t\\tvar result;\\n\\n\\t\\t\\t\\t// loaders which use EventDispatcher\\n\\n\\t\\t\\t\\tif ( event.content ) {\\n\\n\\t\\t\\t\\t\\tresult = event.content;\\n\\n\\t\\t\\t\\t// ColladaLoader\\n\\n\\t\\t\\t\\t} else if ( event.dae ) {\\n\\n\\t\\t\\t\\t\\tresult = event.scene;\\n\\n\\n\\t\\t\\t\\t// UTF8Loader\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tresult = event;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\thandle_hierarchy( result, id, parent, material, obj );\\n\\n\\t\\t\\t\\tcounter_models -= 1;\\n\\n\\t\\t\\t\\tscope.onLoadComplete();\\n\\n\\t\\t\\t\\tasync_callback_gate();\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction create_callback_embed( id ) {\\n\\n\\t\\t\\treturn function ( geo, mat ) {\\n\\n\\t\\t\\t\\tgeo.name = id;\\n\\n\\t\\t\\t\\tresult.geometries[ id ] = geo;\\n\\t\\t\\t\\tresult.face_materials[ id ] = mat;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction async_callback_gate() {\\n\\n\\t\\t\\tvar progress = {\\n\\n\\t\\t\\t\\ttotalModels : total_models,\\n\\t\\t\\t\\ttotalTextures : total_textures,\\n\\t\\t\\t\\tloadedModels : total_models - counter_models,\\n\\t\\t\\t\\tloadedTextures : total_textures - counter_textures\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tscope.callbackProgress( progress, result );\\n\\n\\t\\t\\tscope.onLoadProgress();\\n\\n\\t\\t\\tif ( counter_models === 0 && counter_textures === 0 ) {\\n\\n\\t\\t\\t\\tfinalize();\\n\\t\\t\\t\\tcallbackFinished( result );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction finalize() {\\n\\n\\t\\t\\t// take care of targets which could be asynchronously loaded objects\\n\\n\\t\\t\\tfor ( var i = 0; i < target_array.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar ta = target_array[ i ];\\n\\n\\t\\t\\t\\tvar target = result.objects[ ta.targetName ];\\n\\n\\t\\t\\t\\tif ( target ) {\\n\\n\\t\\t\\t\\t\\tta.object.target = target;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// if there was error and target of specified name doesn't exist in the scene file\\n\\t\\t\\t\\t\\t// create instead dummy target\\n\\t\\t\\t\\t\\t// (target must be added to scene explicitly as parent is already added)\\n\\n\\t\\t\\t\\t\\tta.object.target = new THREE.Object3D();\\n\\t\\t\\t\\t\\tresult.scene.add( ta.object.target );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tta.object.target.userData.targetInverse = ta.object;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tvar callbackTexture = function ( count ) {\\n\\n\\t\\t\\tcounter_textures -= count;\\n\\t\\t\\tasync_callback_gate();\\n\\n\\t\\t\\tscope.onLoadComplete();\\n\\n\\t\\t};\\n\\n\\t\\t// must use this instead of just directly calling callbackTexture\\n\\t\\t// because of closure in the calling context loop\\n\\n\\t\\tvar generateTextureCallback = function ( count ) {\\n\\n\\t\\t\\treturn function () {\\n\\n\\t\\t\\t\\tcallbackTexture( count );\\n\\n\\t\\t\\t};\\n\\n\\t\\t};\\n\\n\\t\\tfunction traverse_json_hierarchy( objJSON, callback ) {\\n\\n\\t\\t\\tcallback( objJSON );\\n\\n\\t\\t\\tif ( objJSON.children !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var objChildID in objJSON.children ) {\\n\\n\\t\\t\\t\\t\\ttraverse_json_hierarchy( objJSON.children[ objChildID ], callback );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\t// first go synchronous elements\\n\\n\\t\\t// fogs\\n\\n\\t\\tvar fogID, fogJSON;\\n\\n\\t\\tfor ( fogID in data.fogs ) {\\n\\n\\t\\t\\tfogJSON = data.fogs[ fogID ];\\n\\n\\t\\t\\tif ( fogJSON.type === \\\"linear\\\" ) {\\n\\n\\t\\t\\t\\tfog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );\\n\\n\\t\\t\\t} else if ( fogJSON.type === \\\"exp2\\\" ) {\\n\\n\\t\\t\\t\\tfog = new THREE.FogExp2( 0x000000, fogJSON.density );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcolor = fogJSON.color;\\n\\t\\t\\tfog.color.setRGB( color[0], color[1], color[2] );\\n\\n\\t\\t\\tresult.fogs[ fogID ] = fog;\\n\\n\\t\\t}\\n\\n\\t\\t// now come potentially asynchronous elements\\n\\n\\t\\t// geometries\\n\\n\\t\\t// count how many geometries will be loaded asynchronously\\n\\n\\t\\tvar geoID, geoJSON;\\n\\n\\t\\tfor ( geoID in data.geometries ) {\\n\\n\\t\\t\\tgeoJSON = data.geometries[ geoID ];\\n\\n\\t\\t\\tif ( geoJSON.type in this.geometryHandlers ) {\\n\\n\\t\\t\\t\\tcounter_models += 1;\\n\\n\\t\\t\\t\\tscope.onLoadStart();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// count how many hierarchies will be loaded asynchronously\\n\\n\\t\\tfor ( var objID in data.objects ) {\\n\\n\\t\\t\\ttraverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {\\n\\n\\t\\t\\t\\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {\\n\\n\\t\\t\\t\\t\\tcounter_models += 1;\\n\\n\\t\\t\\t\\t\\tscope.onLoadStart();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t});\\n\\n\\t\\t}\\n\\n\\t\\ttotal_models = counter_models;\\n\\n\\t\\tfor ( geoID in data.geometries ) {\\n\\n\\t\\t\\tgeoJSON = data.geometries[ geoID ];\\n\\n\\t\\t\\tif ( geoJSON.type === \\\"cube\\\" ) {\\n\\n\\t\\t\\t\\tgeometry = new THREE.BoxGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );\\n\\t\\t\\t\\tgeometry.name = geoID;\\n\\t\\t\\t\\tresult.geometries[ geoID ] = geometry;\\n\\n\\t\\t\\t} else if ( geoJSON.type === \\\"plane\\\" ) {\\n\\n\\t\\t\\t\\tgeometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );\\n\\t\\t\\t\\tgeometry.name = geoID;\\n\\t\\t\\t\\tresult.geometries[ geoID ] = geometry;\\n\\n\\t\\t\\t} else if ( geoJSON.type === \\\"sphere\\\" ) {\\n\\n\\t\\t\\t\\tgeometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );\\n\\t\\t\\t\\tgeometry.name = geoID;\\n\\t\\t\\t\\tresult.geometries[ geoID ] = geometry;\\n\\n\\t\\t\\t} else if ( geoJSON.type === \\\"cylinder\\\" ) {\\n\\n\\t\\t\\t\\tgeometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );\\n\\t\\t\\t\\tgeometry.name = geoID;\\n\\t\\t\\t\\tresult.geometries[ geoID ] = geometry;\\n\\n\\t\\t\\t} else if ( geoJSON.type === \\\"torus\\\" ) {\\n\\n\\t\\t\\t\\tgeometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );\\n\\t\\t\\t\\tgeometry.name = geoID;\\n\\t\\t\\t\\tresult.geometries[ geoID ] = geometry;\\n\\n\\t\\t\\t} else if ( geoJSON.type === \\\"icosahedron\\\" ) {\\n\\n\\t\\t\\t\\tgeometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );\\n\\t\\t\\t\\tgeometry.name = geoID;\\n\\t\\t\\t\\tresult.geometries[ geoID ] = geometry;\\n\\n\\t\\t\\t} else if ( geoJSON.type in this.geometryHandlers ) {\\n\\n\\t\\t\\t\\tvar loaderParameters = {};\\n\\n\\t\\t\\t\\tfor ( var parType in geoJSON ) {\\n\\n\\t\\t\\t\\t\\tif ( parType !== \\\"type\\\" && parType !== \\\"url\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\tloaderParameters[ parType ] = geoJSON[ parType ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar loader = this.geometryHandlers[ geoJSON.type ][ \\\"loaderObject\\\" ];\\n                          hack.log(\\\"geoJSON.type = \\\"+geoJSON.type+\\\", geoJSON.url = \\\"+geoJSON.url, hack.sceneLoader, func);\\n                          if (TiddlyWiki && geoJSON.url.match(/^tw:/)) {\\n\\t\\t\\t      loader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry_for_tiddlywiki_url( geoID ), loaderParameters );\\n                          } else\\n\\t\\t\\t      loader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );\\n\\n\\t\\t\\t} else if ( geoJSON.type === \\\"embedded\\\" ) {\\n\\n\\t\\t\\t\\tvar modelJson = data.embeds[ geoJSON.id ],\\n\\t\\t\\t\\t\\ttexture_path = \\\"\\\";\\n\\n\\t\\t\\t\\t// pass metadata along to jsonLoader so it knows the format version\\n\\n\\t\\t\\t\\tmodelJson.metadata = data.metadata;\\n\\n\\t\\t\\t\\tif ( modelJson ) {\\n\\n\\t\\t\\t\\t\\tvar jsonLoader = this.geometryHandlers[ \\\"ascii\\\" ][ \\\"loaderObject\\\" ];\\n\\t\\t\\t\\t\\tvar model = jsonLoader.parse( modelJson, texture_path );\\n\\t\\t\\t\\t\\tcreate_callback_embed( geoID )( model.geometry, model.materials );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// textures\\n\\n\\t\\t// count how many textures will be loaded asynchronously\\n\\n\\t\\tvar textureID, textureJSON;\\n\\n\\t\\tfor ( textureID in data.textures ) {\\n\\n\\t\\t\\ttextureJSON = data.textures[ textureID ];\\n\\n\\t\\t\\tif ( textureJSON.url instanceof Array ) {\\n\\n\\t\\t\\t\\tcounter_textures += textureJSON.url.length;\\n\\n\\t\\t\\t\\tfor( var n = 0; n < textureJSON.url.length; n ++ ) {\\n\\n\\t\\t\\t\\t\\tscope.onLoadStart();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tcounter_textures += 1;\\n\\n\\t\\t\\t\\tscope.onLoadStart();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\ttotal_textures = counter_textures;\\n\\n\\t\\tfor ( textureID in data.textures ) {\\n\\n\\t\\t\\ttextureJSON = data.textures[ textureID ];\\n\\n\\t\\t\\tif ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {\\n\\n\\t\\t\\t\\ttextureJSON.mapping = new THREE[ textureJSON.mapping ]();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar texture;\\n\\n\\t\\t\\tif ( textureJSON.url instanceof Array ) {\\n\\n\\t\\t\\t\\tvar count = textureJSON.url.length;\\n\\t\\t\\t\\tvar url_array = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < count; i ++ ) {\\n\\n\\t\\t\\t\\t\\turl_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar loader = THREE.Loader.Handlers.get( url_array[ 0 ] );\\n\\n\\t\\t\\t\\tif ( loader !== null ) {\\n\\n\\t\\t\\t\\t\\ttexture = loader.load( url_array, generateTextureCallback( count ) );\\n\\t\\t\\t\\t\\ttexture.mapping = textureJSON.mapping;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\ttexture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar fullUrl = get_url( textureJSON.url, data.urlBaseType );\\n\\t\\t\\t\\tvar textureCallback = generateTextureCallback( 1 );\\n\\n\\t\\t\\t\\tvar loader = THREE.Loader.Handlers.get( fullUrl );\\n\\n\\t\\t\\t\\tif ( loader !== null ) {\\n\\n\\t\\t\\t\\t\\ttexture = loader.load( fullUrl, textureCallback );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\ttexture = new THREE.Texture();\\n\\t\\t\\t\\t\\tloader = new THREE.ImageLoader();\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t( function ( texture ) {\\n\\n\\t\\t\\t\\t\\t\\tloader.load( fullUrl, function ( image ) {\\n\\n\\t\\t\\t\\t\\t\\t\\ttexture.image = image;\\n\\t\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\t\\t\\ttextureCallback();\\n\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t} )( texture )\\n\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttexture.mapping = textureJSON.mapping;\\n\\n\\t\\t\\t\\tif ( THREE[ textureJSON.minFilter ] !== undefined )\\n\\t\\t\\t\\t\\ttexture.minFilter = THREE[ textureJSON.minFilter ];\\n\\n\\t\\t\\t\\tif ( THREE[ textureJSON.magFilter ] !== undefined )\\n\\t\\t\\t\\t\\ttexture.magFilter = THREE[ textureJSON.magFilter ];\\n\\n\\t\\t\\t\\tif ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;\\n\\n\\t\\t\\t\\tif ( textureJSON.repeat ) {\\n\\n\\t\\t\\t\\t\\ttexture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );\\n\\n\\t\\t\\t\\t\\tif ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\\n\\t\\t\\t\\t\\tif ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( textureJSON.offset ) {\\n\\n\\t\\t\\t\\t\\ttexture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// handle wrap after repeat so that default repeat can be overriden\\n\\n\\t\\t\\t\\tif ( textureJSON.wrap ) {\\n\\n\\t\\t\\t\\t\\tvar wrapMap = {\\n\\t\\t\\t\\t\\t\\t\\\"repeat\\\": THREE.RepeatWrapping,\\n\\t\\t\\t\\t\\t\\t\\\"mirror\\\": THREE.MirroredRepeatWrapping\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];\\n\\t\\t\\t\\t\\tif ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult.textures[ textureID ] = texture;\\n\\n\\t\\t}\\n\\n\\t\\t// materials\\n\\n\\t\\tvar matID, matJSON;\\n\\t\\tvar parID;\\n\\n\\t\\tfor ( matID in data.materials ) {\\n\\n\\t\\t\\tmatJSON = data.materials[ matID ];\\n\\n\\t\\t\\tfor ( parID in matJSON.parameters ) {\\n\\n\\t\\t\\t\\tif ( parID === \\\"envMap\\\" || parID === \\\"map\\\" || parID === \\\"lightMap\\\" || parID === \\\"bumpMap\\\" ) {\\n\\n\\t\\t\\t\\t\\tmatJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];\\n\\n\\t\\t\\t\\t} else if ( parID === \\\"shading\\\" ) {\\n\\n\\t\\t\\t\\t\\tmatJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === \\\"flat\\\" ) ? THREE.FlatShading : THREE.SmoothShading;\\n\\n\\t\\t\\t\\t} else if ( parID === \\\"side\\\" ) {\\n\\n\\t\\t\\t\\t\\tif ( matJSON.parameters[ parID ] == \\\"double\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\tmatJSON.parameters[ parID ] = THREE.DoubleSide;\\n\\n\\t\\t\\t\\t\\t} else if ( matJSON.parameters[ parID ] == \\\"back\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\tmatJSON.parameters[ parID ] = THREE.BackSide;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tmatJSON.parameters[ parID ] = THREE.FrontSide;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( parID === \\\"blending\\\" ) {\\n\\n\\t\\t\\t\\t\\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;\\n\\n\\t\\t\\t\\t} else if ( parID === \\\"combine\\\" ) {\\n\\n\\t\\t\\t\\t\\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;\\n\\n\\t\\t\\t\\t} else if ( parID === \\\"vertexColors\\\" ) {\\n\\n\\t\\t\\t\\t\\tif ( matJSON.parameters[ parID ] == \\\"face\\\" ) {\\n\\n\\t\\t\\t\\t\\t\\tmatJSON.parameters[ parID ] = THREE.FaceColors;\\n\\n\\t\\t\\t\\t\\t// default to vertex colors if \\\"vertexColors\\\" is anything else face colors or 0 / null / false\\n\\n\\t\\t\\t\\t\\t} else if ( matJSON.parameters[ parID ] ) {\\n\\n\\t\\t\\t\\t\\t\\tmatJSON.parameters[ parID ] = THREE.VertexColors;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( parID === \\\"wrapRGB\\\" ) {\\n\\n\\t\\t\\t\\t\\tvar v3 = matJSON.parameters[ parID ];\\n\\t\\t\\t\\t\\tmatJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {\\n\\n\\t\\t\\t\\tmatJSON.parameters.transparent = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( matJSON.parameters.normalMap ) {\\n\\n\\t\\t\\t\\tvar shader = THREE.ShaderLib[ \\\"normalmap\\\" ];\\n\\t\\t\\t\\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\\n\\n\\t\\t\\t\\tvar diffuse = matJSON.parameters.color;\\n\\t\\t\\t\\tvar specular = matJSON.parameters.specular;\\n\\t\\t\\t\\tvar ambient = matJSON.parameters.ambient;\\n\\t\\t\\t\\tvar shininess = matJSON.parameters.shininess;\\n\\n\\t\\t\\t\\tuniforms[ \\\"tNormal\\\" ].value = result.textures[ matJSON.parameters.normalMap ];\\n\\n\\t\\t\\t\\tif ( matJSON.parameters.normalScale ) {\\n\\n\\t\\t\\t\\t\\tuniforms[ \\\"uNormalScale\\\" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( matJSON.parameters.map ) {\\n\\n\\t\\t\\t\\t\\tuniforms[ \\\"tDiffuse\\\" ].value = matJSON.parameters.map;\\n\\t\\t\\t\\t\\tuniforms[ \\\"enableDiffuse\\\" ].value = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( matJSON.parameters.envMap ) {\\n\\n\\t\\t\\t\\t\\tuniforms[ \\\"tCube\\\" ].value = matJSON.parameters.envMap;\\n\\t\\t\\t\\t\\tuniforms[ \\\"enableReflection\\\" ].value = true;\\n\\t\\t\\t\\t\\tuniforms[ \\\"reflectivity\\\" ].value = matJSON.parameters.reflectivity;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( matJSON.parameters.lightMap ) {\\n\\n\\t\\t\\t\\t\\tuniforms[ \\\"tAO\\\" ].value = matJSON.parameters.lightMap;\\n\\t\\t\\t\\t\\tuniforms[ \\\"enableAO\\\" ].value = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( matJSON.parameters.specularMap ) {\\n\\n\\t\\t\\t\\t\\tuniforms[ \\\"tSpecular\\\" ].value = result.textures[ matJSON.parameters.specularMap ];\\n\\t\\t\\t\\t\\tuniforms[ \\\"enableSpecular\\\" ].value = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( matJSON.parameters.displacementMap ) {\\n\\n\\t\\t\\t\\t\\tuniforms[ \\\"tDisplacement\\\" ].value = result.textures[ matJSON.parameters.displacementMap ];\\n\\t\\t\\t\\t\\tuniforms[ \\\"enableDisplacement\\\" ].value = true;\\n\\n\\t\\t\\t\\t\\tuniforms[ \\\"uDisplacementBias\\\" ].value = matJSON.parameters.displacementBias;\\n\\t\\t\\t\\t\\tuniforms[ \\\"uDisplacementScale\\\" ].value = matJSON.parameters.displacementScale;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuniforms[ \\\"diffuse\\\" ].value.setHex( diffuse );\\n\\t\\t\\t\\tuniforms[ \\\"specular\\\" ].value.setHex( specular );\\n\\t\\t\\t\\tuniforms[ \\\"ambient\\\" ].value.setHex( ambient );\\n\\n\\t\\t\\t\\tuniforms[ \\\"shininess\\\" ].value = shininess;\\n\\n\\t\\t\\t\\tif ( matJSON.parameters.opacity ) {\\n\\n\\t\\t\\t\\t\\tuniforms[ \\\"opacity\\\" ].value = matJSON.parameters.opacity;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\\n\\n\\t\\t\\t\\tmaterial = new THREE.ShaderMaterial( parameters );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmaterial = new THREE[ matJSON.type ]( matJSON.parameters );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaterial.name = matID;\\n\\n\\t\\t\\tresult.materials[ matID ] = material;\\n\\n\\t\\t}\\n\\n\\t\\t// second pass through all materials to initialize MeshFaceMaterials\\n\\t\\t// that could be referring to other materials out of order\\n\\n\\t\\tfor ( matID in data.materials ) {\\n\\n\\t\\t\\tmatJSON = data.materials[ matID ];\\n\\n\\t\\t\\tif ( matJSON.parameters.materials ) {\\n\\n\\t\\t\\t\\tvar materialArray = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar label = matJSON.parameters.materials[ i ];\\n\\t\\t\\t\\t\\tmaterialArray.push( result.materials[ label ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult.materials[ matID ].materials = materialArray;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// objects ( synchronous init of procedural primitives )\\n\\n\\t\\thandle_objects();\\n\\n\\t\\t// defaults\\n\\n\\t\\tif ( result.cameras && data.defaults.camera ) {\\n\\n\\t\\t\\tresult.currentCamera = result.cameras[ data.defaults.camera ];\\n\\n\\t\\t}\\n\\n\\t\\tif ( result.fogs && data.defaults.fog ) {\\n\\n\\t\\t\\tresult.scene.fog = result.fogs[ data.defaults.fog ];\\n\\n\\t\\t}\\n\\n\\t\\t// synchronous callback\\n\\n\\t\\tscope.callbackSync( result );\\n\\n\\t\\t// just in case there are no async elements\\n\\n\\t\\tasync_callback_gate();\\n\\n\\t}\\n\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/STLLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/STLLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author aleeper / http://adamleeper.com/\\n * @author mrdoob / http://mrdoob.com/\\n * @author gero3 / https://github.com/gero3\\n *\\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\\n *\\n * Supports both binary and ASCII encoded files, with automatic detection of type.\\n *\\n * Limitations:\\n * \\tBinary decoding ignores header. There doesn't seem to be much of a use for it.\\n * \\tThere is perhaps some question as to how valid it is to always assume little-endian-ness.\\n * \\tASCII decoding assumes file is UTF-8. Seems to work for the examples...\\n *\\n * Usage:\\n * \\tvar loader = new THREE.STLLoader();\\n * \\tloader.addEventListener( 'load', function ( event ) {\\n *\\n * \\t\\tvar geometry = event.content;\\n * \\t\\tscene.add( new THREE.Mesh( geometry ) );\\n *\\n * \\t} );\\n * \\tloader.load( './models/stl/slotted_disk.stl' );\\n */\\n\\n\\nTHREE.STLLoader = function () {};\\n\\nTHREE.STLLoader.prototype = {\\n\\n\\tconstructor: THREE.STLLoader\\n\\n};\\n\\nTHREE.STLLoader.prototype.load = function ( url, callback ) {\\n  var func = \\\"THREE.STLLoader.load\\\";\\n\\n  if (TiddlyWiki && url.match(/^tw:/)) {\\n    var res = TiddlyWiki.load(url);\\n    //hack.log(\\\"res.length = \\\"+res.length, hack.loader, func);\\n\\n    var geometry = this.parse(res);\\n    this.dispatchEvent({type: 'load', content: geometry});\\n    if (callback) callback(geometry);\\n\\n    hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n    return;\\n  }\\n\\n\\tvar scope = this;\\n\\n\\tvar xhr = new XMLHttpRequest();\\n\\n\\tfunction onloaded( event ) {\\n\\n\\t\\tif ( event.target.status === 200 || event.target.status === 0 ) {\\n\\n\\t\\t\\tvar geometry = scope.parse( event.target.response || event.target.responseText );\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'load', content: geometry } );\\n\\n\\t\\t\\tif ( callback ) callback( geometry );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\\\'t load URL [' + url + ']', response: event.target.statusText } );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\txhr.addEventListener( 'load', onloaded, false );\\n\\n\\txhr.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\tscope.dispatchEvent( { type: 'progress', loaded: event.loaded, total: event.total } );\\n\\n\\t}, false );\\n\\n\\txhr.addEventListener( 'error', function () {\\n\\n\\t\\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\\\'t load URL [' + url + ']' } );\\n\\n\\t}, false );\\n\\n\\tif ( xhr.overrideMimeType ) xhr.overrideMimeType( 'text/plain; charset=x-user-defined' );\\n\\txhr.open( 'GET', url, true );\\n\\txhr.responseType = 'arraybuffer';\\n\\txhr.send( null );\\n\\n};\\n\\nTHREE.STLLoader.prototype.parse = function ( data ) {\\n  var func = \\\"THREE.STLLoader.parse\\\";\\n\\n\\tvar isBinary = function () {\\n\\n\\t\\tvar expect, face_size, n_faces, reader;\\n\\t\\treader = new DataView( binData );\\n\\t\\tface_size = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);\\n\\t\\tn_faces = reader.getUint32(80,true);\\n\\t\\texpect = 80 + (32 / 8) + (n_faces * face_size);\\n\\t\\treturn expect === reader.byteLength;\\n\\n\\t};\\n\\n\\tvar binData = this.ensureBinary( data );\\n\\n\\treturn isBinary()\\n\\t\\t? this.parseBinary( binData )\\n\\t\\t: this.parseASCII( this.ensureString( data ) );\\n\\n};\\n\\nTHREE.STLLoader.prototype.parseBinary = function ( data ) {\\n\\n\\tvar reader = new DataView( data );\\n\\tvar faces = reader.getUint32( 80, true );\\n\\tvar dataOffset = 84;\\n\\tvar faceLength = 12 * 4 + 2;\\n\\n\\tvar offset = 0;\\n\\n\\tvar geometry = new THREE.BufferGeometry();\\n\\n\\tvar vertices = new Float32Array( faces * 3 * 3 );\\n\\tvar normals = new Float32Array( faces * 3 * 3 );\\n\\n\\tfor ( var face = 0; face < faces; face ++ ) {\\n\\n\\t\\tvar start = dataOffset + face * faceLength;\\n\\n\\t\\tfor ( var i = 1; i <= 3; i ++ ) {\\n\\n\\t\\t\\tvar vertexstart = start + i * 12;\\n\\n\\t\\t\\tvertices[ offset     ] = reader.getFloat32( vertexstart, true );\\n\\t\\t\\tvertices[ offset + 1 ] = reader.getFloat32( vertexstart + 4, true );\\n\\t\\t\\tvertices[ offset + 2 ] = reader.getFloat32( vertexstart + 8, true );\\n\\n\\t\\t\\tnormals[ offset     ] = reader.getFloat32( start    , true );\\n\\t\\t\\tnormals[ offset + 1 ] = reader.getFloat32( start + 4, true );\\n\\t\\t\\tnormals[ offset + 2 ] = reader.getFloat32( start + 8, true );\\n\\n\\t\\t\\toffset += 3;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\\n\\tgeometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\\n\\n\\treturn geometry;\\n\\n};\\n\\nTHREE.STLLoader.prototype.parseASCII = function (data) {\\n  var func = \\\"THREE.STLLoader.parseASCII\\\";\\n\\n\\tvar geometry, length, normal, patternFace, patternNormal, patternVertex, result, text;\\n\\tgeometry = new THREE.Geometry();\\n\\tpatternFace = /facet([\\\\s\\\\S]*?)endfacet/g;\\n\\n\\twhile ( ( result = patternFace.exec( data ) ) !== null ) {\\n\\n\\t\\ttext = result[0];\\n\\t\\tpatternNormal = /normal[\\\\s]+([\\\\-+]?[0-9]+\\\\.?[0-9]*([eE][\\\\-+]?[0-9]+)?)+[\\\\s]+([\\\\-+]?[0-9]*\\\\.?[0-9]+([eE][\\\\-+]?[0-9]+)?)+[\\\\s]+([\\\\-+]?[0-9]*\\\\.?[0-9]+([eE][\\\\-+]?[0-9]+)?)+/g;\\n\\n\\t\\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\\n\\n\\t\\t\\tnormal = new THREE.Vector3( parseFloat( result[ 1 ] ), parseFloat( result[ 3 ] ), parseFloat( result[ 5 ] ) );\\n\\n\\t\\t}\\n\\n\\t\\tpatternVertex = /vertex[\\\\s]+([\\\\-+]?[0-9]+\\\\.?[0-9]*([eE][\\\\-+]?[0-9]+)?)+[\\\\s]+([\\\\-+]?[0-9]*\\\\.?[0-9]+([eE][\\\\-+]?[0-9]+)?)+[\\\\s]+([\\\\-+]?[0-9]*\\\\.?[0-9]+([eE][\\\\-+]?[0-9]+)?)+/g;\\n\\n\\t\\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\\n\\n\\t\\t\\tgeometry.vertices.push( new THREE.Vector3( parseFloat( result[ 1 ] ), parseFloat( result[ 3 ] ), parseFloat( result[ 5 ] ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tlength = geometry.vertices.length;\\n\\n\\t\\tgeometry.faces.push( new THREE.Face3( length - 3, length - 2, length - 1, normal ) );\\n\\n\\t}\\n\\n\\tgeometry.computeBoundingBox();\\n\\tgeometry.computeBoundingSphere();\\n\\n\\treturn geometry;\\n\\n};\\n\\nTHREE.STLLoader.prototype.ensureString = function (buf) {\\n  var func = \\\"THREE.STLLoader.ensureString\\\";\\n\\n\\tif (typeof buf !== \\\"string\\\"){\\n\\t\\tvar array_buffer = new Uint8Array(buf);\\n\\t\\tvar str = '';\\n\\t\\tfor(var i = 0; i < buf.byteLength; i++) {\\n\\t\\t\\tstr += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\\n\\t\\t}\\n\\t\\treturn str;\\n\\t} else {\\n\\t\\treturn buf;\\n\\t}\\n\\n};\\n\\nTHREE.STLLoader.prototype.ensureBinary = function (buf) {\\n\\n\\tif (typeof buf === \\\"string\\\"){\\n\\t\\tvar array_buffer = new Uint8Array(buf.length);\\n\\t\\tfor(var i = 0; i < buf.length; i++) {\\n\\t\\t\\tarray_buffer[i] = buf.charCodeAt(i) & 0xff; // implicitly assumes little-endian\\n\\t\\t}\\n\\t\\treturn array_buffer.buffer || array_buffer;\\n\\t} else {\\n\\t\\treturn buf;\\n\\t}\\n\\n};\\n\\nTHREE.EventDispatcher.prototype.apply( THREE.STLLoader.prototype );\\n\\nif ( typeof DataView === 'undefined'){\\n\\n\\tDataView = function(buffer, byteOffset, byteLength){\\n\\n\\t\\tthis.buffer = buffer;\\n\\t\\tthis.byteOffset = byteOffset || 0;\\n\\t\\tthis.byteLength = byteLength || buffer.byteLength || buffer.length;\\n\\t\\tthis._isString = typeof buffer === \\\"string\\\";\\n\\n\\t}\\n\\n\\tDataView.prototype = {\\n\\n\\t\\t_getCharCodes:function(buffer,start,length){\\n\\t\\t\\tstart = start || 0;\\n\\t\\t\\tlength = length || buffer.length;\\n\\t\\t\\tvar end = start + length;\\n\\t\\t\\tvar codes = [];\\n\\t\\t\\tfor (var i = start; i < end; i++) {\\n\\t\\t\\t\\tcodes.push(buffer.charCodeAt(i) & 0xff);\\n\\t\\t\\t}\\n\\t\\t\\treturn codes;\\n\\t\\t},\\n\\n\\t\\t_getBytes: function (length, byteOffset, littleEndian) {\\n\\n\\t\\t\\tvar result;\\n\\n\\t\\t\\t// Handle the lack of endianness\\n\\t\\t\\tif (littleEndian === undefined) {\\n\\n\\t\\t\\t\\tlittleEndian = this._littleEndian;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Handle the lack of byteOffset\\n\\t\\t\\tif (byteOffset === undefined) {\\n\\n\\t\\t\\t\\tbyteOffset = this.byteOffset;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tbyteOffset = this.byteOffset + byteOffset;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (length === undefined) {\\n\\n\\t\\t\\t\\tlength = this.byteLength - byteOffset;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Error Checking\\n\\t\\t\\tif (typeof byteOffset !== 'number') {\\n\\n\\t\\t\\t\\tthrow new TypeError('DataView byteOffset is not a number');\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (length < 0 || byteOffset + length > this.byteLength) {\\n\\n\\t\\t\\t\\tthrow new Error('DataView length or (byteOffset+length) value is out of bounds');\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (this.isString){\\n\\n\\t\\t\\t\\tresult = this._getCharCodes(this.buffer, byteOffset, byteOffset + length);\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tresult = this.buffer.slice(byteOffset, byteOffset + length);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!littleEndian && length > 1) {\\n\\n\\t\\t\\t\\tif (!(result instanceof Array)) {\\n\\n\\t\\t\\t\\t\\tresult = Array.prototype.slice.call(result);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult.reverse();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\t// Compatibility functions on a String Buffer\\n\\n\\t\\tgetFloat64: function (byteOffset, littleEndian) {\\n\\n\\t\\t\\tvar b = this._getBytes(8, byteOffset, littleEndian),\\n\\n\\t\\t\\t\\tsign = 1 - (2 * (b[7] >> 7)),\\n\\t\\t\\t\\texponent = ((((b[7] << 1) & 0xff) << 3) | (b[6] >> 4)) - ((1 << 10) - 1),\\n\\n\\t\\t\\t// Binary operators such as | and << operate on 32 bit values, using + and Math.pow(2) instead\\n\\t\\t\\t\\tmantissa = ((b[6] & 0x0f) * Math.pow(2, 48)) + (b[5] * Math.pow(2, 40)) + (b[4] * Math.pow(2, 32)) +\\n\\t\\t\\t\\t\\t\\t\\t(b[3] * Math.pow(2, 24)) + (b[2] * Math.pow(2, 16)) + (b[1] * Math.pow(2, 8)) + b[0];\\n\\n\\t\\t\\tif (exponent === 1024) {\\n\\t\\t\\t\\tif (mantissa !== 0) {\\n\\t\\t\\t\\t\\treturn NaN;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn sign * Infinity;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (exponent === -1023) { // Denormalized\\n\\t\\t\\t\\treturn sign * mantissa * Math.pow(2, -1022 - 52);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);\\n\\n\\t\\t},\\n\\n\\t\\tgetFloat32: function (byteOffset, littleEndian) {\\n\\n\\t\\t\\tvar b = this._getBytes(4, byteOffset, littleEndian),\\n\\n\\t\\t\\t\\tsign = 1 - (2 * (b[3] >> 7)),\\n\\t\\t\\t\\texponent = (((b[3] << 1) & 0xff) | (b[2] >> 7)) - 127,\\n\\t\\t\\t\\tmantissa = ((b[2] & 0x7f) << 16) | (b[1] << 8) | b[0];\\n\\n\\t\\t\\tif (exponent === 128) {\\n\\t\\t\\t\\tif (mantissa !== 0) {\\n\\t\\t\\t\\t\\treturn NaN;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn sign * Infinity;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (exponent === -127) { // Denormalized\\n\\t\\t\\t\\treturn sign * mantissa * Math.pow(2, -126 - 23);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn sign * (1 + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);\\n\\t\\t},\\n\\n\\t\\tgetInt32: function (byteOffset, littleEndian) {\\n\\t\\t\\tvar b = this._getBytes(4, byteOffset, littleEndian);\\n\\t\\t\\treturn (b[3] << 24) | (b[2] << 16) | (b[1] << 8) | b[0];\\n\\t\\t},\\n\\n\\t\\tgetUint32: function (byteOffset, littleEndian) {\\n\\t\\t\\treturn this.getInt32(byteOffset, littleEndian) >>> 0;\\n\\t\\t},\\n\\n\\t\\tgetInt16: function (byteOffset, littleEndian) {\\n\\t\\t\\treturn (this.getUint16(byteOffset, littleEndian) << 16) >> 16;\\n\\t\\t},\\n\\n\\t\\tgetUint16: function (byteOffset, littleEndian) {\\n\\t\\t\\tvar b = this._getBytes(2, byteOffset, littleEndian);\\n\\t\\t\\treturn (b[1] << 8) | b[0];\\n\\t\\t},\\n\\n\\t\\tgetInt8: function (byteOffset) {\\n\\t\\t\\treturn (this.getUint8(byteOffset) << 24) >> 24;\\n\\t\\t},\\n\\n\\t\\tgetUint8: function (byteOffset) {\\n\\t\\t\\treturn this._getBytes(1, byteOffset)[0];\\n\\t\\t}\\n\\n\\t };\\n\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/UTF8Loader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/UTF8Loader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * Loader for UTF8 version2 (after r51) encoded models generated by:\\n *\\thttp://code.google.com/p/webgl-loader/\\n *\\n * Code to load/decompress mesh is taken from r100 of this webgl-loader\\n */\\n\\nTHREE.UTF8Loader = function () {};\\n\\n/**\\n * Load UTF8 encoded model\\n * @param jsonUrl - URL from which to load json containing information about model\\n * @param callback - Callback(THREE.Object3D) on successful loading of model\\n * @param options - options on how to load model (see THREE.MTLLoader.MaterialCreator for basic options)\\n *                  Additional options include\\n *                   geometryBase: Base url from which to load referenced geometries\\n *                   materialBase: Base url from which to load referenced textures\\n */\\n\\nTHREE.UTF8Loader.prototype.load = function ( jsonUrl, callback, options ) {\\n  var func = \\\"THREE.UTF8Loader.load\\\";\\n  hack.log(\\\"url: \\\"+jsonUrl, hack.loader, func);\\n\\n    this.downloadModelJson( jsonUrl, options, callback );\\n\\n};\\n\\n// BufferGeometryCreator\\n\\nTHREE.UTF8Loader.BufferGeometryCreator = function () {\\n};\\n\\nTHREE.UTF8Loader.BufferGeometryCreator.prototype.create = function ( attribArray, indices ) {\\n\\n\\tvar ntris = indices.length / 3;\\n\\n\\tvar geometry = new THREE.BufferGeometry();\\n\\n\\tvar positions = new Float32Array( ntris * 3 * 3 );\\n\\tvar normals = new Float32Array( ntris * 3 * 3 );\\n\\tvar uvs = new Float32Array( ntris * 3 * 2 );\\n\\n\\tvar i, j, offset;\\n\\tvar x, y, z;\\n\\tvar u, v;\\n\\n\\tvar end = attribArray.length;\\n\\tvar stride = 8;\\n\\n\\t// extract positions\\n\\n\\tj = 0;\\n\\toffset = 0;\\n\\n\\tfor( i = offset; i < end; i += stride ) {\\n\\n\\t\\tx = attribArray[ i ];\\n\\t\\ty = attribArray[ i + 1 ];\\n\\t\\tz = attribArray[ i + 2 ];\\n\\n\\t\\tpositions[ j++ ] = x;\\n\\t\\tpositions[ j++ ] = y;\\n\\t\\tpositions[ j++ ] = z;\\n\\n\\t}\\n\\n\\t// extract uvs\\n\\n\\tj = 0;\\n\\toffset = 3;\\n\\n\\tfor( i = offset; i < end; i += stride ) {\\n\\n\\t\\tu = attribArray[ i ];\\n\\t\\tv = attribArray[ i + 1 ];\\n\\n\\t\\tuvs[ j++ ] = u;\\n\\t\\tuvs[ j++ ] = v;\\n\\n\\t}\\n\\n\\t// extract normals\\n\\n\\tj = 0;\\n\\toffset = 5;\\n\\n\\tfor( i = offset; i < end; i += stride ) {\\n\\n\\t\\tx = attribArray[ i ];\\n\\t\\ty = attribArray[ i + 1 ];\\n\\t\\tz = attribArray[ i + 2 ];\\n\\n\\t\\tnormals[ j++ ] = x;\\n\\t\\tnormals[ j++ ] = y;\\n\\t\\tnormals[ j++ ] = z;\\n\\n\\t}\\n\\n    geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\\n    geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\\n    geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\\n    geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\\n\\n    geometry.offsets.push( { start: 0, count: indices.length, index: 0 } );\\n\\n\\tgeometry.computeBoundingSphere();\\n\\n\\treturn geometry;\\n\\n};\\n\\n\\n// UTF-8 decoder from webgl-loader (r100)\\n// http://code.google.com/p/webgl-loader/\\n\\n// Model manifest description. Contains objects like:\\n// name: {\\n//   materials: { 'material_name': { ... } ... },\\n//   decodeParams: {\\n//     decodeOffsets: [ ... ],\\n//     decodeScales: [ ... ],\\n//   },\\n//   urls: {\\n//     'url': [\\n//       { material: 'material_name',\\n//         attribRange: [#, #],\\n//         indexRange: [#, #],\\n//         names: [ 'object names' ... ],\\n//         lengths: [#, #, # ... ]\\n//       }\\n//     ],\\n//     ...\\n//   }\\n// }\\n\\nvar DEFAULT_DECODE_PARAMS = {\\n\\n    decodeOffsets: [-4095, -4095, -4095, 0, 0, -511, -511, -511],\\n    decodeScales: [1/8191, 1/8191, 1/8191, 1/1023, 1/1023, 1/1023, 1/1023, 1/1023]\\n\\n    // TODO: normal decoding? (see walt.js)\\n    // needs to know: input, output (from vertex format!)\\n    //\\n    // Should split attrib/index.\\n    // 1) Decode position and non-normal attributes.\\n    // 2) Decode indices, computing normals\\n    // 3) Maybe normalize normals? Only necessary for refinement, or fixed?\\n    // 4) Maybe refine normals? Should this be part of regular refinement?\\n    // 5) Morphing\\n\\n};\\n\\n// Triangle strips!\\n\\n// TODO: will it be an optimization to specialize this method at\\n// runtime for different combinations of stride, decodeOffset and\\n// decodeScale?\\n\\nTHREE.UTF8Loader.prototype.decompressAttribsInner_ = function ( str, inputStart, inputEnd,\\n                                                                  output, outputStart, stride,\\n                                                                  decodeOffset, decodeScale ) {\\n\\n    var prev = 0;\\n\\n    for ( var j = inputStart; j < inputEnd; j ++ ) {\\n\\n        var code = str.charCodeAt( j );\\n        prev += ( code >> 1 ) ^ ( -( code & 1 ) );\\n\\n        output[ outputStart ] = decodeScale * ( prev + decodeOffset );\\n        outputStart += stride;\\n\\n    }\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.decompressIndices_ = function( str, inputStart, numIndices,\\n                                                            output, outputStart ) {\\n\\n\\tvar highest = 0;\\n\\n    for ( var i = 0; i < numIndices; i ++ ) {\\n\\n        var code = str.charCodeAt( inputStart ++ );\\n\\n        output[ outputStart ++ ] = highest - code;\\n\\n        if ( code === 0 ) {\\n\\n            highest ++;\\n\\n        }\\n\\n    }\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.decompressAABBs_ = function ( str, inputStart, numBBoxen,\\n                                                           decodeOffsets, decodeScales ) {\\n    var numFloats = 6 * numBBoxen;\\n\\n    var inputEnd = inputStart + numFloats;\\n    var outputStart = 0;\\n\\n    var bboxen = new Float32Array( numFloats );\\n\\n    for ( var i = inputStart; i < inputEnd; i += 6 ) {\\n\\n        var minX = str.charCodeAt(i + 0) + decodeOffsets[0];\\n        var minY = str.charCodeAt(i + 1) + decodeOffsets[1];\\n        var minZ = str.charCodeAt(i + 2) + decodeOffsets[2];\\n\\n        var radiusX = (str.charCodeAt(i + 3) + 1) >> 1;\\n        var radiusY = (str.charCodeAt(i + 4) + 1) >> 1;\\n        var radiusZ = (str.charCodeAt(i + 5) + 1) >> 1;\\n\\n        bboxen[ outputStart++ ] = decodeScales[0] * (minX + radiusX);\\n        bboxen[ outputStart++ ] = decodeScales[1] * (minY + radiusY);\\n        bboxen[ outputStart++ ] = decodeScales[2] * (minZ + radiusZ);\\n\\n        bboxen[ outputStart++ ] = decodeScales[0] * radiusX;\\n        bboxen[ outputStart++ ] = decodeScales[1] * radiusY;\\n        bboxen[ outputStart++ ] = decodeScales[2] * radiusZ;\\n\\n    }\\n\\n    return bboxen;\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.decompressMesh =  function ( str, meshParams, decodeParams, name, idx, callback ) {\\n\\n    // Extract conversion parameters from attribArrays.\\n\\n    var stride = decodeParams.decodeScales.length;\\n\\n    var decodeOffsets = decodeParams.decodeOffsets;\\n    var decodeScales = decodeParams.decodeScales;\\n\\n    var attribStart = meshParams.attribRange[0];\\n    var numVerts = meshParams.attribRange[1];\\n\\n    // Decode attributes.\\n\\n    var inputOffset = attribStart;\\n    var attribsOut = new Float32Array( stride * numVerts );\\n\\n    for (var j = 0; j < stride; j ++ ) {\\n\\n        var end = inputOffset + numVerts;\\n\\n\\t\\tvar decodeScale = decodeScales[j];\\n\\n        if ( decodeScale ) {\\n\\n            // Assume if decodeScale is never set, simply ignore the\\n            // attribute.\\n\\n            this.decompressAttribsInner_( str, inputOffset, end,\\n                attribsOut, j, stride,\\n                decodeOffsets[j], decodeScale );\\n        }\\n\\n        inputOffset = end;\\n\\n    }\\n\\n    var indexStart = meshParams.indexRange[ 0 ];\\n    var numIndices = 3 * meshParams.indexRange[ 1 ];\\n\\n    var indicesOut = new Uint16Array( numIndices );\\n\\n    this.decompressIndices_( str, inputOffset, numIndices, indicesOut, 0 );\\n\\n    // Decode bboxen.\\n\\n    var bboxen = undefined;\\n    var bboxOffset = meshParams.bboxes;\\n\\n    if ( bboxOffset ) {\\n\\n        bboxen = this.decompressAABBs_( str, bboxOffset, meshParams.names.length, decodeOffsets, decodeScales );\\n    }\\n\\n    callback( name, idx, attribsOut, indicesOut, bboxen, meshParams );\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.copyAttrib = function ( stride, attribsOutFixed, lastAttrib, index ) {\\n\\n    for ( var j = 0; j < stride; j ++ ) {\\n\\n        lastAttrib[ j ] = attribsOutFixed[ stride * index + j ];\\n\\n    }\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.decodeAttrib2 = function ( str, stride, decodeOffsets, decodeScales, deltaStart,\\n                                                        numVerts, attribsOut, attribsOutFixed, lastAttrib,\\n                                                        index ) {\\n\\n    for ( var j = 0; j < 5; j ++ ) {\\n\\n        var code = str.charCodeAt( deltaStart + numVerts*j + index );\\n        var delta = ( code >> 1) ^ (-(code & 1));\\n\\n        lastAttrib[ j ] += delta;\\n        attribsOutFixed[ stride * index + j ] = lastAttrib[ j ];\\n        attribsOut[ stride * index + j ] = decodeScales[ j ] * ( lastAttrib[ j ] + decodeOffsets[ j ] );\\n    }\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.accumulateNormal = function ( i0, i1, i2, attribsOutFixed, crosses ) {\\n\\n    var p0x = attribsOutFixed[ 8*i0 ];\\n    var p0y = attribsOutFixed[ 8*i0 + 1 ];\\n    var p0z = attribsOutFixed[ 8*i0 + 2 ];\\n\\n    var p1x = attribsOutFixed[ 8*i1 ];\\n    var p1y = attribsOutFixed[ 8*i1 + 1 ];\\n    var p1z = attribsOutFixed[ 8*i1 + 2 ];\\n\\n    var p2x = attribsOutFixed[ 8*i2 ];\\n    var p2y = attribsOutFixed[ 8*i2 + 1 ];\\n    var p2z = attribsOutFixed[ 8*i2 + 2 ];\\n\\n    p1x -= p0x;\\n    p1y -= p0y;\\n    p1z -= p0z;\\n\\n    p2x -= p0x;\\n    p2y -= p0y;\\n    p2z -= p0z;\\n\\n    p0x = p1y*p2z - p1z*p2y;\\n    p0y = p1z*p2x - p1x*p2z;\\n    p0z = p1x*p2y - p1y*p2x;\\n\\n    crosses[ 3*i0 ]     += p0x;\\n    crosses[ 3*i0 + 1 ] += p0y;\\n    crosses[ 3*i0 + 2 ] += p0z;\\n\\n    crosses[ 3*i1 ]     += p0x;\\n    crosses[ 3*i1 + 1 ] += p0y;\\n    crosses[ 3*i1 + 2 ] += p0z;\\n\\n    crosses[ 3*i2 ]     += p0x;\\n    crosses[ 3*i2 + 1 ] += p0y;\\n    crosses[ 3*i2 + 2 ] += p0z;\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.decompressMesh2 = function( str, meshParams, decodeParams, name, idx, callback ) {\\n\\n    var MAX_BACKREF = 96;\\n\\n    // Extract conversion parameters from attribArrays.\\n\\n    var stride = decodeParams.decodeScales.length;\\n\\n\\tvar decodeOffsets = decodeParams.decodeOffsets;\\n    var decodeScales = decodeParams.decodeScales;\\n\\n    var deltaStart = meshParams.attribRange[ 0 ];\\n    var numVerts = meshParams.attribRange[ 1 ];\\n\\n    var codeStart = meshParams.codeRange[ 0 ];\\n    var codeLength = meshParams.codeRange[ 1 ];\\n\\n    var numIndices = 3 * meshParams.codeRange[ 2 ];\\n\\n    var indicesOut = new Uint16Array( numIndices );\\n\\n    var crosses = new Int32Array( 3 * numVerts );\\n\\n    var lastAttrib = new Uint16Array( stride );\\n\\n    var attribsOutFixed = new Uint16Array( stride * numVerts );\\n    var attribsOut = new Float32Array( stride * numVerts );\\n\\n    var highest = 0;\\n    var outputStart = 0;\\n\\n    for ( var i = 0; i < numIndices; i += 3 ) {\\n\\n        var code = str.charCodeAt( codeStart ++ );\\n\\n        var max_backref = Math.min( i, MAX_BACKREF );\\n\\n        if ( code < max_backref ) {\\n\\n            // Parallelogram\\n\\n            var winding = code % 3;\\n            var backref = i - ( code - winding );\\n            var i0, i1, i2;\\n\\n            switch ( winding ) {\\n\\n                case 0:\\n\\n                    i0 = indicesOut[ backref + 2 ];\\n                    i1 = indicesOut[ backref + 1 ];\\n                    i2 = indicesOut[ backref + 0 ];\\n                    break;\\n\\n                case 1:\\n\\n                    i0 = indicesOut[ backref + 0 ];\\n                    i1 = indicesOut[ backref + 2 ];\\n                    i2 = indicesOut[ backref + 1 ];\\n                    break;\\n\\n                case 2:\\n\\n                    i0 = indicesOut[ backref + 1 ];\\n                    i1 = indicesOut[ backref + 0 ];\\n                    i2 = indicesOut[ backref + 2 ];\\n                    break;\\n\\n            }\\n\\n            indicesOut[ outputStart ++ ] = i0;\\n            indicesOut[ outputStart ++ ] = i1;\\n\\n            code = str.charCodeAt( codeStart ++ );\\n\\n            var index = highest - code;\\n            indicesOut[ outputStart ++ ] = index;\\n\\n            if ( code === 0 ) {\\n\\n                for (var j = 0; j < 5; j ++ ) {\\n\\n                    var deltaCode = str.charCodeAt( deltaStart + numVerts * j + highest );\\n\\n                    var prediction = ((deltaCode >> 1) ^ (-(deltaCode & 1))) +\\n                        attribsOutFixed[stride*i0 + j] +\\n                        attribsOutFixed[stride*i1 + j] -\\n                        attribsOutFixed[stride*i2 + j];\\n\\n                    lastAttrib[j] = prediction;\\n\\n                    attribsOutFixed[ stride * highest + j ] = prediction;\\n                    attribsOut[ stride * highest + j ] = decodeScales[ j ] * ( prediction + decodeOffsets[ j ] );\\n\\n                }\\n\\n                highest ++;\\n\\n            } else {\\n\\n                this.copyAttrib( stride, attribsOutFixed, lastAttrib, index );\\n\\n            }\\n\\n            this.accumulateNormal( i0, i1, index, attribsOutFixed, crosses );\\n\\n        } else {\\n\\n            // Simple\\n\\n            var index0 = highest - ( code - max_backref );\\n\\n            indicesOut[ outputStart ++ ] = index0;\\n\\n            if ( code === max_backref ) {\\n\\n                this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,\\n                    numVerts, attribsOut, attribsOutFixed, lastAttrib,\\n                    highest ++ );\\n\\n            } else {\\n\\n                this.copyAttrib(stride, attribsOutFixed, lastAttrib, index0);\\n\\n            }\\n\\n            code = str.charCodeAt( codeStart ++ );\\n\\n            var index1 = highest - code;\\n            indicesOut[ outputStart ++ ] = index1;\\n\\n            if ( code === 0 ) {\\n\\n                this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,\\n                    numVerts, attribsOut, attribsOutFixed, lastAttrib,\\n                    highest ++ );\\n\\n            } else {\\n\\n                this.copyAttrib( stride, attribsOutFixed, lastAttrib, index1 );\\n\\n            }\\n\\n            code = str.charCodeAt( codeStart ++ );\\n\\n            var index2 = highest - code;\\n            indicesOut[ outputStart ++ ] = index2;\\n\\n            if ( code === 0 ) {\\n\\n                for ( var j = 0; j < 5; j ++ ) {\\n\\n                    lastAttrib[ j ] = ( attribsOutFixed[ stride * index0 + j ] + attribsOutFixed[ stride * index1 + j ] ) / 2;\\n\\n                }\\n\\n                this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,\\n                    numVerts, attribsOut, attribsOutFixed, lastAttrib,\\n                    highest ++ );\\n\\n            } else {\\n\\n                this.copyAttrib( stride, attribsOutFixed, lastAttrib, index2 );\\n\\n            }\\n\\n            this.accumulateNormal( index0, index1, index2, attribsOutFixed, crosses );\\n\\n        }\\n\\n    }\\n\\n    for ( var i = 0; i < numVerts; i ++ ) {\\n\\n        var nx = crosses[ 3*i ];\\n        var ny = crosses[ 3*i + 1 ];\\n        var nz = crosses[ 3*i + 2 ];\\n\\n        var norm = 511.0 / Math.sqrt( nx*nx + ny*ny + nz*nz );\\n\\n        var cx = str.charCodeAt( deltaStart + 5*numVerts + i );\\n        var cy = str.charCodeAt( deltaStart + 6*numVerts + i );\\n        var cz = str.charCodeAt( deltaStart + 7*numVerts + i );\\n\\n        attribsOut[ stride*i + 5 ] = norm*nx + ((cx >> 1) ^ (-(cx & 1)));\\n        attribsOut[ stride*i + 6 ] = norm*ny + ((cy >> 1) ^ (-(cy & 1)));\\n        attribsOut[ stride*i + 7 ] = norm*nz + ((cz >> 1) ^ (-(cz & 1)));\\n    }\\n\\n    callback( name, idx, attribsOut, indicesOut, undefined, meshParams );\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.downloadMesh = function ( path, name, meshEntry, decodeParams, callback ) {\\n  var func = \\\"THREE.UTF8Loader.downloadMesh\\\";\\n\\n\\n    var loader = this;\\n    var idx = 0;\\n\\n    function onprogress( req, e ) {\\n\\n        while ( idx < meshEntry.length ) {\\n\\n            var meshParams = meshEntry[ idx ];\\n            var indexRange = meshParams.indexRange;\\n\\n            if ( indexRange ) {\\n\\n                var meshEnd = indexRange[ 0 ] + 3 * indexRange[ 1 ];\\n\\n                if ( req.responseText.length < meshEnd ) break;\\n\\n                loader.decompressMesh( req.responseText, meshParams, decodeParams, name, idx, callback );\\n\\n            } else {\\n\\n                var codeRange = meshParams.codeRange;\\n                var meshEnd = codeRange[ 0 ] + codeRange[ 1 ];\\n\\n                if ( req.responseText.length < meshEnd ) break;\\n\\n                loader.decompressMesh2( req.responseText, meshParams, decodeParams, name, idx, callback );\\n            }\\n\\n            ++idx;\\n\\n        }\\n\\n    };\\n\\n    THREE.UTF8Loader.getHttpRequest( path, function( req, e ) {\\n\\n        if ( req.status === 200 || req.status === 0 ) {\\n\\n            onprogress( req, e );\\n\\n        }\\n\\n        // TODO: handle errors.\\n\\n    }, onprogress );\\n};\\n\\nTHREE.UTF8Loader.prototype.downloadMeshes = function ( path, meshUrlMap, decodeParams, callback ) {\\n\\n    for ( var url in meshUrlMap ) {\\n\\n        var meshEntry = meshUrlMap[url];\\n        this.downloadMesh( path + url, url, meshEntry, decodeParams, callback );\\n\\n    }\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.createMeshCallback = function( materialBaseUrl, loadModelInfo, allDoneCallback ) {\\n\\n\\tvar nCompletedUrls = 0;\\n    var nExpectedUrls = 0;\\n\\n    var expectedMeshesPerUrl = {};\\n    var decodedMeshesPerUrl = {};\\n\\n\\tvar modelParts = {};\\n\\n\\tvar meshUrlMap = loadModelInfo.urls;\\n\\n    for ( var url in meshUrlMap ) {\\n\\n        expectedMeshesPerUrl[ url ] = meshUrlMap[ url ].length;\\n        decodedMeshesPerUrl[ url ] = 0;\\n\\n\\t\\tnExpectedUrls ++;\\n\\n        modelParts[ url ] = new THREE.Object3D();\\n\\n    }\\n\\n    var model = new THREE.Object3D();\\n\\n    // Prepare materials first...\\n\\n    var materialCreator = new THREE.MTLLoader.MaterialCreator( materialBaseUrl, loadModelInfo.options );\\n    materialCreator.setMaterials( loadModelInfo.materials );\\n\\n    materialCreator.preload();\\n\\n\\t// Create callback for creating mesh parts\\n\\n\\tvar bufferGeometryCreator = new THREE.UTF8Loader.BufferGeometryCreator();\\n\\n\\tvar meshCallback = function( name, idx, attribArray, indexArray, bboxen, meshParams ) {\\n\\n        // Got ourselves a new mesh\\n\\n        // name identifies this part of the model (url)\\n        // idx is the mesh index of this mesh of the part\\n        // attribArray defines the vertices\\n        // indexArray defines the faces\\n        // bboxen defines the bounding box\\n        // meshParams contains the material info\\n\\n\\t\\tvar geometry = bufferGeometryCreator.create( attribArray, indexArray );\\n        var material = materialCreator.create( meshParams.material );\\n\\n\\t\\tvar mesh = new THREE.Mesh( geometry, material );\\n        modelParts[ name ].add( mesh );\\n\\n        //model.add(new THREE.Mesh(geometry, material));\\n\\n        decodedMeshesPerUrl[ name ] ++;\\n\\n        if ( decodedMeshesPerUrl[ name ] === expectedMeshesPerUrl[ name ] ) {\\n\\n            nCompletedUrls ++;\\n\\n            model.add( modelParts[ name ] );\\n\\n            if ( nCompletedUrls === nExpectedUrls ) {\\n\\n                // ALL DONE!!!\\n\\n                allDoneCallback( model );\\n\\n            }\\n\\n        }\\n\\n    };\\n\\n\\treturn meshCallback;\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.downloadModel = function ( geometryBase, materialBase, model, callback ) {\\n\\n    var meshCallback = this.createMeshCallback( materialBase, model, callback );\\n    this.downloadMeshes( geometryBase, model.urls, model.decodeParams, meshCallback );\\n\\n};\\n\\nTHREE.UTF8Loader.prototype.downloadModelJson = function ( jsonUrl, options, callback ) {\\n\\n    THREE.UTF8Loader.getJsonRequest( jsonUrl, function( loaded ) {\\n\\n        if ( ! loaded.decodeParams ) {\\n\\n            if ( options && options.decodeParams ) {\\n\\n                loaded.decodeParams = options.decodeParams;\\n\\n            } else {\\n\\n                loaded.decodeParams = DEFAULT_DECODE_PARAMS;\\n\\n            }\\n\\n        }\\n\\n        loaded.options = options;\\n\\n        var geometryBase = jsonUrl.substr( 0, jsonUrl.lastIndexOf( \\\"/\\\" ) + 1 );\\n        var materialBase = geometryBase;\\n\\n        if ( options && options.geometryBase ) {\\n\\n            geometryBase = options.geometryBase;\\n\\n            if ( geometryBase.charAt( geometryBase.length - 1 ) !== \\\"/\\\" ) {\\n\\n                geometryBase = geometryBase + \\\"/\\\";\\n\\n            }\\n\\n        }\\n\\n        if ( options && options.materialBase ) {\\n\\n            materialBase = options.materialBase;\\n\\n            if ( materialBase.charAt( materialBase.length - 1 ) !== \\\"/\\\" ) {\\n\\n                materialBase = materialBase  + \\\"/\\\";\\n\\n            }\\n\\n        }\\n\\n        this.downloadModel( geometryBase, materialBase, loaded, callback );\\n\\n    }.bind( this ) );\\n\\n};\\n\\n// XMLHttpRequest stuff\\n\\nTHREE.UTF8Loader.getHttpRequest = function( url, onload, opt_onprogress ) {\\n  var func = \\\"THREE.UTF8Loader.getHttpRequest\\\";\\n\\n  if (TiddlyWiki && url.match(/^tw:/)) {\\n    var res = TiddlyWiki.load(url);\\n    //hack.log(\\\"res.length = \\\"+res.length, hack.loader, func);\\n\\n    var req = {responseText: res};\\n    onload(req);\\n\\n    hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n    return;\\n  }\\n\\n    var LISTENERS = {\\n\\n        load: function( e ) { onload( req, e ); },\\n        progress: function( e ) { opt_onprogress( req, e ); }\\n\\n    };\\n\\n    var req = new XMLHttpRequest();\\n    THREE.UTF8Loader.addListeners( req, LISTENERS );\\n\\n    req.open( 'GET', url, true );\\n    req.send( null );\\n}\\n\\nTHREE.UTF8Loader.getJsonRequest = function( url, onjson ) {\\n\\n    THREE.UTF8Loader.getHttpRequest( url,\\n        function( e ) { onjson( JSON.parse( e.responseText ) ); },\\n        function() {} );\\n\\n}\\n\\nTHREE.UTF8Loader.addListeners = function( dom, listeners ) {\\n\\n    // TODO: handle event capture, object binding.\\n\\n    for ( var key in listeners ) {\\n\\n        dom.addEventListener( key, listeners[ key ] );\\n\\n    }\\n}\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/VRMLLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/VRMLLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.VRMLLoader = function () {};\\n\\nTHREE.VRMLLoader.prototype = {\\n\\n\\tconstructor: THREE.VRMLLoader,\\n\\n\\t// for IndexedFaceSet support\\n\\tisRecordingPoints: false,\\n\\tisRecordingFaces: false,\\n\\tpoints: [],\\n\\tindexes : [],\\n\\n\\t// for Background support\\n\\tisRecordingAngles: false,\\n\\tisRecordingColors: false,\\n\\tangles: [],\\n\\tcolors: [],\\n\\n\\trecordingFieldname: null,\\n\\n\\tload: function ( url, callback ) {\\n          var func = \\\"THREE.VRMLLoader.load\\\";\\n\\n          if (TiddlyWiki && url.match(/^tw:/)) {\\n            var res = TiddlyWiki.load(url);\\n            //hack.log(\\\"res.length = \\\"+res.length, hack.loader, func);\\n            \\n\\t    var object = this.parse(res);\\n\\t    this.dispatchEvent({type: 'load', content: object});\\n\\t    if (callback) callback(object);\\n            \\n            hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n            return;\\n          }\\n\\n\\t\\tvar scope = this;\\n\\t\\tvar request = new XMLHttpRequest();\\n\\n\\t\\trequest.addEventListener( 'load', function ( event ) {\\n\\n\\t\\t\\tvar object = scope.parse( event.target.responseText );\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'load', content: object } );\\n\\n\\t\\t\\tif ( callback ) callback( object );\\n\\n\\t\\t}, false );\\n\\n\\t\\trequest.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'progress', loaded: event.loaded, total: event.total } );\\n\\n\\t\\t}, false );\\n\\n\\t\\trequest.addEventListener( 'error', function () {\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\\\'t load URL [' + url + ']' } );\\n\\n\\t\\t}, false );\\n\\n\\t\\trequest.open( 'GET', url, true );\\n\\t\\trequest.send( null );\\n\\n\\t},\\n\\n\\tparse: function ( data ) {\\n\\n\\t\\tvar parseV1 = function ( lines, scene ) {\\n\\n\\t\\t\\tconsole.warn( 'VRML V1.0 not supported yet' );\\n\\n\\t\\t};\\n\\n\\t\\tvar parseV2 = function ( lines, scene ) {\\n\\t\\t\\tvar defines = {};\\n\\t\\t\\tvar float_pattern = /(\\\\b|\\\\-|\\\\+)([\\\\d\\\\.e]+)/;\\n\\t\\t\\tvar float3_pattern = /([\\\\d\\\\.\\\\+\\\\-e]+),?\\\\s+([\\\\d\\\\.\\\\+\\\\-e]+),?\\\\s+([\\\\d\\\\.\\\\+\\\\-e]+)/;\\n\\n\\t\\t\\t/**\\n\\t\\t\\t* Interpolates colors a and b following their relative distance\\n\\t\\t\\t* expressed by t.\\n\\t\\t\\t*\\n\\t\\t\\t* @param float a\\n\\t\\t\\t* @param float b\\n\\t\\t\\t* @param float t\\n\\t\\t\\t* @returns {Color}\\n\\t\\t\\t*/\\n\\t\\t\\tvar interpolateColors = function(a, b, t) {\\n\\t\\t\\t   var deltaR = a.r - b.r;\\n\\t\\t\\t   var deltaG = a.g - b.g;\\n\\t\\t\\t   var deltaB = a.b - b.b;\\n\\n\\t\\t\\t   var c = new THREE.Color();\\n\\n\\t\\t\\t   c.r = a.r - t * deltaR;\\n\\t\\t\\t   c.g = a.g - t * deltaG;\\n\\t\\t\\t   c.b = a.b - t * deltaB;\\n\\n\\t\\t\\t   return c;\\n\\t\\t\\t};\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Vertically paints the faces interpolating between the\\n\\t\\t\\t * specified colors at the specified angels. This is used for the Background\\n\\t\\t\\t * node, but could be applied to other nodes with multiple faces as well.\\n\\t\\t\\t *\\n\\t\\t\\t * When used with the Background node, default is directionIsDown is true if\\n\\t\\t\\t * interpolating the skyColor down from the Zenith. When interpolationg up from\\n\\t\\t\\t * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\\n\\t\\t\\t *\\n\\t\\t\\t * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\\n\\t\\t\\t * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\\n\\t\\t\\t * is linear along the Y axis in any case.\\n\\t\\t\\t *\\n\\t\\t\\t * You must specify one more color than you have angles at the beginning of the colors array.\\n\\t\\t\\t * This is the color of the Zenith (the top of the shape).\\n\\t\\t\\t *\\n\\t\\t\\t * @param geometry\\n\\t\\t\\t * @param radius\\n\\t\\t\\t * @param angles\\n\\t\\t\\t * @param colors\\n\\t\\t\\t * @param boolean directionIsDown Whether to work bottom up or top down.\\n\\t\\t\\t */\\n\\t\\t\\tvar paintFaces = function (geometry, radius, angles, colors, directionIsDown) {\\n\\n\\t\\t\\t\\tvar f, n, p, vertexIndex, color;\\n\\n\\t\\t\\t\\tvar direction = directionIsDown ? 1 : -1;\\n\\n\\t\\t\\t\\tvar faceIndices = [ 'a', 'b', 'c', 'd' ];\\n\\n\\t\\t\\t\\tvar coord = [ ], aColor, bColor, t = 1, A = {}, B = {}, applyColor = false, colorIndex;\\n\\n\\t\\t\\t\\tfor ( var k = 0; k < angles.length; k++ ) {\\n\\n\\t\\t\\t\\t\\tvar vec = { };\\n\\n\\t\\t\\t\\t\\t// push the vector at which the color changes\\n\\t\\t\\t\\t\\tvec.y = direction * ( Math.cos( angles[k] ) * radius);\\n\\n\\t\\t\\t\\t\\tvec.x = direction * ( Math.sin( angles[k] ) * radius);\\n\\n\\t\\t\\t\\t\\tcoord.push( vec );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// painting the colors on the faces\\n\\t\\t\\t\\tfor ( var i = 0; i < geometry.faces.length ; i++ ) {\\n\\n\\t\\t\\t\\t\\tf  = geometry.faces[ i ];\\n\\n\\t\\t\\t\\t\\tn = ( f instanceof THREE.Face3 ) ? 3 : 4;\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < n; j++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvertexIndex = f[ faceIndices[ j ] ];\\n\\n\\t\\t\\t\\t\\t\\tp = geometry.vertices[ vertexIndex ];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var index = 0; index < colors.length; index++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// linear interpolation between aColor and bColor, calculate proportion\\n\\t\\t\\t\\t\\t\\t\\t// A is previous point (angle)\\n\\t\\t\\t\\t\\t\\t\\tif ( index === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tA.x = 0;\\n\\t\\t\\t\\t\\t\\t\\t\\tA.y = directionIsDown ? radius : -1 * radius;\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tA.x = coord[ index-1 ].x;\\n\\t\\t\\t\\t\\t\\t\\t\\tA.y = coord[ index-1 ].y;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// B is current point (angle)\\n\\t\\t\\t\\t\\t\\t\\tB = coord[index];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( undefined !== B ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// p has to be between the points A and B which we interpolate\\n\\t\\t\\t\\t\\t\\t\\t\\tapplyColor = directionIsDown ? p.y <= A.y && p.y > B.y : p.y >= A.y && p.y < B.y;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (applyColor) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbColor = colors[ index + 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\taColor = colors[ index ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// below is simple linear interpolation\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tt = Math.abs( p.y - A.y ) / ( A.y - B.y );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// to make it faster, you can only calculate this if the y coord changes, the color is the same for points with the same y\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcolor = interpolateColors( aColor, bColor, t );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tf.vertexColors[ j ] = color;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t} else if ( undefined === f.vertexColors[ j ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tcolorIndex = directionIsDown ? colors.length -1 : 0;\\n\\t\\t\\t\\t\\t\\t\\t\\tf.vertexColors[ j ] = colors[ colorIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar parseProperty = function (node, line) {\\n\\n\\t\\t\\t\\tvar parts = [], part, property = {}, fieldName;\\n\\n\\t\\t\\t\\t/**\\n\\t\\t\\t\\t * Expression for matching relevant information, such as a name or value, but not the separators\\n\\t\\t\\t\\t * @type {RegExp}\\n\\t\\t\\t\\t */\\n\\t\\t\\t\\tvar regex = /[^\\\\s,\\\\[\\\\]]+/g;\\n\\n\\t\\t\\t\\tvar point, index, angles, colors;\\n\\n\\t\\t\\t\\twhile (null != ( part = regex.exec(line) ) ) {\\n\\t\\t\\t\\t\\tparts.push(part[0]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfieldName = parts[0];\\n\\n\\n\\t\\t\\t\\t// trigger several recorders\\n\\t\\t\\t\\tswitch (fieldName) {\\n\\t\\t\\t\\t\\tcase 'skyAngle':\\n\\t\\t\\t\\t\\tcase 'groundAngle':\\n\\t\\t\\t\\t\\t\\tthis.recordingFieldname = fieldName;\\n\\t\\t\\t\\t\\t\\tthis.isRecordingAngles = true;\\n\\t\\t\\t\\t\\t\\tthis.angles = [];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 'skyColor':\\n\\t\\t\\t\\t\\tcase 'groundColor':\\n\\t\\t\\t\\t\\t\\tthis.recordingFieldname = fieldName;\\n\\t\\t\\t\\t\\t\\tthis.isRecordingColors = true;\\n\\t\\t\\t\\t\\t\\tthis.colors = [];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 'point':\\n\\t\\t\\t\\t\\t\\tthis.recordingFieldname = fieldName;\\n\\t\\t\\t\\t\\t\\tthis.isRecordingPoints = true;\\n\\t\\t\\t\\t\\t\\tthis.points = [];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 'coordIndex':\\n\\t\\t\\t\\t\\t\\tthis.recordingFieldname = fieldName;\\n\\t\\t\\t\\t\\t\\tthis.isRecordingFaces = true;\\n\\t\\t\\t\\t\\t\\tthis.indexes = [];\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (this.isRecordingFaces) {\\n\\n\\t\\t\\t\\t\\t// the parts hold the indexes as strings\\n\\t\\t\\t\\t\\tif (parts.length > 0) {\\n\\t\\t\\t\\t\\t\\tindex = [];\\n\\n\\t\\t\\t\\t\\t\\tfor (var ind = 0;ind < parts.length; ind++) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// the part should either be positive integer or -1\\n\\t\\t\\t\\t\\t\\t\\tif (!/(-?\\\\d+)/.test( parts[ind]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// end of current face\\n\\t\\t\\t\\t\\t\\t\\tif (parts[ind] === \\\"-1\\\") {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (index.length > 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\t   this.indexes.push(index);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// start new one\\n\\t\\t\\t\\t\\t\\t\\t\\tindex = [];\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tindex.push(parseInt( parts[ind]) );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// end\\n\\t\\t\\t\\t\\tif (/]/.exec(line)) {\\n\\t\\t\\t\\t\\t\\tthis.isRecordingFaces = false;\\n\\t\\t\\t\\t\\t\\tnode.coordIndex = this.indexes;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if (this.isRecordingPoints) {\\n\\n\\t\\t\\t\\t\\tparts = float3_pattern.exec(line);\\n\\n\\t\\t\\t\\t\\t// parts may be empty on first and last line\\n\\t\\t\\t\\t\\tif (null != parts) {\\n\\t\\t\\t\\t\\t\\tpoint = {\\n\\t\\t\\t\\t\\t\\t\\tx: parseFloat(parts[1]),\\n\\t\\t\\t\\t\\t\\t\\ty: parseFloat(parts[2]),\\n\\t\\t\\t\\t\\t\\t\\tz: parseFloat(parts[3])\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\tthis.points.push(point);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// end\\n\\t\\t\\t\\t\\tif ( /]/.exec(line) ) {\\n\\t\\t\\t\\t\\t\\tthis.isRecordingPoints = false;\\n\\t\\t\\t\\t\\t\\tnode.points = this.points;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( this.isRecordingAngles ) {\\n\\n\\t\\t\\t\\t\\t// the parts hold the angles as strings\\n\\t\\t\\t\\t\\tif ( parts.length > 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var ind = 0;ind < parts.length; ind++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// the part should be a float\\n\\t\\t\\t\\t\\t\\t\\tif ( ! float_pattern.test( parts[ind] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.angles.push( parseFloat( parts[ind] ) );\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// end\\n\\t\\t\\t\\t\\tif ( /]/.exec(line) ) {\\n\\t\\t\\t\\t\\t\\tthis.isRecordingAngles = false;\\n\\t\\t\\t\\t\\t\\tnode[this.recordingFieldname] = this.angles;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if (this.isRecordingColors) {\\n\\t\\t\\t\\t\\t// this is the float3 regex with the g modifier added, you could also explode the line by comma first (faster probably)\\n\\t\\t\\t\\t\\tvar float3_repeatable = /([\\\\d\\\\.\\\\+\\\\-e]+),?\\\\s+([\\\\d\\\\.\\\\+\\\\-e]+),?\\\\s+([\\\\d\\\\.\\\\+\\\\-e]+)/g;\\n\\n\\t\\t\\t\\t\\twhile( null !== (parts = float3_repeatable.exec(line) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tcolor = {\\n\\t\\t\\t\\t\\t\\t\\tr: parseFloat(parts[1]),\\n\\t\\t\\t\\t\\t\\t\\tg: parseFloat(parts[2]),\\n\\t\\t\\t\\t\\t\\t\\tb: parseFloat(parts[3])\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\tthis.colors.push(color);\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// end\\n\\t\\t\\t\\t\\tif (/]/.exec(line)) {\\n\\t\\t\\t\\t\\t\\tthis.isRecordingColors = false;\\n\\t\\t\\t\\t\\t\\tnode[this.recordingFieldname] = this.colors;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( parts[parts.length -1] !== 'NULL' && fieldName !== 'children') {\\n\\n\\t\\t\\t\\t\\tswitch (fieldName) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'diffuseColor':\\n\\t\\t\\t\\t\\t\\tcase 'emissiveColor':\\n\\t\\t\\t\\t\\t\\tcase 'specularColor':\\n\\t\\t\\t\\t\\t\\tcase 'color':\\n\\n\\t\\t\\t\\t\\t\\t\\tif (parts.length != 4) {\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn('Invalid color format detected for ' + fieldName );\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tproperty = {\\n\\t\\t\\t\\t\\t\\t\\t\\t'r'         : parseFloat(parts[1]),\\n\\t\\t\\t\\t\\t\\t\\t\\t'g'         : parseFloat(parts[2]),\\n\\t\\t\\t\\t\\t\\t\\t\\t'b'         : parseFloat(parts[3])\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'translation':\\n\\t\\t\\t\\t\\t\\tcase 'scale':\\n\\t\\t\\t\\t\\t\\tcase 'size':\\n\\t\\t\\t\\t\\t\\t\\tif (parts.length != 4) {\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn('Invalid vector format detected for ' + fieldName);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tproperty = {\\n\\t\\t\\t\\t\\t\\t\\t\\t'x'         : parseFloat(parts[1]),\\n\\t\\t\\t\\t\\t\\t\\t\\t'y'         : parseFloat(parts[2]),\\n\\t\\t\\t\\t\\t\\t\\t\\t'z'         : parseFloat(parts[3])\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'radius':\\n\\t\\t\\t\\t\\t\\tcase 'topRadius':\\n\\t\\t\\t\\t\\t\\tcase 'bottomRadius':\\n\\t\\t\\t\\t\\t\\tcase 'height':\\n\\t\\t\\t\\t\\t\\tcase 'transparency':\\n\\t\\t\\t\\t\\t\\tcase 'shininess':\\n\\t\\t\\t\\t\\t\\tcase 'ambientIntensity':\\n\\t\\t\\t\\t\\t\\t\\tif (parts.length != 2) {\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn('Invalid single float value specification detected for ' + fieldName);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tproperty = parseFloat(parts[1]);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'rotation':\\n\\t\\t\\t\\t\\t\\t\\tif (parts.length != 5) {\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn('Invalid quaternion format detected for ' + fieldName);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tproperty = {\\n\\t\\t\\t\\t\\t\\t\\t\\t'x'         : parseFloat(parts[1]),\\n\\t\\t\\t\\t\\t\\t\\t\\t'y'         : parseFloat(parts[2]),\\n\\t\\t\\t\\t\\t\\t\\t\\t'z'         : parseFloat(parts[3]),\\n\\t\\t\\t\\t\\t\\t\\t\\t'w'         : parseFloat(parts[4])\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'ccw':\\n\\t\\t\\t\\t\\t\\tcase 'solid':\\n\\t\\t\\t\\t\\t\\tcase 'colorPerVertex':\\n\\t\\t\\t\\t\\t\\tcase 'convex':\\n\\t\\t\\t\\t\\t\\t\\tif (parts.length != 2) {\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn('Invalid format detected for ' + fieldName);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tproperty = parts[1] === 'TRUE' ? true : false;\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tnode[fieldName] = property;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn property;\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar getTree = function ( lines ) {\\n\\n\\t\\t\\t\\tvar tree = { 'string': 'Scene', children: [] };\\n\\t\\t\\t\\tvar current = tree;\\n\\t\\t\\t\\tvar matches;\\n\\t\\t\\t\\tvar specification;\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < lines.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar comment = '';\\n\\n\\t\\t\\t\\t\\tvar line = lines[ i ];\\n\\n\\t\\t\\t\\t\\t// omit whitespace only lines\\n\\t\\t\\t\\t\\tif ( null !== ( result = /^\\\\s+?$/g.exec( line ) ) ) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tline = line.trim();\\n\\n\\t\\t\\t\\t\\t// skip empty lines\\n\\t\\t\\t\\t\\tif (line === '') {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( /#/.exec( line ) ) {\\n\\n\\t\\t\\t\\t\\t\\tvar parts = line.split('#');\\n\\n\\t\\t\\t\\t\\t\\t// discard everything after the #, it is a comment\\n\\t\\t\\t\\t\\t\\tline = parts[0];\\n\\n\\t\\t\\t\\t\\t\\t// well, let's also keep the comment\\n\\t\\t\\t\\t\\t\\tcomment = parts[1];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( matches = /([^\\\\s]*){1}\\\\s?{/.exec( line ) ) { // first subpattern should match the Node name\\n\\n\\t\\t\\t\\t\\t\\tvar block = { 'nodeType' : matches[1], 'string': line, 'parent': current, 'children': [],'comment' : comment};\\n\\t\\t\\t\\t\\t\\tcurrent.children.push( block );\\n\\t\\t\\t\\t\\t\\tcurrent = block;\\n\\n\\t\\t\\t\\t\\t\\tif ( /}/.exec( line ) ) {\\n\\t\\t\\t\\t\\t\\t\\t// example: geometry Box { size 1 1 1 } # all on the same line\\n\\t\\t\\t\\t\\t\\t\\tspecification = /{(.*)}/.exec( line )[ 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t// todo: remove once new parsing is complete?\\n\\t\\t\\t\\t\\t\\t\\tblock.children.push( specification );\\n\\n\\t\\t\\t\\t\\t\\t\\tparseProperty(current, specification);\\n\\n\\t\\t\\t\\t\\t\\t\\tcurrent = current.parent;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( /}/.exec( line ) ) {\\n\\n\\t\\t\\t\\t\\t\\tcurrent = current.parent;\\n\\n\\t\\t\\t\\t\\t} else if ( line !== '' ) {\\n\\n\\t\\t\\t\\t\\t\\tparseProperty(current, line);\\n\\t\\t\\t\\t\\t\\t// todo: remove once new parsing is complete? we still do not parse geometry and appearance the new way\\n\\t\\t\\t\\t\\t\\tcurrent.children.push( line );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tree;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar parseNode = function ( data, parent ) {\\n\\n\\t\\t\\t\\t// console.log( data );\\n\\n\\t\\t\\t\\tif ( typeof data === 'string' ) {\\n\\n\\t\\t\\t\\t\\tif ( /USE/.exec( data ) ) {\\n\\n\\t\\t\\t\\t\\t\\tvar defineKey = /USE\\\\s+?(\\\\w+)/.exec( data )[ 1 ];\\n\\n\\t\\t\\t\\t\\t\\tif (undefined == defines[defineKey]) {\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn(defineKey + ' is not defined.');\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( /appearance/.exec( data ) && defineKey ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tparent.material = defines[ defineKey ].clone();\\n\\n\\t\\t\\t\\t\\t\\t\\t} else if ( /geometry/.exec( data ) && defineKey ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tparent.geometry = defines[ defineKey ].clone();\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// the solid property is not cloned with clone(), is only needed for VRML loading, so we need to transfer it\\n\\t\\t\\t\\t\\t\\t\\t\\tif (undefined !== defines[ defineKey ].solid && defines[ defineKey ].solid === false) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tparent.geometry.solid = false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tparent.material.side = THREE.DoubleSide;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t} else if (defineKey){\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar object = defines[ defineKey ].clone();\\n\\t\\t\\t\\t\\t\\t\\t\\tparent.add( object );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar object = parent;\\n\\n\\t\\t\\t\\tif ( 'Transform' === data.nodeType || 'Group' === data.nodeType ) {\\n\\n\\t\\t\\t\\t\\tobject = new THREE.Object3D();\\n\\n\\t\\t\\t\\t\\tif ( /DEF/.exec( data.string ) ) {\\n\\t\\t\\t\\t\\t\\tobject.name = /DEF\\\\s+(\\\\w+)/.exec( data.string )[ 1 ];\\n\\t\\t\\t\\t\\t\\tdefines[ object.name ] = object;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( undefined !== data['translation'] ) {\\n\\n\\t\\t\\t\\t\\t\\tvar t = data.translation;\\n\\n\\t\\t\\t\\t\\t\\tobject.position.set(t.x, t.y, t.z);\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( undefined !== data.rotation ) {\\n\\n\\t\\t\\t\\t\\t\\tvar r = data.rotation;\\n\\n\\t\\t\\t\\t\\t\\tobject.quaternion.setFromAxisAngle( new THREE.Vector3( r.x, r.y, r.z ), r.w );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( undefined !== data.scale ) {\\n\\n\\t\\t\\t\\t\\t\\tvar s = data.scale;\\n\\n\\t\\t\\t\\t\\t\\tobject.scale.set( s.x, s.y, s.z );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tparent.add( object );\\n\\n\\t\\t\\t\\t} else if ( 'Shape' === data.nodeType ) {\\n\\n\\t\\t\\t\\t\\tobject = new THREE.Mesh();\\n\\n\\t\\t\\t\\t\\tif ( /DEF/.exec( data.string ) ) {\\n\\n\\t\\t\\t\\t\\t\\tobject.name = /DEF (\\\\w+)/.exec( data.string )[ 1 ];\\n\\n\\t\\t\\t\\t\\t\\tdefines[ object.name ] = object;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tparent.add( object );\\n\\n\\t\\t\\t\\t} else if ( 'Background' === data.nodeType ) {\\n\\n\\t\\t\\t\\t\\tvar segments = 20;\\n\\n\\t\\t\\t\\t\\t// sky (full sphere):\\n\\t\\t\\t\\t\\tvar radius = 2e4;\\n\\n\\t\\t\\t\\t\\tvar skyGeometry = new THREE.SphereGeometry( radius, segments, segments );\\n\\n\\t\\t\\t\\t\\tvar skyMaterial = new THREE.MeshBasicMaterial( { color: 'white', vertexColors: THREE.VertexColors, shading: THREE.NoShading } );\\n\\n\\t\\t\\t\\t\\tskyMaterial.side = THREE.BackSide;\\n\\n\\t\\t\\t\\t\\tskyMaterial.fog = false;\\n\\n\\t\\t\\t\\t\\tskyMaterial.color = new THREE.Color();\\n\\n\\t\\t\\t\\t\\tpaintFaces( skyGeometry, radius, data.skyAngle, data.skyColor, true );\\n\\n\\t\\t\\t\\t\\tvar sky = new THREE.Mesh( skyGeometry, skyMaterial );\\n\\n\\t\\t\\t\\t\\tscene.add( sky );\\n\\n\\t\\t\\t\\t\\t// ground (half sphere):\\n\\n\\t\\t\\t\\t\\tradius = 1.2e4;\\n\\n\\t\\t\\t\\t\\tvar groundGeometry = new THREE.SphereGeometry( radius, segments, segments, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );\\n\\n\\t\\t\\t\\t\\tvar groundMaterial = new THREE.MeshBasicMaterial( { color: 'white', vertexColors: THREE.VertexColors, shading: THREE.NoShading } );\\n\\n\\t\\t\\t\\t\\tgroundMaterial.side = THREE.BackSide;\\n\\n\\t\\t\\t\\t\\tgroundMaterial.fog = false;\\n\\n\\t\\t\\t\\t\\tgroundMaterial.color = new THREE.Color();\\n\\n\\t\\t\\t\\t\\tpaintFaces( groundGeometry, radius, data.groundAngle, data.groundColor, false );\\n\\n\\t\\t\\t\\t\\tvar ground = new THREE.Mesh( groundGeometry, groundMaterial );\\n\\n\\t\\t\\t\\t\\tscene.add( ground );\\n\\n\\t\\t\\t\\t} else if ( /geometry/.exec( data.string ) ) {\\n\\n\\t\\t\\t\\t\\tif ( 'Box' === data.nodeType ) {\\n\\n\\t\\t\\t\\t\\t\\tvar s = data.size;\\n\\n\\t\\t\\t\\t\\t\\tparent.geometry = new THREE.BoxGeometry( s.x, s.y, s.z );\\n\\n\\t\\t\\t\\t\\t} else if ( 'Cylinder' === data.nodeType ) {\\n\\n\\t\\t\\t\\t\\t\\tparent.geometry = new THREE.CylinderGeometry( data.radius, data.radius, data.height );\\n\\n\\t\\t\\t\\t\\t} else if ( 'Cone' === data.nodeType ) {\\n\\n\\t\\t\\t\\t\\t\\tparent.geometry = new THREE.CylinderGeometry( data.topRadius, data.bottomRadius, data.height );\\n\\n\\t\\t\\t\\t\\t} else if ( 'Sphere' === data.nodeType ) {\\n\\n\\t\\t\\t\\t\\t\\tparent.geometry = new THREE.SphereGeometry( data.radius );\\n\\n\\t\\t\\t\\t\\t} else if ( 'IndexedFaceSet' === data.nodeType ) {\\n\\n\\t\\t\\t\\t\\t\\tvar geometry = new THREE.Geometry();\\n\\n\\t\\t\\t\\t\\t\\tvar indexes;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, j = data.children.length; i < j; i++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar child = data.children[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tvar vec;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( 'Coordinate' === child.nodeType ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfor ( var k = 0, l = child.points.length; k < l; k++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar point = child.points[ k ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvec = new THREE.Vector3( point.x, point.y, point.z );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.vertices.push( vec );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tvar skip = 0;\\n\\n\\t\\t\\t\\t\\t\\t// read this: http://math.hws.edu/eck/cs424/notes2013/16_Threejs_Advanced.html\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, j = data.coordIndex.length; i < j; i++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tindexes = data.coordIndex[i];\\n\\n\\t\\t\\t\\t\\t\\t\\t// vrml support multipoint indexed face sets (more then 3 vertices). You must calculate the composing triangles here\\n\\t\\t\\t\\t\\t\\t\\tskip = 0;\\n\\n\\t\\t\\t\\t\\t\\t\\t// todo: this is the time to check if the faces are ordered ccw or not (cw)\\n\\n\\t\\t\\t\\t\\t\\t\\t// Face3 only works with triangles, but IndexedFaceSet allows shapes with more then three vertices, build them of triangles\\n\\t\\t\\t\\t\\t\\t\\twhile ( indexes.length >= 3 && skip < ( indexes.length -2 ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar face = new THREE.Face3(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tindexes[0],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tindexes[skip + 1],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tindexes[skip + 2],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnull // normal, will be added later\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// todo: pass in the color, if a color index is present\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tskip++;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faces.push( face );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( false === data.solid ) {\\n\\t\\t\\t\\t\\t\\t\\tparent.material.side = THREE.DoubleSide;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// we need to store it on the geometry for use with defines\\n\\t\\t\\t\\t\\t\\tgeometry.solid = data.solid;\\n\\n\\t\\t\\t\\t\\t\\tgeometry.computeFaceNormals();\\n\\t\\t\\t\\t\\t\\t//geometry.computeVertexNormals(); // does not show\\n\\t\\t\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\t\\t\\t// see if it's a define\\n\\t\\t\\t\\t\\t\\tif ( /DEF/.exec( data.string ) ) {\\n\\t\\t\\t\\t\\t\\t\\tgeometry.name = /DEF (\\\\w+)/.exec( data.string )[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tdefines[ geometry.name ] = geometry;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tparent.geometry = geometry;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t} else if ( /appearance/.exec( data.string ) ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < data.children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar child = data.children[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( 'Material' === child.nodeType ) {\\n\\t\\t\\t\\t\\t\\t\\tvar material = new THREE.MeshPhongMaterial();\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( undefined !== child.diffuseColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar d = child.diffuseColor;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmaterial.color.setRGB( d.r, d.g, d.b );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( undefined !== child.emissiveColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar e = child.emissiveColor;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmaterial.emissive.setRGB( e.r, e.g, e.b );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( undefined !== child.specularColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar s = child.specularColor;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmaterial.specular.setRGB( s.r, s.g, s.b );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( undefined !== child.transparency ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar t = child.transparency;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// transparency is opposite of opacity\\n\\t\\t\\t\\t\\t\\t\\t\\tmaterial.opacity = Math.abs( 1 - t );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmaterial.transparent = true;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( /DEF/.exec( data.string ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmaterial.name = /DEF (\\\\w+)/.exec( data.string )[ 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdefines[ material.name ] = material;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tparent.material = material;\\n\\n\\t\\t\\t\\t\\t\\t\\t// material found, stop looping\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = data.children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar child = data.children[ i ];\\n\\n\\t\\t\\t\\t\\tparseNode( data.children[ i ], object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tparseNode( getTree( lines ), scene );\\n\\n\\t\\t};\\n\\n\\t\\tvar scene = new THREE.Scene();\\n\\n\\t\\tvar lines = data.split( '\\\\n' );\\n\\n\\t\\tvar header = lines.shift();\\n\\n\\t\\tif ( /V1.0/.exec( header ) ) {\\n\\n\\t\\t\\tparseV1( lines, scene );\\n\\n\\t\\t} else if ( /V2.0/.exec( header ) ) {\\n\\n\\t\\t\\tparseV2( lines, scene );\\n\\n\\t\\t}\\n\\n\\t\\treturn scene;\\n\\n\\t}\\n\\n};\\n\\nTHREE.EventDispatcher.prototype.apply( THREE.VRMLLoader.prototype );\\n\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/VTKLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/VTKLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.VTKLoader = function () {};\\n\\nTHREE.VTKLoader.prototype = {\\n\\n\\tconstructor: THREE.VTKLoader,\\n\\n\\tload: function ( url, callback ) {\\n          var func = \\\"THREE.VTKLoader.load\\\";\\n\\n          if (TiddlyWiki && url.match(/^tw:/)) {\\n            var res = TiddlyWiki.load(url);\\n            //hack.log(\\\"res.length = \\\"+res.length, hack.loader, func);\\n            \\n            var geometry = this.parse(res);\\n            this.dispatchEvent({type: 'load', content: geometry});\\n            if (callback) callback(geometry);\\n           \\n            hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n            return;\\n          }\\n\\t\\tvar scope = this;\\n\\t\\tvar request = new XMLHttpRequest();\\n\\n\\t\\trequest.addEventListener( 'load', function ( event ) {\\n\\n\\t\\t\\tvar geometry = scope.parse( event.target.responseText );\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'load', content: geometry } );\\n\\n\\t\\t\\tif ( callback ) callback( geometry );\\n\\n\\t\\t}, false );\\n\\n\\t\\trequest.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'progress', loaded: event.loaded, total: event.total } );\\n\\n\\t\\t}, false );\\n\\n\\t\\trequest.addEventListener( 'error', function () {\\n\\n\\t\\t\\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\\\'t load URL [' + url + ']' } );\\n\\n\\t\\t}, false );\\n\\n\\t\\trequest.open( 'GET', url, true );\\n\\t\\trequest.send( null );\\n\\n\\t},\\n\\n\\tparse: function ( data ) {\\n\\n\\t\\tvar geometry = new THREE.Geometry();\\n\\n\\t\\tvar vertex = function ( x, y, z ) {\\n\\n\\t\\t\\tgeometry.vertices.push( new THREE.Vector3( x, y, z ) );\\n\\n\\t\\t}\\n\\n\\t\\tvar face3 = function ( a, b, c ) {\\n\\n\\t\\t\\tgeometry.faces.push( new THREE.Face3( a, b, c ) );\\n\\n\\t\\t}\\n\\n\\t\\tvar pattern, result;\\n\\n\\t\\t// float float float\\n\\n\\t\\tpattern = /([\\\\+|\\\\-]?[\\\\d]+[\\\\.]*[\\\\d|\\\\-|e]*)[ ]+([\\\\+|\\\\-]?[\\\\d]+[\\\\.]*[\\\\d|\\\\-|e]*)[ ]+([\\\\+|\\\\-]?[\\\\d]+[\\\\.]*[\\\\d|\\\\-|e]*)/g;\\n\\n\\t\\twhile ( ( result = pattern.exec( data ) ) !== null ) {\\n\\n\\t\\t\\t// [\\\"1.0 2.0 3.0\\\", \\\"1.0\\\", \\\"2.0\\\", \\\"3.0\\\"]\\n\\n\\t\\t\\tvertex( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\\n\\n\\t\\t}\\n\\n\\t\\t// 3 int int int\\n\\n\\t\\tpattern = /3[ ]+([\\\\d]+)[ ]+([\\\\d]+)[ ]+([\\\\d]+)/g;\\n\\n\\t\\twhile ( ( result = pattern.exec( data ) ) !== null ) {\\n\\n\\t\\t\\t// [\\\"3 1 2 3\\\", \\\"1\\\", \\\"2\\\", \\\"3\\\"]\\n\\n\\t\\t\\tface3( parseInt( result[ 1 ] ), parseInt( result[ 2 ] ), parseInt( result[ 3 ] ) );\\n\\n\\t\\t}\\n\\n\\t\\t// 4 int int int int\\n\\n\\t\\tpattern = /4[ ]+([\\\\d]+)[ ]+([\\\\d]+)[ ]+([\\\\d]+)[ ]+([\\\\d]+)/g;\\n\\n\\t\\twhile ( ( result = pattern.exec( data ) ) !== null ) {\\n\\n\\t\\t\\t// [\\\"4 1 2 3 4\\\", \\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\"]\\n\\n\\t\\t\\tface3( parseInt( result[ 1 ] ), parseInt( result[ 2 ] ), parseInt( result[ 4 ] ) );\\n\\t\\t\\tface3( parseInt( result[ 2 ] ), parseInt( result[ 3 ] ), parseInt( result[ 4 ] ) );\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.computeFaceNormals();\\n\\t\\tgeometry.computeVertexNormals();\\n\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\treturn geometry;\\n\\n\\t}\\n\\n};\\n\\nTHREE.EventDispatcher.prototype.apply( THREE.VTKLoader.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/msgpack-js.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/msgpack-js.js\",\n            \"module-type\": \"library\",\n            \"text\": \"THREE.msgpack = {};\\n\\nTHREE.msgpack.inspect = function(buffer) {\\n  if (buffer === undefined) return \\\"undefined\\\";\\n  var view;\\n  var type;\\n  if (buffer instanceof ArrayBuffer) {\\n    type = \\\"ArrayBuffer\\\";\\n    view = new DataView(buffer);\\n  }\\n  else if (buffer instanceof DataView) {\\n    type = \\\"DataView\\\";\\n    view = buffer;\\n  }\\n  if (!view) return JSON.stringify(buffer);\\n  var bytes = [];\\n  for (var i = 0; i < buffer.byteLength; i++) {\\n    if (i > 20) {\\n      bytes.push(\\\"...\\\");\\n      break;\\n    }\\n    var byte = view.getUint8(i).toString(16);\\n    if (byte.length === 1) byte = \\\"0\\\" + byte;\\n    bytes.push(byte);\\n  }\\n  return \\\"<\\\" + type + \\\" \\\" + bytes.join(\\\" \\\") + \\\">\\\";\\n};\\n\\n// Encode string as utf8 into dataview at offset\\nTHREE.msgpack.utf8Write = function(view, offset, string) {\\n  var byteLength = view.byteLength;\\n  for(var i = 0, l = string.length; i < l; i++) {\\n    var codePoint = string.charCodeAt(i);\\n\\n    // One byte of UTF-8\\n    if (codePoint < 0x80) {\\n      view.setUint8(offset++, codePoint >>> 0 & 0x7f | 0x00);\\n      continue;\\n    }\\n\\n    // Two bytes of UTF-8\\n    if (codePoint < 0x800) {\\n      view.setUint8(offset++, codePoint >>> 6 & 0x1f | 0xc0);\\n      view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);\\n      continue;\\n    }\\n\\n    // Three bytes of UTF-8.  \\n    if (codePoint < 0x10000) {\\n      view.setUint8(offset++, codePoint >>> 12 & 0x0f | 0xe0);\\n      view.setUint8(offset++, codePoint >>> 6  & 0x3f | 0x80);\\n      view.setUint8(offset++, codePoint >>> 0  & 0x3f | 0x80);\\n      continue;\\n    }\\n\\n    // Four bytes of UTF-8\\n    if (codePoint < 0x110000) {\\n      view.setUint8(offset++, codePoint >>> 18 & 0x07 | 0xf0);\\n      view.setUint8(offset++, codePoint >>> 12 & 0x3f | 0x80);\\n      view.setUint8(offset++, codePoint >>> 6  & 0x3f | 0x80);\\n      view.setUint8(offset++, codePoint >>> 0  & 0x3f | 0x80);\\n      continue;\\n    }\\n    throw new Error(\\\"bad codepoint \\\" + codePoint);\\n  }\\n};\\n\\nTHREE.msgpack.utf8Read = function(view, offset, length) {\\n  var string = \\\"\\\";\\n  for (var i = offset, end = offset + length; i < end; i++) {\\n    var byte = view.getUint8(i);\\n    // One byte character\\n    if ((byte & 0x80) === 0x00) {\\n      string += String.fromCharCode(byte);\\n      continue;\\n    }\\n    // Two byte character\\n    if ((byte & 0xe0) === 0xc0) {\\n      string += String.fromCharCode(\\n        ((byte & 0x0f) << 6) | \\n        (view.getUint8(++i) & 0x3f)\\n      );\\n      continue;\\n    }\\n    // Three byte character\\n    if ((byte & 0xf0) === 0xe0) {\\n      string += String.fromCharCode(\\n        ((byte & 0x0f) << 12) |\\n        ((view.getUint8(++i) & 0x3f) << 6) |\\n        ((view.getUint8(++i) & 0x3f) << 0)\\n      );\\n      continue;\\n    }\\n    // Four byte character\\n    if ((byte & 0xf8) === 0xf0) {\\n      string += String.fromCharCode(\\n        ((byte & 0x07) << 18) |\\n        ((view.getUint8(++i) & 0x3f) << 12) |\\n        ((view.getUint8(++i) & 0x3f) << 6) |\\n        ((view.getUint8(++i) & 0x3f) << 0)\\n      );\\n      continue;\\n    }\\n    throw new Error(\\\"Invalid byte \\\" + byte.toString(16));\\n  }\\n  return string;\\n};\\n\\nTHREE.msgpack.utf8ByteCount = function(string) {\\n  var count = 0;\\n  for(var i = 0, l = string.length; i < l; i++) {\\n    var codePoint = string.charCodeAt(i);\\n    if (codePoint < 0x80) {\\n      count += 1;\\n      continue;\\n    }\\n    if (codePoint < 0x800) {\\n      count += 2;\\n      continue;\\n    }\\n    if (codePoint < 0x10000) {\\n      count += 3;\\n      continue;\\n    }\\n    if (codePoint < 0x110000) {\\n      count += 4;\\n      continue;\\n    }\\n    throw new Error(\\\"bad codepoint \\\" + codePoint);\\n  }\\n  return count;\\n};\\n\\nTHREE.msgpack.encode = function(value) {\\n  var buffer = new ArrayBuffer(sizeof(value));\\n  var view = new DataView(buffer);\\n  THREE.msgpack.encode1(value, view, 0);\\n  return buffer;\\n};\\n\\n// http://wiki.msgpack.org/display/MSGPACK/Format+specification\\n// I've extended the protocol to have two new types that were previously reserved.\\n//   buffer 16  11011000  0xd8\\n//   buffer 32  11011001  0xd9\\n// These work just like raw16 and raw32 except they are node buffers instead of strings.\\n//\\n// Also I've added a type for `undefined`\\n//   undefined  11000100  0xc4\\n\\nTHREE.msgpack.Decoder = function(view, offset) {\\n  this.offset = offset || 0;\\n  this.view = view;\\n};\\nTHREE.msgpack.Decoder.prototype.map = function (length) {\\n  var value = {};\\n  for (var i = 0; i < length; i++) {\\n    var key = this.parse();\\n    value[key] = this.parse();\\n  }\\n  return value;\\n};\\nTHREE.msgpack.Decoder.prototype.buf = function (length) {\\n  var value = new ArrayBuffer(length);\\n  (new Uint8Array(value)).set(new Uint8Array(this.view.buffer, this.offset, length), 0);\\n  this.offset += length;\\n  return value;\\n};\\nTHREE.msgpack.Decoder.prototype.raw = function (length) {\\n  var value = THREE.msgpack.utf8Read(this.view, this.offset, length);\\n  this.offset += length;\\n  return value;\\n};\\nTHREE.msgpack.Decoder.prototype.array = function (length) {\\n  var value = new Array(length);\\n  for (var i = 0; i < length; i++) {\\n    value[i] = this.parse();\\n  }\\n  return value;\\n};\\nTHREE.msgpack.Decoder.prototype.parse = function () {\\n  var type = this.view.getUint8(this.offset);\\n  var value, length;\\n  // FixRaw\\n  if ((type & 0xe0) === 0xa0) {\\n    length = type & 0x1f;\\n    this.offset++;\\n    return this.raw(length);\\n  }\\n  // FixMap\\n  if ((type & 0xf0) === 0x80) {\\n    length = type & 0x0f;\\n    this.offset++;\\n    return this.map(length);\\n  }\\n  // FixArray\\n  if ((type & 0xf0) === 0x90) {\\n    length = type & 0x0f;\\n    this.offset++;\\n    return this.array(length);\\n  }\\n  // Positive FixNum\\n  if ((type & 0x80) === 0x00) {\\n    this.offset++;\\n    return type;\\n  }\\n  // Negative Fixnum\\n  if ((type & 0xe0) === 0xe0) {\\n    value = this.view.getInt8(this.offset);\\n    this.offset++;\\n    return value;\\n  }\\n  switch (type) {\\n  // raw 16\\n  case 0xda:\\n    length = this.view.getUint16(this.offset + 1);\\n    this.offset += 3;\\n    return this.raw(length);\\n  // raw 32\\n  case 0xdb:\\n    length = this.view.getUint32(this.offset + 1);\\n    this.offset += 5;\\n    return this.raw(length);\\n  // nil\\n  case 0xc0:\\n    this.offset++;\\n    return null;\\n  // false\\n  case 0xc2:\\n    this.offset++;\\n    return false;\\n  // true\\n  case 0xc3:\\n    this.offset++;\\n    return true;\\n  // undefined\\n  case 0xc4:\\n    this.offset++;\\n    return undefined;\\n  // uint8\\n  case 0xcc:\\n    value = this.view.getUint8(this.offset + 1);\\n    this.offset += 2;\\n    return value;\\n  // uint 16\\n  case 0xcd:\\n    value = this.view.getUint16(this.offset + 1);\\n    this.offset += 3;\\n    return value;\\n  // uint 32\\n  case 0xce:\\n    value = this.view.getUint32(this.offset + 1);\\n    this.offset += 5;\\n    return value;\\n  // int 8\\n  case 0xd0:\\n    value = this.view.getInt8(this.offset + 1);\\n    this.offset += 2;\\n    return value;\\n  // int 16\\n  case 0xd1:\\n    value = this.view.getInt16(this.offset + 1);\\n    this.offset += 3;\\n    return value;\\n  // int 32\\n  case 0xd2:\\n    value = this.view.getInt32(this.offset + 1);\\n    this.offset += 5;\\n    return value;\\n  // map 16\\n  case 0xde:\\n    length = this.view.getUint16(this.offset + 1);\\n    this.offset += 3;\\n    return this.map(length);\\n  // map 32\\n  case 0xdf:\\n    length = this.view.getUint32(this.offset + 1);\\n    this.offset += 5;\\n    return this.map(length);\\n  // array 16\\n  case 0xdc:\\n    length = this.view.getUint16(this.offset + 1);\\n    this.offset += 3;\\n    return this.array(length);\\n  // array 32\\n  case 0xdd:\\n    length = this.view.getUint32(this.offset + 1);\\n    this.offset += 5;\\n    return this.array(length);\\n  // buffer 16\\n  case 0xd8:\\n    length = this.view.getUint16(this.offset + 1);\\n    this.offset += 3;\\n    return this.buf(length);\\n  // buffer 32\\n  case 0xd9:\\n    length = this.view.getUint32(this.offset + 1);\\n    this.offset += 5;\\n    return this.buf(length);\\n  // float\\n  case 0xca:\\n    value = this.view.getFloat32(this.offset + 1);\\n    this.offset += 5;\\n    return value;\\n  // double\\n  case 0xcb:\\n    value = this.view.getFloat64(this.offset + 1);\\n    this.offset += 9;\\n    return value;\\n  }\\n  throw new Error(\\\"Unknown type 0x\\\" + type.toString(16));\\n};\\nTHREE.msgpack.decode = function(buffer) {\\n  var view = new DataView(buffer);\\n  var decoder = new THREE.msgpack.Decoder(view);\\n  var value = decoder.parse();\\n  if (decoder.offset !== buffer.byteLength) throw new Error((buffer.byteLength - decoder.offset) + \\\" trailing bytes\\\");\\n  return value;\\n};\\n\\nTHREE.msgpack.encode1 = function(value, view, offset) {\\n  var type = typeof value;\\n\\n  // Strings Bytes\\n  if (type === \\\"string\\\") {\\n    var length = utf8ByteCount(value);\\n    // fix raw\\n    if (length < 0x20) {\\n      view.setUint8(offset, length | 0xa0);\\n      THREE.msgpack.utf8Write(view, offset + 1, value);\\n      return 1 + length;\\n    }\\n    // raw 16\\n    if (length < 0x10000) {\\n      view.setUint8(offset, 0xda);\\n      view.setUint16(offset + 1, length);\\n      THREE.msgpack.utf8Write(view, offset + 3, value);\\n      return 3 + length;\\n    }\\n    // raw 32\\n    if (length < 0x100000000) {\\n      view.setUint8(offset, 0xdb);\\n      view.setUint32(offset + 1, length);\\n      THREE.msgpack.utf8Write(view, offset + 5, value);\\n      return 5 + length;\\n    }\\n  }\\n\\n  if (value instanceof ArrayBuffer) {\\n    var length = value.byteLength;\\n    // buffer 16\\n    if (length < 0x10000) {\\n      view.setUint8(offset, 0xd8);\\n      view.setUint16(offset + 1, length);\\n      (new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 3);\\n      return 3 + length;\\n    }\\n    // buffer 32\\n    if (length < 0x100000000) {\\n      view.setUint8(offset, 0xd9);\\n      view.setUint32(offset + 1, length);\\n      (new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 5);\\n      return 5 + length;\\n    }\\n  }\\n  \\n  if (type === \\\"number\\\") {\\n    // Floating Point\\n    if ((value << 0) !== value) {\\n      view.setUint8(offset, 0xcb);\\n      view.setFloat64(offset + 1, value);\\n      return 9;\\n    }\\n\\n    // Integers\\n    if (value >=0) {\\n      // positive fixnum\\n      if (value < 0x80) {\\n        view.setUint8(offset, value);\\n        return 1;\\n      }\\n      // uint 8\\n      if (value < 0x100) {\\n        view.setUint8(offset, 0xcc);\\n        view.setUint8(offset + 1, value);\\n        return 2;\\n      }\\n      // uint 16\\n      if (value < 0x10000) {\\n        view.setUint8(offset, 0xcd);\\n        view.setUint16(offset + 1, value);\\n        return 3;\\n      }\\n      // uint 32\\n      if (value < 0x100000000) {\\n        view.setUint8(offset, 0xce);\\n        view.setUint32(offset + 1, value);\\n        return 5;\\n      }\\n      throw new Error(\\\"Number too big 0x\\\" + value.toString(16));\\n    }\\n    // negative fixnum\\n    if (value >= -0x20) {\\n      view.setInt8(offset, value);\\n      return 1;\\n    }\\n    // int 8\\n    if (value >= -0x80) {\\n      view.setUint8(offset, 0xd0);\\n      view.setInt8(offset + 1, value);\\n      return 2;\\n    }\\n    // int 16\\n    if (value >= -0x8000) {\\n      view.setUint8(offset, 0xd1);\\n      view.setInt16(offset + 1, value);\\n      return 3;\\n    }\\n    // int 32\\n    if (value >= -0x80000000) {\\n      view.setUint8(offset, 0xd2);\\n      view.setInt32(offset + 1, value);\\n      return 5;\\n    }\\n    throw new Error(\\\"Number too small -0x\\\" + (-value).toString(16).substr(1));\\n  }\\n  \\n  // undefined\\n  if (type === \\\"undefined\\\") {\\n    view.setUint8(offset, 0xc4);\\n    return 1;\\n  }\\n  \\n  // null\\n  if (value === null) {\\n    view.setUint8(offset, 0xc0);\\n    return 1;\\n  }\\n\\n  // Boolean\\n  if (type === \\\"boolean\\\") {\\n    view.setUint8(offset, value ? 0xc3 : 0xc2);\\n    return 1;\\n  }\\n  \\n  // Container Types\\n  if (type === \\\"object\\\") {\\n    var length, size = 0;\\n    var isArray = Array.isArray(value);\\n\\n    if (isArray) {\\n      length = value.length;\\n    }\\n    else {\\n      var keys = Object.keys(value);\\n      length = keys.length;\\n    }\\n\\n    var size;\\n    if (length < 0x10) {\\n      view.setUint8(offset, length | (isArray ? 0x90 : 0x80));\\n      size = 1;\\n    }\\n    else if (length < 0x10000) {\\n      view.setUint8(offset, isArray ? 0xdc : 0xde);\\n      view.setUint16(offset + 1, length);\\n      size = 3;\\n    }\\n    else if (length < 0x100000000) {\\n      view.setUint8(offset, isArray ? 0xdd : 0xdf);\\n      view.setUint32(offset + 1, length);\\n      size = 5;\\n    }\\n\\n    if (isArray) {\\n      for (var i = 0; i < length; i++) {\\n        size += THREE.msgpack.encode(value[i], view, offset + size);\\n      }\\n    }\\n    else {\\n      for (var i = 0; i < length; i++) {\\n        var key = keys[i];\\n        size += THREE.msgpack.encode(key, view, offset + size);\\n        size += THREE.msgpack.encode(value[key], view, offset + size);\\n      }\\n    }\\n    \\n    return size;\\n  }\\n  throw new Error(\\\"Unknown type \\\" + type);\\n};\\n\\nTHREE.msgpack.sizeof = function(value) {\\n  var type = typeof value;\\n\\n  // Raw Bytes\\n  if (type === \\\"string\\\") {\\n    var length = THREE.msgpack.utf8ByteCount(value);\\n    if (length < 0x20) {\\n      return 1 + length;\\n    }\\n    if (length < 0x10000) {\\n      return 3 + length;\\n    }\\n    if (length < 0x100000000) {\\n      return 5 + length;\\n    }\\n  }\\n  \\n  if (value instanceof ArrayBuffer) {\\n    var length = value.byteLength;\\n    if (length < 0x10000) {\\n      return 3 + length;\\n    }\\n    if (length < 0x100000000) {\\n      return 5 + length;\\n    }\\n  }\\n  \\n  if (type === \\\"number\\\") {\\n    // Floating Point\\n    // double\\n    if (value << 0 !== value) return 9;\\n\\n    // Integers\\n    if (value >=0) {\\n      // positive fixnum\\n      if (value < 0x80) return 1;\\n      // uint 8\\n      if (value < 0x100) return 2;\\n      // uint 16\\n      if (value < 0x10000) return 3;\\n      // uint 32\\n      if (value < 0x100000000) return 5;\\n      // uint 64\\n      if (value < 0x10000000000000000) return 9;\\n      throw new Error(\\\"Number too big 0x\\\" + value.toString(16));\\n    }\\n    // negative fixnum\\n    if (value >= -0x20) return 1;\\n    // int 8\\n    if (value >= -0x80) return 2;\\n    // int 16\\n    if (value >= -0x8000) return 3;\\n    // int 32\\n    if (value >= -0x80000000) return 5;\\n    // int 64\\n    if (value >= -0x8000000000000000) return 9;\\n    throw new Error(\\\"Number too small -0x\\\" + value.toString(16).substr(1));\\n  }\\n  \\n  // Boolean, null, undefined\\n  if (type === \\\"boolean\\\" || type === \\\"undefined\\\" || value === null) return 1;\\n  \\n  // Container Types\\n  if (type === \\\"object\\\") {\\n    var length, size = 0;\\n    if (Array.isArray(value)) {\\n      length = value.length;\\n      for (var i = 0; i < length; i++) {\\n        size += sizeof(value[i]);\\n      }\\n    }\\n    else {\\n      var keys = Object.keys(value);\\n      length = keys.length;\\n      for (var i = 0; i < length; i++) {\\n        var key = keys[i];\\n        size += sizeof(key) + sizeof(value[key]);\\n      }\\n    }\\n    if (length < 0x10) {\\n      return 1 + size;\\n    }\\n    if (length < 0x10000) {\\n      return 3 + size;\\n    }\\n    if (length < 0x100000000) {\\n      return 5 + size;\\n    }\\n    throw new Error(\\\"Array or object too long 0x\\\" + length.toString(16));\\n  }\\n  throw new Error(\\\"Unknown type \\\" + type);\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/CTMLoader.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/CTMLoader.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * Loader for CTM encoded models generated by OpenCTM tools:\\n *\\thttp://openctm.sourceforge.net/\\n *\\n * Uses js-openctm library by Juan Mellado\\n *\\thttp://code.google.com/p/js-openctm/\\n *\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.CTMLoader = function ( showStatus ) {\\n\\n\\tTHREE.Loader.call( this, showStatus );\\n\\n};\\n\\nTHREE.CTMLoader.prototype = Object.create( THREE.Loader.prototype );\\n\\n// Load multiple CTM parts defined in JSON\\n\\nTHREE.CTMLoader.prototype.loadParts = function( url, callback, parameters ) {\\n  var func = \\\"THREE.CTMLoader.loadParts\\\";\\n\\n\\tparameters = parameters || {};\\n\\n\\tvar scope = this;\\n\\n  if (TiddlyWiki && url.match(/^tw:/)) {\\n    var res = TiddlyWiki.load(url);\\n    //hack.log(\\\"res.length = \\\"+res.length, hack.loader, func);\\n\\n    var basePath = parameters.basePath ? parameters.basePath : this.extractUrlBase(url);\\n    var jsonObject = JSON.parse(res);\\n    var materials = [], geometries = [], counter = 0;\\n    function callbackFinal(geometry) {\\n      counter += 1;\\n      geometries.push(geometry);\\n      if (counter === jsonObject.offsets.length) {\\n\\tcallback(geometries, materials);\\n      }\\n    }\\n\\n    // init materials\\n    for (var i = 0; i < jsonObject.materials.length; i++) {\\n      materials[i] = scope.createMaterial(jsonObject.materials[i], basePath);\\n    }\\n\\n    // load joined CTM file\\n    var partUrl = basePath + jsonObject.data;\\n    var parametersPart = {useWorker: parameters.useWorker, offsets: jsonObject.offsets};\\n    scope.load(partUrl, callbackFinal, parametersPart);\\n\\n    hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n    return;\\n  }\\n\\n\\tvar xhr = new XMLHttpRequest();\\n\\n\\tvar basePath = parameters.basePath ? parameters.basePath : this.extractUrlBase( url );\\n\\n\\txhr.onreadystatechange = function() {\\n\\n\\t\\tif ( xhr.readyState === 4 ) {\\n\\n\\t\\t\\tif ( xhr.status === 200 || xhr.status === 0 ) {\\n\\n\\t\\t\\t\\tvar jsonObject = JSON.parse( xhr.responseText );\\n\\n\\t\\t\\t\\tvar materials = [], geometries = [], counter = 0;\\n\\n\\t\\t\\t\\tfunction callbackFinal( geometry ) {\\n\\n\\t\\t\\t\\t\\tcounter += 1;\\n\\n\\t\\t\\t\\t\\tgeometries.push( geometry );\\n\\n\\t\\t\\t\\t\\tif ( counter === jsonObject.offsets.length ) {\\n\\n\\t\\t\\t\\t\\t\\tcallback( geometries, materials );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t// init materials\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < jsonObject.materials.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmaterials[ i ] = scope.createMaterial( jsonObject.materials[ i ], basePath );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// load joined CTM file\\n\\n\\t\\t\\t\\tvar partUrl = basePath + jsonObject.data;\\n\\t\\t\\t\\tvar parametersPart = { useWorker: parameters.useWorker, offsets: jsonObject.offsets };\\n\\t\\t\\t\\tscope.load( partUrl, callbackFinal, parametersPart );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\txhr.open( \\\"GET\\\", url, true );\\n\\txhr.setRequestHeader( \\\"Content-Type\\\", \\\"text/plain\\\" );\\n\\txhr.send( null );\\n\\n};\\n\\n// Load CTMLoader compressed models\\n//\\t- parameters\\n//\\t\\t- url (required)\\n//\\t\\t- callback (required)\\n\\nTHREE.CTMLoader.prototype.load = function( url, callback, parameters ) {\\n  var func = \\\"THREE.CTMLoader.load\\\";\\n\\n\\tparameters = parameters || {};\\n\\n\\tvar scope = this;\\n\\n\\tvar offsets = parameters.offsets !== undefined ? parameters.offsets : [ 0 ];\\n\\n  if (TiddlyWiki && url.match(/^tw:/)) {\\n    var res = TiddlyWiki.load(url);\\n    //hack.log(\\\"res.length = \\\"+res.length, hack.loader, func);\\n\\n    var binaryData = new Uint8Array(res);\\n    var s = Date.now();\\n    if (parameters.useWorker) {\\n      if (TiddlyWiki) {\\n        alert(func+\\\": Worker() not supported !\\\");\\n        return;\\n      }\\n      var worker = new Worker(\\\"js/loaders/ctm/CTMWorker.js\\\");\\n      worker.onmessage = function(event) {\\n\\tvar files = event.data;\\n\\tfor (var i = 0; i < files.length; i++) {\\n\\t  var ctmFile = files[ i ];\\n\\t  var e1 = Date.now();\\n\\t  // console.log( \\\"CTM data parse time [worker]: \\\" + (e1-s) + \\\" ms\\\" );\\n\\t  scope.createModel( ctmFile, callback );\\n\\t  var e = Date.now();\\n\\t  console.log(\\\"model load time [worker]: \\\" + (e-e1) + \\\" ms, total: \\\" + (e-s));\\n\\t}\\n      };\\n      worker.postMessage({\\\"data\\\": binaryData, \\\"offsets\\\": offsets});\\n    } else {\\n      for (var i = 0; i < offsets.length; i++) {\\n\\tvar stream = new CTM.Stream(binaryData);\\n\\tstream.offset = offsets[i];\\n\\tvar ctmFile = new CTM.File(stream);\\n\\tscope.createModel(ctmFile, callback);\\n      }\\n      //var e = Date.now();\\n      //console.log( \\\"CTM data parse time [inline]: \\\" + (e-s) + \\\" ms\\\" );\\n    }\\n\\n    hack.log(\\\"url: \\\"+url+\\\": loaded\\\", hack.loader, func);\\n    return;\\n  }\\n\\n\\tvar xhr = new XMLHttpRequest(),\\n\\t\\tcallbackProgress = null;\\n\\n\\tvar length = 0;\\n\\n\\txhr.onreadystatechange = function() {\\n\\n\\t\\tif ( xhr.readyState === 4 ) {\\n\\n\\t\\t\\tif ( xhr.status === 200 || xhr.status === 0 ) {\\n\\n\\t\\t\\t\\tvar binaryData = new Uint8Array(xhr.response);\\n\\n\\t\\t\\t\\tvar s = Date.now();\\n\\n\\t\\t\\t\\tif ( parameters.useWorker ) {\\n\\n\\t\\t\\t\\t\\tvar worker = new Worker( \\\"js/loaders/ctm/CTMWorker.js\\\" );\\n\\n\\t\\t\\t\\t\\tworker.onmessage = function( event ) {\\n\\n\\t\\t\\t\\t\\t\\tvar files = event.data;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < files.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar ctmFile = files[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tvar e1 = Date.now();\\n\\t\\t\\t\\t\\t\\t\\t// console.log( \\\"CTM data parse time [worker]: \\\" + (e1-s) + \\\" ms\\\" );\\n\\n\\t\\t\\t\\t\\t\\t\\tscope.createModel( ctmFile, callback );\\n\\n\\t\\t\\t\\t\\t\\t\\tvar e = Date.now();\\n\\t\\t\\t\\t\\t\\t\\tconsole.log( \\\"model load time [worker]: \\\" + (e-e1) + \\\" ms, total: \\\" + (e-s));\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\tworker.postMessage( { \\\"data\\\": binaryData, \\\"offsets\\\": offsets } );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < offsets.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar stream = new CTM.Stream( binaryData );\\n\\t\\t\\t\\t\\t\\tstream.offset = offsets[ i ];\\n\\n\\t\\t\\t\\t\\t\\tvar ctmFile = new CTM.File( stream );\\n\\n\\t\\t\\t\\t\\t\\tscope.createModel( ctmFile, callback );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//var e = Date.now();\\n\\t\\t\\t\\t\\t//console.log( \\\"CTM data parse time [inline]: \\\" + (e-s) + \\\" ms\\\" );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.error( \\\"Couldn't load [\\\" + url + \\\"] [\\\" + xhr.status + \\\"]\\\" );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else if ( xhr.readyState === 3 ) {\\n\\n\\t\\t\\tif ( callbackProgress ) {\\n\\n\\t\\t\\t\\tif ( length === 0 ) {\\n\\n\\t\\t\\t\\t\\tlength = xhr.getResponseHeader( \\\"Content-Length\\\" );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else if ( xhr.readyState === 2 ) {\\n\\n\\t\\t\\tlength = xhr.getResponseHeader( \\\"Content-Length\\\" );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\txhr.open( \\\"GET\\\", url, true );\\n\\txhr.responseType = \\\"arraybuffer\\\";\\n\\n\\txhr.send( null );\\n\\n};\\n\\n\\nTHREE.CTMLoader.prototype.createModel = function ( file, callback ) {\\n\\n\\tvar Model = function () {\\n\\n\\t\\tTHREE.BufferGeometry.call( this );\\n\\n\\t\\tthis.materials = [];\\n\\n\\t\\tvar indices = file.body.indices,\\n\\t\\tpositions = file.body.vertices,\\n\\t\\tnormals = file.body.normals;\\n\\n\\t\\tvar uvs, colors;\\n\\n\\t\\tvar uvMaps = file.body.uvMaps;\\n\\n\\t\\tif ( uvMaps !== undefined && uvMaps.length > 0 ) {\\n\\n\\t\\t\\tuvs = uvMaps[ 0 ].uv;\\n\\n\\t\\t}\\n\\n\\t\\tvar attrMaps = file.body.attrMaps;\\n\\n\\t\\tif ( attrMaps !== undefined && attrMaps.length > 0 && attrMaps[ 0 ].name === 'Color' ) {\\n\\n\\t\\t\\tcolors = attrMaps[ 0 ].attr;\\n\\n\\t\\t}\\n\\n\\t\\tthis.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\\n\\t\\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\\n\\n\\t\\tif ( normals !== undefined ) {\\n\\n\\t\\t\\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\\n\\n\\t\\t}\\n\\n\\t\\tif ( uvs !== undefined ) {\\n\\n\\t\\t\\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\\n\\n\\t\\t}\\n\\n\\t\\tif ( colors !== undefined ) {\\n\\n\\t\\t\\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 4 ) );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tModel.prototype = Object.create( THREE.BufferGeometry.prototype );\\n\\n\\tvar geometry = new Model();\\n\\n\\tgeometry.computeOffsets();\\n\\n\\t// compute vertex normals if not present in the CTM model\\n\\tif ( geometry.attributes[ \\\"normal\\\" ] === undefined ) {\\n\\t\\tgeometry.computeVertexNormals();\\n\\t}\\n\\n\\tcallback( geometry );\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/ctm.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/ctm.js\",\n            \"module-type\": \"library\",\n            \"text\": \"(function(){\\n/*\\nCopyright (c) 2011 Juan Mellado\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n*/\\n\\n/*\\nReferences:\\n- \\\"OpenCTM: The Open Compressed Triangle Mesh file format\\\" by Marcus Geelnard\\n  http://openctm.sourceforge.net/\\n*/\\n\\nvar CTM = CTM || {};\\n\\nCTM.CompressionMethod = {\\n  RAW: 0x00574152,\\n  MG1: 0x0031474d,\\n  MG2: 0x0032474d\\n};\\n\\nCTM.Flags = {\\n  NORMALS: 0x00000001\\n};\\n\\nCTM.File = function(stream){\\n  this.load(stream);\\n};\\n\\nCTM.File.prototype.load = function(stream){\\n  this.header = new CTM.FileHeader(stream);\\n\\n  this.body = new CTM.FileBody(this.header);\\n  \\n  this.getReader().read(stream, this.body);\\n};\\n\\nCTM.File.prototype.getReader = function(){\\n  var reader;\\n\\n  switch(this.header.compressionMethod){\\n    case CTM.CompressionMethod.RAW:\\n      reader = new CTM.ReaderRAW();\\n      break;\\n    case CTM.CompressionMethod.MG1:\\n      reader = new CTM.ReaderMG1();\\n      break;\\n    case CTM.CompressionMethod.MG2:\\n      reader = new CTM.ReaderMG2();\\n      break;\\n  }\\n\\n  return reader;\\n};\\n\\nCTM.FileHeader = function(stream){\\n  stream.readInt32(); //magic \\\"OCTM\\\"\\n  this.fileFormat = stream.readInt32();\\n  this.compressionMethod = stream.readInt32();\\n  this.vertexCount = stream.readInt32();\\n  this.triangleCount = stream.readInt32();\\n  this.uvMapCount = stream.readInt32();\\n  this.attrMapCount = stream.readInt32();\\n  this.flags = stream.readInt32();\\n  this.comment = stream.readString();\\n};\\n\\nCTM.FileHeader.prototype.hasNormals = function(){\\n  return this.flags & CTM.Flags.NORMALS;\\n};\\n\\nCTM.FileBody = function(header){\\n  var i = header.triangleCount * 3,\\n      v = header.vertexCount * 3,\\n      n = header.hasNormals()? header.vertexCount * 3: 0,\\n      u = header.vertexCount * 2,\\n      a = header.vertexCount * 4,\\n      j = 0;\\n\\n  var data = new ArrayBuffer(\\n    (i + v + n + (u * header.uvMapCount) + (a * header.attrMapCount) ) * 4);\\n\\n  this.indices = new Uint32Array(data, 0, i);\\n\\n  this.vertices = new Float32Array(data, i * 4, v);\\n\\n  if ( header.hasNormals() ){\\n    this.normals = new Float32Array(data, (i + v) * 4, n);\\n  }\\n  \\n  if (header.uvMapCount){\\n    this.uvMaps = [];\\n    for (j = 0; j < header.uvMapCount; ++ j){\\n      this.uvMaps[j] = {uv: new Float32Array(data,\\n        (i + v + n + (j * u) ) * 4, u) };\\n    }\\n  }\\n  \\n  if (header.attrMapCount){\\n    this.attrMaps = [];\\n    for (j = 0; j < header.attrMapCount; ++ j){\\n      this.attrMaps[j] = {attr: new Float32Array(data,\\n        (i + v + n + (u * header.uvMapCount) + (j * a) ) * 4, a) };\\n    }\\n  }\\n};\\n\\nCTM.FileMG2Header = function(stream){\\n  stream.readInt32(); //magic \\\"MG2H\\\"\\n  this.vertexPrecision = stream.readFloat32();\\n  this.normalPrecision = stream.readFloat32();\\n  this.lowerBoundx = stream.readFloat32();\\n  this.lowerBoundy = stream.readFloat32();\\n  this.lowerBoundz = stream.readFloat32();\\n  this.higherBoundx = stream.readFloat32();\\n  this.higherBoundy = stream.readFloat32();\\n  this.higherBoundz = stream.readFloat32();\\n  this.divx = stream.readInt32();\\n  this.divy = stream.readInt32();\\n  this.divz = stream.readInt32();\\n  \\n  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;\\n  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;\\n  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;\\n};\\n\\nCTM.ReaderRAW = function(){\\n};\\n\\nCTM.ReaderRAW.prototype.read = function(stream, body){\\n  this.readIndices(stream, body.indices);\\n  this.readVertices(stream, body.vertices);\\n  \\n  if (body.normals){\\n    this.readNormals(stream, body.normals);\\n  }\\n  if (body.uvMaps){\\n    this.readUVMaps(stream, body.uvMaps);\\n  }\\n  if (body.attrMaps){\\n    this.readAttrMaps(stream, body.attrMaps);\\n  }\\n};\\n\\nCTM.ReaderRAW.prototype.readIndices = function(stream, indices){\\n  stream.readInt32(); //magic \\\"INDX\\\"\\n  stream.readArrayInt32(indices);\\n};\\n\\nCTM.ReaderRAW.prototype.readVertices = function(stream, vertices){\\n  stream.readInt32(); //magic \\\"VERT\\\"\\n  stream.readArrayFloat32(vertices);\\n};\\n\\nCTM.ReaderRAW.prototype.readNormals = function(stream, normals){\\n  stream.readInt32(); //magic \\\"NORM\\\"\\n  stream.readArrayFloat32(normals);\\n};\\n\\nCTM.ReaderRAW.prototype.readUVMaps = function(stream, uvMaps){\\n  var i = 0;\\n  for (; i < uvMaps.length; ++ i){\\n    stream.readInt32(); //magic \\\"TEXC\\\"\\n\\n    uvMaps[i].name = stream.readString();\\n    uvMaps[i].filename = stream.readString();\\n    stream.readArrayFloat32(uvMaps[i].uv);\\n  }\\n};\\n\\nCTM.ReaderRAW.prototype.readAttrMaps = function(stream, attrMaps){\\n  var i = 0;\\n  for (; i < attrMaps.length; ++ i){\\n    stream.readInt32(); //magic \\\"ATTR\\\"\\n\\n    attrMaps[i].name = stream.readString();\\n    stream.readArrayFloat32(attrMaps[i].attr);\\n  }\\n};\\n\\nCTM.ReaderMG1 = function(){\\n};\\n\\nCTM.ReaderMG1.prototype.read = function(stream, body){\\n  this.readIndices(stream, body.indices);\\n  this.readVertices(stream, body.vertices);\\n  \\n  if (body.normals){\\n    this.readNormals(stream, body.normals);\\n  }\\n  if (body.uvMaps){\\n    this.readUVMaps(stream, body.uvMaps);\\n  }\\n  if (body.attrMaps){\\n    this.readAttrMaps(stream, body.attrMaps);\\n  }\\n};\\n\\nCTM.ReaderMG1.prototype.readIndices = function(stream, indices){\\n  stream.readInt32(); //magic \\\"INDX\\\"\\n  stream.readInt32(); //packed size\\n  \\n  var interleaved = new CTM.InterleavedStream(indices, 3);\\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n\\n  CTM.restoreIndices(indices, indices.length);\\n};\\n\\nCTM.ReaderMG1.prototype.readVertices = function(stream, vertices){\\n  stream.readInt32(); //magic \\\"VERT\\\"\\n  stream.readInt32(); //packed size\\n  \\n  var interleaved = new CTM.InterleavedStream(vertices, 1);\\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n};\\n\\nCTM.ReaderMG1.prototype.readNormals = function(stream, normals){\\n  stream.readInt32(); //magic \\\"NORM\\\"\\n  stream.readInt32(); //packed size\\n\\n  var interleaved = new CTM.InterleavedStream(normals, 3);\\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n};\\n\\nCTM.ReaderMG1.prototype.readUVMaps = function(stream, uvMaps){\\n  var i = 0;\\n  for (; i < uvMaps.length; ++ i){\\n    stream.readInt32(); //magic \\\"TEXC\\\"\\n\\n    uvMaps[i].name = stream.readString();\\n    uvMaps[i].filename = stream.readString();\\n    \\n    stream.readInt32(); //packed size\\n\\n    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n  }\\n};\\n\\nCTM.ReaderMG1.prototype.readAttrMaps = function(stream, attrMaps){\\n  var i = 0;\\n  for (; i < attrMaps.length; ++ i){\\n    stream.readInt32(); //magic \\\"ATTR\\\"\\n\\n    attrMaps[i].name = stream.readString();\\n    \\n    stream.readInt32(); //packed size\\n\\n    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n  }\\n};\\n\\nCTM.ReaderMG2 = function(){\\n};\\n\\nCTM.ReaderMG2.prototype.read = function(stream, body){\\n  this.MG2Header = new CTM.FileMG2Header(stream);\\n  \\n  this.readVertices(stream, body.vertices);\\n  this.readIndices(stream, body.indices);\\n  \\n  if (body.normals){\\n    this.readNormals(stream, body);\\n  }\\n  if (body.uvMaps){\\n    this.readUVMaps(stream, body.uvMaps);\\n  }\\n  if (body.attrMaps){\\n    this.readAttrMaps(stream, body.attrMaps);\\n  }\\n};\\n\\nCTM.ReaderMG2.prototype.readVertices = function(stream, vertices){\\n  stream.readInt32(); //magic \\\"VERT\\\"\\n  stream.readInt32(); //packed size\\n\\n  var interleaved = new CTM.InterleavedStream(vertices, 3);\\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n  \\n  var gridIndices = this.readGridIndices(stream, vertices);\\n  \\n  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);\\n};\\n\\nCTM.ReaderMG2.prototype.readGridIndices = function(stream, vertices){\\n  stream.readInt32(); //magic \\\"GIDX\\\"\\n  stream.readInt32(); //packed size\\n  \\n  var gridIndices = new Uint32Array(vertices.length / 3);\\n  \\n  var interleaved = new CTM.InterleavedStream(gridIndices, 1);\\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n  \\n  CTM.restoreGridIndices(gridIndices, gridIndices.length);\\n  \\n  return gridIndices;\\n};\\n\\nCTM.ReaderMG2.prototype.readIndices = function(stream, indices){\\n  stream.readInt32(); //magic \\\"INDX\\\"\\n  stream.readInt32(); //packed size\\n\\n  var interleaved = new CTM.InterleavedStream(indices, 3);\\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n\\n  CTM.restoreIndices(indices, indices.length);\\n};\\n\\nCTM.ReaderMG2.prototype.readNormals = function(stream, body){\\n  stream.readInt32(); //magic \\\"NORM\\\"\\n  stream.readInt32(); //packed size\\n\\n  var interleaved = new CTM.InterleavedStream(body.normals, 3);\\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n\\n  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);\\n\\n  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);\\n};\\n\\nCTM.ReaderMG2.prototype.readUVMaps = function(stream, uvMaps){\\n  var i = 0;\\n  for (; i < uvMaps.length; ++ i){\\n    stream.readInt32(); //magic \\\"TEXC\\\"\\n\\n    uvMaps[i].name = stream.readString();\\n    uvMaps[i].filename = stream.readString();\\n    \\n    var precision = stream.readFloat32();\\n    \\n    stream.readInt32(); //packed size\\n\\n    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n    \\n    CTM.restoreMap(uvMaps[i].uv, 2, precision);\\n  }\\n};\\n\\nCTM.ReaderMG2.prototype.readAttrMaps = function(stream, attrMaps){\\n  var i = 0;\\n  for (; i < attrMaps.length; ++ i){\\n    stream.readInt32(); //magic \\\"ATTR\\\"\\n\\n    attrMaps[i].name = stream.readString();\\n    \\n    var precision = stream.readFloat32();\\n    \\n    stream.readInt32(); //packed size\\n\\n    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\\n    \\n    CTM.restoreMap(attrMaps[i].attr, 4, precision);\\n  }\\n};\\n\\nCTM.restoreIndices = function(indices, len){\\n  var i = 3;\\n  if (len > 0){\\n    indices[2] += indices[0];\\n    indices[1] += indices[0];\\n  }\\n  for (; i < len; i += 3){\\n    indices[i] += indices[i - 3];\\n    \\n    if (indices[i] === indices[i - 3]){\\n      indices[i + 1] += indices[i - 2];\\n    }else{\\n      indices[i + 1] += indices[i];\\n    }\\n\\n    indices[i + 2] += indices[i];\\n  }\\n};\\n\\nCTM.restoreGridIndices = function(gridIndices, len){\\n  var i = 1;\\n  for (; i < len; ++ i){\\n    gridIndices[i] += gridIndices[i - 1];\\n  }\\n};\\n\\nCTM.restoreVertices = function(vertices, grid, gridIndices, precision){\\n  var gridIdx, delta, x, y, z,\\n      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),\\n      ydiv = grid.divx, zdiv = ydiv * grid.divy,\\n      prevGridIdx = 0x7fffffff, prevDelta = 0,\\n      i = 0, j = 0, len = gridIndices.length;\\n\\n  for (; i < len; j += 3){\\n    x = gridIdx = gridIndices[i ++];\\n    \\n    z = ~~(x / zdiv);\\n    x -= ~~(z * zdiv);\\n    y = ~~(x / ydiv);\\n    x -= ~~(y * ydiv);\\n\\n    delta = intVertices[j];\\n    if (gridIdx === prevGridIdx){\\n      delta += prevDelta;\\n    }\\n\\n    vertices[j]     = grid.lowerBoundx +\\n      x * grid.sizex + precision * delta;\\n    vertices[j + 1] = grid.lowerBoundy +\\n      y * grid.sizey + precision * intVertices[j + 1];\\n    vertices[j + 2] = grid.lowerBoundz +\\n      z * grid.sizez + precision * intVertices[j + 2];\\n\\n    prevGridIdx = gridIdx;\\n    prevDelta = delta;\\n  }\\n};\\n\\nCTM.restoreNormals = function(normals, smooth, precision){\\n  var ro, phi, theta, sinPhi,\\n      nx, ny, nz, by, bz, len,\\n      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),\\n      i = 0, k = normals.length,\\n      PI_DIV_2 = 3.141592653589793238462643 * 0.5;\\n\\n  for (; i < k; i += 3){\\n    ro = intNormals[i] * precision;\\n    phi = intNormals[i + 1];\\n\\n    if (phi === 0){\\n      normals[i]     = smooth[i]     * ro;\\n      normals[i + 1] = smooth[i + 1] * ro;\\n      normals[i + 2] = smooth[i + 2] * ro;\\n    }else{\\n      \\n      if (phi <= 4){\\n        theta = (intNormals[i + 2] - 2) * PI_DIV_2;\\n      }else{\\n        theta = ( (intNormals[i + 2] * 4 / phi) - 2) * PI_DIV_2;\\n      }\\n      \\n      phi *= precision * PI_DIV_2;\\n      sinPhi = ro * Math.sin(phi);\\n\\n      nx = sinPhi * Math.cos(theta);\\n      ny = sinPhi * Math.sin(theta);\\n      nz = ro * Math.cos(phi);\\n\\n      bz = smooth[i + 1];\\n      by = smooth[i] - smooth[i + 2];\\n\\n      len = Math.sqrt(2 * bz * bz + by * by);\\n      if (len > 1e-20){\\n        by /= len;\\n        bz /= len;\\n      }\\n\\n      normals[i]     = smooth[i]     * nz +\\n        (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;\\n      normals[i + 1] = smooth[i + 1] * nz -\\n        (smooth[i + 2]      + smooth[i]   ) * bz  * ny + by * nx;\\n      normals[i + 2] = smooth[i + 2] * nz +\\n        (smooth[i]     * by + smooth[i + 1] * bz) * ny + bz * nx;\\n    }\\n  }\\n};\\n\\nCTM.restoreMap = function(map, count, precision){\\n  var delta, value,\\n      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),\\n      i = 0, j, len = map.length;\\n\\n  for (; i < count; ++ i){\\n    delta = 0;\\n\\n    for (j = i; j < len; j += count){\\n      value = intMap[j];\\n      \\n      delta += value & 1? -( (value + 1) >> 1): value >> 1;\\n      \\n      map[j] = delta * precision;\\n    }\\n  }\\n};\\n\\nCTM.calcSmoothNormals = function(indices, vertices){\\n  var smooth = new Float32Array(vertices.length),\\n      indx, indy, indz, nx, ny, nz,\\n      v1x, v1y, v1z, v2x, v2y, v2z, len,\\n      i, k;\\n\\n  for (i = 0, k = indices.length; i < k;){\\n    indx = indices[i ++] * 3;\\n    indy = indices[i ++] * 3;\\n    indz = indices[i ++] * 3;\\n\\n    v1x = vertices[indy]     - vertices[indx];\\n    v2x = vertices[indz]     - vertices[indx];\\n    v1y = vertices[indy + 1] - vertices[indx + 1];\\n    v2y = vertices[indz + 1] - vertices[indx + 1];\\n    v1z = vertices[indy + 2] - vertices[indx + 2];\\n    v2z = vertices[indz + 2] - vertices[indx + 2];\\n    \\n    nx = v1y * v2z - v1z * v2y;\\n    ny = v1z * v2x - v1x * v2z;\\n    nz = v1x * v2y - v1y * v2x;\\n    \\n    len = Math.sqrt(nx * nx + ny * ny + nz * nz);\\n    if (len > 1e-10){\\n      nx /= len;\\n      ny /= len;\\n      nz /= len;\\n    }\\n    \\n    smooth[indx]     += nx;\\n    smooth[indx + 1] += ny;\\n    smooth[indx + 2] += nz;\\n    smooth[indy]     += nx;\\n    smooth[indy + 1] += ny;\\n    smooth[indy + 2] += nz;\\n    smooth[indz]     += nx;\\n    smooth[indz + 1] += ny;\\n    smooth[indz + 2] += nz;\\n  }\\n\\n  for (i = 0, k = smooth.length; i < k; i += 3){\\n    len = Math.sqrt(smooth[i] * smooth[i] + \\n      smooth[i + 1] * smooth[i + 1] +\\n      smooth[i + 2] * smooth[i + 2]);\\n\\n    if(len > 1e-10){\\n      smooth[i]     /= len;\\n      smooth[i + 1] /= len;\\n      smooth[i + 2] /= len;\\n    }\\n  }\\n\\n  return smooth;\\n};\\n\\nCTM.isLittleEndian = (function(){\\n  var buffer = new ArrayBuffer(2),\\n      bytes = new Uint8Array(buffer),\\n      ints = new Uint16Array(buffer);\\n\\n  bytes[0] = 1;\\n\\n  return ints[0] === 1;\\n}());\\n\\nCTM.InterleavedStream = function(data, count){\\n  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\\n  this.offset = CTM.isLittleEndian? 3: 0;\\n  this.count = count * 4;\\n  this.len = this.data.length;\\n};\\n\\nCTM.InterleavedStream.prototype.writeByte = function(value){\\n  this.data[this.offset] = value;\\n  \\n  this.offset += this.count;\\n  if (this.offset >= this.len){\\n  \\n    this.offset -= this.len - 4;\\n    if (this.offset >= this.count){\\n    \\n      this.offset -= this.count + (CTM.isLittleEndian? 1: -1);\\n    }\\n  }\\n};\\n\\nCTM.Stream = function(data){\\n  this.data = data;\\n  this.offset = 0;\\n};\\n\\nCTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);\\n\\nCTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);\\n\\nCTM.Stream.prototype.readByte = function(){\\n  return this.data[this.offset ++] & 0xff;\\n};\\n\\nCTM.Stream.prototype.readInt32 = function(){\\n  var i = this.readByte();\\n  i |= this.readByte() << 8;\\n  i |= this.readByte() << 16;\\n  return i | (this.readByte() << 24);\\n};\\n\\nCTM.Stream.prototype.readFloat32 = function(){\\n  var m = this.readByte();\\n  m += this.readByte() << 8;\\n\\n  var b1 = this.readByte();\\n  var b2 = this.readByte();\\n\\n  m += (b1 & 0x7f) << 16; \\n  var e = ( (b2 & 0x7f) << 1) | ( (b1 & 0x80) >>> 7);\\n  var s = b2 & 0x80? -1: 1;\\n\\n  if (e === 255){\\n    return m !== 0? NaN: s * Infinity;\\n  }\\n  if (e > 0){\\n    return s * (1 + (m * this.TWO_POW_MINUS23) ) * Math.pow(2, e - 127);\\n  }\\n  if (m !== 0){\\n    return s * m * this.TWO_POW_MINUS126;\\n  }\\n  return s * 0;\\n};\\n\\nCTM.Stream.prototype.readString = function(){\\n  var len = this.readInt32();\\n\\n  this.offset += len;\\n\\n  return String.fromCharCode.apply(null,this.data.subarray(this.offset - len, this.offset));\\n};\\n\\nCTM.Stream.prototype.readArrayInt32 = function(array){\\n  var i = 0, len = array.length;\\n  \\n  while(i < len){\\n    array[i ++] = this.readInt32();\\n  }\\n\\n  return array;\\n};\\n\\nCTM.Stream.prototype.readArrayFloat32 = function(array){\\n  var i = 0, len = array.length;\\n\\n  while(i < len){\\n    array[i ++] = this.readFloat32();\\n  }\\n\\n  return array;\\n};\\n\\nexports.CTM = CTM;})();\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/lzma.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/lzma.js\",\n            \"module-type\": \"library\",\n            \"text\": \"(function(){\\n\\nvar LZMA = LZMA || {};\\n\\nLZMA.OutWindow = function(){\\n  this._windowSize = 0;\\n};\\n\\nLZMA.OutWindow.prototype.create = function(windowSize){\\n  if ( (!this._buffer) || (this._windowSize !== windowSize) ){\\n    this._buffer = [];\\n  }\\n  this._windowSize = windowSize;\\n  this._pos = 0;\\n  this._streamPos = 0;\\n};\\n\\nLZMA.OutWindow.prototype.flush = function(){\\n  var size = this._pos - this._streamPos;\\n  if (size !== 0){\\n    while(size --){\\n      this._stream.writeByte(this._buffer[this._streamPos ++]);\\n    }\\n    if (this._pos >= this._windowSize){\\n      this._pos = 0;\\n    }\\n    this._streamPos = this._pos;\\n  }\\n};\\n\\nLZMA.OutWindow.prototype.releaseStream = function(){\\n  this.flush();\\n  this._stream = null;\\n};\\n\\nLZMA.OutWindow.prototype.setStream = function(stream){\\n  this.releaseStream();\\n  this._stream = stream;\\n};\\n\\nLZMA.OutWindow.prototype.init = function(solid){\\n  if (!solid){\\n    this._streamPos = 0;\\n    this._pos = 0;\\n  }\\n};\\n\\nLZMA.OutWindow.prototype.copyBlock = function(distance, len){\\n  var pos = this._pos - distance - 1;\\n  if (pos < 0){\\n    pos += this._windowSize;\\n  }\\n  while(len --){\\n    if (pos >= this._windowSize){\\n      pos = 0;\\n    }\\n    this._buffer[this._pos ++] = this._buffer[pos ++];\\n    if (this._pos >= this._windowSize){\\n      this.flush();\\n    }\\n  }\\n};\\n\\nLZMA.OutWindow.prototype.putByte = function(b){\\n  this._buffer[this._pos ++] = b;\\n  if (this._pos >= this._windowSize){\\n    this.flush();\\n  }\\n};\\n\\nLZMA.OutWindow.prototype.getByte = function(distance){\\n  var pos = this._pos - distance - 1;\\n  if (pos < 0){\\n    pos += this._windowSize;\\n  }\\n  return this._buffer[pos];\\n};\\n\\nLZMA.RangeDecoder = function(){\\n};\\n\\nLZMA.RangeDecoder.prototype.setStream = function(stream){\\n  this._stream = stream;\\n};\\n\\nLZMA.RangeDecoder.prototype.releaseStream = function(){\\n  this._stream = null;\\n};\\n\\nLZMA.RangeDecoder.prototype.init = function(){\\n  var i = 5;\\n\\n  this._code = 0;\\n  this._range = -1;\\n  \\n  while(i --){\\n    this._code = (this._code << 8) | this._stream.readByte();\\n  }\\n};\\n\\nLZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){\\n  var result = 0, i = numTotalBits, t;\\n\\n  while(i --){\\n    this._range >>>= 1;\\n    t = (this._code - this._range) >>> 31;\\n    this._code -= this._range & (t - 1);\\n    result = (result << 1) | (1 - t);\\n\\n    if ( (this._range & 0xff000000) === 0){\\n      this._code = (this._code << 8) | this._stream.readByte();\\n      this._range <<= 8;\\n    }\\n  }\\n\\n  return result;\\n};\\n\\nLZMA.RangeDecoder.prototype.decodeBit = function(probs, index){\\n  var prob = probs[index],\\n      newBound = (this._range >>> 11) * prob;\\n\\n  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){\\n    this._range = newBound;\\n    probs[index] += (2048 - prob) >>> 5;\\n    if ( (this._range & 0xff000000) === 0){\\n      this._code = (this._code << 8) | this._stream.readByte();\\n      this._range <<= 8;\\n    }\\n    return 0;\\n  }\\n\\n  this._range -= newBound;\\n  this._code -= newBound;\\n  probs[index] -= prob >>> 5;\\n  if ( (this._range & 0xff000000) === 0){\\n    this._code = (this._code << 8) | this._stream.readByte();\\n    this._range <<= 8;\\n  }\\n  return 1;\\n};\\n\\nLZMA.initBitModels = function(probs, len){\\n  while(len --){\\n    probs[len] = 1024;\\n  }\\n};\\n\\nLZMA.BitTreeDecoder = function(numBitLevels){\\n  this._models = [];\\n  this._numBitLevels = numBitLevels;\\n};\\n\\nLZMA.BitTreeDecoder.prototype.init = function(){\\n  LZMA.initBitModels(this._models, 1 << this._numBitLevels);\\n};\\n\\nLZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){\\n  var m = 1, i = this._numBitLevels;\\n\\n  while(i --){\\n    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);\\n  }\\n  return m - (1 << this._numBitLevels);\\n};\\n\\nLZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){\\n  var m = 1, symbol = 0, i = 0, bit;\\n\\n  for (; i < this._numBitLevels; ++ i){\\n    bit = rangeDecoder.decodeBit(this._models, m);\\n    m = (m << 1) | bit;\\n    symbol |= bit << i;\\n  }\\n  return symbol;\\n};\\n\\nLZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){\\n  var m = 1, symbol = 0, i = 0, bit;\\n\\n  for (; i < numBitLevels; ++ i){\\n    bit = rangeDecoder.decodeBit(models, startIndex + m);\\n    m = (m << 1) | bit;\\n    symbol |= bit << i;\\n  }\\n  return symbol;\\n};\\n\\nLZMA.LenDecoder = function(){\\n  this._choice = [];\\n  this._lowCoder = [];\\n  this._midCoder = [];\\n  this._highCoder = new LZMA.BitTreeDecoder(8);\\n  this._numPosStates = 0;\\n};\\n\\nLZMA.LenDecoder.prototype.create = function(numPosStates){\\n  for (; this._numPosStates < numPosStates; ++ this._numPosStates){\\n    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\\n    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\\n  }\\n};\\n\\nLZMA.LenDecoder.prototype.init = function(){\\n  var i = this._numPosStates;\\n  LZMA.initBitModels(this._choice, 2);\\n  while(i --){\\n    this._lowCoder[i].init();\\n    this._midCoder[i].init();\\n  }\\n  this._highCoder.init();\\n};\\n\\nLZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){\\n  if (rangeDecoder.decodeBit(this._choice, 0) === 0){\\n    return this._lowCoder[posState].decode(rangeDecoder);\\n  }\\n  if (rangeDecoder.decodeBit(this._choice, 1) === 0){\\n    return 8 + this._midCoder[posState].decode(rangeDecoder);\\n  }\\n  return 16 + this._highCoder.decode(rangeDecoder);\\n};\\n\\nLZMA.Decoder2 = function(){\\n  this._decoders = [];\\n};\\n\\nLZMA.Decoder2.prototype.init = function(){\\n  LZMA.initBitModels(this._decoders, 0x300);\\n};\\n\\nLZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){\\n  var symbol = 1;\\n\\n  do{\\n    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\\n  }while(symbol < 0x100);\\n\\n  return symbol & 0xff;\\n};\\n\\nLZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){\\n  var symbol = 1, matchBit, bit;\\n\\n  do{\\n    matchBit = (matchByte >> 7) & 1;\\n    matchByte <<= 1;\\n    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);\\n    symbol = (symbol << 1) | bit;\\n    if (matchBit !== bit){\\n      while(symbol < 0x100){\\n        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\\n      }\\n      break;\\n    }\\n  }while(symbol < 0x100);\\n\\n  return symbol & 0xff;\\n};\\n\\nLZMA.LiteralDecoder = function(){\\n};\\n\\nLZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){\\n  var i;\\n\\n  if (this._coders\\n    && (this._numPrevBits === numPrevBits)\\n    && (this._numPosBits === numPosBits) ){\\n    return;\\n  }\\n  this._numPosBits = numPosBits;\\n  this._posMask = (1 << numPosBits) - 1;\\n  this._numPrevBits = numPrevBits;\\n\\n  this._coders = [];\\n\\n  i = 1 << (this._numPrevBits + this._numPosBits);\\n  while(i --){\\n    this._coders[i] = new LZMA.Decoder2();\\n  }\\n};\\n\\nLZMA.LiteralDecoder.prototype.init = function(){\\n  var i = 1 << (this._numPrevBits + this._numPosBits);\\n  while(i --){\\n    this._coders[i].init();\\n  }\\n};\\n\\nLZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){\\n  return this._coders[( (pos & this._posMask) << this._numPrevBits)\\n    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];\\n};\\n\\nLZMA.Decoder = function(){\\n  this._outWindow = new LZMA.OutWindow();\\n  this._rangeDecoder = new LZMA.RangeDecoder();\\n  this._isMatchDecoders = [];\\n  this._isRepDecoders = [];\\n  this._isRepG0Decoders = [];\\n  this._isRepG1Decoders = [];\\n  this._isRepG2Decoders = [];\\n  this._isRep0LongDecoders = [];\\n  this._posSlotDecoder = [];\\n  this._posDecoders = [];\\n  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);\\n  this._lenDecoder = new LZMA.LenDecoder();\\n  this._repLenDecoder = new LZMA.LenDecoder();\\n  this._literalDecoder = new LZMA.LiteralDecoder();\\n  this._dictionarySize = -1;\\n  this._dictionarySizeCheck = -1;\\n\\n  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);\\n  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);\\n  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);\\n  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);\\n};\\n\\nLZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){\\n  if (dictionarySize < 0){\\n    return false;\\n  }\\n  if (this._dictionarySize !== dictionarySize){\\n    this._dictionarySize = dictionarySize;\\n    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);\\n    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );\\n  }\\n  return true;\\n};\\n\\nLZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){\\n  var numPosStates = 1 << pb;\\n\\n  if (lc > 8 || lp > 4 || pb > 4){\\n    return false;\\n  }\\n\\n  this._literalDecoder.create(lp, lc);\\n\\n  this._lenDecoder.create(numPosStates);\\n  this._repLenDecoder.create(numPosStates);\\n  this._posStateMask = numPosStates - 1;\\n\\n  return true;\\n};\\n\\nLZMA.Decoder.prototype.init = function(){\\n  var i = 4;\\n\\n  this._outWindow.init(false);\\n\\n  LZMA.initBitModels(this._isMatchDecoders, 192);\\n  LZMA.initBitModels(this._isRep0LongDecoders, 192);\\n  LZMA.initBitModels(this._isRepDecoders, 12);\\n  LZMA.initBitModels(this._isRepG0Decoders, 12);\\n  LZMA.initBitModels(this._isRepG1Decoders, 12);\\n  LZMA.initBitModels(this._isRepG2Decoders, 12);\\n  LZMA.initBitModels(this._posDecoders, 114);\\n\\n  this._literalDecoder.init();\\n\\n  while(i --){\\n    this._posSlotDecoder[i].init();\\n  }\\n\\n  this._lenDecoder.init();\\n  this._repLenDecoder.init();\\n  this._posAlignDecoder.init();\\n  this._rangeDecoder.init();\\n};\\n\\nLZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){\\n  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,\\n      posState, decoder2, len, distance, posSlot, numDirectBits;\\n\\n  this._rangeDecoder.setStream(inStream);\\n  this._outWindow.setStream(outStream);\\n\\n  this.init();\\n\\n  while(outSize < 0 || nowPos64 < outSize){\\n    posState = nowPos64 & this._posStateMask;\\n\\n    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){\\n      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);\\n\\n      if (state >= 7){\\n        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );\\n      }else{\\n        prevByte = decoder2.decodeNormal(this._rangeDecoder);\\n      }\\n      this._outWindow.putByte(prevByte);\\n\\n      state = state < 4? 0: state - (state < 10? 3: 6);\\n\\n    }else{\\n\\n      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){\\n        len = 0;\\n        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){\\n          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){\\n            state = state < 7? 9: 11;\\n            len = 1;\\n          }\\n        }else{\\n          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){\\n            distance = rep1;\\n          }else{\\n            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){\\n              distance = rep2;\\n            }else{\\n              distance = rep3;\\n              rep3 = rep2;\\n            }\\n            rep2 = rep1;\\n          }\\n          rep1 = rep0;\\n          rep0 = distance;\\n        }\\n        if (len === 0){\\n          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);\\n          state = state < 7? 8: 11;\\n        }\\n      }else{\\n        rep3 = rep2;\\n        rep2 = rep1;\\n        rep1 = rep0;\\n\\n        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);\\n        state = state < 7? 7: 10;\\n\\n        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);\\n        if (posSlot >= 4){\\n\\n          numDirectBits = (posSlot >> 1) - 1;\\n          rep0 = (2 | (posSlot & 1) ) << numDirectBits;\\n\\n          if (posSlot < 14){\\n            rep0 += LZMA.reverseDecode2(this._posDecoders,\\n                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);\\n          }else{\\n            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;\\n            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);\\n            if (rep0 < 0){\\n              if (rep0 === -1){\\n                break;\\n              }\\n              return false;\\n            }\\n          }\\n        }else{\\n          rep0 = posSlot;\\n        }\\n      }\\n\\n      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){\\n        return false;\\n      }\\n\\n      this._outWindow.copyBlock(rep0, len);\\n      nowPos64 += len;\\n      prevByte = this._outWindow.getByte(0);\\n    }\\n  }\\n\\n  this._outWindow.flush();\\n  this._outWindow.releaseStream();\\n  this._rangeDecoder.releaseStream();\\n\\n  return true;\\n};\\n\\nLZMA.Decoder.prototype.setDecoderProperties = function(properties){\\n  var value, lc, lp, pb, dictionarySize;\\n\\n  if (properties.size < 5){\\n    return false;\\n  }\\n\\n  value = properties.readByte();\\n  lc = value % 9;\\n  value = ~~(value / 9);\\n  lp = value % 5;\\n  pb = ~~(value / 5);\\n\\n  if ( !this.setLcLpPb(lc, lp, pb) ){\\n    return false;\\n  }\\n\\n  dictionarySize = properties.readByte();\\n  dictionarySize |= properties.readByte() << 8;\\n  dictionarySize |= properties.readByte() << 16;\\n  dictionarySize += properties.readByte() * 16777216;\\n\\n  return this.setDictionarySize(dictionarySize);\\n};\\n\\nLZMA.decompress = function(properties, inStream, outStream, outSize){\\n  var decoder = new LZMA.Decoder();\\n\\n  if ( !decoder.setDecoderProperties(properties) ){\\n    throw \\\"Incorrect stream properties\\\";\\n  }\\n\\n  if ( !decoder.decode(inStream, outStream, outSize) ){\\n    throw \\\"Error in data stream\\\";\\n  }\\n\\n  return true;\\n};\\n\\nexports.LZMA = LZMA;})();\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/License/js-lzma.txt\": {\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/License/js-lzma.txt\",\n            \"text\": \"Copyright (c) 2011 Juan Mellado\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/License/js-openctm.txt\": {\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/License/js-openctm.txt\",\n            \"text\": \"Copyright (c) 2011 Juan Mellado\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/License/OpenCTM.txt\": {\n            \"type\": \"text/plain\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Loaders/Ctm/License/OpenCTM.txt\",\n            \"text\": \"Copyright (c) 2009-2010 Marcus Geelnard\\n\\nThis software is provided 'as-is', without any express or implied\\nwarranty. In no event will the authors be held liable for any damages\\narising from the use of this software.\\n\\nPermission is granted to anyone to use this software for any purpose,\\nincluding commercial applications, and to alter it and redistribute it\\nfreely, subject to the following restrictions:\\n\\n    1. The origin of this software must not be misrepresented; you must not\\n    claim that you wrote the original software. If you use this software\\n    in a product, an acknowledgment in the product documentation would be\\n    appreciated but is not required.\\n\\n    2. Altered source versions must be plainly marked as such, and must not\\n    be misrepresented as being the original software.\\n\\n    3. This notice may not be removed or altered from any source\\n    distribution.\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Renderers/RaytracingRenderer.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Renderers/RaytracingRenderer.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author alteredq / http://alteredqualia.com/\\n */\\n\\nTHREE.RaytracingRenderer = function ( parameters ) {\\n\\n\\tconsole.log( 'THREE.RaytracingRenderer', THREE.REVISION );\\n\\n\\tparameters = parameters || {};\\n\\n  // *TiddlyWiki*\\n  var _self = this;\\n\\n\\tvar canvas = document.createElement( 'canvas' );\\n\\tvar context = canvas.getContext( '2d', {\\n\\t\\talpha: parameters.alpha === true\\n\\t} );\\n\\n\\tvar maxRecursionDepth = 3;\\n\\n\\tvar canvasWidth, canvasHeight;\\n\\tvar canvasWidthHalf, canvasHeightHalf;\\n\\n\\tvar clearColor = new THREE.Color( 0x000000 );\\n\\n\\tvar origin = new THREE.Vector3();\\n\\tvar direction = new THREE.Vector3();\\n\\n\\tvar cameraPosition = new THREE.Vector3();\\n\\n\\tvar raycaster = new THREE.Raycaster( origin, direction );\\n\\tvar raycasterLight = new THREE.Raycaster();\\n\\n\\tvar perspective;\\n\\tvar modelViewMatrix = new THREE.Matrix4();\\n\\tvar cameraNormalMatrix = new THREE.Matrix3();\\n\\n\\tvar objects;\\n\\tvar lights = [];\\n\\tvar cache = {};\\n\\n\\tvar animationFrameId = null;\\n\\n\\tthis.domElement = canvas;\\n\\n\\tthis.autoClear = true;\\n\\n\\tthis.setClearColor = function ( color, alpha ) {\\n\\n\\t\\tclearColor.set( color );\\n\\n\\t};\\n\\n\\tthis.setSize = function ( width, height ) {\\n\\n\\t\\tcanvas.width = width;\\n\\t\\tcanvas.height = height;\\n\\n\\t\\tcanvasWidth = canvas.width;\\n\\t\\tcanvasHeight = canvas.height;\\n\\n\\t\\tcanvasWidthHalf = Math.floor( canvasWidth / 2 );\\n\\t\\tcanvasHeightHalf = Math.floor( canvasHeight / 2 );\\n\\n\\t\\tcontext.fillStyle = 'white';\\n\\n\\t};\\n\\n\\tthis.setSize( canvas.width, canvas.height );\\n\\n\\tthis.clear = function () {\\n\\n\\t};\\n\\n\\t//\\n\\n\\tvar spawnRay = ( function () {\\n\\n\\t\\tvar diffuseColor = new THREE.Color();\\n\\t\\tvar specularColor = new THREE.Color();\\n\\t\\tvar lightColor = new THREE.Color();\\n\\t\\tvar schlick = new THREE.Color();\\n\\n\\t\\tvar lightContribution = new THREE.Color();\\n\\n\\t\\tvar eyeVector = new THREE.Vector3();\\n\\t\\tvar lightVector = new THREE.Vector3();\\n\\t\\tvar normalVector = new THREE.Vector3();\\n\\t\\tvar halfVector = new THREE.Vector3();\\n\\n\\t\\tvar localPoint = new THREE.Vector3();\\n\\t\\tvar reflectionVector = new THREE.Vector3();\\n\\n\\t\\tvar tmpVec = new THREE.Vector3();\\n\\n\\t\\tvar tmpColor = [];\\n\\n\\t\\tfor ( var i = 0; i < maxRecursionDepth; i ++ ) {\\n\\n\\t\\t\\ttmpColor[ i ] = new THREE.Color();\\n\\n\\t\\t}\\n\\n\\t\\treturn function ( rayOrigin, rayDirection, outputColor, recursionDepth ) {\\n\\n\\t\\t\\tvar ray = raycaster.ray;\\n\\n\\t\\t\\tray.origin = rayOrigin;\\n\\t\\t\\tray.direction = rayDirection;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar rayLight = raycasterLight.ray;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\toutputColor.setRGB( 0, 0, 0 );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar intersections = raycaster.intersectObjects( objects, true );\\n\\n\\t\\t\\t// ray didn't find anything\\n\\t\\t\\t// (here should come setting of background color?)\\n\\n\\t\\t\\tif ( intersections.length === 0 ) {\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ray hit\\n\\n\\t\\t\\tvar intersection = intersections[ 0 ];\\n\\n\\t\\t\\tvar point = intersection.point;\\n\\t\\t\\tvar object = intersection.object;\\n\\t\\t\\tvar material = object.material;\\n\\t\\t\\tvar face = intersection.face;\\n\\n\\t\\t\\tvar vertices = object.geometry.vertices;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar _object = cache[ object.id ];\\n\\n\\t\\t\\tlocalPoint.copy( point ).applyMatrix4( _object.inverseMatrix );\\n\\t\\t\\teyeVector.subVectors( raycaster.ray.origin, point ).normalize();\\n\\n\\t\\t\\t// resolve pixel diffuse color\\n\\n\\t\\t\\tif ( material instanceof THREE.MeshLambertMaterial ||\\n\\t\\t\\t\\t material instanceof THREE.MeshPhongMaterial ||\\n\\t\\t\\t\\t material instanceof THREE.MeshBasicMaterial ) {\\n\\n\\t\\t\\t\\tdiffuseColor.copyGammaToLinear( material.color );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdiffuseColor.setRGB( 1, 1, 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.vertexColors === THREE.FaceColors ) {\\n\\n\\t\\t\\t\\tdiffuseColor.multiply( face.color );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute light shading\\n\\n\\t\\t\\trayLight.origin.copy( point );\\n\\n\\t\\t\\tif ( material instanceof THREE.MeshBasicMaterial ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar light = lights[ i ];\\n\\n\\t\\t\\t\\t\\tlightVector.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tlightVector.sub( point );\\n\\n\\t\\t\\t\\t\\trayLight.direction.copy( lightVector ).normalize();\\n\\n\\t\\t\\t\\t\\tvar intersections = raycasterLight.intersectObjects( objects, true );\\n\\n\\t\\t\\t\\t\\t// point in shadow\\n\\n\\t\\t\\t\\t\\tif ( intersections.length > 0 ) continue;\\n\\n\\t\\t\\t\\t\\t// point visible\\n\\n\\t\\t\\t\\t\\toutputColor.add( diffuseColor );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( material instanceof THREE.MeshLambertMaterial ||\\n\\t\\t\\t\\t\\t\\tmaterial instanceof THREE.MeshPhongMaterial ) {\\n\\n\\t\\t\\t\\tvar normalComputed = false;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar light = lights[ i ];\\n\\n\\t\\t\\t\\t\\tlightColor.copyGammaToLinear( light.color );\\n\\n\\t\\t\\t\\t\\tlightVector.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tlightVector.sub( point );\\n\\n\\t\\t\\t\\t\\trayLight.direction.copy( lightVector ).normalize();\\n\\n\\t\\t\\t\\t\\tvar intersections = raycasterLight.intersectObjects( objects, true );\\n\\n\\t\\t\\t\\t\\t// point in shadow\\n\\n\\t\\t\\t\\t\\tif ( intersections.length > 0 ) continue;\\n\\n\\t\\t\\t\\t\\t// point lit\\n\\n\\t\\t\\t\\t\\tif ( normalComputed === false ) {\\n\\n\\t\\t\\t\\t\\t\\t// the same normal can be reused for all lights\\n\\t\\t\\t\\t\\t\\t// (should be possible to cache even more)\\n\\n\\t\\t\\t\\t\\t\\tcomputePixelNormal( normalVector, localPoint, material.shading, face, vertices );\\n\\t\\t\\t\\t\\t\\tnormalVector.applyMatrix3( _object.normalMatrix ).normalize();\\n\\n\\t\\t\\t\\t\\t\\tnormalComputed = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// compute attenuation\\n\\n\\t\\t\\t\\t\\tvar attenuation = 1.0;\\n\\n\\t\\t\\t\\t\\tif ( light.physicalAttenuation === true ) {\\n\\n\\t\\t\\t\\t\\t\\tattenuation = lightVector.length();\\n\\t\\t\\t\\t\\t\\tattenuation = 1.0 / ( attenuation * attenuation );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tlightVector.normalize();\\n\\n\\t\\t\\t\\t\\t// compute diffuse\\n\\n\\t\\t\\t\\t\\tvar dot = Math.max( normalVector.dot( lightVector ), 0 );\\n\\t\\t\\t\\t\\tvar diffuseIntensity = dot * light.intensity;\\n\\n\\t\\t\\t\\t\\tlightContribution.copy( diffuseColor );\\n\\t\\t\\t\\t\\tlightContribution.multiply( lightColor );\\n\\t\\t\\t\\t\\tlightContribution.multiplyScalar( diffuseIntensity * attenuation );\\n\\n\\t\\t\\t\\t\\toutputColor.add( lightContribution );\\n\\n\\t\\t\\t\\t\\t// compute specular\\n\\n\\t\\t\\t\\t\\tif ( material instanceof THREE.MeshPhongMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\thalfVector.addVectors( lightVector, eyeVector ).normalize();\\n\\n\\t\\t\\t\\t\\t\\tvar dotNormalHalf = Math.max( normalVector.dot( halfVector ), 0.0 );\\n\\t\\t\\t\\t\\t\\tvar specularIntensity = Math.max( Math.pow( dotNormalHalf, material.shininess ), 0.0 ) * diffuseIntensity;\\n\\n\\t\\t\\t\\t\\t\\tvar specularNormalization = ( material.shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\t\\t\\tspecularColor.copyGammaToLinear( material.specular );\\n\\n\\t\\t\\t\\t\\t\\tvar alpha = Math.pow( Math.max( 1.0 - lightVector.dot( halfVector ), 0.0 ), 5.0 );\\n\\n\\t\\t\\t\\t\\t\\tschlick.r = specularColor.r + ( 1.0 - specularColor.r ) * alpha;\\n\\t\\t\\t\\t\\t\\tschlick.g = specularColor.g + ( 1.0 - specularColor.g ) * alpha;\\n\\t\\t\\t\\t\\t\\tschlick.b = specularColor.b + ( 1.0 - specularColor.b ) * alpha;\\n\\n\\t\\t\\t\\t\\t\\tlightContribution.copy( schlick );\\n\\n\\t\\t\\t\\t\\t\\tlightContribution.multiply( lightColor );\\n\\t\\t\\t\\t\\t\\tlightContribution.multiplyScalar( specularNormalization * specularIntensity * attenuation );\\n\\t\\t\\t\\t\\t\\toutputColor.add( lightContribution );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// reflection / refraction\\n\\n\\t\\t\\tvar reflectivity = material.reflectivity;\\n\\n\\t\\t\\tif ( ( material.mirror || material.glass ) && reflectivity > 0 && recursionDepth < maxRecursionDepth ) {\\n\\n\\t\\t\\t\\tif ( material.mirror ) {\\n\\n\\t\\t\\t\\t\\treflectionVector.copy( rayDirection );\\n\\t\\t\\t\\t\\treflectionVector.reflect( normalVector );\\n\\n\\t\\t\\t\\t} else if ( material.glass ) {\\n\\n\\t\\t\\t\\t\\tvar eta = material.refractionRatio;\\n\\n\\t\\t\\t\\t\\tvar dotNI = rayDirection.dot( normalVector )\\n\\t\\t\\t\\t\\tvar k = 1.0 - eta * eta * ( 1.0 - dotNI * dotNI );\\n\\n\\t\\t\\t\\t\\tif ( k < 0.0 ) {\\n\\n\\t\\t\\t\\t\\t\\treflectionVector.set( 0, 0, 0 );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\treflectionVector.copy( rayDirection );\\n\\t\\t\\t\\t\\t\\treflectionVector.multiplyScalar( eta );\\n\\n\\t\\t\\t\\t\\t\\tvar alpha = eta * dotNI + Math.sqrt( k );\\n\\t\\t\\t\\t\\t\\ttmpVec.copy( normalVector );\\n\\t\\t\\t\\t\\t\\ttmpVec.multiplyScalar( alpha );\\n\\t\\t\\t\\t\\t\\treflectionVector.sub( tmpVec );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar theta = Math.max( eyeVector.dot( normalVector ), 0.0 );\\n\\t\\t\\t\\tvar rf0 = reflectivity;\\n\\t\\t\\t\\tvar fresnel = rf0 + ( 1.0 - rf0 ) * Math.pow( ( 1.0 - theta ), 5.0 );\\n\\n\\t\\t\\t\\tvar weight = fresnel;\\n\\n\\t\\t\\t\\tvar zColor = tmpColor[ recursionDepth ];\\n\\n\\t\\t\\t\\tspawnRay( point, reflectionVector, zColor, recursionDepth + 1 );\\n\\n\\t\\t\\t\\tif ( material.specular !== undefined ) {\\n\\n\\t\\t\\t\\t\\tzColor.multiply( material.specular );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tzColor.multiplyScalar( weight );\\n\\t\\t\\t\\toutputColor.multiplyScalar( 1 - weight );\\n\\t\\t\\t\\toutputColor.add( zColor );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\tvar computePixelNormal = ( function () {\\n\\n\\t\\tvar tmpVec1 = new THREE.Vector3();\\n\\t\\tvar tmpVec2 = new THREE.Vector3();\\n\\t\\tvar tmpVec3 = new THREE.Vector3();\\n\\n\\t\\treturn function ( outputVector, point, shading, face, vertices ) {\\n\\n\\t\\t\\tvar faceNormal = face.normal;\\n\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\tif ( shading === THREE.FlatShading ) {\\n\\n\\t\\t\\t\\toutputVector.copy( faceNormal );\\n\\n\\t\\t\\t} else if ( shading === THREE.SmoothShading ) {\\n\\n\\t\\t\\t\\t// compute barycentric coordinates\\n\\n\\t\\t\\t\\tvar vA = vertices[ face.a ];\\n\\t\\t\\t\\tvar vB = vertices[ face.b ];\\n\\t\\t\\t\\tvar vC = vertices[ face.c ];\\n\\n\\t\\t\\t\\ttmpVec3.crossVectors( tmpVec1.subVectors( vB, vA ), tmpVec2.subVectors( vC, vA ) );\\n\\t\\t\\t\\tvar areaABC = faceNormal.dot( tmpVec3 );\\n\\n\\t\\t\\t\\ttmpVec3.crossVectors( tmpVec1.subVectors( vB, point ), tmpVec2.subVectors( vC, point ) );\\n\\t\\t\\t\\tvar areaPBC = faceNormal.dot( tmpVec3 );\\n\\t\\t\\t\\tvar a = areaPBC / areaABC;\\n\\n\\t\\t\\t\\ttmpVec3.crossVectors( tmpVec1.subVectors( vC, point ), tmpVec2.subVectors( vA, point ) );\\n\\t\\t\\t\\tvar areaPCA = faceNormal.dot( tmpVec3 );\\n\\t\\t\\t\\tvar b = areaPCA / areaABC;\\n\\n\\t\\t\\t\\tvar c = 1.0 - a - b;\\n\\n\\t\\t\\t\\t// compute interpolated vertex normal\\n\\n\\t\\t\\t\\ttmpVec1.copy( vertexNormals[ 0 ] );\\n\\t\\t\\t\\ttmpVec1.multiplyScalar( a );\\n\\n\\t\\t\\t\\ttmpVec2.copy( vertexNormals[ 1 ] );\\n\\t\\t\\t\\ttmpVec2.multiplyScalar( b );\\n\\n\\t\\t\\t\\ttmpVec3.copy( vertexNormals[ 2 ] );\\n\\t\\t\\t\\ttmpVec3.multiplyScalar( c );\\n\\n\\t\\t\\t\\toutputVector.addVectors( tmpVec1, tmpVec2 );\\n\\t\\t\\t\\toutputVector.add( tmpVec3 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\tvar renderBlock = ( function () {\\n\\n\\t\\tvar blockSize = 64;\\n\\n\\t\\tvar canvasBlock = document.createElement( 'canvas' );\\n\\t\\tcanvasBlock.width = blockSize;\\n\\t\\tcanvasBlock.height = blockSize;\\n\\n\\t\\tvar contextBlock = canvasBlock.getContext( '2d', {\\n\\n\\t\\t\\talpha: parameters.alpha === true\\n\\n\\t\\t} );\\n\\n\\t\\tvar imagedata = contextBlock.getImageData( 0, 0, blockSize, blockSize );\\n\\t\\tvar data = imagedata.data;\\n\\n\\t\\tvar pixelColor = new THREE.Color();\\n\\n\\t\\treturn function ( blockX, blockY ) {\\n\\n\\t\\t\\tvar index = 0;\\n\\n\\t\\t\\tfor ( var y = 0; y < blockSize; y ++ ) {\\n\\n\\t\\t\\t\\tfor ( var x = 0; x < blockSize; x ++, index += 4 ) {\\n\\n\\t\\t\\t\\t\\t// spawn primary ray at pixel position\\n\\n\\t\\t\\t\\t\\torigin.copy( cameraPosition );\\n\\n\\t\\t\\t\\t\\tdirection.set( x + blockX - canvasWidthHalf, - ( y + blockY - canvasHeightHalf ), - perspective );\\n\\t\\t\\t\\t\\tdirection.applyMatrix3( cameraNormalMatrix ).normalize();\\n\\n\\t\\t\\t\\t\\tspawnRay( origin, direction, pixelColor, 0 );\\n\\n\\t\\t\\t\\t\\t// convert from linear to gamma\\n\\n\\t\\t\\t\\t\\tdata[ index ]     = Math.sqrt( pixelColor.r ) * 255;\\n\\t\\t\\t\\t\\tdata[ index + 1 ] = Math.sqrt( pixelColor.g ) * 255;\\n\\t\\t\\t\\t\\tdata[ index + 2 ] = Math.sqrt( pixelColor.b ) * 255;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcontext.putImageData( imagedata, blockX, blockY );\\n\\n\\t\\t\\tblockX += blockSize;\\n\\n\\t\\t\\tif ( blockX >= canvasWidth ) {\\n\\n\\t\\t\\t\\tblockX = 0;\\n\\t\\t\\t\\tblockY += blockSize;\\n\\n\\t\\t\\t  if ( blockY >= canvasHeight ) {\\n                            if (TiddlyWiki) {\\n                              // End of rendering\\n                              _self.endingCallback();\\n                            }\\n                            return;\\n                          }\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcontext.fillRect( blockX, blockY, blockSize, blockSize );\\n\\n\\t\\t\\tanimationFrameId = requestAnimationFrame( function () {\\n\\n\\t\\t\\t\\trenderBlock( blockX, blockY );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n  this.render = function ( scene, camera /* *TiddlyWiki* */, endingCallback ) {\\n\\n    if (TiddlyWiki && endingCallback) {\\n      this.endingCallback = endingCallback;\\n    }\\n\\n\\n\\t\\tif ( this.autoClear === true ) this.clear();\\n\\n\\t\\tcancelAnimationFrame( animationFrameId );\\n\\n\\t\\t// update scene graph\\n\\n\\t\\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\\n\\n\\t\\t// update camera matrices\\n\\n\\t\\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\\n\\n\\t\\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\\n\\t\\tcameraPosition.setFromMatrixPosition( camera.matrixWorld );\\n\\n\\t\\t//\\n\\n\\t\\tcameraNormalMatrix.getNormalMatrix( camera.matrixWorld );\\n\\t\\torigin.copy( cameraPosition );\\n\\n\\t\\tperspective = 0.5 / Math.tan( THREE.Math.degToRad( camera.fov * 0.5 ) ) * canvasHeight;\\n\\n\\t\\tobjects = scene.children;\\n\\n\\t\\t// collect lights and set up object matrices\\n\\n\\t\\tlights.length = 0;\\n\\n\\t\\tscene.traverse( function ( object ) {\\n\\n\\t\\t\\tif ( object instanceof THREE.Light ) {\\n\\n\\t\\t\\t\\tlights.push( object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( cache[ object.id ] === undefined ) {\\n\\n\\t\\t\\t\\tcache[ object.id ] = {\\n\\t\\t\\t\\t\\tnormalMatrix: new THREE.Matrix3(),\\n\\t\\t\\t\\t\\tinverseMatrix: new THREE.Matrix4()\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmodelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld )\\n\\n\\t\\t\\tvar _object = cache[ object.id ];\\n\\n\\t\\t\\t_object.normalMatrix.getNormalMatrix( modelViewMatrix );\\n\\t\\t\\t_object.inverseMatrix.getInverse( object.matrixWorld );\\n\\n\\t\\t} );\\n\\n\\t\\trenderBlock( 0, 0 );\\n\\n\\t};\\n\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Renderers/CSS3DRenderer.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Renderers/CSS3DRenderer.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.CSS3DObject = function ( element ) {\\n\\n\\tTHREE.Object3D.call( this );\\n\\n\\tthis.element = element;\\n\\tthis.element.style.position = 'absolute';\\n\\n\\tthis.addEventListener( 'removed', function ( event ) {\\n\\n\\t\\tif ( this.element.parentNode !== null ) {\\n\\n\\t\\t\\tthis.element.parentNode.removeChild( this.element );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n};\\n\\nTHREE.CSS3DObject.prototype = Object.create( THREE.Object3D.prototype );\\n\\nTHREE.CSS3DSprite = function ( element ) {\\n\\n\\tTHREE.CSS3DObject.call( this, element );\\n\\n};\\n\\nTHREE.CSS3DSprite.prototype = Object.create( THREE.CSS3DObject.prototype );\\n\\n//\\n\\nTHREE.CSS3DRenderer = function () {\\n\\n\\tconsole.log( 'THREE.CSS3DRenderer', THREE.REVISION );\\n\\n\\tvar _width, _height;\\n\\tvar _widthHalf, _heightHalf;\\n\\n\\tvar matrix = new THREE.Matrix4();\\n\\t\\n\\tvar cache = {\\n\\t\\tcamera: { fov: 0, style: '' },\\n\\t\\tobjects: {}\\n\\t};\\n\\n\\tvar domElement = document.createElement( 'div' );\\n\\tdomElement.style.overflow = 'hidden';\\n\\n\\tdomElement.style.WebkitTransformStyle = 'preserve-3d';\\n\\tdomElement.style.MozTransformStyle = 'preserve-3d';\\n\\tdomElement.style.oTransformStyle = 'preserve-3d';\\n\\tdomElement.style.transformStyle = 'preserve-3d';\\n\\n\\tthis.domElement = domElement;\\n\\n\\tvar cameraElement = document.createElement( 'div' );\\n\\n\\tcameraElement.style.WebkitTransformStyle = 'preserve-3d';\\n\\tcameraElement.style.MozTransformStyle = 'preserve-3d';\\n\\tcameraElement.style.oTransformStyle = 'preserve-3d';\\n\\tcameraElement.style.transformStyle = 'preserve-3d';\\n\\n\\tdomElement.appendChild( cameraElement );\\n\\n\\tthis.setClearColor = function () {\\n\\n\\t};\\n\\n\\tthis.setSize = function ( width, height ) {\\n\\n\\t\\t_width = width;\\n\\t\\t_height = height;\\n\\n\\t\\t_widthHalf = _width / 2;\\n\\t\\t_heightHalf = _height / 2;\\n\\n\\t\\tdomElement.style.width = width + 'px';\\n\\t\\tdomElement.style.height = height + 'px';\\n\\n\\t\\tcameraElement.style.width = width + 'px';\\n\\t\\tcameraElement.style.height = height + 'px';\\n\\n\\t};\\n\\n\\tvar epsilon = function ( value ) {\\n\\n\\t\\treturn Math.abs( value ) < 0.000001 ? 0 : value;\\n\\n\\t};\\n\\n\\tvar getCameraCSSMatrix = function ( matrix ) {\\n\\n\\t\\tvar elements = matrix.elements;\\n\\n\\t\\treturn 'matrix3d(' +\\n\\t\\t\\tepsilon( elements[ 0 ] ) + ',' +\\n\\t\\t\\tepsilon( - elements[ 1 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 2 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 3 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 4 ] ) + ',' +\\n\\t\\t\\tepsilon( - elements[ 5 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 6 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 7 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 8 ] ) + ',' +\\n\\t\\t\\tepsilon( - elements[ 9 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 10 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 11 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 12 ] ) + ',' +\\n\\t\\t\\tepsilon( - elements[ 13 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 14 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 15 ] ) +\\n\\t\\t')';\\n\\n\\t};\\n\\n\\tvar getObjectCSSMatrix = function ( matrix ) {\\n\\n\\t\\tvar elements = matrix.elements;\\n\\n\\t\\treturn 'translate3d(-50%,-50%,0) matrix3d(' +\\n\\t\\t\\tepsilon( elements[ 0 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 1 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 2 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 3 ] ) + ',' +\\n\\t\\t\\tepsilon( - elements[ 4 ] ) + ',' +\\n\\t\\t\\tepsilon( - elements[ 5 ] ) + ',' +\\n\\t\\t\\tepsilon( - elements[ 6 ] ) + ',' +\\n\\t\\t\\tepsilon( - elements[ 7 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 8 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 9 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 10 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 11 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 12 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 13 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 14 ] ) + ',' +\\n\\t\\t\\tepsilon( elements[ 15 ] ) +\\n\\t\\t')';\\n\\n\\t};\\n\\n\\tvar renderObject = function ( object, camera ) {\\n\\n\\t\\tif ( object instanceof THREE.CSS3DObject ) {\\n\\n\\t\\t\\tvar style;\\n\\n\\t\\t\\tif ( object instanceof THREE.CSS3DSprite ) {\\n\\n\\t\\t\\t\\t// http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/\\n\\n\\t\\t\\t\\tmatrix.copy( camera.matrixWorldInverse );\\n\\t\\t\\t\\tmatrix.transpose();\\n\\t\\t\\t\\tmatrix.copyPosition( object.matrixWorld );\\n\\t\\t\\t\\tmatrix.scale( object.scale );\\n\\n\\t\\t\\t\\tmatrix.elements[ 3 ] = 0;\\n\\t\\t\\t\\tmatrix.elements[ 7 ] = 0;\\n\\t\\t\\t\\tmatrix.elements[ 11 ] = 0;\\n\\t\\t\\t\\tmatrix.elements[ 15 ] = 1;\\n\\n\\t\\t\\t\\tstyle = getObjectCSSMatrix( matrix );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tstyle = getObjectCSSMatrix( object.matrixWorld );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar element = object.element;\\n\\t\\t\\tvar cachedStyle = cache.objects[ object.id ];\\n\\n\\t\\t\\tif ( cachedStyle === undefined || cachedStyle !== style ) {\\n\\n\\t\\t\\t\\telement.style.WebkitTransform = style;\\n\\t\\t\\t\\telement.style.MozTransform = style;\\n\\t\\t\\t\\telement.style.oTransform = style;\\n\\t\\t\\t\\telement.style.transform = style;\\n\\n\\t\\t\\t\\tcache.objects[ object.id ] = style;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( element.parentNode !== cameraElement ) {\\n\\n\\t\\t\\t\\tcameraElement.appendChild( element );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\\n\\n\\t\\t\\trenderObject( object.children[ i ], camera );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\n\\t\\tvar fov = 0.5 / Math.tan( THREE.Math.degToRad( camera.fov * 0.5 ) ) * _height;\\n\\n\\t\\tif ( cache.camera.fov !== fov ) {\\n\\n\\t\\t\\tdomElement.style.WebkitPerspective = fov + \\\"px\\\";\\n\\t\\t\\tdomElement.style.MozPerspective = fov + \\\"px\\\";\\n\\t\\t\\tdomElement.style.oPerspective = fov + \\\"px\\\";\\n\\t\\t\\tdomElement.style.perspective = fov + \\\"px\\\";\\n\\n\\t\\t\\tcache.camera.fov = fov;\\n\\n\\t\\t}\\n\\n\\t\\tscene.updateMatrixWorld();\\n\\n\\t\\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\\n\\n\\t\\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\\n\\n\\t\\tvar style = \\\"translate3d(0,0,\\\" + fov + \\\"px)\\\" + getCameraCSSMatrix( camera.matrixWorldInverse ) +\\n\\t\\t\\t\\\" translate3d(\\\" + _widthHalf + \\\"px,\\\" + _heightHalf + \\\"px, 0)\\\";\\n\\n\\t\\tif ( cache.camera.style !== style ) {\\n\\n\\t\\t\\tcameraElement.style.WebkitTransform = style;\\n\\t\\t\\tcameraElement.style.MozTransform = style;\\n\\t\\t\\tcameraElement.style.oTransform = style;\\n\\t\\t\\tcameraElement.style.transform = style;\\n\\t\\t\\t\\n\\t\\t\\tcache.camera.style = style;\\n\\n\\t\\t}\\n\\n\\t\\trenderObject( scene, camera );\\n\\n\\t};\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Renderers/SoftwareRenderer.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Renderers/SoftwareRenderer.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author ryg / http://farbrausch.de/~fg\\n * @author mraleph / http://mrale.ph/\\n */\\n\\nTHREE.SoftwareRenderer = function ( parameters ) {\\n\\n\\tconsole.log( 'THREE.SoftwareRenderer', THREE.REVISION );\\n\\n\\tparameters = parameters || {};\\n\\n\\tvar canvas = document.createElement( 'canvas' );\\n\\tvar context = canvas.getContext( '2d', {\\n\\t\\talpha: parameters.alpha === true\\n\\t} );\\n\\n\\tvar shaders = {};\\n\\n\\tvar canvasWidth, canvasHeight;\\n\\tvar canvasWBlocks, canvasHBlocks;\\n\\tvar viewportXScale, viewportYScale, viewportZScale;\\n\\tvar viewportXOffs, viewportYOffs, viewportZOffs;\\n\\n\\tvar clearColor = new THREE.Color( 0x000000 );\\n\\n\\tvar imagedata, data, zbuffer;\\n\\tvar numBlocks, blockMaxZ, blockFlags;\\n\\n\\tvar BLOCK_ISCLEAR = (1 << 0);\\n\\tvar BLOCK_NEEDCLEAR = (1 << 1);\\n\\n\\tvar subpixelBits = 4;\\n\\tvar subpixelBias = (1 << subpixelBits) - 1;\\n\\tvar blockShift = 3;\\n\\tvar blockSize = 1 << blockShift;\\n\\tvar maxZVal = (1 << 24); // Note: You want to size this so you don't get overflows.\\n\\n\\tvar rectx1 = Infinity, recty1 = Infinity;\\n\\tvar rectx2 = 0, recty2 = 0;\\n\\n\\tvar prevrectx1 = Infinity, prevrecty1 = Infinity;\\n\\tvar prevrectx2 = 0, prevrecty2 = 0;\\n\\n\\tvar projector = new THREE.Projector();\\n\\n\\tvar vector1 = new THREE.Vector3();\\n\\tvar vector2 = new THREE.Vector3();\\n\\tvar vector3 = new THREE.Vector3();\\n\\n\\tthis.domElement = canvas;\\n\\n\\tthis.autoClear = true;\\n\\n\\t// WebGLRenderer compatibility\\n\\n\\tthis.supportsVertexTextures = function () {};\\n\\tthis.setFaceCulling = function () {};\\n\\n\\tthis.setClearColor = function ( color, alpha ) {\\n\\n\\t\\tclearColor.set( color );\\n\\n\\t};\\n\\n\\tthis.setSize = function ( width, height ) {\\n\\n\\t\\tcanvasWBlocks = Math.floor( width / blockSize );\\n\\t\\tcanvasHBlocks = Math.floor( height / blockSize );\\n\\t\\tcanvasWidth   = canvasWBlocks * blockSize;\\n\\t\\tcanvasHeight  = canvasHBlocks * blockSize;\\n\\n\\t\\tvar fixScale = 1 << subpixelBits;\\n\\n\\t\\tviewportXScale =  fixScale * canvasWidth  / 2;\\n\\t\\tviewportYScale = -fixScale * canvasHeight / 2;\\n\\t\\tviewportZScale =             maxZVal      / 2;\\n\\t\\tviewportXOffs  =  fixScale * canvasWidth  / 2 + 0.5;\\n\\t\\tviewportYOffs  =  fixScale * canvasHeight / 2 + 0.5;\\n\\t\\tviewportZOffs  =             maxZVal      / 2 + 0.5;\\n\\n\\t\\tcanvas.width = canvasWidth;\\n\\t\\tcanvas.height = canvasHeight;\\n\\n\\t\\tcontext.fillStyle = clearColor.getStyle();\\n\\t\\tcontext.fillRect( 0, 0, canvasWidth, canvasHeight );\\n\\n\\t\\timagedata = context.getImageData( 0, 0, canvasWidth, canvasHeight );\\n\\t\\tdata = imagedata.data;\\n\\n\\t\\tzbuffer = new Int32Array( data.length / 4 );\\n\\n\\t\\tnumBlocks = canvasWBlocks * canvasHBlocks;\\n\\t\\tblockMaxZ = new Int32Array( numBlocks );\\n\\t\\tblockFlags = new Uint8Array( numBlocks );\\n\\n\\t\\tfor ( var i = 0, l = zbuffer.length; i < l; i ++ ) {\\n\\n\\t\\t\\tzbuffer[ i ] = maxZVal;\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0; i < numBlocks; i ++ ) {\\n\\n\\t\\t\\tblockFlags[ i ] = BLOCK_ISCLEAR;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.setSize( canvas.width, canvas.height );\\n\\n\\tthis.clear = function () {\\n\\n\\t\\trectx1 = Infinity;\\n\\t\\trecty1 = Infinity;\\n\\t\\trectx2 = 0;\\n\\t\\trecty2 = 0;\\n\\n\\t\\tfor ( var i = 0; i < numBlocks; i ++ ) {\\n\\n\\t\\t\\tblockMaxZ[ i ] = maxZVal;\\n\\t\\t\\tblockFlags[ i ] = (blockFlags[ i ] & BLOCK_ISCLEAR) ? BLOCK_ISCLEAR : BLOCK_NEEDCLEAR;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\n\\t\\tif ( this.autoClear === true ) this.clear();\\n\\n\\t\\tvar renderData = projector.projectScene( scene, camera, false, false );\\n\\t\\tvar elements = renderData.elements;\\n\\n\\t\\tfor ( var e = 0, el = elements.length; e < el; e ++ ) {\\n\\n\\t\\t\\tvar element = elements[ e ];\\n\\t\\t\\tvar material = element.material;\\n\\t\\t\\tvar shader = getMaterialShader( material );\\n\\n\\t\\t\\tif ( element instanceof THREE.RenderableFace ) {\\n\\n\\t\\t\\t\\tdrawTriangle(\\n\\t\\t\\t\\t\\telement.v1.positionScreen,\\n\\t\\t\\t\\t\\telement.v2.positionScreen,\\n\\t\\t\\t\\t\\telement.v3.positionScreen,\\n\\t\\t\\t\\t\\tshader, element, material\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else if ( element instanceof THREE.RenderableSprite ) {\\n\\n\\t\\t\\t\\tvar scaleX = element.scale.x * 0.5;\\n\\t\\t\\t\\tvar scaleY = element.scale.y * 0.5;\\n\\n\\t\\t\\t\\tvector1.copy( element );\\n\\t\\t\\t\\tvector1.x -= scaleX;\\n\\t\\t\\t\\tvector1.y += scaleY;\\n\\n\\t\\t\\t\\tvector2.copy( element );\\n\\t\\t\\t\\tvector2.x -= scaleX;\\n\\t\\t\\t\\tvector2.y -= scaleY;\\n\\n\\t\\t\\t\\tvector3.copy( element );\\n\\t\\t\\t\\tvector3.x += scaleX;\\n\\t\\t\\t\\tvector3.y += scaleY;\\n\\n\\t\\t\\t\\tdrawTriangle(\\n\\t\\t\\t\\t\\tvector1, vector2, vector3,\\n\\t\\t\\t\\t\\tshader, element, material\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\tvector1.copy( element );\\n\\t\\t\\t\\tvector1.x += scaleX;\\n\\t\\t\\t\\tvector1.y += scaleY;\\n\\n\\t\\t\\t\\tvector2.copy( element );\\n\\t\\t\\t\\tvector2.x -= scaleX;\\n\\t\\t\\t\\tvector2.y -= scaleY;\\n\\n\\t\\t\\t\\tvector3.copy( element );\\n\\t\\t\\t\\tvector3.x += scaleX;\\n\\t\\t\\t\\tvector3.y -= scaleY;\\n\\n\\t\\t\\t\\tdrawTriangle(\\n\\t\\t\\t\\t\\tvector1, vector2, vector3,\\n\\t\\t\\t\\t\\tshader, element, material\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfinishClear();\\n\\n\\t\\tvar x = Math.min( rectx1, prevrectx1 );\\n\\t\\tvar y = Math.min( recty1, prevrecty1 );\\n\\t\\tvar width = Math.max( rectx2, prevrectx2 ) - x;\\n\\t\\tvar height = Math.max( recty2, prevrecty2 ) - y;\\n\\n\\t\\t/*\\n\\t\\t// debug; draw zbuffer\\n\\n\\t\\tfor ( var i = 0, l = zbuffer.length; i < l; i++ ) {\\n\\n\\t\\t\\tvar o = i * 4;\\n\\t\\t\\tvar v = (65535 - zbuffer[ i ]) >> 3;\\n\\t\\t\\tdata[ o + 0 ] = v;\\n\\t\\t\\tdata[ o + 1 ] = v;\\n\\t\\t\\tdata[ o + 2 ] = v;\\n\\t\\t\\tdata[ o + 3 ] = 255;\\n\\t\\t}\\n\\t\\t*/\\n\\n\\t\\tif ( x !== Infinity ) {\\n\\n\\t\\t\\tcontext.putImageData( imagedata, 0, 0, x, y, width, height );\\n\\n\\t\\t}\\n\\n\\t\\tprevrectx1 = rectx1; prevrecty1 = recty1;\\n\\t\\tprevrectx2 = rectx2; prevrecty2 = recty2;\\n\\n\\t};\\n\\n\\tfunction getMaterialShader( material ) {\\n\\n\\t\\tvar id = material.id;\\n\\t\\tvar shader = shaders[ id ];\\n\\n\\t\\tif ( shaders[ id ] === undefined ) {\\n\\n\\t\\t\\tif ( material instanceof THREE.MeshBasicMaterial ||\\n\\t\\t\\t     material instanceof THREE.MeshLambertMaterial ||\\n\\t\\t\\t     material instanceof THREE.MeshPhongMaterial ||\\n\\t\\t\\t     material instanceof THREE.SpriteMaterial ) {\\n\\n\\t\\t\\t\\tvar string;\\n\\n\\t\\t\\t\\tif ( material.vertexColors === THREE.FaceColors ) {\\n\\n\\t\\t\\t\\t\\tstring = [\\n\\t\\t\\t\\t\\t\\t'buffer[ offset ] = face.color.r * 255;',\\n\\t\\t\\t\\t\\t\\t'buffer[ offset + 1 ] = face.color.g * 255;',\\n\\t\\t\\t\\t\\t\\t'buffer[ offset + 2 ] = face.color.b * 255;',\\n\\t\\t\\t\\t\\t\\t'buffer[ offset + 3 ] = material.opacity * 255;',\\n\\t\\t\\t\\t\\t].join('\\\\n');\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tstring = [\\n\\t\\t\\t\\t\\t\\t'buffer[ offset ] = material.color.r * 255;',\\n\\t\\t\\t\\t\\t\\t'buffer[ offset + 1 ] = material.color.g * 255;',\\n\\t\\t\\t\\t\\t\\t'buffer[ offset + 2 ] = material.color.b * 255;',\\n\\t\\t\\t\\t\\t\\t'buffer[ offset + 3 ] = material.opacity * 255;',\\n\\t\\t\\t\\t\\t].join('\\\\n');\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tshader = new Function( 'buffer, offset, u, v, face, material', string );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar string = [\\n\\t\\t\\t\\t\\t'buffer[ offset ] = u * 255;',\\n\\t\\t\\t\\t\\t'buffer[ offset + 1 ] = v * 255;',\\n\\t\\t\\t\\t\\t'buffer[ offset + 2 ] = 0;',\\n\\t\\t\\t\\t\\t'buffer[ offset + 3 ] = 255;'\\n\\t\\t\\t\\t].join('\\\\n');\\n\\n\\t\\t\\t\\tshader = new Function( 'buffer, offset, u, v', string );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tshaders[ id ] = shader;\\n\\n\\t\\t}\\n\\n\\t\\treturn shader;\\n\\n\\t}\\n\\n\\tfunction clearRectangle( x1, y1, x2, y2 ) {\\n\\n\\t\\tvar xmin = Math.max( Math.min( x1, x2 ), 0 );\\n\\t\\tvar xmax = Math.min( Math.max( x1, x2 ), canvasWidth );\\n\\t\\tvar ymin = Math.max( Math.min( y1, y2 ), 0 );\\n\\t\\tvar ymax = Math.min( Math.max( y1, y2 ), canvasHeight );\\n\\n\\t\\tvar offset = ( xmin + ymin * canvasWidth ) * 4 + 3;\\n\\t\\tvar linestep = ( canvasWidth - ( xmax - xmin ) ) * 4;\\n\\n\\t\\tfor ( var y = ymin; y < ymax; y ++ ) {\\n\\n\\t\\t\\tfor ( var x = xmin; x < xmax; x ++ ) {\\n\\n\\t\\t\\t\\tdata[ offset += 4 ] = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\toffset += linestep;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction drawTriangle( v1, v2, v3, shader, face, material ) {\\n\\n\\t\\t// TODO: Implement per-pixel z-clipping\\n\\n\\t\\tif ( v1.z < -1 || v1.z > 1 || v2.z < -1 || v2.z > 1 || v3.z < -1 || v3.z > 1 ) return;\\n\\n\\t\\t// https://gist.github.com/2486101\\n\\t\\t// explanation: http://pouet.net/topic.php?which=8760&page=1\\n\\n\\t\\t// 28.4 fixed-point coordinates\\n\\n\\t\\tvar x1 = (v1.x * viewportXScale + viewportXOffs) | 0;\\n\\t\\tvar x2 = (v2.x * viewportXScale + viewportXOffs) | 0;\\n\\t\\tvar x3 = (v3.x * viewportXScale + viewportXOffs) | 0;\\n\\n\\t\\tvar y1 = (v1.y * viewportYScale + viewportYOffs) | 0;\\n\\t\\tvar y2 = (v2.y * viewportYScale + viewportYOffs) | 0;\\n\\t\\tvar y3 = (v3.y * viewportYScale + viewportYOffs) | 0;\\n\\n\\t\\t// Z values (.28 fixed-point)\\n\\n\\t\\tvar z1 = (v1.z * viewportZScale + viewportZOffs) | 0;\\n\\t\\tvar z2 = (v2.z * viewportZScale + viewportZOffs) | 0;\\n\\t\\tvar z3 = (v3.z * viewportZScale + viewportZOffs) | 0;\\n\\n\\t\\t// Deltas\\n\\n\\t\\tvar dx12 = x1 - x2, dy12 = y2 - y1;\\n\\t\\tvar dx23 = x2 - x3, dy23 = y3 - y2;\\n\\t\\tvar dx31 = x3 - x1, dy31 = y1 - y3;\\n\\n\\t\\t// Bounding rectangle\\n\\n\\t\\tvar minx = Math.max( ( Math.min( x1, x2, x3 ) + subpixelBias ) >> subpixelBits, 0 );\\n\\t\\tvar maxx = Math.min( ( Math.max( x1, x2, x3 ) + subpixelBias ) >> subpixelBits, canvasWidth );\\n\\t\\tvar miny = Math.max( ( Math.min( y1, y2, y3 ) + subpixelBias ) >> subpixelBits, 0 );\\n\\t\\tvar maxy = Math.min( ( Math.max( y1, y2, y3 ) + subpixelBias ) >> subpixelBits, canvasHeight );\\n\\n\\t\\trectx1 = Math.min( minx, rectx1 );\\n\\t\\trectx2 = Math.max( maxx, rectx2 );\\n\\t\\trecty1 = Math.min( miny, recty1 );\\n\\t\\trecty2 = Math.max( maxy, recty2 );\\n\\n\\t\\t// Block size, standard 8x8 (must be power of two)\\n\\n\\t\\tvar q = blockSize;\\n\\n\\t\\t// Start in corner of 8x8 block\\n\\n\\t\\tminx &= ~(q - 1);\\n\\t\\tminy &= ~(q - 1);\\n\\n\\t\\t// Constant part of half-edge functions\\n\\n\\t\\tvar c1 = dy12 * ((minx << subpixelBits) - x1) + dx12 * ((miny << subpixelBits) - y1);\\n\\t\\tvar c2 = dy23 * ((minx << subpixelBits) - x2) + dx23 * ((miny << subpixelBits) - y2);\\n\\t\\tvar c3 = dy31 * ((minx << subpixelBits) - x3) + dx31 * ((miny << subpixelBits) - y3);\\n\\n\\t\\t// Correct for fill convention\\n\\n\\t\\tif ( dy12 > 0 || ( dy12 == 0 && dx12 > 0 ) ) c1 ++;\\n\\t\\tif ( dy23 > 0 || ( dy23 == 0 && dx23 > 0 ) ) c2 ++;\\n\\t\\tif ( dy31 > 0 || ( dy31 == 0 && dx31 > 0 ) ) c3 ++;\\n\\n\\t\\t// Note this doesn't kill subpixel precision, but only because we test for >=0 (not >0).\\n\\t\\t// It's a bit subtle. :)\\n\\t\\tc1 = (c1 - 1) >> subpixelBits;\\n\\t\\tc2 = (c2 - 1) >> subpixelBits;\\n\\t\\tc3 = (c3 - 1) >> subpixelBits;\\n\\n\\t\\t// Z interpolation setup\\n\\n\\t\\tvar dz12 = z1 - z2, dz31 = z3 - z1;\\n\\t\\tvar invDet = 1.0 / (dx12*dy31 - dx31*dy12);\\n\\t\\tvar dzdx = (invDet * (dz12*dy31 - dz31*dy12)); // dz per one subpixel step in x\\n\\t\\tvar dzdy = (invDet * (dz12*dx31 - dx12*dz31)); // dz per one subpixel step in y\\n\\n\\t\\t// Z at top/left corner of rast area\\n\\n\\t\\tvar cz = ( z1 + ((minx << subpixelBits) - x1) * dzdx + ((miny << subpixelBits) - y1) * dzdy ) | 0;\\n\\n\\t\\t// Z pixel steps\\n\\n\\t\\tvar zfixscale = (1 << subpixelBits);\\n\\t\\tdzdx = (dzdx * zfixscale) | 0;\\n\\t\\tdzdy = (dzdy * zfixscale) | 0;\\n\\n\\t\\t// Set up min/max corners\\n\\t\\tvar qm1 = q - 1; // for convenience\\n\\t\\tvar nmin1 = 0, nmax1 = 0;\\n\\t\\tvar nmin2 = 0, nmax2 = 0;\\n\\t\\tvar nmin3 = 0, nmax3 = 0;\\n\\t\\tvar nminz = 0, nmaxz = 0;\\n\\t\\tif (dx12 >= 0) nmax1 -= qm1*dx12; else nmin1 -= qm1*dx12;\\n\\t\\tif (dy12 >= 0) nmax1 -= qm1*dy12; else nmin1 -= qm1*dy12;\\n\\t\\tif (dx23 >= 0) nmax2 -= qm1*dx23; else nmin2 -= qm1*dx23;\\n\\t\\tif (dy23 >= 0) nmax2 -= qm1*dy23; else nmin2 -= qm1*dy23;\\n\\t\\tif (dx31 >= 0) nmax3 -= qm1*dx31; else nmin3 -= qm1*dx31;\\n\\t\\tif (dy31 >= 0) nmax3 -= qm1*dy31; else nmin3 -= qm1*dy31;\\n\\t\\tif (dzdx >= 0) nmaxz += qm1*dzdx; else nminz += qm1*dzdx;\\n\\t\\tif (dzdy >= 0) nmaxz += qm1*dzdy; else nminz += qm1*dzdy;\\n\\n\\t\\t// Loop through blocks\\n\\t\\tvar linestep = canvasWidth - q;\\n\\t\\tvar scale = 1.0 / (c1 + c2 + c3);\\n\\n\\t\\tvar cb1 = c1;\\n\\t\\tvar cb2 = c2;\\n\\t\\tvar cb3 = c3;\\n\\t\\tvar cbz = cz;\\n\\t\\tvar qstep = -q;\\n\\t\\tvar e1x = qstep * dy12;\\n\\t\\tvar e2x = qstep * dy23;\\n\\t\\tvar e3x = qstep * dy31;\\n\\t\\tvar ezx = qstep * dzdx;\\n\\t\\tvar x0 = minx;\\n\\n\\t\\tfor ( var y0 = miny; y0 < maxy; y0 += q ) {\\n\\n\\t\\t\\t// New block line - keep hunting for tri outer edge in old block line dir\\n\\t\\t\\twhile ( x0 >= minx && x0 < maxx && cb1 >= nmax1 && cb2 >= nmax2 && cb3 >= nmax3 ) {\\n\\n\\t\\t\\t\\tx0 += qstep;\\n\\t\\t\\t\\tcb1 += e1x;\\n\\t\\t\\t\\tcb2 += e2x;\\n\\t\\t\\t\\tcb3 += e3x;\\n\\t\\t\\t\\tcbz += ezx;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Okay, we're now in a block we know is outside. Reverse direction and go into main loop.\\n\\t\\t\\tqstep = -qstep;\\n\\t\\t\\te1x = -e1x;\\n\\t\\t\\te2x = -e2x;\\n\\t\\t\\te3x = -e3x;\\n\\t\\t\\tezx = -ezx;\\n\\n\\t\\t\\twhile ( 1 ) {\\n\\n\\t\\t\\t\\t// Step everything\\n\\t\\t\\t\\tx0 += qstep;\\n\\t\\t\\t\\tcb1 += e1x;\\n\\t\\t\\t\\tcb2 += e2x;\\n\\t\\t\\t\\tcb3 += e3x;\\n\\t\\t\\t\\tcbz += ezx;\\n\\n\\t\\t\\t\\t// We're done with this block line when at least one edge completely out\\n\\t\\t\\t\\t// If an edge function is too small and decreasing in the current traversal\\n\\t\\t\\t\\t// dir, we're done with this line.\\n\\t\\t\\t\\tif (x0 < minx || x0 >= maxx) break;\\n\\t\\t\\t\\tif (cb1 < nmax1) if (e1x < 0) break; else continue;\\n\\t\\t\\t\\tif (cb2 < nmax2) if (e2x < 0) break; else continue;\\n\\t\\t\\t\\tif (cb3 < nmax3) if (e3x < 0) break; else continue;\\n\\n\\t\\t\\t\\t// We can skip this block if it's already fully covered\\n\\t\\t\\t\\tvar blockX = x0 >> blockShift;\\n\\t\\t\\t\\tvar blockY = y0 >> blockShift;\\n\\t\\t\\t\\tvar blockId = blockX + blockY * canvasWBlocks;\\n\\t\\t\\t\\tvar minz = cbz + nminz;\\n\\n\\t\\t\\t\\t// farthest point in block closer than closest point in our tri?\\n\\t\\t\\t\\tif ( blockMaxZ[ blockId ] < minz ) continue;\\n\\n\\t\\t\\t\\t// Need to do a deferred clear?\\n\\t\\t\\t\\tvar bflags = blockFlags[ blockId ];\\n\\t\\t\\t\\tif ( bflags & BLOCK_NEEDCLEAR) clearBlock( blockX, blockY );\\n\\t\\t\\t\\tblockFlags[ blockId ] = bflags & ~( BLOCK_ISCLEAR | BLOCK_NEEDCLEAR );\\n\\n\\t\\t\\t\\t// Offset at top-left corner\\n\\t\\t\\t\\tvar offset = x0 + y0 * canvasWidth;\\n\\n\\t\\t\\t\\t// Accept whole block when fully covered\\n\\t\\t\\t\\tif ( cb1 >= nmin1 && cb2 >= nmin2 && cb3 >= nmin3 ) {\\n\\n\\t\\t\\t\\t\\tvar maxz = cbz + nmaxz;\\n\\t\\t\\t\\t\\tblockMaxZ[ blockId ] = Math.min( blockMaxZ[ blockId ], maxz );\\n\\n\\t\\t\\t\\t\\tvar cy1 = cb1;\\n\\t\\t\\t\\t\\tvar cy2 = cb2;\\n\\t\\t\\t\\t\\tvar cyz = cbz;\\n\\n\\t\\t\\t\\t\\tfor ( var iy = 0; iy < q; iy ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar cx1 = cy1;\\n\\t\\t\\t\\t\\t\\tvar cx2 = cy2;\\n\\t\\t\\t\\t\\t\\tvar cxz = cyz;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var ix = 0; ix < q; ix ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar z = cxz;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( z < zbuffer[ offset ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tzbuffer[ offset ] = z;\\n\\t\\t\\t\\t\\t\\t\\t\\tvar u = cx1 * scale;\\n\\t\\t\\t\\t\\t\\t\\t\\tvar v = cx2 * scale;\\n\\t\\t\\t\\t\\t\\t\\t\\tshader( data, offset * 4, u, v, face, material );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tcx1 += dy12;\\n\\t\\t\\t\\t\\t\\t\\tcx2 += dy23;\\n\\t\\t\\t\\t\\t\\t\\tcxz += dzdx;\\n\\t\\t\\t\\t\\t\\t\\toffset++;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tcy1 += dx12;\\n\\t\\t\\t\\t\\t\\tcy2 += dx23;\\n\\t\\t\\t\\t\\t\\tcyz += dzdy;\\n\\t\\t\\t\\t\\t\\toffset += linestep;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else { // Partially covered block\\n\\n\\t\\t\\t\\t\\tvar cy1 = cb1;\\n\\t\\t\\t\\t\\tvar cy2 = cb2;\\n\\t\\t\\t\\t\\tvar cy3 = cb3;\\n\\t\\t\\t\\t\\tvar cyz = cbz;\\n\\n\\t\\t\\t\\t\\tfor ( var iy = 0; iy < q; iy ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar cx1 = cy1;\\n\\t\\t\\t\\t\\t\\tvar cx2 = cy2;\\n\\t\\t\\t\\t\\t\\tvar cx3 = cy3;\\n\\t\\t\\t\\t\\t\\tvar cxz = cyz;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var ix = 0; ix < q; ix ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( ( cx1 | cx2 | cx3 ) >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar z = cxz;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( z < zbuffer[ offset ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar u = cx1 * scale;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar v = cx2 * scale;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tzbuffer[ offset ] = z;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tshader( data, offset * 4, u, v, face, material );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tcx1 += dy12;\\n\\t\\t\\t\\t\\t\\t\\tcx2 += dy23;\\n\\t\\t\\t\\t\\t\\t\\tcx3 += dy31;\\n\\t\\t\\t\\t\\t\\t\\tcxz += dzdx;\\n\\t\\t\\t\\t\\t\\t\\toffset++;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tcy1 += dx12;\\n\\t\\t\\t\\t\\t\\tcy2 += dx23;\\n\\t\\t\\t\\t\\t\\tcy3 += dx31;\\n\\t\\t\\t\\t\\t\\tcyz += dzdy;\\n\\t\\t\\t\\t\\t\\toffset += linestep;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Advance to next row of blocks\\n\\t\\t\\tcb1 += q*dx12;\\n\\t\\t\\tcb2 += q*dx23;\\n\\t\\t\\tcb3 += q*dx31;\\n\\t\\t\\tcbz += q*dzdy;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction clearBlock( blockX, blockY ) {\\n\\n\\t\\tvar zoffset = blockX * blockSize + blockY * blockSize * canvasWidth;\\n\\t\\tvar poffset = zoffset * 4;\\n\\n\\t\\tvar zlinestep = canvasWidth - blockSize;\\n\\t\\tvar plinestep = zlinestep * 4;\\n\\n\\t\\tfor ( var y = 0; y < blockSize; y ++ ) {\\n\\n\\t\\t\\tfor ( var x = 0; x < blockSize; x ++ ) {\\n\\n\\t\\t\\t\\tzbuffer[ zoffset ++ ] = maxZVal;\\n\\n\\t\\t\\t\\tdata[ poffset ++ ] = clearColor.r * 255 | 0;\\n\\t\\t\\t\\tdata[ poffset ++ ] = clearColor.g * 255 | 0;\\n\\t\\t\\t\\tdata[ poffset ++ ] = clearColor.b * 255 | 0;\\n\\t\\t\\t\\tdata[ poffset ++ ] = 255;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tzoffset += zlinestep;\\n\\t\\t\\tpoffset += plinestep;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction finishClear( ) {\\n\\n\\t\\tvar block = 0;\\n\\n\\t\\tfor ( var y = 0; y < canvasHBlocks; y ++ ) {\\n\\n\\t\\t\\tfor ( var x = 0; x < canvasWBlocks; x ++ ) {\\n\\n\\t\\t\\t\\tif ( blockFlags[ block ] & BLOCK_NEEDCLEAR ) {\\n\\n\\t\\t\\t\\t\\tclearBlock( x, y );\\n\\t\\t\\t\\t\\tblockFlags[ block ] = BLOCK_ISCLEAR;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tblock ++;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Renderers/WebGLRenderer3.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Renderers/WebGLRenderer3.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n *\\n * parameters = {\\n *   canvas: canvas,\\n *   contextAttributes: {\\n *     alpha: false,\\n *     depth: true,\\n *     stencil: false,\\n *     antialias: true,\\n *     premultipliedAlpha: true,\\n *     preserveDrawingBuffer: false\\n *   }\\n * }\\n *\\n */\\n\\nTHREE.WebGLRenderer3 = function ( parameters ) {\\n\\n\\tconsole.log( 'THREE.WebGLRenderer3', THREE.REVISION );\\n\\n\\tparameters = parameters || {};\\n\\n\\tvar scope = this;\\n\\n\\tvar canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' );\\n\\n\\tvar devicePixelRatio = parameters.devicePixelRatio !== undefined\\n\\t\\t\\t\\t? parameters.devicePixelRatio\\n\\t\\t\\t\\t: self.devicePixelRatio !== undefined\\n\\t\\t\\t\\t\\t? self.devicePixelRatio\\n\\t\\t\\t\\t\\t: 1;\\n\\n\\tvar gl;\\n\\n\\ttry {\\n\\n\\t\\tvar attributes = parameters.contextAttributes || {};\\n\\t\\t\\n\\t\\tif ( attributes.alpha === undefined ) attributes.alpha = false;\\n\\n\\t\\tgl = canvas.getContext( 'webgl', attributes ) || canvas.getContext( 'experimental-webgl', attributes );\\n\\n\\t\\tif ( gl === null ) {\\n\\n\\t\\t\\tthrow 'Error creating WebGL context.';\\n\\n\\t\\t}\\n\\n\\t} catch ( exception ) {\\n\\n\\t\\tconsole.error( exception );\\n\\n\\t}\\n\\n\\tvar precision = 'highp';\\n\\tvar extensions = {};\\n\\n\\tif ( gl !== null ) {\\n\\n\\t\\textensions.element_index_uint = gl.getExtension( 'OES_element_index_uint' );\\n\\t\\textensions.texture_float = gl.getExtension( 'OES_texture_float' );\\n\\t\\textensions.texture_float_linear = gl.getExtension( 'OES_texture_float_linear' );\\n\\t\\textensions.standard_derivatives = gl.getExtension( 'OES_standard_derivatives' );\\n\\t\\textensions.texture_filter_anisotropic = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\\n\\t\\textensions.compressed_texture_s3tc = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\\n\\n\\t\\tgl.clearColor( 0, 0, 0, 1 );\\n\\t\\tgl.clearDepth( 1 );\\n\\t\\tgl.clearStencil( 0 );\\n\\n\\t\\tgl.enable( gl.DEPTH_TEST );\\n\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\n\\t\\tgl.enable( gl.CULL_FACE );\\n\\t\\tgl.frontFace( gl.CCW );\\n\\t\\tgl.cullFace( gl.BACK );\\n\\n\\t\\tgl.enable( gl.BLEND );\\n\\t\\tgl.blendEquation( gl.FUNC_ADD );\\n\\t\\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );\\n\\n\\t\\tgl.clearColor( 0, 0, 0, 0 );\\n\\n\\t}\\n\\n\\tvar clearColor = new THREE.Color( 0x000000 );\\n\\tvar clearAlpha = 0;\\n\\n\\t//\\n\\n\\tvar vector3 = new THREE.Vector3();\\n\\tvar frustum = new THREE.Frustum();\\n\\tvar normalMatrix = new THREE.Matrix3();\\n\\tvar modelViewMatrix = new THREE.Matrix4();\\n\\tvar cameraViewProjectionMatrix = new THREE.Matrix4();\\n\\n\\t// buffers\\n\\n\\tvar buffers = {};\\n\\n\\tvar getBuffer = function ( geometry, material ) {\\n\\n\\t\\tvar hash = geometry.id.toString() + '+' + material.id.toString();\\n\\n\\t\\tif ( buffers[ hash ] !== undefined ) {\\n\\n\\t\\t\\treturn buffers[ hash ];\\n\\n\\t\\t}\\n\\n\\t\\tvar vertices = geometry.vertices;\\n\\t\\tvar faces = geometry.faces;\\n\\n\\t\\t//\\n\\n\\t\\tvar positions = [];\\n\\t\\tvar addPosition = function ( position ) {\\n\\n\\t\\t\\tpositions.push( position.x, position.y, position.z );\\n\\n\\t\\t}\\n\\n\\t\\tvar normals = [];\\n\\t\\tvar addNormal = function ( normal ) {\\n\\n\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar face = faces[ i ];\\n\\t\\t\\tvar vertexNormals = face.vertexNormals.length > 0;\\n\\n\\t\\t\\taddPosition( vertices[ face.a ] );\\n\\t\\t\\taddPosition( vertices[ face.b ] );\\n\\t\\t\\taddPosition( vertices[ face.c ] );\\n\\n\\t\\t\\tif ( vertexNormals === true ) {\\n\\n\\t\\t\\t\\taddNormal( face.vertexNormals[ 0 ] );\\n\\t\\t\\t\\taddNormal( face.vertexNormals[ 1 ] );\\n\\t\\t\\t\\taddNormal( face.vertexNormals[ 2 ] );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\taddNormal( face.normal );\\n\\t\\t\\t\\taddNormal( face.normal );\\n\\t\\t\\t\\taddNormal( face.normal );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar buffer = {\\n\\t\\t\\tpositions: gl.createBuffer(),\\n\\t\\t\\tnormals: gl.createBuffer(),\\n\\t\\t\\tcount: positions.length / 3\\n\\t\\t};\\n\\n\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer.positions );\\n\\t\\tgl.bufferData( gl.ARRAY_BUFFER, new Float32Array( positions ), gl.STATIC_DRAW );\\n\\n\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer.normals );\\n\\t\\tgl.bufferData( gl.ARRAY_BUFFER, new Float32Array( normals ), gl.STATIC_DRAW );\\n\\n\\t\\tbuffers[ hash ] = buffer;\\n\\n\\t\\tscope.info.memory.geometries ++;\\n\\n\\t\\treturn buffer;\\n\\n\\t};\\n\\n\\t// programs\\n\\n\\tvar programs = {};\\n\\tvar programsCache = {};\\n\\n\\tvar getProgram = function ( material ) {\\n\\n\\t\\tif ( programs[ material.id ] !== undefined ) {\\n\\n\\t\\t\\treturn programs[ material.id ];\\n\\n\\t\\t}\\n\\n\\t\\tvar vertexShader = [\\n\\t\\t\\t'precision ' + precision + ' float;',\\n\\t\\t\\t\\\"precision \\\" + precision + \\\" int;\\\",\\n\\t\\t\\t'attribute vec3 position;',\\n\\t\\t\\t'attribute vec3 normal;',\\n\\t\\t\\t'uniform mat4 modelViewMatrix;',\\n\\t\\t\\t'uniform mat3 normalMatrix;',\\n\\t\\t\\t'uniform mat4 projectionMatrix;',\\n\\t\\t\\t''\\n\\t\\t].join( '\\\\n' );\\n\\n\\t\\tvar fragmentShader = [\\n\\t\\t\\t'precision ' + precision + ' float;',\\n\\t\\t\\t\\\"precision \\\" + precision + \\\" int;\\\",\\n\\t\\t\\t''\\n\\t\\t].join( '\\\\n' );\\n\\n\\t\\tif ( material instanceof THREE.ShaderMaterial ) {\\n\\n\\t\\t\\tvertexShader += material.vertexShader;\\n\\t\\t\\tfragmentShader += material.fragmentShader;\\n\\n\\t\\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\\n\\n\\t\\t\\tvertexShader += [\\n\\t\\t\\t\\t'varying vec3 vNormal;',\\n\\t\\t\\t\\t'void main() {',\\n\\t\\t\\t\\t'\\tvNormal = normalize( normalMatrix * normal );',\\n\\t\\t\\t\\t'\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\\n\\t\\t\\t\\t'}'\\n\\t\\t\\t].join( '\\\\n' );\\n\\n\\t\\t\\tfragmentShader += [\\n\\t\\t\\t\\t'varying vec3 vNormal;',\\n\\t\\t\\t\\t'uniform float opacity;',\\n\\t\\t\\t\\t'void main() {',\\n\\t\\t\\t\\t'\\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );',\\n\\t\\t\\t\\t'}'\\n\\t\\t\\t].join( '\\\\n' );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tvertexShader += [\\n\\t\\t\\t\\t'void main() {',\\n\\t\\t\\t\\t'\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\\n\\t\\t\\t\\t'}'\\n\\t\\t\\t].join( '\\\\n' );\\n\\n\\t\\t\\tfragmentShader += [\\n\\t\\t\\t\\t'void main() {',\\n\\t\\t\\t\\t'\\tgl_FragColor = vec4( 1.0, 0, 0, 1.0 );',\\n\\t\\t\\t\\t'}'\\n\\t\\t\\t].join( '\\\\n' );\\n\\n\\t\\t}\\n\\n\\t\\tvar program;\\n\\t\\tvar code = vertexShader + fragmentShader;\\n\\n\\t\\tif ( programsCache[ code ] !== undefined ) {\\n\\n\\t\\t\\tprogram = programsCache[ code ];\\n\\t\\t\\tprograms[ material.id ] = program;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tprogram = gl.createProgram();\\n\\n\\t\\t\\tgl.attachShader( program, createShader( gl.VERTEX_SHADER, vertexShader ) );\\n\\t\\t\\tgl.attachShader( program, createShader( gl.FRAGMENT_SHADER, fragmentShader ) );\\n\\t\\t\\tgl.linkProgram( program );\\n\\n\\t\\t\\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === true ) {\\n\\n\\t\\t\\t\\tprogramsCache[ code ] = program;\\n\\t\\t\\t\\tprograms[ material.id ] = program;\\n\\n\\t\\t\\t\\tscope.info.memory.programs ++;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.error( 'Program Info Log: ' + gl.getProgramInfoLog( program ) );\\n\\t\\t\\t\\tconsole.error( 'VALIDATE_STATUS: ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) );\\n\\t\\t\\t\\tconsole.error( 'GL_ERROR: ' + gl.getError() );\\n\\n\\t\\t\\t\\t// fallback\\n\\n\\t\\t\\t\\tprogram = getProgram( new THREE.MeshBasicMaterial() );\\n\\t\\t\\t\\tprograms[ material.id ] = program;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn program;\\n\\n\\t};\\n\\n\\tvar createShader = function ( type, string ) {\\n\\n\\t\\tvar shader = gl.createShader( type );\\n\\n\\t\\tgl.shaderSource( shader, string );\\n\\t\\tgl.compileShader( shader );\\n\\n\\t\\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === true ) {\\n\\n\\t\\t\\t// console.log( string );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.error( gl.getShaderInfoLog( shader ), string );\\n\\t\\t\\treturn null;\\n\\n\\t\\t}\\n\\n\\t\\treturn shader;\\n\\n\\t};\\n\\n\\tthis.info = {\\n\\n\\t\\tmemory: {\\n\\n\\t\\t\\tprograms: 0,\\n\\t\\t\\tgeometries: 0,\\n\\t\\t\\ttextures: 0\\n\\n\\t\\t},\\n\\n\\t\\trender: {\\n\\n\\t\\t\\tcalls: 0,\\n\\t\\t\\tvertices: 0,\\n\\t\\t\\tfaces: 0,\\n\\t\\t\\tpoints: 0\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.domElement = canvas;\\n\\tthis.extensions = extensions;\\n\\n\\tthis.autoClear = true; // TODO: Make private\\n\\n\\tthis.setClearColor = function ( color, alpha ) {\\n\\n\\t\\tclearColor.set( color );\\n\\t\\tclearAlpha = alpha !== undefined ? alpha : 1;\\n\\n\\t\\tgl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\\n\\n\\t};\\n\\n\\tthis.setSize = function ( width, height, updateStyle ) {\\n\\n\\t\\tcanvas.width = width * devicePixelRatio;\\n\\t\\tcanvas.height = height * devicePixelRatio;\\n\\n\\t\\tif ( devicePixelRatio !== 1 && updateStyle !== false ) {\\n\\n\\t\\t\\tcanvas.style.width = width + 'px';\\n\\t\\t\\tcanvas.style.height = height + 'px';\\n\\n\\t\\t}\\n\\n\\t\\tgl.viewport( 0, 0, canvas.width, canvas.height );\\n\\n\\t};\\n\\n\\tthis.clear = function ( color, depth, stencil ) {\\n\\n\\t\\tvar bits = 0;\\n\\n\\t\\tif ( color === undefined || color ) bits |= gl.COLOR_BUFFER_BIT;\\n\\t\\tif ( depth === undefined || depth ) bits |= gl.DEPTH_BUFFER_BIT;\\n\\t\\tif ( stencil === undefined || stencil ) bits |= gl.STENCIL_BUFFER_BIT;\\n\\n\\t\\tgl.clear( bits );\\n\\n\\t};\\n\\n\\t// blending\\n\\n\\tvar currentBlending = null;\\n\\n\\tvar setBlending = function ( blending ) {\\n\\n\\t\\tif ( blending !== currentBlending ) {\\n\\n\\t\\t\\tif ( blending === THREE.NoBlending ) {\\n\\n\\t\\t\\t\\tgl.disable( gl.BLEND );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tgl.enable( gl.BLEND );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentBlending = blending;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// depthTest\\n\\n\\tvar currentDepthTest = null;\\n\\n\\tvar setDepthTest = function ( value ) {\\n\\n\\t\\tif ( value !== currentDepthTest ) {\\n\\n\\t\\t\\tvalue === true ? gl.enable( gl.DEPTH_TEST ) : gl.disable( gl.DEPTH_TEST );\\n\\t\\t\\tcurrentDepthTest = value;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// depthWrite\\n\\n\\tvar currentDepthWrite = null;\\n\\n\\tvar setDepthWrite = function ( value ) {\\n\\n\\t\\tif ( value !== currentDepthWrite ) {\\n\\n\\t\\t\\tgl.depthMask( value );\\n\\t\\t\\tcurrentDepthWrite = value;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar objectsOpaque = [];\\n\\tvar objectsTransparent = [];\\n\\n\\tvar projectObject = function ( object ) {\\n\\n\\t\\tif ( object.visible === false ) return;\\n\\n\\t\\tif ( object instanceof THREE.Mesh && frustum.intersectsObject( object ) === true ) {\\n\\n\\t\\t\\t// TODO: Do not polute scene graph with .z\\n\\n\\t\\t\\tif ( object.renderDepth !== null ) {\\n\\n\\t\\t\\t\\tobject.z = object.renderDepth;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvector3.setFromMatrixPosition( object.matrixWorld );\\n\\t\\t\\t\\tvector3.applyProjection( cameraViewProjectionMatrix );\\n\\n\\t\\t\\t\\tobject.z = vector3.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.material.transparent === true ) {\\n\\n\\t\\t\\t\\tobjectsTransparent.push( object );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tobjectsOpaque.push( object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\\n\\n\\t\\t\\tprojectObject( object.children[ i ] );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar sortOpaque = function ( a, b ) {\\n\\n\\t\\treturn a.z - b.z;\\n\\n\\t};\\n\\n\\tvar sortTransparent = function ( a, b ) {\\n\\n\\t\\treturn a.z !== b.z ? b.z - a.z : b.id - a.id;\\n\\n\\t};\\n\\n\\tvar currentBuffer, currentMaterial, currentProgram;\\n\\tvar locations = {};\\n\\n\\tvar renderObject = function ( object, camera ) {\\n\\n\\t\\tvar buffer = getBuffer( object.geometry, object.material );\\n\\n\\t\\tvar material = object.material;\\n\\n\\t\\tif ( material !== currentMaterial ) {\\n\\n\\t\\t\\tvar program = getProgram( object.material );\\n\\n\\t\\t\\tif ( program !== currentProgram ) {\\n\\n\\t\\t\\t\\tgl.useProgram( program );\\n\\n\\t\\t\\t\\tlocations.modelViewMatrix = gl.getUniformLocation( program, 'modelViewMatrix' );\\n\\t\\t\\t\\tlocations.normalMatrix = gl.getUniformLocation( program, 'normalMatrix' );\\n\\t\\t\\t\\tlocations.projectionMatrix = gl.getUniformLocation( program, 'projectionMatrix' );\\n\\n\\t\\t\\t\\tlocations.position = gl.getAttribLocation( program, 'position' );\\n\\t\\t\\t\\tlocations.normal = gl.getAttribLocation( program, 'normal' );\\n\\n\\t\\t\\t\\tgl.uniformMatrix4fv( locations.projectionMatrix, false, camera.projectionMatrix.elements );\\n\\n\\t\\t\\t\\tcurrentProgram = program;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material instanceof THREE.MeshNormalMaterial ) {\\n\\n\\t\\t\\t\\tgl.uniform1f( gl.getUniformLocation( program, 'opacity' ), material.opacity );\\n\\n\\t\\t\\t} else if ( material instanceof THREE.ShaderMaterial ) {\\n\\n\\t\\t\\t\\tvar uniforms = material.uniforms;\\n\\n\\t\\t\\t\\tfor ( var uniform in uniforms ) {\\n\\n\\t\\t\\t\\t\\tvar location = gl.getUniformLocation( program, uniform );\\n\\n\\t\\t\\t\\t\\tvar type = uniforms[ uniform ].type;\\n\\t\\t\\t\\t\\tvar value = uniforms[ uniform ].value;\\n\\n\\t\\t\\t\\t\\tif ( type === \\\"i\\\" ) { // single integer\\n\\n\\t\\t\\t\\t\\t\\tgl.uniform1i( location, value );\\n\\n\\t\\t\\t\\t\\t} else if ( type === \\\"f\\\" ) { // single float\\n\\n\\t\\t\\t\\t\\t\\tgl.uniform1f( location, value );\\n\\n\\t\\t\\t\\t\\t} else if ( type === \\\"v2\\\" ) { // single THREE.Vector2\\n\\n\\t\\t\\t\\t\\t\\tgl.uniform2f( location, value.x, value.y );\\n\\n\\t\\t\\t\\t\\t} else if ( type === \\\"v3\\\" ) { // single THREE.Vector3\\n\\n\\t\\t\\t\\t\\t\\tgl.uniform3f( location, value.x, value.y, value.z );\\n\\n\\t\\t\\t\\t\\t} else if ( type === \\\"v4\\\" ) { // single THREE.Vector4\\n\\n\\t\\t\\t\\t\\t\\tgl.uniform4f( location, value.x, value.y, value.z, value.w );\\n\\n\\t\\t\\t\\t\\t} else if ( type === \\\"c\\\" ) { // single THREE.Color\\n\\n\\t\\t\\t\\t\\t\\tgl.uniform3f( location, value.r, value.g, value.b );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentMaterial = material;\\n\\n\\t\\t}\\n\\n\\t\\tif ( buffer !== currentBuffer ) {\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer.positions );\\n\\t\\t\\tgl.enableVertexAttribArray( locations.position );\\n\\t\\t\\tgl.vertexAttribPointer( locations.position, 3, gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\tif ( locations.normal >= 0 ) {\\n\\n\\t\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer.normals );\\n\\t\\t\\t\\tgl.enableVertexAttribArray( locations.normal );\\n\\t\\t\\t\\tgl.vertexAttribPointer( locations.normal, 3, gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentBuffer = buffer;\\n\\n\\t\\t}\\n\\n\\t\\tmodelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\\n\\t\\tnormalMatrix.getNormalMatrix( modelViewMatrix );\\n\\n\\t\\tgl.uniformMatrix4fv( locations.modelViewMatrix, false, modelViewMatrix.elements );\\n\\t\\tgl.uniformMatrix3fv( locations.normalMatrix, false, normalMatrix.elements );\\n\\n\\t\\tgl.drawArrays( gl.TRIANGLES, 0, buffer.count );\\n\\n\\t\\tscope.info.render.calls ++;\\n\\n\\t};\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\n\\t\\tif ( this.autoClear === true ) this.clear();\\n\\n\\t\\tscene.updateMatrixWorld();\\n\\n\\t\\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\\n\\n\\t\\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\\n\\n\\t\\tcameraViewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\\n\\t\\tfrustum.setFromMatrix( cameraViewProjectionMatrix );\\n\\n\\t\\tobjectsOpaque.length = 0;\\n\\t\\tobjectsTransparent.length = 0;\\n\\n\\t\\tscope.info.render.calls = 0;\\n\\n\\t\\tcurrentBuffer = undefined;\\n\\t\\tcurrentMaterial = undefined;\\n\\t\\tcurrentProgram = undefined;\\n\\n\\t\\tprojectObject( scene );\\n\\n\\t\\tif ( objectsOpaque.length > 0 ) {\\n\\n\\t\\t\\tobjectsOpaque.sort( sortOpaque );\\n\\n\\t\\t\\tsetBlending( THREE.NoBlending );\\n\\n\\t\\t\\tfor ( var i = 0, l = objectsOpaque.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\trenderObject( objectsOpaque[ i ], camera );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( objectsTransparent.length > 0 ) {\\n\\n\\t\\t\\tobjectsTransparent.sort( sortTransparent );\\n\\n\\t\\t\\tsetBlending( THREE.NormalBlending );\\n\\n\\t\\t\\tfor ( var i = 0, l = objectsTransparent.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\trenderObject( objectsTransparent[ i ], camera );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Renderers/WebGLDeferredRenderer.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Renderers/WebGLDeferredRenderer.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author alteredq / http://alteredqualia.com/\\n * @author MPanknin / http://www.redplant.de/\\n */\\n\\nTHREE.WebGLDeferredRenderer = function ( parameters ) {\\n\\n\\tvar _this = this;\\n\\n\\tvar fullWidth = parameters.width !== undefined ? parameters.width : 800;\\n\\tvar fullHeight = parameters.height !== undefined ? parameters.height : 600;\\n\\tvar currentScale = parameters.scale !== undefined ? parameters.scale : 1;\\n\\n\\tvar scaledWidth = Math.floor( currentScale * fullWidth );\\n\\tvar scaledHeight = Math.floor( currentScale * fullHeight );\\n\\n\\tvar brightness = parameters.brightness !== undefined ? parameters.brightness : 1;\\n\\tvar tonemapping = parameters.tonemapping !== undefined ? parameters.tonemapping : THREE.SimpleOperator;\\n\\tvar antialias = parameters.antialias !== undefined ? parameters.antialias : false;\\n\\n\\tthis.renderer = parameters.renderer;\\n\\n\\tif ( this.renderer === undefined ) {\\n\\n\\t\\tthis.renderer = new THREE.WebGLRenderer( { antialias: false } );\\n\\t\\tthis.renderer.setSize( fullWidth, fullHeight );\\n\\t\\tthis.renderer.setClearColor( 0x000000, 0 );\\n\\n\\t\\tthis.renderer.autoClear = false;\\n\\n\\t}\\n\\n\\tthis.domElement = this.renderer.domElement;\\n\\n\\t//\\n\\n\\tvar gl = this.renderer.context;\\n\\n\\t//\\n\\n\\tvar currentCamera = null;\\n\\tvar projectionMatrixInverse = new THREE.Matrix4();\\n\\n\\tvar positionVS = new THREE.Vector3();\\n\\tvar directionVS = new THREE.Vector3();\\n\\tvar tempVS = new THREE.Vector3();\\n\\n\\tvar rightVS = new THREE.Vector3();\\n\\tvar normalVS = new THREE.Vector3();\\n\\tvar upVS = new THREE.Vector3();\\n\\n\\t//\\n\\n\\tvar geometryLightSphere = new THREE.SphereGeometry( 1, 16, 8 );\\n\\tvar geometryLightPlane = new THREE.PlaneGeometry( 2, 2 );\\n\\n\\tvar black = new THREE.Color( 0x000000 );\\n\\n\\tvar colorShader = THREE.ShaderDeferred[ \\\"color\\\" ];\\n\\tvar normalDepthShader = THREE.ShaderDeferred[ \\\"normalDepth\\\" ];\\n\\n\\t//\\n\\n\\tvar emissiveLightShader = THREE.ShaderDeferred[ \\\"emissiveLight\\\" ];\\n\\tvar pointLightShader = THREE.ShaderDeferred[ \\\"pointLight\\\" ];\\n\\tvar spotLightShader = THREE.ShaderDeferred[ \\\"spotLight\\\" ];\\n\\tvar directionalLightShader = THREE.ShaderDeferred[ \\\"directionalLight\\\" ];\\n\\tvar hemisphereLightShader = THREE.ShaderDeferred[ \\\"hemisphereLight\\\" ];\\n\\tvar areaLightShader = THREE.ShaderDeferred[ \\\"areaLight\\\" ];\\n\\n\\tvar compositeShader = THREE.ShaderDeferred[ \\\"composite\\\" ];\\n\\n\\t//\\n\\n\\tvar compColor, compNormal, compDepth, compLight, compFinal;\\n\\tvar passColor, passNormal, passDepth, passLightFullscreen, passLightProxy, compositePass;\\n\\n\\tvar effectFXAA;\\n\\n\\t//\\n\\n\\tvar lightSceneFullscreen, lightSceneProxy;\\n\\n\\t//\\n\\n\\tvar resizableMaterials = [];\\n\\n\\t//\\n\\n\\tvar invisibleMaterial = new THREE.ShaderMaterial();\\n\\tinvisibleMaterial.visible = false;\\n\\n\\n\\tvar defaultNormalDepthMaterial = new THREE.ShaderMaterial( {\\n\\n\\t\\tuniforms:       THREE.UniformsUtils.clone( normalDepthShader.uniforms ),\\n\\t\\tvertexShader:   normalDepthShader.vertexShader,\\n\\t\\tfragmentShader: normalDepthShader.fragmentShader,\\n\\t\\tblending:\\t\\tTHREE.NoBlending\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tvar initDeferredMaterials = function ( object ) {\\n\\n\\t\\tif ( object.material instanceof THREE.MeshFaceMaterial ) {\\n\\n\\t\\t\\tvar colorMaterials = [];\\n\\t\\t\\tvar normalDepthMaterials = [];\\n\\n\\t\\t\\tvar materials = object.material.materials;\\n\\n\\t\\t\\tfor ( var i = 0, il = materials.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar deferredMaterials = createDeferredMaterials( materials[ i ] );\\n\\n\\t\\t\\t\\tif ( deferredMaterials.transparent ) {\\n\\n\\t\\t\\t\\t\\tcolorMaterials.push( invisibleMaterial );\\n\\t\\t\\t\\t\\tnormalDepthMaterials.push( invisibleMaterial );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tcolorMaterials.push( deferredMaterials.colorMaterial );\\n\\t\\t\\t\\t\\tnormalDepthMaterials.push( deferredMaterials.normalDepthMaterial );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tobject.userData.colorMaterial = new THREE.MeshFaceMaterial( colorMaterials );\\n\\t\\t\\tobject.userData.normalDepthMaterial = new THREE.MeshFaceMaterial( normalDepthMaterials );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tvar deferredMaterials = createDeferredMaterials( object.material );\\n\\n\\t\\t\\tobject.userData.colorMaterial = deferredMaterials.colorMaterial;\\n\\t\\t\\tobject.userData.normalDepthMaterial = deferredMaterials.normalDepthMaterial;\\n\\t\\t\\tobject.userData.transparent = deferredMaterials.transparent;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar createDeferredMaterials = function ( originalMaterial ) {\\n\\n\\t\\tvar deferredMaterials = {};\\n\\n\\t\\t// color material\\n\\t\\t// -----------------\\n\\t\\t// \\tdiffuse color\\n\\t\\t//\\tspecular color\\n\\t\\t//\\tshininess\\n\\t\\t//\\tdiffuse map\\n\\t\\t//\\tvertex colors\\n\\t\\t//\\talphaTest\\n\\t\\t// \\tmorphs\\n\\n\\t\\tvar uniforms = THREE.UniformsUtils.clone( colorShader.uniforms );\\n\\t\\tvar defines = { \\\"USE_MAP\\\": !! originalMaterial.map, \\\"USE_ENVMAP\\\": !! originalMaterial.envMap, \\\"GAMMA_INPUT\\\": true };\\n\\n\\t\\tvar material = new THREE.ShaderMaterial( {\\n\\n\\t\\t\\tfragmentShader: colorShader.fragmentShader,\\n\\t\\t\\tvertexShader: \\tcolorShader.vertexShader,\\n\\t\\t\\tuniforms: \\t\\tuniforms,\\n\\t\\t\\tdefines: \\t\\tdefines,\\n\\t\\t\\tshading:\\t\\toriginalMaterial.shading\\n\\n\\t\\t} );\\n\\n\\t\\tif ( originalMaterial instanceof THREE.MeshBasicMaterial ) {\\n\\n\\t\\t\\tvar diffuse = black;\\n\\t\\t\\tvar emissive = originalMaterial.color;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tvar diffuse = originalMaterial.color;\\n\\t\\t\\tvar emissive = originalMaterial.emissive !== undefined ? originalMaterial.emissive : black;\\n\\n\\t\\t}\\n\\n\\t\\tvar specular = originalMaterial.specular !== undefined ? originalMaterial.specular : black;\\n\\t\\tvar shininess = originalMaterial.shininess !== undefined ? originalMaterial.shininess : 1;\\n\\t\\tvar wrapAround = originalMaterial.wrapAround !== undefined ? ( originalMaterial.wrapAround ? -1 : 1 ) : 1;\\n\\t\\tvar additiveSpecular = originalMaterial.metal !== undefined ? ( originalMaterial.metal ? 1 : -1 ) : -1;\\n\\n\\t\\tuniforms.emissive.value.copyGammaToLinear( emissive );\\n\\t\\tuniforms.diffuse.value.copyGammaToLinear( diffuse );\\n\\t\\tuniforms.specular.value.copyGammaToLinear( specular );\\n\\t\\tuniforms.shininess.value = shininess;\\n\\t\\tuniforms.wrapAround.value = wrapAround;\\n\\t\\tuniforms.additiveSpecular.value = additiveSpecular;\\n\\n\\t\\tuniforms.map.value = originalMaterial.map;\\n\\n\\t\\tif ( originalMaterial.envMap ) {\\n\\n\\t\\t\\tuniforms.envMap.value = originalMaterial.envMap;\\n\\t\\t\\tuniforms.useRefract.value = originalMaterial.envMap.mapping instanceof THREE.CubeRefractionMapping;\\n\\t\\t\\tuniforms.refractionRatio.value = originalMaterial.refractionRatio;\\n\\t\\t\\tuniforms.combine.value = originalMaterial.combine;\\n\\t\\t\\tuniforms.reflectivity.value = originalMaterial.reflectivity;\\n\\t\\t\\tuniforms.flipEnvMap.value = ( originalMaterial.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;\\n\\n\\t\\t\\tuniforms.samplerNormalDepth.value = compNormalDepth.renderTarget2;\\n\\t\\t\\tuniforms.viewWidth.value = scaledWidth;\\n\\t\\t\\tuniforms.viewHeight.value = scaledHeight;\\n\\n\\t\\t\\tresizableMaterials.push( { \\\"material\\\": material } );\\n\\n\\t\\t}\\n\\n\\t\\tmaterial.vertexColors = originalMaterial.vertexColors;\\n\\t\\tmaterial.morphTargets = originalMaterial.morphTargets;\\n\\t\\tmaterial.morphNormals = originalMaterial.morphNormals;\\n\\t\\tmaterial.skinning = originalMaterial.skinning;\\n\\n\\t\\tmaterial.alphaTest = originalMaterial.alphaTest;\\n\\t\\tmaterial.wireframe = originalMaterial.wireframe;\\n\\n\\t\\t// uv repeat and offset setting priorities\\n\\t\\t//\\t1. color map\\n\\t\\t//\\t2. specular map\\n\\t\\t//\\t3. normal map\\n\\t\\t//\\t4. bump map\\n\\n\\t\\tvar uvScaleMap;\\n\\n\\t\\tif ( originalMaterial.map ) {\\n\\n\\t\\t\\tuvScaleMap = originalMaterial.map;\\n\\n\\t\\t} else if ( originalMaterial.specularMap ) {\\n\\n\\t\\t\\tuvScaleMap = originalMaterial.specularMap;\\n\\n\\t\\t} else if ( originalMaterial.normalMap ) {\\n\\n\\t\\t\\tuvScaleMap = originalMaterial.normalMap;\\n\\n\\t\\t} else if ( originalMaterial.bumpMap ) {\\n\\n\\t\\t\\tuvScaleMap = originalMaterial.bumpMap;\\n\\n\\t\\t}\\n\\n\\t\\tif ( uvScaleMap !== undefined ) {\\n\\n\\t\\t\\tvar offset = uvScaleMap.offset;\\n\\t\\t\\tvar repeat = uvScaleMap.repeat;\\n\\n\\t\\t\\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\\n\\n\\t\\t}\\n\\n\\t\\tdeferredMaterials.colorMaterial = material;\\n\\n\\t\\t// normal + depth material\\n\\t\\t// -----------------\\n\\t\\t//\\tvertex normals\\n\\t\\t//\\tmorph normals\\n\\t\\t//\\tbump map\\n\\t\\t//\\tbump scale\\n\\t\\t//  clip depth\\n\\n\\t\\tif ( originalMaterial.morphTargets || originalMaterial.skinning || originalMaterial.bumpMap ) {\\n\\n\\t\\t\\tvar uniforms = THREE.UniformsUtils.clone( normalDepthShader.uniforms );\\n\\t\\t\\tvar defines = { \\\"USE_BUMPMAP\\\": !!originalMaterial.bumpMap };\\n\\n\\t\\t\\tvar normalDepthMaterial = new THREE.ShaderMaterial( {\\n\\n\\t\\t\\t\\tuniforms:       uniforms,\\n\\t\\t\\t\\tvertexShader:   normalDepthShader.vertexShader,\\n\\t\\t\\t\\tfragmentShader: normalDepthShader.fragmentShader,\\n\\t\\t\\t\\tshading:\\t\\toriginalMaterial.shading,\\n\\t\\t\\t\\tdefines:\\t\\tdefines,\\n\\t\\t\\t\\tblending:\\t\\tTHREE.NoBlending\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\tnormalDepthMaterial.morphTargets = originalMaterial.morphTargets;\\n\\t\\t\\tnormalDepthMaterial.morphNormals = originalMaterial.morphNormals;\\n\\t\\t\\tnormalDepthMaterial.skinning = originalMaterial.skinning;\\n\\n\\t\\t\\tif ( originalMaterial.bumpMap ) {\\n\\n\\t\\t\\t\\tuniforms.bumpMap.value = originalMaterial.bumpMap;\\n\\t\\t\\t\\tuniforms.bumpScale.value = originalMaterial.bumpScale;\\n\\n\\t\\t\\t\\tvar offset = originalMaterial.bumpMap.offset;\\n\\t\\t\\t\\tvar repeat = originalMaterial.bumpMap.repeat;\\n\\n\\t\\t\\t\\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tvar normalDepthMaterial = defaultNormalDepthMaterial.clone();\\n\\n\\t\\t}\\n\\n\\t\\tnormalDepthMaterial.wireframe = originalMaterial.wireframe;\\n\\t\\tnormalDepthMaterial.vertexColors = originalMaterial.vertexColors;\\n\\n\\t\\tdeferredMaterials.normalDepthMaterial = normalDepthMaterial;\\n\\n\\t\\t//\\n\\n\\t\\tdeferredMaterials.transparent = originalMaterial.transparent;\\n\\n\\t\\treturn deferredMaterials;\\n\\n\\t};\\n\\n\\tvar updatePointLightProxy = function ( lightProxy ) {\\n\\n\\t\\tvar light = lightProxy.userData.originalLight;\\n\\t\\tvar uniforms = lightProxy.material.uniforms;\\n\\n\\t\\t// skip infinite pointlights\\n\\t\\t// right now you can't switch between infinite and finite pointlights\\n\\t\\t// it's just too messy as they use different proxies\\n\\n\\t\\tvar distance = light.distance;\\n\\n\\t\\tif ( distance > 0 ) {\\n\\n\\t\\t\\tlightProxy.scale.set( 1, 1, 1 ).multiplyScalar( distance );\\n\\t\\t\\tuniforms[ \\\"lightRadius\\\" ].value = distance;\\n\\n\\t\\t\\tpositionVS.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\tpositionVS.applyMatrix4( currentCamera.matrixWorldInverse );\\n\\n\\t\\t\\tuniforms[ \\\"lightPositionVS\\\" ].value.copy( positionVS );\\n\\n\\t\\t\\tlightProxy.position.setFromMatrixPosition( light.matrixWorld );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tuniforms[ \\\"lightRadius\\\" ].value = Infinity;\\n\\n\\t\\t}\\n\\n\\t\\t// linear space colors\\n\\n\\t\\tvar intensity = light.intensity * light.intensity;\\n\\n\\t\\tuniforms[ \\\"lightIntensity\\\" ].value = intensity;\\n\\t\\tuniforms[ \\\"lightColor\\\" ].value.copyGammaToLinear( light.color );\\n\\n\\t};\\n\\n\\tvar createDeferredPointLight = function ( light ) {\\n\\n\\t\\t// setup light material\\n\\n\\t\\tvar materialLight = new THREE.ShaderMaterial( {\\n\\n\\t\\t\\tuniforms:       THREE.UniformsUtils.clone( pointLightShader.uniforms ),\\n\\t\\t\\tvertexShader:   pointLightShader.vertexShader,\\n\\t\\t\\tfragmentShader: pointLightShader.fragmentShader,\\n\\n\\t\\t\\tblending:\\t\\tTHREE.AdditiveBlending,\\n\\t\\t\\tdepthWrite:\\t\\tfalse,\\n\\t\\t\\ttransparent:\\ttrue,\\n\\n\\t\\t\\tside: THREE.BackSide\\n\\n\\t\\t} );\\n\\n\\t\\t// infinite pointlights use full-screen quad proxy\\n\\t\\t// regular pointlights use sphere proxy\\n\\n\\t\\tvar  geometry;\\n\\n\\t\\tif ( light.distance > 0 ) {\\n\\n\\t\\t\\tgeometry = geometryLightSphere;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tgeometry = geometryLightPlane;\\n\\n\\t\\t\\tmaterialLight.depthTest = false;\\n\\t\\t\\tmaterialLight.side = THREE.FrontSide;\\n\\n\\t\\t}\\n\\n\\t\\tmaterialLight.uniforms[ \\\"viewWidth\\\" ].value = scaledWidth;\\n\\t\\tmaterialLight.uniforms[ \\\"viewHeight\\\" ].value = scaledHeight;\\n\\n\\t\\tmaterialLight.uniforms[ 'samplerColor' ].value = compColor.renderTarget2;\\n\\t\\tmaterialLight.uniforms[ 'samplerNormalDepth' ].value = compNormalDepth.renderTarget2;\\n\\n\\t\\t// create light proxy mesh\\n\\n\\t\\tvar meshLight = new THREE.Mesh( geometry, materialLight );\\n\\n\\t\\t// keep reference for color and intensity updates\\n\\n\\t\\tmeshLight.userData.originalLight = light;\\n\\n\\t\\t// keep reference for size reset\\n\\n\\t\\tresizableMaterials.push( { \\\"material\\\": materialLight } );\\n\\n\\t\\t// sync proxy uniforms to the original light\\n\\n\\t\\tupdatePointLightProxy( meshLight );\\n\\n\\t\\treturn meshLight;\\n\\n\\t};\\n\\n\\tvar updateSpotLightProxy = function ( lightProxy ) {\\n\\n\\t\\tvar light = lightProxy.userData.originalLight;\\n\\t\\tvar uniforms = lightProxy.material.uniforms;\\n\\n\\t\\tvar viewMatrix = currentCamera.matrixWorldInverse;\\n\\t\\tvar modelMatrix = light.matrixWorld;\\n\\n\\t\\tpositionVS.setFromMatrixPosition( modelMatrix );\\n\\t\\tpositionVS.applyMatrix4( viewMatrix );\\n\\n\\t\\tdirectionVS.setFromMatrixPosition( modelMatrix );\\n\\t\\ttempVS.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\tdirectionVS.sub( tempVS );\\n\\t\\tdirectionVS.normalize();\\n\\t\\tdirectionVS.transformDirection( viewMatrix );\\n\\n\\t\\tuniforms[ \\\"lightPositionVS\\\" ].value.copy( positionVS );\\n\\t\\tuniforms[ \\\"lightDirectionVS\\\" ].value.copy( directionVS );\\n\\n\\t\\tuniforms[ \\\"lightAngle\\\" ].value = light.angle;\\n\\t\\tuniforms[ \\\"lightDistance\\\" ].value = light.distance;\\n\\n\\t\\t// linear space colors\\n\\n\\t\\tvar intensity = light.intensity * light.intensity;\\n\\n\\t\\tuniforms[ \\\"lightIntensity\\\" ].value = intensity;\\n\\t\\tuniforms[ \\\"lightColor\\\" ].value.copyGammaToLinear( light.color );\\n\\n\\t};\\n\\n\\tvar createDeferredSpotLight = function ( light ) {\\n\\n\\t\\t// setup light material\\n\\n\\t\\tvar uniforms = THREE.UniformsUtils.clone( spotLightShader.uniforms );\\n\\n\\t\\tvar materialLight = new THREE.ShaderMaterial( {\\n\\n\\t\\t\\tuniforms:       uniforms,\\n\\t\\t\\tvertexShader:   spotLightShader.vertexShader,\\n\\t\\t\\tfragmentShader: spotLightShader.fragmentShader,\\n\\n\\t\\t\\tblending:\\t\\tTHREE.AdditiveBlending,\\n\\t\\t\\tdepthWrite:\\t\\tfalse,\\n\\t\\t\\tdepthTest:\\t\\tfalse,\\n\\t\\t\\ttransparent:\\ttrue\\n\\n\\t\\t} );\\n\\n\\t\\tuniforms[ \\\"viewWidth\\\" ].value = scaledWidth;\\n\\t\\tuniforms[ \\\"viewHeight\\\" ].value = scaledHeight;\\n\\n\\t\\tuniforms[ 'samplerColor' ].value = compColor.renderTarget2;\\n\\t\\tuniforms[ 'samplerNormalDepth' ].value = compNormalDepth.renderTarget2;\\n\\n\\t\\t// create light proxy mesh\\n\\n\\t\\tvar meshLight = new THREE.Mesh( geometryLightPlane, materialLight );\\n\\n\\t\\t// keep reference for color and intensity updates\\n\\n\\t\\tmeshLight.userData.originalLight = light;\\n\\n\\t\\t// keep reference for size reset\\n\\n\\t\\tresizableMaterials.push( { \\\"material\\\": materialLight } );\\n\\n\\t\\t// sync proxy uniforms to the original light\\n\\n\\t\\tupdateSpotLightProxy( meshLight );\\n\\n\\t\\treturn meshLight;\\n\\n\\t};\\n\\n\\tvar updateDirectionalLightProxy = function ( lightProxy ) {\\n\\n\\t\\tvar light = lightProxy.userData.originalLight;\\n\\t\\tvar uniforms = lightProxy.material.uniforms;\\n\\n\\t\\tdirectionVS.setFromMatrixPosition( light.matrixWorld );\\n\\t\\ttempVS.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\tdirectionVS.sub( tempVS );\\n\\t\\tdirectionVS.normalize();\\n\\t\\tdirectionVS.transformDirection( currentCamera.matrixWorldInverse );\\n\\n\\t\\tuniforms[ \\\"lightDirectionVS\\\" ].value.copy( directionVS );\\n\\n\\t\\t// linear space colors\\n\\n\\t\\tvar intensity = light.intensity * light.intensity;\\n\\n\\t\\tuniforms[ \\\"lightIntensity\\\" ].value = intensity;\\n\\t\\tuniforms[ \\\"lightColor\\\" ].value.copyGammaToLinear( light.color );\\n\\n\\t};\\n\\n\\tvar createDeferredDirectionalLight = function ( light ) {\\n\\n\\t\\t// setup light material\\n\\n\\t\\tvar uniforms = THREE.UniformsUtils.clone( directionalLightShader.uniforms );\\n\\n\\t\\tvar materialLight = new THREE.ShaderMaterial( {\\n\\n\\t\\t\\tuniforms:       uniforms,\\n\\t\\t\\tvertexShader:   directionalLightShader.vertexShader,\\n\\t\\t\\tfragmentShader: directionalLightShader.fragmentShader,\\n\\n\\t\\t\\tblending:\\t\\tTHREE.AdditiveBlending,\\n\\t\\t\\tdepthWrite:\\t\\tfalse,\\n\\t\\t\\tdepthTest:\\t\\tfalse,\\n\\t\\t\\ttransparent:\\ttrue\\n\\n\\t\\t} );\\n\\n\\t\\tuniforms[ \\\"viewWidth\\\" ].value = scaledWidth;\\n\\t\\tuniforms[ \\\"viewHeight\\\" ].value = scaledHeight;\\n\\n\\t\\tuniforms[ 'samplerColor' ].value = compColor.renderTarget2;\\n\\t\\tuniforms[ 'samplerNormalDepth' ].value = compNormalDepth.renderTarget2;\\n\\n\\t\\t// create light proxy mesh\\n\\n\\t\\tvar meshLight = new THREE.Mesh( geometryLightPlane, materialLight );\\n\\n\\t\\t// keep reference for color and intensity updates\\n\\n\\t\\tmeshLight.userData.originalLight = light;\\n\\n\\t\\t// keep reference for size reset\\n\\n\\t\\tresizableMaterials.push( { \\\"material\\\": materialLight } );\\n\\n\\t\\t// sync proxy uniforms to the original light\\n\\n\\t\\tupdateDirectionalLightProxy( meshLight );\\n\\n\\t\\treturn meshLight;\\n\\n\\t};\\n\\n\\tvar updateHemisphereLightProxy = function ( lightProxy ) {\\n\\n\\t\\tvar light = lightProxy.userData.originalLight;\\n\\t\\tvar uniforms = lightProxy.material.uniforms;\\n\\n\\t\\tdirectionVS.setFromMatrixPosition( light.matrixWorld );\\n\\t\\tdirectionVS.normalize();\\n\\t\\tdirectionVS.transformDirection( currentCamera.matrixWorldInverse );\\n\\n\\t\\tuniforms[ \\\"lightDirectionVS\\\" ].value.copy( directionVS );\\n\\n\\t\\t// linear space colors\\n\\n\\t\\tvar intensity = light.intensity * light.intensity;\\n\\n\\t\\tuniforms[ \\\"lightIntensity\\\" ].value = intensity;\\n\\t\\tuniforms[ \\\"lightColorSky\\\" ].value.copyGammaToLinear( light.color );\\n\\t\\tuniforms[ \\\"lightColorGround\\\" ].value.copyGammaToLinear( light.groundColor );\\n\\n\\t};\\n\\n\\tvar createDeferredHemisphereLight = function ( light ) {\\n\\n\\t\\t// setup light material\\n\\n\\t\\tvar uniforms = THREE.UniformsUtils.clone( hemisphereLightShader.uniforms );\\n\\n\\t\\tvar materialLight = new THREE.ShaderMaterial( {\\n\\n\\t\\t\\tuniforms:       uniforms,\\n\\t\\t\\tvertexShader:   hemisphereLightShader.vertexShader,\\n\\t\\t\\tfragmentShader: hemisphereLightShader.fragmentShader,\\n\\n\\t\\t\\tblending:\\t\\tTHREE.AdditiveBlending,\\n\\t\\t\\tdepthWrite:\\t\\tfalse,\\n\\t\\t\\tdepthTest:\\t\\tfalse,\\n\\t\\t\\ttransparent:\\ttrue\\n\\n\\t\\t} );\\n\\n\\t\\tuniforms[ \\\"viewWidth\\\" ].value = scaledWidth;\\n\\t\\tuniforms[ \\\"viewHeight\\\" ].value = scaledHeight;\\n\\n\\t\\tuniforms[ 'samplerColor' ].value = compColor.renderTarget2;\\n\\t\\tuniforms[ 'samplerNormalDepth' ].value = compNormalDepth.renderTarget2;\\n\\n\\t\\t// create light proxy mesh\\n\\n\\t\\tvar meshLight = new THREE.Mesh( geometryLightPlane, materialLight );\\n\\n\\t\\t// keep reference for color and intensity updates\\n\\n\\t\\tmeshLight.userData.originalLight = light;\\n\\n\\t\\t// keep reference for size reset\\n\\n\\t\\tresizableMaterials.push( { \\\"material\\\": materialLight } );\\n\\n\\t\\t// sync proxy uniforms to the original light\\n\\n\\t\\tupdateHemisphereLightProxy( meshLight );\\n\\n\\t\\treturn meshLight;\\n\\n\\t};\\n\\n\\tvar updateAreaLightProxy = function ( lightProxy ) {\\n\\n\\t\\tvar light = lightProxy.userData.originalLight;\\n\\t\\tvar uniforms = lightProxy.material.uniforms;\\n\\n\\t\\tvar modelMatrix = light.matrixWorld;\\n\\t\\tvar viewMatrix = currentCamera.matrixWorldInverse;\\n\\n\\t\\tpositionVS.setFromMatrixPosition( modelMatrix );\\n\\t\\tpositionVS.applyMatrix4( viewMatrix );\\n\\n\\t\\tuniforms[ \\\"lightPositionVS\\\" ].value.copy( positionVS );\\n\\n\\t\\trightVS.copy( light.right );\\n\\t\\trightVS.transformDirection( modelMatrix );\\n\\t\\trightVS.transformDirection( viewMatrix );\\n\\n\\t\\tnormalVS.copy( light.normal );\\n\\t\\tnormalVS.transformDirection( modelMatrix );\\n\\t\\tnormalVS.transformDirection( viewMatrix );\\n\\n\\t\\tupVS.crossVectors( rightVS, normalVS );\\n\\t\\tupVS.normalize();\\n\\n\\t\\tuniforms[ \\\"lightRightVS\\\" ].value.copy( rightVS );\\n\\t\\tuniforms[ \\\"lightNormalVS\\\" ].value.copy( normalVS );\\n\\t\\tuniforms[ \\\"lightUpVS\\\" ].value.copy( upVS );\\n\\n\\t\\tuniforms[ \\\"lightWidth\\\" ].value = light.width;\\n\\t\\tuniforms[ \\\"lightHeight\\\" ].value = light.height;\\n\\n\\t\\tuniforms[ \\\"constantAttenuation\\\" ].value = light.constantAttenuation;\\n\\t\\tuniforms[ \\\"linearAttenuation\\\" ].value = light.linearAttenuation;\\n\\t\\tuniforms[ \\\"quadraticAttenuation\\\" ].value = light.quadraticAttenuation;\\n\\n\\t\\t// linear space colors\\n\\n\\t\\tvar intensity = light.intensity * light.intensity;\\n\\n\\t\\tuniforms[ \\\"lightIntensity\\\" ].value = intensity;\\n\\t\\tuniforms[ \\\"lightColor\\\" ].value.copyGammaToLinear( light.color );\\n\\n\\t};\\n\\n\\tvar createDeferredAreaLight = function ( light ) {\\n\\n\\t\\t// setup light material\\n\\n\\t\\tvar uniforms = THREE.UniformsUtils.clone( areaLightShader.uniforms );\\n\\n\\t\\tvar materialLight = new THREE.ShaderMaterial( {\\n\\n\\t\\t\\tuniforms:       uniforms,\\n\\t\\t\\tvertexShader:   areaLightShader.vertexShader,\\n\\t\\t\\tfragmentShader: areaLightShader.fragmentShader,\\n\\n\\t\\t\\tblending:\\t\\tTHREE.AdditiveBlending,\\n\\t\\t\\tdepthWrite:\\t\\tfalse,\\n\\t\\t\\tdepthTest:\\t\\tfalse,\\n\\t\\t\\ttransparent:\\ttrue\\n\\n\\t\\t} );\\n\\n\\t\\tuniforms[ \\\"viewWidth\\\" ].value = scaledWidth;\\n\\t\\tuniforms[ \\\"viewHeight\\\" ].value = scaledHeight;\\n\\n\\t\\tuniforms[ 'samplerColor' ].value = compColor.renderTarget2;\\n\\t\\tuniforms[ 'samplerNormalDepth' ].value = compNormalDepth.renderTarget2;\\n\\n\\t\\t// create light proxy mesh\\n\\n\\t\\tvar meshLight = new THREE.Mesh( geometryLightPlane, materialLight );\\n\\n\\t\\t// keep reference for color and intensity updates\\n\\n\\t\\tmeshLight.userData.originalLight = light;\\n\\n\\t\\t// keep reference for size reset\\n\\n\\t\\tresizableMaterials.push( { \\\"material\\\": materialLight } );\\n\\n\\t\\t// sync proxy uniforms to the original light\\n\\n\\t\\tupdateAreaLightProxy( meshLight );\\n\\n\\t\\treturn meshLight;\\n\\n\\t};\\n\\n\\tvar createDeferredEmissiveLight = function () {\\n\\n\\t\\t// setup light material\\n\\n\\t\\tvar materialLight = new THREE.ShaderMaterial( {\\n\\n\\t\\t\\tuniforms:       THREE.UniformsUtils.clone( emissiveLightShader.uniforms ),\\n\\t\\t\\tvertexShader:   emissiveLightShader.vertexShader,\\n\\t\\t\\tfragmentShader: emissiveLightShader.fragmentShader,\\n\\t\\t\\tdepthTest:\\t\\tfalse,\\n\\t\\t\\tdepthWrite:\\t\\tfalse,\\n\\t\\t\\tblending:\\t\\tTHREE.NoBlending\\n\\n\\t\\t} );\\n\\n\\t\\tmaterialLight.uniforms[ \\\"viewWidth\\\" ].value = scaledWidth;\\n\\t\\tmaterialLight.uniforms[ \\\"viewHeight\\\" ].value = scaledHeight;\\n\\n\\t\\tmaterialLight.uniforms[ 'samplerColor' ].value = compColor.renderTarget2;\\n\\n\\t\\t// create light proxy mesh\\n\\n\\t\\tvar meshLight = new THREE.Mesh( geometryLightPlane, materialLight );\\n\\n\\t\\t// keep reference for size reset\\n\\n\\t\\tresizableMaterials.push( { \\\"material\\\": materialLight } );\\n\\n\\t\\treturn meshLight;\\n\\n\\t};\\n\\n\\tvar initDeferredProperties = function ( object ) {\\n\\n\\t\\tif ( object.userData.deferredInitialized ) return;\\n\\n\\t\\tif ( object.material ) initDeferredMaterials( object );\\n\\n\\t\\tif ( object instanceof THREE.PointLight ) {\\n\\n\\t\\t\\tvar proxy = createDeferredPointLight( object );\\n\\n\\t\\t\\tif ( object.distance > 0 ) {\\n\\n\\t\\t\\t\\tlightSceneProxy.add( proxy );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tlightSceneFullscreen.add( proxy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else if ( object instanceof THREE.SpotLight ) {\\n\\n\\t\\t\\tvar proxy = createDeferredSpotLight( object );\\n\\t\\t\\tlightSceneFullscreen.add( proxy );\\n\\n\\t\\t} else if ( object instanceof THREE.DirectionalLight ) {\\n\\n\\t\\t\\tvar proxy = createDeferredDirectionalLight( object );\\n\\t\\t\\tlightSceneFullscreen.add( proxy );\\n\\n\\t\\t} else if ( object instanceof THREE.HemisphereLight ) {\\n\\n\\t\\t\\tvar proxy = createDeferredHemisphereLight( object );\\n\\t\\t\\tlightSceneFullscreen.add( proxy );\\n\\n\\t\\t} else if ( object instanceof THREE.AreaLight ) {\\n\\n\\t\\t\\tvar proxy = createDeferredAreaLight( object );\\n\\t\\t\\tlightSceneFullscreen.add( proxy );\\n\\n\\t\\t}\\n\\n\\t\\tobject.userData.deferredInitialized = true;\\n\\n\\t};\\n\\n\\t//\\n\\n\\tvar setMaterialColor = function ( object ) {\\n\\n\\t\\tif ( object.material ) {\\n\\n\\t\\t\\tif ( object.userData.transparent ) {\\n\\n\\t\\t\\t\\tobject.material = invisibleMaterial;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tobject.material = object.userData.colorMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar setMaterialNormalDepth = function ( object ) {\\n\\n\\t\\tif ( object.material ) {\\n\\n\\t\\t\\tif ( object.userData.transparent ) {\\n\\n\\t\\t\\t\\tobject.material = invisibleMaterial;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tobject.material = object.userData.normalDepthMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// external API\\n\\n\\tthis.setAntialias = function ( enabled ) {\\n\\n\\t\\tantialias = enabled;\\n\\n\\t\\tif ( antialias ) {\\n\\n\\t\\t\\teffectFXAA.enabled = true;\\n\\t\\t\\tcompositePass.renderToScreen = false;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\teffectFXAA.enabled = false;\\n\\t\\t\\tcompositePass.renderToScreen = true;\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.getAntialias = function () {\\n\\n\\t\\treturn antialias;\\n\\n\\t};\\n\\n\\tthis.addEffect = function ( effect, normalDepthUniform, colorUniform ) {\\n\\n\\t\\tif ( effect.material && effect.uniforms ) {\\n\\n\\t\\t\\tif ( normalDepthUniform ) effect.uniforms[ normalDepthUniform ].value = compNormalDepth.renderTarget2;\\n\\t\\t\\tif ( colorUniform )    \\t  effect.uniforms[ colorUniform ].value = compColor.renderTarget2;\\n\\n\\t\\t\\tif ( normalDepthUniform || colorUniform ) {\\n\\n\\t\\t\\t\\tresizableMaterials.push( { \\\"material\\\": effect.material, \\\"normalDepth\\\": normalDepthUniform, \\\"color\\\": colorUniform } );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tcompFinal.insertPass( effect, -1 );\\n\\n\\t};\\n\\n\\tthis.setScale = function ( scale ) {\\n\\n\\t\\tcurrentScale = scale;\\n\\n\\t\\tscaledWidth = Math.floor( currentScale * fullWidth );\\n\\t\\tscaledHeight = Math.floor( currentScale * fullHeight );\\n\\n\\t\\tcompNormalDepth.setSize( scaledWidth, scaledHeight );\\n\\t\\tcompColor.setSize( scaledWidth, scaledHeight );\\n\\t\\tcompLight.setSize( scaledWidth, scaledHeight );\\n\\t\\tcompFinal.setSize( scaledWidth, scaledHeight );\\n\\n\\t\\tcompColor.renderTarget2.shareDepthFrom = compNormalDepth.renderTarget2;\\n\\t\\tcompLight.renderTarget2.shareDepthFrom = compNormalDepth.renderTarget2;\\n\\n\\t\\tfor ( var i = 0, il = resizableMaterials.length; i < il; i ++ ) {\\n\\n\\t\\t\\tvar materialEntry = resizableMaterials[ i ];\\n\\n\\t\\t\\tvar material = materialEntry.material;\\n\\t\\t\\tvar uniforms = material.uniforms;\\n\\n\\t\\t\\tvar colorLabel = materialEntry.color !== undefined ? materialEntry.color : 'samplerColor';\\n\\t\\t\\tvar normalDepthLabel = materialEntry.normalDepth !== undefined ? materialEntry.normalDepth : 'samplerNormalDepth';\\n\\n\\t\\t\\tif ( uniforms[ colorLabel ] ) uniforms[ colorLabel ].value = compColor.renderTarget2;\\n\\t\\t\\tif ( uniforms[ normalDepthLabel ] ) uniforms[ normalDepthLabel ].value = compNormalDepth.renderTarget2;\\n\\n\\t\\t\\tif ( uniforms[ 'viewWidth' ] ) uniforms[ \\\"viewWidth\\\" ].value = scaledWidth;\\n\\t\\t\\tif ( uniforms[ 'viewHeight' ] ) uniforms[ \\\"viewHeight\\\" ].value = scaledHeight;\\n\\n\\t\\t}\\n\\n\\t\\tcompositePass.uniforms[ 'samplerLight' ].value = compLight.renderTarget2;\\n\\n\\t\\teffectFXAA.uniforms[ 'resolution' ].value.set( 1 / fullWidth, 1 / fullHeight );\\n\\n\\t};\\n\\n\\tthis.setSize = function ( width, height ) {\\n\\n\\t\\tfullWidth = width;\\n\\t\\tfullHeight = height;\\n\\n\\t\\tthis.renderer.setSize( fullWidth, fullHeight );\\n\\n\\t\\tthis.setScale( currentScale );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tfunction updateLightProxy ( proxy ) {\\n\\n\\t\\tvar uniforms = proxy.material.uniforms;\\n\\n\\t\\tif ( uniforms[ \\\"matProjInverse\\\" ] ) uniforms[ \\\"matProjInverse\\\" ].value = projectionMatrixInverse;\\n\\t\\tif ( uniforms[ \\\"matView\\\" ] ) uniforms[ \\\"matView\\\" ].value = currentCamera.matrixWorldInverse;\\n\\n\\t\\tvar originalLight = proxy.userData.originalLight;\\n\\n\\t\\tif ( originalLight ) {\\n\\n\\t\\t\\tproxy.visible = originalLight.visible;\\n\\n\\t\\t\\tif ( originalLight instanceof THREE.PointLight ) {\\n\\n\\t\\t\\t\\tupdatePointLightProxy( proxy );\\n\\n\\t\\t\\t} else if ( originalLight instanceof THREE.SpotLight ) {\\n\\n\\t\\t\\t\\tupdateSpotLightProxy( proxy );\\n\\n\\t\\t\\t} else if ( originalLight instanceof THREE.DirectionalLight ) {\\n\\n\\t\\t\\t\\tupdateDirectionalLightProxy( proxy );\\n\\n\\t\\t\\t} else if ( originalLight instanceof THREE.HemisphereLight ) {\\n\\n\\t\\t\\t\\tupdateHemisphereLightProxy( proxy );\\n\\n\\t\\t\\t} else if ( originalLight instanceof THREE.AreaLight ) {\\n\\n\\t\\t\\t\\tupdateAreaLightProxy( proxy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\n\\t\\t// setup deferred properties\\n\\n\\t\\tif ( ! scene.userData.lightSceneProxy ) {\\n\\n\\t\\t\\tscene.userData.lightSceneProxy = new THREE.Scene();\\n\\t\\t\\tscene.userData.lightSceneFullscreen = new THREE.Scene();\\n\\n\\t\\t\\tvar meshLight = createDeferredEmissiveLight();\\n\\t\\t\\tscene.userData.lightSceneFullscreen.add( meshLight );\\n\\n\\t\\t}\\n\\n\\t\\tcurrentCamera = camera;\\n\\n\\t\\tlightSceneProxy = scene.userData.lightSceneProxy;\\n\\t\\tlightSceneFullscreen = scene.userData.lightSceneFullscreen;\\n\\n\\t\\tpassColor.camera = currentCamera;\\n\\t\\tpassNormalDepth.camera = currentCamera;\\n\\t\\tpassLightProxy.camera = currentCamera;\\n\\t\\tpassLightFullscreen.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\\n\\n\\t\\tpassColor.scene = scene;\\n\\t\\tpassNormalDepth.scene = scene;\\n\\t\\tpassLightFullscreen.scene = lightSceneFullscreen;\\n\\t\\tpassLightProxy.scene = lightSceneProxy;\\n\\n\\t\\tscene.traverse( initDeferredProperties );\\n\\n\\t\\t// update scene graph only once per frame\\n\\t\\t// (both color and normalDepth passes use exactly the same scene state)\\n\\n\\t\\tscene.autoUpdate = false;\\n\\t\\tscene.updateMatrixWorld();\\n\\n\\t\\t// 1) g-buffer normals + depth pass\\n\\n\\t\\tscene.traverse( setMaterialNormalDepth );\\n\\n\\t\\t// clear shared depth buffer\\n\\n\\t\\tthis.renderer.autoClearDepth = true;\\n\\t\\tthis.renderer.autoClearStencil = true;\\n\\n\\t\\t// write 1 to shared stencil buffer\\n\\t\\t// for non-background pixels\\n\\n\\t\\t//gl.enable( gl.STENCIL_TEST );\\n\\t\\tgl.stencilOp( gl.REPLACE, gl.REPLACE, gl.REPLACE );\\n\\t\\tgl.stencilFunc( gl.ALWAYS, 1, 0xffffffff );\\n\\t\\tgl.clearStencil( 0 );\\n\\n\\t\\tcompNormalDepth.render();\\n\\n\\t\\t// just touch foreground pixels (stencil == 1)\\n\\t\\t// both in color and light passes\\n\\n\\t\\tgl.stencilFunc( gl.EQUAL, 1, 0xffffffff );\\n\\t\\tgl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );\\n\\n\\t\\t// 2) g-buffer color pass\\n\\n\\t\\tscene.traverse( setMaterialColor );\\n\\n\\t\\t// must use clean slate depth buffer\\n\\t\\t// otherwise there are z-fighting glitches\\n\\t\\t// not enough precision between two geometry passes\\n\\t\\t// just to use EQUAL depth test\\n\\n\\t\\tthis.renderer.autoClearDepth = true;\\n\\t\\tthis.renderer.autoClearStencil = false;\\n\\n\\t\\tcompColor.render();\\n\\n\\t\\t// 3) light pass\\n\\n\\t\\t// do not clear depth buffer in this pass\\n\\t\\t// depth from geometry pass is used for light culling\\n\\t\\t// (write light proxy color pixel if behind scene pixel)\\n\\n\\t\\tthis.renderer.autoClearDepth = false;\\n\\n\\t\\tscene.autoUpdate = true;\\n\\n\\t\\tgl.depthFunc( gl.GEQUAL );\\n\\n\\t\\tprojectionMatrixInverse.getInverse( currentCamera.projectionMatrix );\\n\\n\\t\\tfor ( var i = 0, il = lightSceneProxy.children.length; i < il; i ++ ) {\\n\\n\\t\\t\\tvar proxy = lightSceneProxy.children[ i ];\\n\\t\\t\\tupdateLightProxy( proxy );\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0, il = lightSceneFullscreen.children.length; i < il; i ++ ) {\\n\\n\\t\\t\\tvar proxy = lightSceneFullscreen.children[ i ];\\n\\t\\t\\tupdateLightProxy( proxy );\\n\\n\\t\\t}\\n\\n\\t\\tcompLight.render();\\n\\n\\t\\t// 4) composite pass\\n\\n\\t\\t// return back to usual depth and stencil handling state\\n\\n\\t\\tthis.renderer.autoClearDepth = true;\\n\\t\\tthis.renderer.autoClearStencil = true;\\n\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\t\\tgl.disable( gl.STENCIL_TEST );\\n\\n\\t\\tcompFinal.render( 0.1 );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tvar createRenderTargets = function ( ) {\\n\\n\\t\\tvar rtParamsFloatLinear = { minFilter: THREE.NearestFilter, magFilter: THREE.LinearFilter, stencilBuffer: true,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tformat: THREE.RGBAFormat, type: THREE.FloatType };\\n\\n\\t\\tvar rtParamsFloatNearest = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, stencilBuffer: true,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t format: THREE.RGBAFormat, type: THREE.FloatType };\\n\\n\\t\\tvar rtParamsUByte = { minFilter: THREE.NearestFilter, magFilter: THREE.LinearFilter, stencilBuffer: false,\\n\\t\\t\\t\\t\\t\\t\\t  format: THREE.RGBFormat, type: THREE.UnsignedByteType };\\n\\n\\t\\t// g-buffers\\n\\n\\t\\tvar rtColor   = new THREE.WebGLRenderTarget( scaledWidth, scaledHeight, rtParamsFloatNearest );\\n\\t\\tvar rtNormalDepth = new THREE.WebGLRenderTarget( scaledWidth, scaledHeight, rtParamsFloatNearest );\\n\\t\\tvar rtLight   = new THREE.WebGLRenderTarget( scaledWidth, scaledHeight, rtParamsFloatLinear );\\n\\t\\tvar rtFinal   = new THREE.WebGLRenderTarget( scaledWidth, scaledHeight, rtParamsUByte );\\n\\n\\t\\trtColor.generateMipmaps = false;\\n\\t\\trtNormalDepth.generateMipmaps = false;\\n\\t\\trtLight.generateMipmaps = false;\\n\\t\\trtFinal.generateMipmaps = false;\\n\\n\\t\\t// normal + depth composer\\n\\n\\t\\tpassNormalDepth = new THREE.RenderPass();\\n\\t\\tpassNormalDepth.clear = true;\\n\\n\\t\\tcompNormalDepth = new THREE.EffectComposer( _this.renderer, rtNormalDepth );\\n\\t\\tcompNormalDepth.addPass( passNormalDepth );\\n\\n\\t\\t// color composer\\n\\n\\t\\tpassColor = new THREE.RenderPass();\\n\\t\\tpassColor.clear = true;\\n\\n\\t\\tcompColor = new THREE.EffectComposer( _this.renderer, rtColor );\\n\\t\\tcompColor.addPass( passColor );\\n\\n\\t\\tcompColor.renderTarget2.shareDepthFrom = compNormalDepth.renderTarget2;\\n\\n\\t\\t// light composer\\n\\n\\t\\tpassLightFullscreen = new THREE.RenderPass();\\n\\t\\tpassLightFullscreen.clear = true;\\n\\n\\t\\tpassLightProxy = new THREE.RenderPass();\\n\\t\\tpassLightProxy.clear = false;\\n\\n\\t\\tcompLight = new THREE.EffectComposer( _this.renderer, rtLight );\\n\\t\\tcompLight.addPass( passLightFullscreen );\\n\\t\\tcompLight.addPass( passLightProxy );\\n\\n\\t\\tcompLight.renderTarget2.shareDepthFrom = compNormalDepth.renderTarget2;\\n\\n\\t\\t// final composer\\n\\n\\t\\tcompositePass = new THREE.ShaderPass( compositeShader );\\n\\t\\tcompositePass.uniforms[ 'samplerLight' ].value = compLight.renderTarget2;\\n\\t\\tcompositePass.uniforms[ 'brightness' ].value = brightness;\\n\\t\\tcompositePass.material.blending = THREE.NoBlending;\\n\\t\\tcompositePass.clear = true;\\n\\n\\t\\tvar defines;\\n\\n\\t\\tswitch ( tonemapping ) {\\n\\n\\t\\t\\tcase THREE.SimpleOperator:    defines = { \\\"TONEMAP_SIMPLE\\\": true };    break;\\n\\t\\t\\tcase THREE.LinearOperator:    defines = { \\\"TONEMAP_LINEAR\\\": true };    break;\\n\\t\\t\\tcase THREE.ReinhardOperator:  defines = { \\\"TONEMAP_REINHARD\\\": true };  break;\\n\\t\\t\\tcase THREE.FilmicOperator:    defines = { \\\"TONEMAP_FILMIC\\\": true };    break;\\n\\t\\t\\tcase THREE.UnchartedOperator: defines = { \\\"TONEMAP_UNCHARTED\\\": true }; break;\\n\\n\\t\\t}\\n\\n\\t\\tcompositePass.material.defines = defines;\\n\\n\\t\\t// FXAA\\n\\n\\t\\teffectFXAA = new THREE.ShaderPass( THREE.FXAAShader );\\n\\t\\teffectFXAA.uniforms[ 'resolution' ].value.set( 1 / fullWidth, 1 / fullHeight );\\n\\t\\teffectFXAA.renderToScreen = true;\\n\\n\\t\\t//\\n\\n\\t\\tcompFinal = new THREE.EffectComposer( _this.renderer, rtFinal );\\n\\t\\tcompFinal.addPass( compositePass );\\n\\t\\tcompFinal.addPass( effectFXAA );\\n\\n\\t\\tif ( antialias ) {\\n\\n\\t\\t\\teffectFXAA.enabled = true;\\n\\t\\t\\tcompositePass.renderToScreen = false;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\teffectFXAA.enabled = false;\\n\\t\\t\\tcompositePass.renderToScreen = true;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// init\\n\\n\\tcreateRenderTargets();\\n\\n};\\n\\n// tonemapping operator types\\n\\nTHREE.NoOperator = 0;\\nTHREE.SimpleOperator = 1;\\nTHREE.LinearOperator = 2;\\nTHREE.ReinhardOperator = 3;\\nTHREE.FilmicOperator = 4;\\nTHREE.UnchartedOperator = 5;\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Renderers/CSS2DRenderer.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Renderers/CSS2DRenderer.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.CSS2DObject = function ( element ) {\\n\\n\\tTHREE.Object3D.call( this );\\n\\n\\tthis.element = element;\\n\\tthis.element.style.position = 'absolute';\\n\\n\\tthis.addEventListener( 'removed', function ( event ) {\\n\\n\\t\\tif ( this.element.parentNode !== null ) {\\n\\n\\t\\t\\tthis.element.parentNode.removeChild( this.element );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n};\\n\\nTHREE.CSS2DObject.prototype = Object.create( THREE.Object3D.prototype );\\n\\n//\\n\\nTHREE.CSS2DRenderer = function () {\\n\\n\\tconsole.log( 'THREE.CSS2DRenderer', THREE.REVISION );\\n\\n\\tvar _width, _height;\\n\\tvar _widthHalf, _heightHalf;\\n\\n\\tvar vector = new THREE.Vector3();\\n\\tvar viewMatrix = new THREE.Matrix4();\\n\\tvar viewProjectionMatrix = new THREE.Matrix4();\\n\\n\\tvar domElement = document.createElement( 'div' );\\n\\tdomElement.style.overflow = 'hidden';\\n\\n\\tthis.domElement = domElement;\\n\\n\\tthis.setSize = function ( width, height ) {\\n\\n\\t\\t_width = width;\\n\\t\\t_height = height;\\n\\n\\t\\t_widthHalf = _width / 2;\\n\\t\\t_heightHalf = _height / 2;\\n\\n\\t\\tdomElement.style.width = width + 'px';\\n\\t\\tdomElement.style.height = height + 'px';\\n\\n\\t};\\n\\n\\tvar renderObject = function ( object, camera ) {\\n\\n\\t\\tif ( object instanceof THREE.CSS2DObject ) {\\n\\n\\t\\t\\tvector.setFromMatrixPosition( object.matrixWorld );\\n\\t\\t\\tvector.applyProjection( viewProjectionMatrix );\\n\\n\\t\\t\\tvar element = object.element;\\n\\t\\t\\tvar style = 'translate(-50%,-50%) translate(' + ( vector.x * _widthHalf + _widthHalf ) + 'px,' + ( - vector.y * _heightHalf + _heightHalf ) + 'px)';\\n\\n\\t\\t\\telement.style.WebkitTransform = style;\\n\\t\\t\\telement.style.MozTransform = style;\\n\\t\\t\\telement.style.oTransform = style;\\n\\t\\t\\telement.style.transform = style;\\n\\n\\t\\t\\tif ( element.parentNode !== domElement ) {\\n\\n\\t\\t\\t\\tdomElement.appendChild( element );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\\n\\n\\t\\t\\trenderObject( object.children[ i ], camera );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\n\\t\\tscene.updateMatrixWorld();\\n\\n\\t\\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\\n\\n\\t\\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\\n\\n\\t\\tviewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\\n\\t\\tviewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, viewMatrix );\\n\\n\\t\\trenderObject( scene, camera );\\n\\n\\t};\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Renderers/SVGRenderer.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Renderers/SVGRenderer.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.SVGRenderer = function () {\\n\\n\\tconsole.log( 'THREE.SVGRenderer', THREE.REVISION );\\n\\n\\tvar _this = this,\\n\\t_renderData, _elements, _lights,\\n\\t_projector = new THREE.Projector(),\\n\\t_svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),\\n\\t_svgWidth, _svgHeight, _svgWidthHalf, _svgHeightHalf,\\n\\n\\t_v1, _v2, _v3, _v4,\\n\\n\\t_clipBox = new THREE.Box2(),\\n\\t_elemBox = new THREE.Box2(),\\n\\n\\t_color = new THREE.Color(),\\n\\t_diffuseColor = new THREE.Color(),\\n\\t_ambientLight = new THREE.Color(),\\n\\t_directionalLights = new THREE.Color(),\\n\\t_pointLights = new THREE.Color(),\\n\\t_clearColor = new THREE.Color(),\\n\\t_clearAlpha = 1,\\n\\n\\t_w, // z-buffer to w-buffer\\n\\t_vector3 = new THREE.Vector3(), // Needed for PointLight\\n\\t_centroid = new THREE.Vector3(),\\n\\n\\t_svgPathPool = [], _svgLinePool = [], _svgRectPool = [],\\n\\t_svgNode, _pathCount = 0, _lineCount = 0, _rectCount = 0,\\n\\t_quality = 1;\\n\\n\\tthis.domElement = _svg;\\n\\n\\tthis.autoClear = true;\\n\\tthis.sortObjects = true;\\n\\tthis.sortElements = true;\\n\\n\\tthis.info = {\\n\\n\\t\\trender: {\\n\\n\\t\\t\\tvertices: 0,\\n\\t\\t\\tfaces: 0\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tthis.setQuality = function( quality ) {\\n\\n\\t\\tswitch(quality) {\\n\\n\\t\\t\\tcase \\\"high\\\": _quality = 1; break;\\n\\t\\t\\tcase \\\"low\\\": _quality = 0; break;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// WebGLRenderer compatibility\\n\\n\\tthis.supportsVertexTextures = function () {};\\n\\tthis.setFaceCulling = function () {};\\n\\n\\tthis.setClearColor = function ( color, alpha ) {\\n\\n\\t\\t_clearColor.set( color );\\n\\t\\t_clearAlpha = alpha !== undefined ? alpha : 1;\\n\\n\\t};\\n\\n\\tthis.setSize = function( width, height ) {\\n\\n\\t\\t_svgWidth = width; _svgHeight = height;\\n\\t\\t_svgWidthHalf = _svgWidth / 2; _svgHeightHalf = _svgHeight / 2;\\n\\n\\t\\t_svg.setAttribute( 'viewBox', ( - _svgWidthHalf ) + ' ' + ( - _svgHeightHalf ) + ' ' + _svgWidth + ' ' + _svgHeight );\\n\\t\\t_svg.setAttribute( 'width', _svgWidth );\\n\\t\\t_svg.setAttribute( 'height', _svgHeight );\\n\\n\\t\\t_clipBox.min.set( - _svgWidthHalf, - _svgHeightHalf );\\n\\t\\t_clipBox.max.set( _svgWidthHalf, _svgHeightHalf );\\n\\n\\t};\\n\\n\\tthis.clear = function () {\\n\\n\\t\\t_pathCount = 0;\\n\\t\\t_lineCount = 0;\\n\\t\\t_rectCount = 0;\\n\\n\\t\\twhile ( _svg.childNodes.length > 0 ) {\\n\\n\\t\\t\\t_svg.removeChild( _svg.childNodes[ 0 ] );\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\t_svg.style.backgroundColor = 'rgba(' + ( ( _clearColor.r * 255 ) | 0 ) + ',' + ( ( _clearColor.g * 255 ) | 0 ) + ',' + ( ( _clearColor.b * 255 ) | 0 ) + ',' + _clearAlpha + ')';\\n\\n\\t};\\n\\n\\tthis.render = function ( scene, camera ) {\\n\\n\\t\\tif ( camera instanceof THREE.Camera === false ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.SVGRenderer.render: camera is not an instance of THREE.Camera.' );\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tif ( this.autoClear === true ) this.clear();\\n\\n\\t\\t_this.info.render.vertices = 0;\\n\\t\\t_this.info.render.faces = 0;\\n\\n\\t\\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\\n\\t\\t_elements = _renderData.elements;\\n\\t\\t_lights = _renderData.lights;\\n\\n\\t\\tcalculateLights( _lights );\\n\\n\\t\\tfor ( var e = 0, el = _elements.length; e < el; e ++ ) {\\n\\n\\t\\t\\tvar element = _elements[ e ];\\n\\t\\t\\tvar material = element.material;\\n\\n\\t\\t\\tif ( material === undefined || material.opacity === 0 ) continue;\\n\\n\\t\\t\\t_elemBox.makeEmpty();\\n\\n\\t\\t\\tif ( element instanceof THREE.RenderableSprite ) {\\n\\n\\t\\t\\t\\t_v1 = element;\\n\\t\\t\\t\\t_v1.x *= _svgWidthHalf; _v1.y *= - _svgHeightHalf;\\n\\n\\t\\t\\t\\trenderSprite( _v1, element, material );\\n\\n\\t\\t\\t} else if ( element instanceof THREE.RenderableLine ) {\\n\\n\\t\\t\\t\\t_v1 = element.v1; _v2 = element.v2;\\n\\n\\t\\t\\t\\t_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;\\n\\t\\t\\t\\t_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;\\n\\n\\t\\t\\t\\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen ] );\\n\\n\\t\\t\\t\\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\\n\\n\\t\\t\\t\\t\\trenderLine( _v1, _v2, element, material );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( element instanceof THREE.RenderableFace ) {\\n\\n\\t\\t\\t\\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\\n\\n\\t\\t\\t\\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\\n\\t\\t\\t\\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\\n\\t\\t\\t\\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\\n\\n\\t\\t\\t\\t_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;\\n\\t\\t\\t\\t_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;\\n\\t\\t\\t\\t_v3.positionScreen.x *= _svgWidthHalf; _v3.positionScreen.y *= - _svgHeightHalf;\\n\\n\\t\\t\\t\\t_elemBox.setFromPoints( [\\n\\t\\t\\t\\t\\t_v1.positionScreen,\\n\\t\\t\\t\\t\\t_v2.positionScreen,\\n\\t\\t\\t\\t\\t_v3.positionScreen\\n\\t\\t\\t\\t] );\\n\\n\\t\\t\\t\\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\\n\\n\\t\\t\\t\\t\\trenderFace3( _v1, _v2, _v3, element, material );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction calculateLights( lights ) {\\n\\n\\t\\t_ambientLight.setRGB( 0, 0, 0 );\\n\\t\\t_directionalLights.setRGB( 0, 0, 0 );\\n\\t\\t_pointLights.setRGB( 0, 0, 0 );\\n\\n\\t\\tfor ( var l = 0, ll = lights.length; l < ll; l++ ) {\\n\\n\\t\\t\\tvar light = lights[ l ];\\n\\t\\t\\tvar lightColor = light.color;\\n\\n\\t\\t\\tif ( light instanceof THREE.AmbientLight ) {\\n\\n\\t\\t\\t\\t_ambientLight.r += lightColor.r;\\n\\t\\t\\t\\t_ambientLight.g += lightColor.g;\\n\\t\\t\\t\\t_ambientLight.b += lightColor.b;\\n\\n\\t\\t\\t} else if ( light instanceof THREE.DirectionalLight ) {\\n\\n\\t\\t\\t\\t_directionalLights.r += lightColor.r;\\n\\t\\t\\t\\t_directionalLights.g += lightColor.g;\\n\\t\\t\\t\\t_directionalLights.b += lightColor.b;\\n\\n\\t\\t\\t} else if ( light instanceof THREE.PointLight ) {\\n\\n\\t\\t\\t\\t_pointLights.r += lightColor.r;\\n\\t\\t\\t\\t_pointLights.g += lightColor.g;\\n\\t\\t\\t\\t_pointLights.b += lightColor.b;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction calculateLight( lights, position, normal, color ) {\\n\\n\\t\\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\\n\\n\\t\\t\\tvar light = lights[ l ];\\n\\t\\t\\tvar lightColor = light.color;\\n\\n\\t\\t\\tif ( light instanceof THREE.DirectionalLight ) {\\n\\n\\t\\t\\t\\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();\\n\\n\\t\\t\\t\\tvar amount = normal.dot( lightPosition );\\n\\n\\t\\t\\t\\tif ( amount <= 0 ) continue;\\n\\n\\t\\t\\t\\tamount *= light.intensity;\\n\\n\\t\\t\\t\\tcolor.r += lightColor.r * amount;\\n\\t\\t\\t\\tcolor.g += lightColor.g * amount;\\n\\t\\t\\t\\tcolor.b += lightColor.b * amount;\\n\\n\\t\\t\\t} else if ( light instanceof THREE.PointLight ) {\\n\\n\\t\\t\\t\\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );\\n\\n\\t\\t\\t\\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\\n\\n\\t\\t\\t\\tif ( amount <= 0 ) continue;\\n\\n\\t\\t\\t\\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\\n\\n\\t\\t\\t\\tif ( amount == 0 ) continue;\\n\\n\\t\\t\\t\\tamount *= light.intensity;\\n\\n\\t\\t\\t\\tcolor.r += lightColor.r * amount;\\n\\t\\t\\t\\tcolor.g += lightColor.g * amount;\\n\\t\\t\\t\\tcolor.b += lightColor.b * amount;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction renderSprite( v1, element, material ) {\\n\\n\\t\\tvar scaleX = element.scale.x * _svgWidthHalf;\\n\\t\\tvar scaleY = element.scale.y * _svgHeightHalf;\\n\\n\\t\\t_svgNode = getRectNode( _rectCount ++ );\\n\\n\\t\\t_svgNode.setAttribute( 'x', v1.x - ( scaleX * 0.5 ) );\\n\\t\\t_svgNode.setAttribute( 'y', v1.y - ( scaleY * 0.5 ) );\\n\\t\\t_svgNode.setAttribute( 'width', scaleX );\\n\\t\\t_svgNode.setAttribute( 'height', scaleY );\\n\\n\\t\\tif ( material instanceof THREE.SpriteMaterial ) {\\n\\n\\t\\t\\t_svgNode.setAttribute( 'style', 'fill: ' + material.color.getStyle() );\\n\\n\\t\\t}\\n\\n\\t\\t_svg.appendChild( _svgNode );\\n\\n\\t}\\n\\n\\tfunction renderLine( v1, v2, element, material ) {\\n\\n\\t\\t_svgNode = getLineNode( _lineCount ++ );\\n\\n\\t\\t_svgNode.setAttribute( 'x1', v1.positionScreen.x );\\n\\t\\t_svgNode.setAttribute( 'y1', v1.positionScreen.y );\\n\\t\\t_svgNode.setAttribute( 'x2', v2.positionScreen.x );\\n\\t\\t_svgNode.setAttribute( 'y2', v2.positionScreen.y );\\n\\n\\t\\tif ( material instanceof THREE.LineBasicMaterial ) {\\n\\n\\t\\t\\t_svgNode.setAttribute( 'style', 'fill: none; stroke: ' + material.color.getStyle() + '; stroke-width: ' + material.linewidth + '; stroke-opacity: ' + material.opacity + '; stroke-linecap: ' + material.linecap + '; stroke-linejoin: ' + material.linejoin );\\n\\n\\t\\t\\t_svg.appendChild( _svgNode );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction renderFace3( v1, v2, v3, element, material ) {\\n\\n\\t\\t_this.info.render.vertices += 3;\\n\\t\\t_this.info.render.faces ++;\\n\\n\\t\\t_svgNode = getPathNode( _pathCount ++ );\\n\\t\\t_svgNode.setAttribute( 'd', 'M ' + v1.positionScreen.x + ' ' + v1.positionScreen.y + ' L ' + v2.positionScreen.x + ' ' + v2.positionScreen.y + ' L ' + v3.positionScreen.x + ',' + v3.positionScreen.y + 'z' );\\n\\n\\t\\tif ( material instanceof THREE.MeshBasicMaterial ) {\\n\\n\\t\\t\\t_color.copy( material.color );\\n\\n\\t\\t\\tif ( material.vertexColors === THREE.FaceColors ) {\\n\\n\\t\\t\\t\\t_color.multiply( element.color );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else if ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\\n\\n\\t\\t\\t_diffuseColor.copy( material.color );\\n\\n\\t\\t\\tif ( material.vertexColors === THREE.FaceColors ) {\\n\\n\\t\\t\\t\\t_diffuseColor.multiply( element.color );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_color.copy( _ambientLight );\\n\\n\\t\\t\\t_centroid.copy( v1.positionWorld ).add( v2.positionWorld ).add( v3.positionWorld ).divideScalar( 3 );\\n\\n\\t\\t\\tcalculateLight( _lights, _centroid, element.normalModel, _color );\\n\\n\\t\\t\\t_color.multiply( _diffuseColor ).add( material.emissive );\\n\\n\\t\\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\\n\\n\\t\\t\\t_w = 1 - ( material.__2near / (material.__farPlusNear - element.z * material.__farMinusNear) );\\n\\t\\t\\t_color.setRGB( _w, _w, _w );\\n\\n\\t\\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\\n\\n\\t\\t\\tvar normal = element.normalModelView;\\n\\n\\t\\t\\t_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\\n\\n\\t\\t}\\n\\n\\t\\tif ( material.wireframe ) {\\n\\n\\t\\t\\t_svgNode.setAttribute( 'style', 'fill: none; stroke: ' + _color.getStyle() + '; stroke-width: ' + material.wireframeLinewidth + '; stroke-opacity: ' + material.opacity + '; stroke-linecap: ' + material.wireframeLinecap + '; stroke-linejoin: ' + material.wireframeLinejoin );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t_svgNode.setAttribute( 'style', 'fill: ' + _color.getStyle() + '; fill-opacity: ' + material.opacity );\\n\\n\\t\\t}\\n\\n\\t\\t_svg.appendChild( _svgNode );\\n\\n\\t}\\n\\n\\tfunction getLineNode( id ) {\\n\\n\\t\\tif ( _svgLinePool[ id ] == null ) {\\n\\n\\t\\t\\t_svgLinePool[ id ] = document.createElementNS( 'http://www.w3.org/2000/svg', 'line' );\\n\\n\\t\\t\\tif ( _quality == 0 ) {\\n\\n\\t\\t\\t\\t_svgLinePool[ id ].setAttribute( 'shape-rendering', 'crispEdges' ); //optimizeSpeed\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn _svgLinePool[ id ];\\n\\n\\t\\t}\\n\\n\\t\\treturn _svgLinePool[ id ];\\n\\n\\t}\\n\\n\\tfunction getPathNode( id ) {\\n\\n\\t\\tif ( _svgPathPool[ id ] == null ) {\\n\\n\\t\\t\\t_svgPathPool[ id ] = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );\\n\\n\\t\\t\\tif ( _quality == 0 ) {\\n\\n\\t\\t\\t\\t_svgPathPool[ id ].setAttribute( 'shape-rendering', 'crispEdges' ); //optimizeSpeed\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn _svgPathPool[ id ];\\n\\n\\t\\t}\\n\\n\\t\\treturn _svgPathPool[ id ];\\n\\n\\t}\\n\\n\\tfunction getRectNode( id ) {\\n\\n\\t\\tif ( _svgRectPool[ id ] == null ) {\\n\\n\\t\\t\\t_svgRectPool[ id ] = document.createElementNS( 'http://www.w3.org/2000/svg', 'rect' );\\n\\n\\t\\t\\tif ( _quality == 0 ) {\\n\\n\\t\\t\\t\\t_svgRectPool[ id ].setAttribute( 'shape-rendering', 'crispEdges' ); //optimizeSpeed\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn _svgRectPool[ id ];\\n\\n\\t\\t}\\n\\n\\t\\treturn _svgRectPool[ id ];\\n\\n\\t}\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/DeviceOrientationControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/DeviceOrientationControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author richt / http://richt.me\\n * @author WestLangley / http://github.com/WestLangley\\n *\\n * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)\\n */\\n\\nTHREE.DeviceOrientationControls = function ( object ) {\\n\\n\\tvar scope = this;\\n\\n\\tthis.object = object;\\n\\n\\tthis.object.rotation.reorder( \\\"YXZ\\\" );\\n\\n\\tthis.freeze = true;\\n\\n\\tthis.deviceOrientation = {};\\n\\n\\tthis.screenOrientation = 0;\\n\\n\\tvar onDeviceOrientationChangeEvent = function ( event ) {\\n\\n\\t\\tscope.deviceOrientation = event;\\n\\n\\t};\\n\\n\\tvar onScreenOrientationChangeEvent = function () {\\n\\n\\t\\tscope.screenOrientation = window.orientation || 0;\\n\\n\\t};\\n\\n\\t// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''\\n\\n\\tvar setObjectQuaternion = function () {\\n\\n\\t\\tvar zee = new THREE.Vector3( 0, 0, 1 );\\n\\n\\t\\tvar euler = new THREE.Euler();\\n\\n\\t\\tvar q0 = new THREE.Quaternion();\\n\\n\\t\\tvar q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis\\n\\n\\t\\treturn function ( quaternion, alpha, beta, gamma, orient ) {\\n\\n\\t\\t\\teuler.set( beta, alpha, - gamma, 'YXZ' );                       // 'ZXY' for the device, but 'YXZ' for us\\n\\n\\t\\t\\tquaternion.setFromEuler( euler );                               // orient the device\\n\\n\\t\\t\\tquaternion.multiply( q1 );                                      // camera looks out the back of the device, not the top\\n\\n\\t\\t\\tquaternion.multiply( q0.setFromAxisAngle( zee, - orient ) );    // adjust for screen orientation\\n\\n\\t\\t}\\n\\n\\t}();\\n\\n\\tthis.connect = function() {\\n\\n\\t\\tonScreenOrientationChangeEvent(); // run once on load\\n\\n\\t\\twindow.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\\n\\t\\twindow.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\\n\\n\\t\\tscope.freeze = false;\\n\\n\\t};\\n\\n\\tthis.disconnect = function() {\\n\\n\\t\\tscope.freeze = true;\\n\\n\\t\\twindow.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\\n\\t\\twindow.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\\n\\n\\t};\\n\\n\\tthis.update = function () {\\n\\n\\t\\tif ( scope.freeze ) return;\\n\\n\\t\\tvar alpha  = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.alpha ) : 0; // Z\\n\\t\\tvar beta   = scope.deviceOrientation.beta  ? THREE.Math.degToRad( scope.deviceOrientation.beta  ) : 0; // X'\\n\\t\\tvar gamma  = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.gamma ) : 0; // Y''\\n\\t\\tvar orient = scope.screenOrientation       ? THREE.Math.degToRad( scope.screenOrientation       ) : 0; // O\\n\\n\\t\\tsetObjectQuaternion( scope.object.quaternion, alpha, beta, gamma, orient );\\n\\n\\t};\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/EditorControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/EditorControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author qiao / https://github.com/qiao\\n * @author mrdoob / http://mrdoob.com\\n * @author alteredq / http://alteredqualia.com/\\n * @author WestLangley / http://github.com/WestLangley\\n */\\n\\nTHREE.EditorControls = function ( object, domElement ) {\\n\\n\\tdomElement = ( domElement !== undefined ) ? domElement : document;\\n\\n\\t// API\\n\\n\\tthis.enabled = true;\\n\\tthis.center = new THREE.Vector3();\\n\\n\\t// internals\\n\\n\\tvar scope = this;\\n\\tvar vector = new THREE.Vector3();\\n\\n\\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2 };\\n\\tvar state = STATE.NONE;\\n\\n\\tvar center = this.center;\\n\\tvar normalMatrix = new THREE.Matrix3();\\n\\tvar pointer = new THREE.Vector2();\\n\\tvar pointerOld = new THREE.Vector2();\\n\\n\\t// events\\n\\n\\tvar changeEvent = { type: 'change' };\\n\\n\\tthis.focus = function ( target, frame ) {\\n\\n\\t\\tvar scale = new THREE.Vector3();\\n\\t\\ttarget.matrixWorld.decompose( center, new THREE.Quaternion(), scale );\\n\\n\\t\\tif ( frame && target.geometry ) {\\n\\n\\t\\t\\tscale = ( scale.x + scale.y + scale.z ) / 3;\\n\\t\\t\\tcenter.add(target.geometry.boundingSphere.center.clone().multiplyScalar( scale ));\\n\\t\\t\\tvar radius = target.geometry.boundingSphere.radius * ( scale );\\n\\t\\t\\tvar pos = object.position.clone().sub( center ).normalize().multiplyScalar( radius * 2 );\\n\\t\\t\\tobject.position.copy( center ).add( pos );\\n\\n\\t\\t}\\n\\n\\t\\tobject.lookAt( center );\\n\\n\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t};\\n\\n\\tthis.pan = function ( distance ) {\\n\\n\\t\\tnormalMatrix.getNormalMatrix( object.matrix );\\n\\n\\t\\tdistance.applyMatrix3( normalMatrix );\\n\\t\\tdistance.multiplyScalar( vector.copy( center ).sub( object.position ).length() * 0.001 );\\n\\n\\t\\tobject.position.add( distance );\\n\\t\\tcenter.add( distance );\\n\\n\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t};\\n\\n\\tthis.zoom = function ( distance ) {\\n\\n\\t\\tnormalMatrix.getNormalMatrix( object.matrix );\\n\\n\\t\\tdistance.applyMatrix3( normalMatrix );\\n\\t\\tdistance.multiplyScalar( vector.copy( center ).sub( object.position ).length() * 0.001 );\\n\\n\\t\\tobject.position.add( distance );\\n\\n\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t};\\n\\n\\tthis.rotate = function ( delta ) {\\n\\n\\t\\tvector.copy( object.position ).sub( center );\\n\\n\\t\\tvar theta = Math.atan2( vector.x, vector.z );\\n\\t\\tvar phi = Math.atan2( Math.sqrt( vector.x * vector.x + vector.z * vector.z ), vector.y );\\n\\n\\t\\ttheta += delta.x;\\n\\t\\tphi += delta.y;\\n\\n\\t\\tvar EPS = 0.000001;\\n\\n\\t\\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\\n\\n\\t\\tvar radius = vector.length();\\n\\n\\t\\tvector.x = radius * Math.sin( phi ) * Math.sin( theta );\\n\\t\\tvector.y = radius * Math.cos( phi );\\n\\t\\tvector.z = radius * Math.sin( phi ) * Math.cos( theta );\\n\\n\\t\\tobject.position.copy( center ).add( vector );\\n\\n\\t\\tobject.lookAt( center );\\n\\n\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t};\\n\\n\\t// mouse\\n\\n\\tfunction onMouseDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tif ( event.button === 0 ) {\\n\\n\\t\\t\\tstate = STATE.ROTATE;\\n\\n\\t\\t} else if ( event.button === 1 ) {\\n\\n\\t\\t\\tstate = STATE.ZOOM;\\n\\n\\t\\t} else if ( event.button === 2 ) {\\n\\n\\t\\t\\tstate = STATE.PAN;\\n\\n\\t\\t}\\n\\n\\t\\tpointerOld.set( event.clientX, event.clientY );\\n\\n\\t\\tdomElement.addEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdomElement.addEventListener( 'mouseup', onMouseUp, false );\\n\\t\\tdomElement.addEventListener( 'mouseout', onMouseUp, false );\\n\\t\\tdomElement.addEventListener( 'dblclick', onMouseUp, false );\\n\\n\\t}\\n\\n\\tfunction onMouseMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tpointer.set( event.clientX, event.clientY );\\n\\n\\t\\tvar movementX = pointer.x - pointerOld.x;\\n\\t\\tvar movementY = pointer.y - pointerOld.y;\\n\\n\\t\\tif ( state === STATE.ROTATE ) {\\n\\n\\t\\t\\tscope.rotate( new THREE.Vector3( - movementX * 0.005, - movementY * 0.005, 0 ) );\\n\\n\\t\\t} else if ( state === STATE.ZOOM ) {\\n\\n\\t\\t\\tscope.zoom( new THREE.Vector3( 0, 0, movementY ) );\\n\\n\\t\\t} else if ( state === STATE.PAN ) {\\n\\n\\t\\t\\tscope.pan( new THREE.Vector3( - movementX, movementY, 0 ) );\\n\\n\\t\\t}\\n\\n\\t\\tpointerOld.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction onMouseUp( event ) {\\n\\n\\t\\tdomElement.removeEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdomElement.removeEventListener( 'mouseup', onMouseUp, false );\\n\\t\\tdomElement.removeEventListener( 'mouseout', onMouseUp, false );\\n\\t\\tdomElement.removeEventListener( 'dblclick', onMouseUp, false );\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onMouseWheel( event ) {\\n\\n\\t\\t// if ( scope.enabled === false ) return;\\n\\n\\t\\tvar delta = 0;\\n\\n\\t\\tif ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\\n\\n\\t\\t\\tdelta = - event.wheelDelta;\\n\\n\\t\\t} else if ( event.detail ) { // Firefox\\n\\n\\t\\t\\tdelta = event.detail * 10;\\n\\n\\t\\t}\\n\\n\\t\\tscope.zoom( new THREE.Vector3( 0, 0, delta ) );\\n\\n\\t}\\n\\n\\tdomElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\\n\\tdomElement.addEventListener( 'mousedown', onMouseDown, false );\\n\\tdomElement.addEventListener( 'mousewheel', onMouseWheel, false );\\n\\tdomElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\\n\\n\\t// touch\\n\\n\\tvar touch = new THREE.Vector3();\\n\\n\\tvar touches = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\\n\\tvar prevTouches = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\\n\\n\\tvar prevDistance = null;\\n\\n\\tfunction touchStart( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\n\\t\\t\\t\\ttouches[ 1 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\n\\t\\t\\t\\ttouches[ 1 ].set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY, 0 );\\n\\t\\t\\t\\tprevDistance = touches[ 0 ].distanceTo( touches[ 1 ] );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t\\tprevTouches[ 0 ].copy( touches[ 0 ] );\\n\\t\\tprevTouches[ 1 ].copy( touches[ 1 ] );\\n\\n\\t}\\n\\n\\n\\tfunction touchMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tvar getClosest = function( touch, touches ) {\\n\\n\\t\\t\\tvar closest = touches[ 0 ];\\n\\n\\t\\t\\tfor ( var i in touches ) {\\n\\t\\t\\t\\tif ( closest.distanceTo(touch) > touches[ i ].distanceTo(touch) ) closest = touches[ i ];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn closest;\\n\\n\\t\\t}\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\n\\t\\t\\t\\ttouches[ 1 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\n\\t\\t\\t\\tscope.rotate( touches[ 0 ].sub( getClosest( touches[ 0 ] ,prevTouches ) ).multiplyScalar( - 0.005 ) );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\\n\\t\\t\\t\\ttouches[ 1 ].set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY, 0 );\\n\\t\\t\\t\\tdistance = touches[ 0 ].distanceTo( touches[ 1 ] );\\n\\t\\t\\t\\tscope.zoom( new THREE.Vector3( 0, 0, prevDistance - distance ) );\\n\\t\\t\\t\\tprevDistance = distance;\\n\\n\\n\\t\\t\\t\\tvar offset0 = touches[ 0 ].clone().sub( getClosest( touches[ 0 ] ,prevTouches ) );\\n\\t\\t\\t\\tvar offset1 = touches[ 1 ].clone().sub( getClosest( touches[ 1 ] ,prevTouches ) );\\n\\t\\t\\t\\toffset0.x = -offset0.x;\\n\\t\\t\\t\\toffset1.x = -offset1.x;\\n\\n\\t\\t\\t\\tscope.pan( offset0.add( offset1 ).multiplyScalar( 0.5 ) );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t\\tprevTouches[ 0 ].copy( touches[ 0 ] );\\n\\t\\tprevTouches[ 1 ].copy( touches[ 1 ] );\\n\\n\\t}\\n\\n\\tdomElement.addEventListener( 'touchstart', touchStart, false );\\n\\tdomElement.addEventListener( 'touchmove', touchMove, false );\\n\\n};\\n\\nTHREE.EditorControls.prototype = Object.create( THREE.EventDispatcher.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/FirstPersonControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/FirstPersonControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n * @author alteredq / http://alteredqualia.com/\\n * @author paulirish / http://paulirish.com/\\n */\\n\\nTHREE.FirstPersonControls = function ( object, domElement ) {\\n\\n\\tthis.object = object;\\n\\tthis.target = new THREE.Vector3( 0, 0, 0 );\\n\\n\\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\\n\\n\\tthis.movementSpeed = 1.0;\\n\\tthis.lookSpeed = 0.005;\\n\\n\\tthis.lookVertical = true;\\n\\tthis.autoForward = false;\\n\\t// this.invertVertical = false;\\n\\n\\tthis.activeLook = true;\\n\\n\\tthis.heightSpeed = false;\\n\\tthis.heightCoef = 1.0;\\n\\tthis.heightMin = 0.0;\\n\\tthis.heightMax = 1.0;\\n\\n\\tthis.constrainVertical = false;\\n\\tthis.verticalMin = 0;\\n\\tthis.verticalMax = Math.PI;\\n\\n\\tthis.autoSpeedFactor = 0.0;\\n\\n\\tthis.mouseX = 0;\\n\\tthis.mouseY = 0;\\n\\n\\tthis.lat = 0;\\n\\tthis.lon = 0;\\n\\tthis.phi = 0;\\n\\tthis.theta = 0;\\n\\n\\tthis.moveForward = false;\\n\\tthis.moveBackward = false;\\n\\tthis.moveLeft = false;\\n\\tthis.moveRight = false;\\n\\tthis.freeze = false;\\n\\n\\tthis.mouseDragOn = false;\\n\\n\\tthis.viewHalfX = 0;\\n\\tthis.viewHalfY = 0;\\n\\n\\tif ( this.domElement !== document ) {\\n\\n\\t\\tthis.domElement.setAttribute( 'tabindex', -1 );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tthis.handleResize = function () {\\n\\n\\t\\tif ( this.domElement === document ) {\\n\\n\\t\\t\\tthis.viewHalfX = window.innerWidth / 2;\\n\\t\\t\\tthis.viewHalfY = window.innerHeight / 2;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.viewHalfX = this.domElement.offsetWidth / 2;\\n\\t\\t\\tthis.viewHalfY = this.domElement.offsetHeight / 2;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.onMouseDown = function ( event ) {\\n\\n\\t\\tif ( this.domElement !== document ) {\\n\\n\\t\\t\\tthis.domElement.focus();\\n\\n\\t\\t}\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tif ( this.activeLook ) {\\n\\n\\t\\t\\tswitch ( event.button ) {\\n\\n\\t\\t\\t\\tcase 0: this.moveForward = true; break;\\n\\t\\t\\t\\tcase 2: this.moveBackward = true; break;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.mouseDragOn = true;\\n\\n\\t};\\n\\n\\tthis.onMouseUp = function ( event ) {\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tif ( this.activeLook ) {\\n\\n\\t\\t\\tswitch ( event.button ) {\\n\\n\\t\\t\\t\\tcase 0: this.moveForward = false; break;\\n\\t\\t\\t\\tcase 2: this.moveBackward = false; break;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.mouseDragOn = false;\\n\\n\\t};\\n\\n\\tthis.onMouseMove = function ( event ) {\\n\\n\\t\\tif ( this.domElement === document ) {\\n\\n\\t\\t\\tthis.mouseX = event.pageX - this.viewHalfX;\\n\\t\\t\\tthis.mouseY = event.pageY - this.viewHalfY;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;\\n\\t\\t\\tthis.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.onKeyDown = function ( event ) {\\n\\n\\t\\t//event.preventDefault();\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\n\\t\\t\\tcase 38: /*up*/\\n\\t\\t\\tcase 87: /*W*/ this.moveForward = true; break;\\n\\n\\t\\t\\tcase 37: /*left*/\\n\\t\\t\\tcase 65: /*A*/ this.moveLeft = true; break;\\n\\n\\t\\t\\tcase 40: /*down*/\\n\\t\\t\\tcase 83: /*S*/ this.moveBackward = true; break;\\n\\n\\t\\t\\tcase 39: /*right*/\\n\\t\\t\\tcase 68: /*D*/ this.moveRight = true; break;\\n\\n\\t\\t\\tcase 82: /*R*/ this.moveUp = true; break;\\n\\t\\t\\tcase 70: /*F*/ this.moveDown = true; break;\\n\\n\\t\\t\\tcase 81: /*Q*/ this.freeze = !this.freeze; break;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.onKeyUp = function ( event ) {\\n\\n\\t\\tswitch( event.keyCode ) {\\n\\n\\t\\t\\tcase 38: /*up*/\\n\\t\\t\\tcase 87: /*W*/ this.moveForward = false; break;\\n\\n\\t\\t\\tcase 37: /*left*/\\n\\t\\t\\tcase 65: /*A*/ this.moveLeft = false; break;\\n\\n\\t\\t\\tcase 40: /*down*/\\n\\t\\t\\tcase 83: /*S*/ this.moveBackward = false; break;\\n\\n\\t\\t\\tcase 39: /*right*/\\n\\t\\t\\tcase 68: /*D*/ this.moveRight = false; break;\\n\\n\\t\\t\\tcase 82: /*R*/ this.moveUp = false; break;\\n\\t\\t\\tcase 70: /*F*/ this.moveDown = false; break;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.update = function( delta ) {\\n\\n\\t\\tif ( this.freeze ) {\\n\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tif ( this.heightSpeed ) {\\n\\n\\t\\t\\tvar y = THREE.Math.clamp( this.object.position.y, this.heightMin, this.heightMax );\\n\\t\\t\\tvar heightDelta = y - this.heightMin;\\n\\n\\t\\t\\tthis.autoSpeedFactor = delta * ( heightDelta * this.heightCoef );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.autoSpeedFactor = 0.0;\\n\\n\\t\\t}\\n\\n\\t\\tvar actualMoveSpeed = delta * this.movementSpeed;\\n\\n\\t\\tif ( this.moveForward || ( this.autoForward && !this.moveBackward ) ) this.object.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) );\\n\\t\\tif ( this.moveBackward ) this.object.translateZ( actualMoveSpeed );\\n\\n\\t\\tif ( this.moveLeft ) this.object.translateX( - actualMoveSpeed );\\n\\t\\tif ( this.moveRight ) this.object.translateX( actualMoveSpeed );\\n\\n\\t\\tif ( this.moveUp ) this.object.translateY( actualMoveSpeed );\\n\\t\\tif ( this.moveDown ) this.object.translateY( - actualMoveSpeed );\\n\\n\\t\\tvar actualLookSpeed = delta * this.lookSpeed;\\n\\n\\t\\tif ( !this.activeLook ) {\\n\\n\\t\\t\\tactualLookSpeed = 0;\\n\\n\\t\\t}\\n\\n\\t\\tvar verticalLookRatio = 1;\\n\\n\\t\\tif ( this.constrainVertical ) {\\n\\n\\t\\t\\tverticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );\\n\\n\\t\\t}\\n\\n\\t\\tthis.lon += this.mouseX * actualLookSpeed;\\n\\t\\tif( this.lookVertical ) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;\\n\\n\\t\\tthis.lat = Math.max( - 85, Math.min( 85, this.lat ) );\\n\\t\\tthis.phi = THREE.Math.degToRad( 90 - this.lat );\\n\\n\\t\\tthis.theta = THREE.Math.degToRad( this.lon );\\n\\n\\t\\tif ( this.constrainVertical ) {\\n\\n\\t\\t\\tthis.phi = THREE.Math.mapLinear( this.phi, 0, Math.PI, this.verticalMin, this.verticalMax );\\n\\n\\t\\t}\\n\\n\\t\\tvar targetPosition = this.target,\\n\\t\\t\\tposition = this.object.position;\\n\\n\\t\\ttargetPosition.x = position.x + 100 * Math.sin( this.phi ) * Math.cos( this.theta );\\n\\t\\ttargetPosition.y = position.y + 100 * Math.cos( this.phi );\\n\\t\\ttargetPosition.z = position.z + 100 * Math.sin( this.phi ) * Math.sin( this.theta );\\n\\n\\t\\tthis.object.lookAt( targetPosition );\\n\\n\\t};\\n\\n\\n\\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\\n\\n\\tthis.domElement.addEventListener( 'mousemove', bind( this, this.onMouseMove ), false );\\n\\tthis.domElement.addEventListener( 'mousedown', bind( this, this.onMouseDown ), false );\\n\\tthis.domElement.addEventListener( 'mouseup', bind( this, this.onMouseUp ), false );\\n\\t\\n\\twindow.addEventListener( 'keydown', bind( this, this.onKeyDown ), false );\\n\\twindow.addEventListener( 'keyup', bind( this, this.onKeyUp ), false );\\n\\n\\tfunction bind( scope, fn ) {\\n\\n\\t\\treturn function () {\\n\\n\\t\\t\\tfn.apply( scope, arguments );\\n\\n\\t\\t};\\n\\n\\t};\\n\\n\\tthis.handleResize();\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/FlyControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/FlyControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author James Baicoianu / http://www.baicoianu.com/\\n */\\n\\nTHREE.FlyControls = function ( object, domElement ) {\\n\\n\\tthis.object = object;\\n\\n\\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\\n\\tif ( domElement ) this.domElement.setAttribute( 'tabindex', -1 );\\n\\n\\t// API\\n\\n\\tthis.movementSpeed = 1.0;\\n\\tthis.rollSpeed = 0.005;\\n\\n\\tthis.dragToLook = false;\\n\\tthis.autoForward = false;\\n\\n\\t// disable default target object behavior\\n\\n\\t// internals\\n\\n\\tthis.tmpQuaternion = new THREE.Quaternion();\\n\\n\\tthis.mouseStatus = 0;\\n\\n\\tthis.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };\\n\\tthis.moveVector = new THREE.Vector3( 0, 0, 0 );\\n\\tthis.rotationVector = new THREE.Vector3( 0, 0, 0 );\\n\\n\\tthis.handleEvent = function ( event ) {\\n\\n\\t\\tif ( typeof this[ event.type ] == 'function' ) {\\n\\n\\t\\t\\tthis[ event.type ]( event );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.keydown = function( event ) {\\n\\n\\t\\tif ( event.altKey ) {\\n\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\t//event.preventDefault();\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\n\\t\\t\\tcase 16: /* shift */ this.movementSpeedMultiplier = .1; break;\\n\\n\\t\\t\\tcase 87: /*W*/ this.moveState.forward = 1; break;\\n\\t\\t\\tcase 83: /*S*/ this.moveState.back = 1; break;\\n\\n\\t\\t\\tcase 65: /*A*/ this.moveState.left = 1; break;\\n\\t\\t\\tcase 68: /*D*/ this.moveState.right = 1; break;\\n\\n\\t\\t\\tcase 82: /*R*/ this.moveState.up = 1; break;\\n\\t\\t\\tcase 70: /*F*/ this.moveState.down = 1; break;\\n\\n\\t\\t\\tcase 38: /*up*/ this.moveState.pitchUp = 1; break;\\n\\t\\t\\tcase 40: /*down*/ this.moveState.pitchDown = 1; break;\\n\\n\\t\\t\\tcase 37: /*left*/ this.moveState.yawLeft = 1; break;\\n\\t\\t\\tcase 39: /*right*/ this.moveState.yawRight = 1; break;\\n\\n\\t\\t\\tcase 81: /*Q*/ this.moveState.rollLeft = 1; break;\\n\\t\\t\\tcase 69: /*E*/ this.moveState.rollRight = 1; break;\\n\\n\\t\\t}\\n\\n\\t\\tthis.updateMovementVector();\\n\\t\\tthis.updateRotationVector();\\n\\n\\t};\\n\\n\\tthis.keyup = function( event ) {\\n\\n\\t\\tswitch( event.keyCode ) {\\n\\n\\t\\t\\tcase 16: /* shift */ this.movementSpeedMultiplier = 1; break;\\n\\n\\t\\t\\tcase 87: /*W*/ this.moveState.forward = 0; break;\\n\\t\\t\\tcase 83: /*S*/ this.moveState.back = 0; break;\\n\\n\\t\\t\\tcase 65: /*A*/ this.moveState.left = 0; break;\\n\\t\\t\\tcase 68: /*D*/ this.moveState.right = 0; break;\\n\\n\\t\\t\\tcase 82: /*R*/ this.moveState.up = 0; break;\\n\\t\\t\\tcase 70: /*F*/ this.moveState.down = 0; break;\\n\\n\\t\\t\\tcase 38: /*up*/ this.moveState.pitchUp = 0; break;\\n\\t\\t\\tcase 40: /*down*/ this.moveState.pitchDown = 0; break;\\n\\n\\t\\t\\tcase 37: /*left*/ this.moveState.yawLeft = 0; break;\\n\\t\\t\\tcase 39: /*right*/ this.moveState.yawRight = 0; break;\\n\\n\\t\\t\\tcase 81: /*Q*/ this.moveState.rollLeft = 0; break;\\n\\t\\t\\tcase 69: /*E*/ this.moveState.rollRight = 0; break;\\n\\n\\t\\t}\\n\\n\\t\\tthis.updateMovementVector();\\n\\t\\tthis.updateRotationVector();\\n\\n\\t};\\n\\n\\tthis.mousedown = function( event ) {\\n\\n\\t\\tif ( this.domElement !== document ) {\\n\\n\\t\\t\\tthis.domElement.focus();\\n\\n\\t\\t}\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tif ( this.dragToLook ) {\\n\\n\\t\\t\\tthis.mouseStatus ++;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tswitch ( event.button ) {\\n\\n\\t\\t\\t\\tcase 0: this.moveState.forward = 1; break;\\n\\t\\t\\t\\tcase 2: this.moveState.back = 1; break;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.updateMovementVector();\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.mousemove = function( event ) {\\n\\n\\t\\tif ( !this.dragToLook || this.mouseStatus > 0 ) {\\n\\n\\t\\t\\tvar container = this.getContainerDimensions();\\n\\t\\t\\tvar halfWidth  = container.size[ 0 ] / 2;\\n\\t\\t\\tvar halfHeight = container.size[ 1 ] / 2;\\n\\n\\t\\t\\tthis.moveState.yawLeft   = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth  ) / halfWidth;\\n\\t\\t\\tthis.moveState.pitchDown =   ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;\\n\\n\\t\\t\\tthis.updateRotationVector();\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.mouseup = function( event ) {\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tif ( this.dragToLook ) {\\n\\n\\t\\t\\tthis.mouseStatus --;\\n\\n\\t\\t\\tthis.moveState.yawLeft = this.moveState.pitchDown = 0;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tswitch ( event.button ) {\\n\\n\\t\\t\\t\\tcase 0: this.moveState.forward = 0; break;\\n\\t\\t\\t\\tcase 2: this.moveState.back = 0; break;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.updateMovementVector();\\n\\n\\t\\t}\\n\\n\\t\\tthis.updateRotationVector();\\n\\n\\t};\\n\\n\\tthis.update = function( delta ) {\\n\\n\\t\\tvar moveMult = delta * this.movementSpeed;\\n\\t\\tvar rotMult = delta * this.rollSpeed;\\n\\n\\t\\tthis.object.translateX( this.moveVector.x * moveMult );\\n\\t\\tthis.object.translateY( this.moveVector.y * moveMult );\\n\\t\\tthis.object.translateZ( this.moveVector.z * moveMult );\\n\\n\\t\\tthis.tmpQuaternion.set( this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1 ).normalize();\\n\\t\\tthis.object.quaternion.multiply( this.tmpQuaternion );\\n\\n\\t\\t// expose the rotation vector for convenience\\n\\t\\tthis.object.rotation.setFromQuaternion( this.object.quaternion, this.object.rotation.order );\\n\\n\\n\\t};\\n\\n\\tthis.updateMovementVector = function() {\\n\\n\\t\\tvar forward = ( this.moveState.forward || ( this.autoForward && !this.moveState.back ) ) ? 1 : 0;\\n\\n\\t\\tthis.moveVector.x = ( -this.moveState.left    + this.moveState.right );\\n\\t\\tthis.moveVector.y = ( -this.moveState.down    + this.moveState.up );\\n\\t\\tthis.moveVector.z = ( -forward + this.moveState.back );\\n\\n\\t\\t//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );\\n\\n\\t};\\n\\n\\tthis.updateRotationVector = function() {\\n\\n\\t\\tthis.rotationVector.x = ( -this.moveState.pitchDown + this.moveState.pitchUp );\\n\\t\\tthis.rotationVector.y = ( -this.moveState.yawRight  + this.moveState.yawLeft );\\n\\t\\tthis.rotationVector.z = ( -this.moveState.rollRight + this.moveState.rollLeft );\\n\\n\\t\\t//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );\\n\\n\\t};\\n\\n\\tthis.getContainerDimensions = function() {\\n\\n\\t\\tif ( this.domElement != document ) {\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tsize\\t: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],\\n\\t\\t\\t\\toffset\\t: [ this.domElement.offsetLeft,  this.domElement.offsetTop ]\\n\\t\\t\\t};\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tsize\\t: [ window.innerWidth, window.innerHeight ],\\n\\t\\t\\t\\toffset\\t: [ 0, 0 ]\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tfunction bind( scope, fn ) {\\n\\n\\t\\treturn function () {\\n\\n\\t\\t\\tfn.apply( scope, arguments );\\n\\n\\t\\t};\\n\\n\\t};\\n\\n\\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\\n\\n\\tthis.domElement.addEventListener( 'mousemove', bind( this, this.mousemove ), false );\\n\\tthis.domElement.addEventListener( 'mousedown', bind( this, this.mousedown ), false );\\n\\tthis.domElement.addEventListener( 'mouseup',   bind( this, this.mouseup ), false );\\n\\n\\twindow.addEventListener( 'keydown', bind( this, this.keydown ), false );\\n\\twindow.addEventListener( 'keyup',   bind( this, this.keyup ), false );\\n\\n\\tthis.updateMovementVector();\\n\\tthis.updateRotationVector();\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/OculusControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/OculusControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author possan / http://possan.se/\\n *\\n * Oculus headtracking control\\n * - use together with the oculus-rest project to get headtracking\\n *   coordinates from the rift: http://github.com/possan/oculus-rest\\n */\\n\\nTHREE.OculusControls = function ( object ) {\\n\\n\\tthis.object = object;\\n\\tthis.target = new THREE.Vector3( 0, 0, 0 );\\n\\n\\tthis.headquat = new THREE.Quaternion();\\n\\tthis.freeze = false;\\n\\n\\tthis.loadAjaxJSON = function ( url, callback ) {\\n\\t\\tvar xhr = new XMLHttpRequest();\\n\\t\\txhr.onreadystatechange = function () {\\n\\t\\t\\tif ( xhr.readyState === xhr.DONE ) {\\n\\t\\t\\t\\tif ( xhr.status === 200 || xhr.status === 0 ) {\\n\\t\\t\\t\\t\\tif ( xhr.responseText ) {\\n\\t\\t\\t\\t\\t\\tvar json = JSON.parse( xhr.responseText );\\n\\t\\t\\t\\t\\t\\tcallback( json );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\txhr.open( \\\"GET\\\", url, true );\\n\\t\\txhr.withCredentials = false;\\n\\t\\txhr.send( null );\\n\\t};\\n\\n\\tthis.gotCoordinates = function( r ) {\\n\\t\\tthis.headquat.set(r.quat.x, r.quat.y, r.quat.z, r.quat.w);\\n\\t\\tthis.queuePoll();\\n\\t}\\n\\n\\tthis.pollOnce = function() {\\n\\t\\tthis.loadAjaxJSON('http://localhost:50000', bind(this, this.gotCoordinates));\\n\\t}\\n\\n\\tthis.queuePoll = function() {\\n\\t\\tsetTimeout(bind(this, this.pollOnce), 10);\\n\\t}\\n\\n\\tthis.update = function( delta ) {\\n\\t\\tif ( this.freeze ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.object.quaternion.multiply(this.headquat);\\n\\t};\\n\\n\\tfunction bind( scope, fn ) {\\n\\t\\treturn function () {\\n\\t\\t\\tfn.apply( scope, arguments );\\n\\t\\t};\\n\\t};\\n\\n\\tthis.connect = function() {\\n\\t\\tthis.queuePoll();\\n\\t};\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/OrbitControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/OrbitControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author qiao / https://github.com/qiao\\n * @author mrdoob / http://mrdoob.com\\n * @author alteredq / http://alteredqualia.com/\\n * @author WestLangley / http://github.com/WestLangley\\n * @author erich666 / http://erichaines.com\\n */\\n/*global THREE, console */\\n\\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\\n// the \\\"up\\\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\\n// supported.\\n//\\n//    Orbit - left mouse / touch: one finger move\\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\\n//\\n// This is a drop-in replacement for (most) TrackballControls used in examples.\\n// That is, include this js file and wherever you see:\\n//    \\tcontrols = new THREE.TrackballControls( camera );\\n//      controls.target.z = 150;\\n// Simple substitute \\\"OrbitControls\\\" and the control should work as-is.\\n\\nTHREE.OrbitControls = function ( object, domElement ) {\\n\\n\\tthis.object = object;\\n\\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\\n\\n\\t// API\\n\\n\\t// Set to false to disable this control\\n\\tthis.enabled = true;\\n\\n\\t// \\\"target\\\" sets the location of focus, where the control orbits around\\n\\t// and where it pans with respect to.\\n\\tthis.target = new THREE.Vector3();\\n\\n\\t// center is old, deprecated; use \\\"target\\\" instead\\n\\tthis.center = this.target;\\n\\n\\t// This option actually enables dollying in and out; left as \\\"zoom\\\" for\\n\\t// backwards compatibility\\n\\tthis.noZoom = false;\\n\\tthis.zoomSpeed = 1.0;\\n\\n\\t// Limits to how far you can dolly in and out\\n\\tthis.minDistance = 0;\\n\\tthis.maxDistance = Infinity;\\n\\n\\t// Set to true to disable this control\\n\\tthis.noRotate = false;\\n\\tthis.rotateSpeed = 1.0;\\n\\n\\t// Set to true to disable this control\\n\\tthis.noPan = false;\\n\\tthis.keyPanSpeed = 7.0;\\t// pixels moved per arrow key push\\n\\n\\t// Set to true to automatically rotate around the target\\n\\tthis.autoRotate = false;\\n\\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\\n\\n\\t// How far you can orbit vertically, upper and lower limits.\\n\\t// Range is 0 to Math.PI radians.\\n\\tthis.minPolarAngle = 0; // radians\\n\\tthis.maxPolarAngle = Math.PI; // radians\\n\\n\\t// Set to true to disable use of the keys\\n\\tthis.noKeys = false;\\n\\n\\t// The four arrow keys\\n\\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\\n\\n\\t////////////\\n\\t// internals\\n\\n\\tvar scope = this;\\n\\n\\tvar EPS = 0.000001;\\n\\n\\tvar rotateStart = new THREE.Vector2();\\n\\tvar rotateEnd = new THREE.Vector2();\\n\\tvar rotateDelta = new THREE.Vector2();\\n\\n\\tvar panStart = new THREE.Vector2();\\n\\tvar panEnd = new THREE.Vector2();\\n\\tvar panDelta = new THREE.Vector2();\\n\\tvar panOffset = new THREE.Vector3();\\n\\n\\tvar offset = new THREE.Vector3();\\n\\n\\tvar dollyStart = new THREE.Vector2();\\n\\tvar dollyEnd = new THREE.Vector2();\\n\\tvar dollyDelta = new THREE.Vector2();\\n\\n\\tvar phiDelta = 0;\\n\\tvar thetaDelta = 0;\\n\\tvar scale = 1;\\n\\tvar pan = new THREE.Vector3();\\n\\n\\tvar lastPosition = new THREE.Vector3();\\n\\tvar lastQuaternion = new THREE.Quaternion();\\n\\n\\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\\n\\n\\tvar state = STATE.NONE;\\n\\n\\t// for reset\\n\\n\\tthis.target0 = this.target.clone();\\n\\tthis.position0 = this.object.position.clone();\\n\\n\\t// so camera.up is the orbit axis\\n\\n\\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\\n\\tvar quatInverse = quat.clone().inverse();\\n\\n\\t// events\\n\\n\\tvar changeEvent = { type: 'change' };\\n\\tvar startEvent = { type: 'start'};\\n\\tvar endEvent = { type: 'end'};\\n\\n\\tthis.rotateLeft = function ( angle ) {\\n\\n\\t\\tif ( angle === undefined ) {\\n\\n\\t\\t\\tangle = getAutoRotationAngle();\\n\\n\\t\\t}\\n\\n\\t\\tthetaDelta -= angle;\\n\\n\\t};\\n\\n\\tthis.rotateUp = function ( angle ) {\\n\\n\\t\\tif ( angle === undefined ) {\\n\\n\\t\\t\\tangle = getAutoRotationAngle();\\n\\n\\t\\t}\\n\\n\\t\\tphiDelta -= angle;\\n\\n\\t};\\n\\n\\t// pass in distance in world space to move left\\n\\tthis.panLeft = function ( distance ) {\\n\\n\\t\\tvar te = this.object.matrix.elements;\\n\\n\\t\\t// get X column of matrix\\n\\t\\tpanOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\\n\\t\\tpanOffset.multiplyScalar( - distance );\\n\\t\\t\\n\\t\\tpan.add( panOffset );\\n\\n\\t};\\n\\n\\t// pass in distance in world space to move up\\n\\tthis.panUp = function ( distance ) {\\n\\n\\t\\tvar te = this.object.matrix.elements;\\n\\n\\t\\t// get Y column of matrix\\n\\t\\tpanOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\\n\\t\\tpanOffset.multiplyScalar( distance );\\n\\t\\t\\n\\t\\tpan.add( panOffset );\\n\\n\\t};\\n\\t\\n\\t// pass in x,y of change desired in pixel space,\\n\\t// right and down are positive\\n\\tthis.pan = function ( deltaX, deltaY ) {\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\tif ( scope.object.fov !== undefined ) {\\n\\n\\t\\t\\t// perspective\\n\\t\\t\\tvar position = scope.object.position;\\n\\t\\t\\tvar offset = position.clone().sub( scope.target );\\n\\t\\t\\tvar targetDistance = offset.length();\\n\\n\\t\\t\\t// half of the fov is center to top of screen\\n\\t\\t\\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\\n\\n\\t\\t\\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\\n\\t\\t\\tscope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\\n\\t\\t\\tscope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\\n\\n\\t\\t} else if ( scope.object.top !== undefined ) {\\n\\n\\t\\t\\t// orthographic\\n\\t\\t\\tscope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\\n\\t\\t\\tscope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// camera neither orthographic or perspective\\n\\t\\t\\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.dollyIn = function ( dollyScale ) {\\n\\n\\t\\tif ( dollyScale === undefined ) {\\n\\n\\t\\t\\tdollyScale = getZoomScale();\\n\\n\\t\\t}\\n\\n\\t\\tscale /= dollyScale;\\n\\n\\t};\\n\\n\\tthis.dollyOut = function ( dollyScale ) {\\n\\n\\t\\tif ( dollyScale === undefined ) {\\n\\n\\t\\t\\tdollyScale = getZoomScale();\\n\\n\\t\\t}\\n\\n\\t\\tscale *= dollyScale;\\n\\n\\t};\\n\\n\\tthis.update = function () {\\n\\n\\t\\tvar position = this.object.position;\\n\\n\\t\\toffset.copy( position ).sub( this.target );\\n\\n\\t\\t// rotate offset to \\\"y-axis-is-up\\\" space\\n\\t\\toffset.applyQuaternion( quat );\\n\\n\\t\\t// angle from z-axis around y-axis\\n\\n\\t\\tvar theta = Math.atan2( offset.x, offset.z );\\n\\n\\t\\t// angle from y-axis\\n\\n\\t\\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\\n\\n\\t\\tif ( this.autoRotate ) {\\n\\n\\t\\t\\tthis.rotateLeft( getAutoRotationAngle() );\\n\\n\\t\\t}\\n\\n\\t\\ttheta += thetaDelta;\\n\\t\\tphi += phiDelta;\\n\\n\\t\\t// restrict phi to be between desired limits\\n\\t\\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\\n\\n\\t\\t// restrict phi to be betwee EPS and PI-EPS\\n\\t\\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\\n\\n\\t\\tvar radius = offset.length() * scale;\\n\\n\\t\\t// restrict radius to be between desired limits\\n\\t\\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\\n\\t\\t\\n\\t\\t// move target to panned location\\n\\t\\tthis.target.add( pan );\\n\\n\\t\\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\\n\\t\\toffset.y = radius * Math.cos( phi );\\n\\t\\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\\n\\n\\t\\t// rotate offset back to \\\"camera-up-vector-is-up\\\" space\\n\\t\\toffset.applyQuaternion( quatInverse );\\n\\n\\t\\tposition.copy( this.target ).add( offset );\\n\\n\\t\\tthis.object.lookAt( this.target );\\n\\n\\t\\tthetaDelta = 0;\\n\\t\\tphiDelta = 0;\\n\\t\\tscale = 1;\\n\\t\\tpan.set( 0, 0, 0 );\\n\\n\\t\\t// update condition is:\\n\\t\\t// min(camera displacement, camera rotation in radians)^2 > EPS\\n\\t\\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\\n\\n\\t\\tif ( lastPosition.distanceToSquared( this.object.position ) > EPS\\n\\t\\t    || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS ) {\\n\\n\\t\\t\\tthis.dispatchEvent( changeEvent );\\n\\n\\t\\t\\tlastPosition.copy( this.object.position );\\n\\t\\t\\tlastQuaternion.copy (this.object.quaternion );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\n\\tthis.reset = function () {\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t\\tthis.target.copy( this.target0 );\\n\\t\\tthis.object.position.copy( this.position0 );\\n\\n\\t\\tthis.update();\\n\\n\\t};\\n\\n\\tfunction getAutoRotationAngle() {\\n\\n\\t\\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\\n\\n\\t}\\n\\n\\tfunction getZoomScale() {\\n\\n\\t\\treturn Math.pow( 0.95, scope.zoomSpeed );\\n\\n\\t}\\n\\n\\tfunction onMouseDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tif ( event.button === 0 ) {\\n\\t\\t\\tif ( scope.noRotate === true ) return;\\n\\n\\t\\t\\tstate = STATE.ROTATE;\\n\\n\\t\\t\\trotateStart.set( event.clientX, event.clientY );\\n\\n\\t\\t} else if ( event.button === 1 ) {\\n\\t\\t\\tif ( scope.noZoom === true ) return;\\n\\n\\t\\t\\tstate = STATE.DOLLY;\\n\\n\\t\\t\\tdollyStart.set( event.clientX, event.clientY );\\n\\n\\t\\t} else if ( event.button === 2 ) {\\n\\t\\t\\tif ( scope.noPan === true ) return;\\n\\n\\t\\t\\tstate = STATE.PAN;\\n\\n\\t\\t\\tpanStart.set( event.clientX, event.clientY );\\n\\n\\t\\t}\\n\\n\\t\\tdocument.addEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdocument.addEventListener( 'mouseup', onMouseUp, false );\\n\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t}\\n\\n\\tfunction onMouseMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\tif ( state === STATE.ROTATE ) {\\n\\n\\t\\t\\tif ( scope.noRotate === true ) return;\\n\\n\\t\\t\\trotateEnd.set( event.clientX, event.clientY );\\n\\t\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\t\\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\n\\t\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\t\\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\t} else if ( state === STATE.DOLLY ) {\\n\\n\\t\\t\\tif ( scope.noZoom === true ) return;\\n\\n\\t\\t\\tdollyEnd.set( event.clientX, event.clientY );\\n\\t\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\t\\tscope.dollyIn();\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tscope.dollyOut();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\t} else if ( state === STATE.PAN ) {\\n\\n\\t\\t\\tif ( scope.noPan === true ) return;\\n\\n\\t\\t\\tpanEnd.set( event.clientX, event.clientY );\\n\\t\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\t\\t\\t\\n\\t\\t\\tscope.pan( panDelta.x, panDelta.y );\\n\\n\\t\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\t}\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction onMouseUp( /* event */ ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onMouseWheel( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.noZoom === true ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tvar delta = 0;\\n\\n\\t\\tif ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\\n\\n\\t\\t\\tdelta = event.wheelDelta;\\n\\n\\t\\t} else if ( event.detail !== undefined ) { // Firefox\\n\\n\\t\\t\\tdelta = - event.detail;\\n\\n\\t\\t}\\n\\n\\t\\tif ( delta > 0 ) {\\n\\n\\t\\t\\tscope.dollyOut();\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tscope.dollyIn();\\n\\n\\t\\t}\\n\\n\\t\\tscope.update();\\n\\t\\tscope.dispatchEvent( startEvent );\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t}\\n\\n\\tfunction onKeyDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\\n\\t\\t\\n\\t\\tswitch ( event.keyCode ) {\\n\\n\\t\\t\\tcase scope.keys.UP:\\n\\t\\t\\t\\tscope.pan( 0, scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.BOTTOM:\\n\\t\\t\\t\\tscope.pan( 0, - scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.LEFT:\\n\\t\\t\\t\\tscope.pan( scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.RIGHT:\\n\\t\\t\\t\\tscope.pan( - scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction touchstart( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\t// one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.noRotate === true ) return;\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_ROTATE;\\n\\n\\t\\t\\t\\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\t// two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.noZoom === true ) return;\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_DOLLY;\\n\\n\\t\\t\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\t\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\t\\t\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\t\\t\\t\\tdollyStart.set( 0, distance );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.noPan === true ) return;\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_PAN;\\n\\n\\t\\t\\t\\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t}\\n\\n\\tfunction touchmove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1: // one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.noRotate === true ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_ROTATE ) return;\\n\\n\\t\\t\\t\\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\t\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\t\\t\\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\t\\t\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\t\\t\\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\t\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2: // two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.noZoom === true ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_DOLLY ) return;\\n\\n\\t\\t\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\t\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\t\\t\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\t\\t\\tdollyEnd.set( 0, distance );\\n\\t\\t\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\t\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\t\\t\\tscope.dollyOut();\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tscope.dollyIn();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.noPan === true ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_PAN ) return;\\n\\n\\t\\t\\t\\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tscope.pan( panDelta.x, panDelta.y );\\n\\n\\t\\t\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction touchend( /* event */ ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\\n\\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\\n\\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\\n\\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\\n\\n\\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\\n\\tthis.domElement.addEventListener( 'touchend', touchend, false );\\n\\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\\n\\n\\twindow.addEventListener( 'keydown', onKeyDown, false );\\n\\n\\t// force an update at start\\n\\tthis.update();\\n\\n};\\n\\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/OrbitZControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/OrbitZControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author qiao / https://github.com/qiao\\n * @author mrdoob / http://mrdoob.com\\n * @author alteredq / http://alteredqualia.com/\\n * @author WestLangley / http://github.com/WestLangley\\n * @author erich666 / http://erichaines.com\\n *\\n * cook for adaptation to Z up (initially Y up).\\n */\\n/*global THREE, console */\\n\\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\\n// the \\\"up\\\" direction as +Z. Touch on tablet and phones is supported (but not tested, sorry).\\n//\\n//    Orbit - left mouse / touch: one finger move\\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\\n\\nTHREE.OrbitZControls = function ( object, domElement ) {\\n  var func = \\\"THREE.OrbitZControls\\\";\\n  flagLog = false;\\n  logPoint = function(p) {return \\\"\\\"+p.x+\\\", \\\"+p.y+\\\", \\\"+p.z;};\\n\\n\\tthis.object = object;\\n\\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\\n\\n  if (flagLog) console.log(func+\\\": object.position = \\\"+logPoint(this.object.position));\\n  if (flagLog) console.log(func+\\\": object.up = \\\"+logPoint(this.object.up));\\n\\n\\t// API\\n\\n\\t// Set to false to disable this control\\n\\tthis.enabled = true;\\n\\n\\t// \\\"target\\\" sets the location of focus, where the control orbits around\\n\\t// and where it pans with respect to.\\n\\tthis.target = new THREE.Vector3();\\n\\n\\t// center is old, deprecated; use \\\"target\\\" instead\\n\\tthis.center = this.target;\\n\\n\\t// This option actually enables dollying in and out; left as \\\"zoom\\\" for\\n\\t// backwards compatibility\\n\\tthis.noZoom = false;\\n\\tthis.zoomSpeed = 1.0;\\n\\n\\t// Limits to how far you can dolly in and out\\n\\tthis.minDistance = 0;\\n\\tthis.maxDistance = Infinity;\\n\\n\\t// Set to true to disable this control\\n\\tthis.noRotate = false;\\n\\tthis.rotateSpeed = 1.0;\\n\\n\\t// Set to true to disable this control\\n\\tthis.noPan = false;\\n\\tthis.keyPanSpeed = 7.0;\\t// pixels moved per arrow key push\\n\\n\\t// Set to true to automatically rotate around the target\\n\\tthis.autoRotate = false;\\n\\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\\n\\n\\t// How far you can orbit vertically, upper and lower limits.\\n\\t// Range is 0 to Math.PI radians.\\n\\tthis.minPolarAngle = 0; // radians\\n\\tthis.maxPolarAngle = Math.PI; // radians\\n\\n\\t// Set to true to disable use of the keys\\n\\tthis.noKeys = false;\\n\\n\\t// The four arrow keys\\n\\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\\n\\n\\t////////////\\n\\t// internals\\n\\n\\tvar scope = this;\\n\\n\\tvar EPS = 0.000001;\\n\\n\\tvar rotateStart = new THREE.Vector2();\\n\\tvar rotateEnd = new THREE.Vector2();\\n\\tvar rotateDelta = new THREE.Vector2();\\n\\n\\tvar panStart = new THREE.Vector2();\\n\\tvar panEnd = new THREE.Vector2();\\n\\tvar panDelta = new THREE.Vector2();\\n\\tvar panOffset = new THREE.Vector3();\\n\\n\\tvar offset = new THREE.Vector3();\\n\\n\\tvar dollyStart = new THREE.Vector2();\\n\\tvar dollyEnd = new THREE.Vector2();\\n\\tvar dollyDelta = new THREE.Vector2();\\n\\n\\tvar phiDelta = 0;\\n\\tvar thetaDelta = 0;\\n\\tvar scale = 1;\\n\\tvar pan = new THREE.Vector3();\\n\\n\\tvar lastPosition = new THREE.Vector3();\\n\\tvar lastQuaternion = new THREE.Quaternion();\\n\\n\\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\\n\\n\\tvar state = STATE.NONE;\\n\\n\\t// for reset\\n\\n\\tthis.target0 = this.target.clone();\\n\\tthis.position0 = this.object.position.clone();\\n\\n\\t// so camera.up is the orbit axis\\n\\n\\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 0, 1 ) );\\n\\tvar quatInverse = quat.clone().inverse();\\n\\n\\t// events\\n\\n\\tvar changeEvent = { type: 'change' };\\n\\tvar startEvent = { type: 'start'};\\n\\tvar endEvent = { type: 'end'};\\n\\n\\tthis.rotateLeft = function ( angle ) {\\n\\n\\t\\tif ( angle === undefined ) {\\n\\n\\t\\t\\tangle = getAutoRotationAngle();\\n\\n\\t\\t}\\n\\n\\t\\tthetaDelta -= angle;\\n\\n\\t};\\n\\n\\tthis.rotateUp = function ( angle ) {\\n\\n\\t\\tif ( angle === undefined ) {\\n\\n\\t\\t\\tangle = getAutoRotationAngle();\\n\\n\\t\\t}\\n\\n\\t\\tphiDelta -= angle;\\n\\n\\t};\\n\\n\\t// pass in distance in world space to move left\\n\\tthis.panLeft = function ( distance ) {\\n\\n\\t\\tvar te = this.object.matrix.elements;\\n\\n\\t\\t// get X column of matrix\\n\\t\\tpanOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\\n\\t\\tpanOffset.multiplyScalar( - distance );\\n\\t\\t\\n\\t\\tpan.add( panOffset );\\n\\n\\t};\\n\\n\\t// pass in distance in world space to move up\\n\\tthis.panUp = function ( distance ) {\\n\\n\\t\\tvar te = this.object.matrix.elements;\\n\\n\\t\\t// get Z column of matrix\\n\\t\\tpanOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\\n\\t\\tpanOffset.multiplyScalar( distance );\\n\\t\\t\\n\\t\\tpan.add( panOffset );\\n\\n\\t};\\n\\t\\n\\t// pass in x,y of change desired in pixel space,\\n\\t// right and down are positive\\n\\tthis.pan = function ( deltaX, deltaY ) {\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\tif ( scope.object.fov !== undefined ) {\\n\\n\\t\\t\\t// perspective\\n\\t\\t\\tvar position = scope.object.position;\\n\\t\\t\\tvar offset = position.clone().sub( scope.target );\\n\\t\\t\\tvar targetDistance = offset.length();\\n\\n\\t\\t\\t// half of the fov is center to top of screen\\n\\t\\t\\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\\n\\n\\t\\t\\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\\n\\t\\t\\tscope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\\n\\t\\t\\tscope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\\n\\n\\t\\t} else if ( scope.object.top !== undefined ) {\\n\\n\\t\\t\\t// orthographic\\n\\t\\t\\tscope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\\n\\t\\t\\tscope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// camera neither orthographic or perspective\\n\\t\\t\\tconsole.warn( 'WARNING: OrbitZControls.js encountered an unknown camera type - pan disabled.' );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.dollyIn = function ( dollyScale ) {\\n\\n\\t\\tif ( dollyScale === undefined ) {\\n\\n\\t\\t\\tdollyScale = getZoomScale();\\n\\n\\t\\t}\\n\\n\\t\\tscale /= dollyScale;\\n\\n\\t};\\n\\n\\tthis.dollyOut = function ( dollyScale ) {\\n\\n\\t\\tif ( dollyScale === undefined ) {\\n\\n\\t\\t\\tdollyScale = getZoomScale();\\n\\n\\t\\t}\\n\\n\\t\\tscale *= dollyScale;\\n\\n\\t};\\n\\n\\tthis.update = function () {\\n          var func = \\\"THREE.OrbitZControls.update\\\";\\n\\n          if (flagLog) console.log(func+\\\": ====================\\\");\\n          if (flagLog) console.log(func+\\\": this.target = \\\"+logPoint(this.target));\\n\\n\\t\\tvar position = this.object.position;\\n\\n\\t\\toffset.copy( position ).sub( this.target );\\n\\n\\t\\t// rotate offset to \\\"z-axis-is-up\\\" space\\n\\t\\toffset.applyQuaternion( quat );\\n\\n          if (flagLog) console.log(func+\\\": offset = \\\"+logPoint(offset));\\n\\n\\t\\t// angle from x-axis around z-axis\\n\\n\\t\\tvar theta = Math.atan2( offset.y, offset.x );\\n\\n\\t\\t// angle from z-axis\\n\\n\\t\\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.y * offset.y ), offset.z );\\n\\n          if (flagLog) console.log(func+\\\": theta = \\\"+(theta * 180 / Math.PI)+\\\" degrs, phi = \\\"+(phi * 180 / Math.PI)+\\\" degrs\\\");\\n\\n\\t\\tif ( this.autoRotate ) {\\n\\n\\t\\t\\tthis.rotateLeft( getAutoRotationAngle() );\\n\\n\\t\\t}\\n\\n\\t\\ttheta += thetaDelta;\\n\\t\\tphi += phiDelta;\\n\\n\\t\\t// restrict phi to be between desired limits\\n\\t\\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\\n\\n\\t\\t// restrict phi to be betwee EPS and PI-EPS\\n\\t\\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\\n\\n\\t\\tvar radius = offset.length() * scale;\\n\\n\\t\\t// restrict radius to be between desired limits\\n\\t\\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\\n\\t\\t\\n\\t\\t// move target to panned location\\n\\t\\tthis.target.add( pan );\\n\\n\\t\\toffset.x = radius * Math.sin( phi ) * Math.cos( theta );\\n\\t\\toffset.z = radius * Math.cos( phi );\\n\\t\\toffset.y = radius * Math.sin( phi ) * Math.sin( theta );\\n\\n\\t\\t// rotate offset back to \\\"camera-up-vector-is-up\\\" space\\n\\t\\toffset.applyQuaternion( quatInverse );\\n\\n\\t\\tposition.copy( this.target ).add( offset );\\n\\n\\t\\tthis.object.lookAt( this.target );\\n\\n\\t\\tthetaDelta = 0;\\n\\t\\tphiDelta = 0;\\n\\t\\tscale = 1;\\n\\t\\tpan.set( 0, 0, 0 );\\n\\n\\t\\t// update condition is:\\n\\t\\t// min(camera displacement, camera rotation in radians)^2 > EPS\\n\\t\\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\\n\\n\\t\\tif ( lastPosition.distanceToSquared( this.object.position ) > EPS\\n\\t\\t    || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS ) {\\n\\n\\t\\t\\tthis.dispatchEvent( changeEvent );\\n\\n\\t\\t\\tlastPosition.copy( this.object.position );\\n\\t\\t\\tlastQuaternion.copy (this.object.quaternion );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\n\\tthis.reset = function () {\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t\\tthis.target.copy( this.target0 );\\n\\t\\tthis.object.position.copy( this.position0 );\\n\\n\\t\\tthis.update();\\n\\n\\t};\\n\\n\\tfunction getAutoRotationAngle() {\\n\\n\\t\\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\\n\\n\\t}\\n\\n\\tfunction getZoomScale() {\\n\\n\\t\\treturn Math.pow( 0.95, scope.zoomSpeed );\\n\\n\\t}\\n\\n\\tfunction onMouseDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tif ( event.button === 0 ) {\\n\\t\\t\\tif ( scope.noRotate === true ) return;\\n\\n\\t\\t\\tstate = STATE.ROTATE;\\n\\n\\t\\t\\trotateStart.set( event.clientX, event.clientY );\\n\\n\\t\\t} else if ( event.button === 1 ) {\\n\\t\\t\\tif ( scope.noZoom === true ) return;\\n\\n\\t\\t\\tstate = STATE.DOLLY;\\n\\n\\t\\t\\tdollyStart.set( event.clientX, event.clientY );\\n\\n\\t\\t} else if ( event.button === 2 ) {\\n\\t\\t\\tif ( scope.noPan === true ) return;\\n\\n\\t\\t\\tstate = STATE.PAN;\\n\\n\\t\\t\\tpanStart.set( event.clientX, event.clientY );\\n\\n\\t\\t}\\n\\n\\t\\tdocument.addEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdocument.addEventListener( 'mouseup', onMouseUp, false );\\n\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t}\\n\\n\\tfunction onMouseMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\tif ( state === STATE.ROTATE ) {\\n\\n\\t\\t\\tif ( scope.noRotate === true ) return;\\n\\n\\t\\t\\trotateEnd.set( event.clientX, event.clientY );\\n\\t\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\t\\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\n\\t\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\t\\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\t} else if ( state === STATE.DOLLY ) {\\n\\n\\t\\t\\tif ( scope.noZoom === true ) return;\\n\\n\\t\\t\\tdollyEnd.set( event.clientX, event.clientY );\\n\\t\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\t\\tscope.dollyIn();\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tscope.dollyOut();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\t} else if ( state === STATE.PAN ) {\\n\\n\\t\\t\\tif ( scope.noPan === true ) return;\\n\\n\\t\\t\\tpanEnd.set( event.clientX, event.clientY );\\n\\t\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\t\\t\\t\\n\\t\\t\\tscope.pan( panDelta.x, panDelta.y );\\n\\n\\t\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\t}\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction onMouseUp( /* event */ ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onMouseWheel( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.noZoom === true ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tvar delta = 0;\\n\\n\\t\\tif ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\\n\\n\\t\\t\\tdelta = event.wheelDelta;\\n\\n\\t\\t} else if ( event.detail !== undefined ) { // Firefox\\n\\n\\t\\t\\tdelta = - event.detail;\\n\\n\\t\\t}\\n\\n\\t\\tif ( delta > 0 ) {\\n\\n\\t\\t\\tscope.dollyOut();\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tscope.dollyIn();\\n\\n\\t\\t}\\n\\n\\t\\tscope.update();\\n\\t\\tscope.dispatchEvent( startEvent );\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t}\\n\\n\\tfunction onKeyDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\\n\\t\\t\\n\\t\\tswitch ( event.keyCode ) {\\n\\n\\t\\t\\tcase scope.keys.UP:\\n\\t\\t\\t\\tscope.pan( 0, scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.BOTTOM:\\n\\t\\t\\t\\tscope.pan( 0, - scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.LEFT:\\n\\t\\t\\t\\tscope.pan( scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.RIGHT:\\n\\t\\t\\t\\tscope.pan( - scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction touchstart( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\t// one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.noRotate === true ) return;\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_ROTATE;\\n\\n\\t\\t\\t\\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\t// two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.noZoom === true ) return;\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_DOLLY;\\n\\n\\t\\t\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\t\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\t\\t\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\t\\t\\t\\tdollyStart.set( 0, distance );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.noPan === true ) return;\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_PAN;\\n\\n\\t\\t\\t\\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t}\\n\\n\\tfunction touchmove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1: // one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.noRotate === true ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_ROTATE ) return;\\n\\n\\t\\t\\t\\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\t\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\t\\t\\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\t\\t\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\t\\t\\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\t\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2: // two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.noZoom === true ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_DOLLY ) return;\\n\\n\\t\\t\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\t\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\t\\t\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\t\\t\\tdollyEnd.set( 0, distance );\\n\\t\\t\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\t\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\t\\t\\tscope.dollyOut();\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tscope.dollyIn();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.noPan === true ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_PAN ) return;\\n\\n\\t\\t\\t\\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tscope.pan( panDelta.x, panDelta.y );\\n\\n\\t\\t\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction touchend( /* event */ ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\\n\\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\\n\\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\\n\\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\\n\\n\\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\\n\\tthis.domElement.addEventListener( 'touchend', touchend, false );\\n\\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\\n\\n\\twindow.addEventListener( 'keydown', onKeyDown, false );\\n\\n\\t// force an update at start\\n\\tthis.update();\\n\\n};\\n\\nTHREE.OrbitZControls.prototype = Object.create( THREE.EventDispatcher.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/OrthographicTrackballControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/OrthographicTrackballControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author Eberhard Graether / http://egraether.com/\\n * @author Patrick Fuller / http://patrick-fuller.com\\n */\\n\\nTHREE.OrthographicTrackballControls = function ( object, domElement ) {\\n\\n\\tvar _this = this;\\n\\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM: 4, TOUCH_PAN: 5 };\\n\\n\\tthis.object = object;\\n\\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\\n\\n\\t// API\\n\\n\\tthis.enabled = true;\\n\\n\\tthis.screen = { width: 0, height: 0, offsetLeft: 0, offsetTop: 0 };\\n\\tthis.radius = ( this.screen.width + this.screen.height ) / 4;\\n\\n\\tthis.rotateSpeed = 1.0;\\n\\tthis.zoomSpeed = 1.2;\\n\\tthis.panSpeed = 0.3;\\n\\n\\tthis.noRotate = false;\\n\\tthis.noZoom = false;\\n\\tthis.noPan = false;\\n\\n\\tthis.staticMoving = false;\\n\\tthis.dynamicDampingFactor = 0.2;\\n\\n\\tthis.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];\\n\\n\\t// internals\\n\\n\\tthis.target = new THREE.Vector3();\\n\\n\\tvar lastPosition = new THREE.Vector3();\\n\\n\\tvar _state = STATE.NONE,\\n\\t_prevState = STATE.NONE,\\n\\n\\t_eye = new THREE.Vector3(),\\n\\n\\t_rotateStart = new THREE.Vector3(),\\n\\t_rotateEnd = new THREE.Vector3(),\\n\\n\\t_zoomStart = new THREE.Vector2(),\\n\\t_zoomEnd = new THREE.Vector2(),\\n\\t_zoomFactor = 1,\\n\\n\\t_touchZoomDistanceStart = 0,\\n\\t_touchZoomDistanceEnd = 0,\\n\\n\\t_panStart = new THREE.Vector2(),\\n\\t_panEnd = new THREE.Vector2();\\n\\n\\t// for reset\\n\\n\\tthis.target0 = this.target.clone();\\n\\tthis.position0 = this.object.position.clone();\\n\\tthis.up0 = this.object.up.clone();\\n\\n\\tthis.left0 = this.object.left;\\n\\tthis.right0 = this.object.right;\\n\\tthis.top0 = this.object.top;\\n\\tthis.bottom0 = this.object.bottom;\\n\\tthis.center0 = new THREE.Vector2((this.left0 + this.right0) / 2.0, (this.top0 + this.bottom0) / 2.0);\\n\\n\\t// events\\n\\n\\tvar changeEvent = { type: 'change' };\\n\\n\\n\\t// methods\\n\\n\\tthis.handleResize = function () {\\n\\n\\t\\tthis.screen.width = window.innerWidth;\\n\\t\\tthis.screen.height = window.innerHeight;\\n\\n\\t\\tthis.screen.offsetLeft = 0;\\n\\t\\tthis.screen.offsetTop = 0;\\n\\n\\t\\tthis.radius = ( this.screen.width + this.screen.height ) / 4;\\n\\n\\t};\\n\\n\\tthis.handleEvent = function ( event ) {\\n\\n\\t\\tif ( typeof this[ event.type ] == 'function' ) {\\n\\n\\t\\t\\tthis[ event.type ]( event );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.getMouseOnScreen = function ( clientX, clientY ) {\\n\\n\\t\\treturn new THREE.Vector2(\\n\\t\\t\\t( clientX - _this.screen.offsetLeft ) / _this.radius * 0.5,\\n\\t\\t\\t( clientY - _this.screen.offsetTop ) / _this.radius * 0.5\\n\\t\\t);\\n\\n\\t};\\n\\n\\tthis.getMouseProjectionOnBall = function ( clientX, clientY ) {\\n\\n\\t\\tvar mouseOnBall = new THREE.Vector3(\\n\\t\\t\\t( clientX - _this.screen.width * 0.5 - _this.screen.offsetLeft ) / _this.radius,\\n\\t\\t\\t( _this.screen.height * 0.5 + _this.screen.offsetTop - clientY ) / _this.radius,\\n\\t\\t\\t0.0\\n\\t\\t);\\n\\n\\t\\tvar length = mouseOnBall.length();\\n\\n\\t\\tif ( length > 1.0 ) {\\n\\n\\t\\t\\tmouseOnBall.normalize();\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tmouseOnBall.z = Math.sqrt( 1.0 - length * length );\\n\\n\\t\\t}\\n\\n\\t\\t_eye.copy( _this.object.position ).sub( _this.target );\\n\\n\\t\\tvar projection = _this.object.up.clone().setLength( mouseOnBall.y );\\n\\t\\tprojection.add( _this.object.up.clone().cross( _eye ).setLength( mouseOnBall.x ) );\\n\\t\\tprojection.add( _eye.setLength( mouseOnBall.z ) );\\n\\n\\t\\treturn projection;\\n\\n\\t};\\n\\n\\tthis.rotateCamera = function () {\\n\\n\\t\\tvar angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );\\n\\n\\t\\tif ( angle ) {\\n\\n\\t\\t\\tvar axis = ( new THREE.Vector3() ).crossVectors( _rotateStart, _rotateEnd ).normalize(),\\n\\t\\t\\t\\tquaternion = new THREE.Quaternion();\\n\\n\\t\\t\\tangle *= _this.rotateSpeed;\\n\\n\\t\\t\\tquaternion.setFromAxisAngle( axis, -angle );\\n\\n\\t\\t\\t_eye.applyQuaternion( quaternion );\\n\\t\\t\\t_this.object.up.applyQuaternion( quaternion );\\n\\n\\t\\t\\t_rotateEnd.applyQuaternion( quaternion );\\n\\n\\t\\t\\tif ( _this.staticMoving ) {\\n\\n\\t\\t\\t\\t_rotateStart.copy( _rotateEnd );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tquaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );\\n\\t\\t\\t\\t_rotateStart.applyQuaternion( quaternion );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.zoomCamera = function () {\\n\\n\\t\\tif ( _state === STATE.TOUCH_ZOOM ) {\\n\\n\\t\\t\\tvar factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;\\n\\t\\t\\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\\n\\t\\t\\t_zoomFactor *= factor;\\n\\n\\t\\t\\t_this.object.left = _zoomFactor * _this.left0 + ( 1 - _zoomFactor ) *  _this.center0.x;\\n\\t\\t\\t_this.object.right = _zoomFactor * _this.right0 + ( 1 - _zoomFactor ) *  _this.center0.x;\\n\\t\\t\\t_this.object.top = _zoomFactor * _this.top0 + ( 1 - _zoomFactor ) *  _this.center0.y;\\n\\t\\t\\t_this.object.bottom = _zoomFactor * _this.bottom0 + ( 1 - _zoomFactor ) *  _this.center0.y;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tvar factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;\\n\\n\\t\\t\\tif ( factor !== 1.0 && factor > 0.0 ) {\\n\\t\\t\\t\\t_zoomFactor *= factor;\\n\\n\\t\\t\\t\\t_this.object.left = _zoomFactor * _this.left0 + ( 1 - _zoomFactor ) *  _this.center0.x;\\n\\t\\t\\t\\t_this.object.right = _zoomFactor * _this.right0 + ( 1 - _zoomFactor ) *  _this.center0.x;\\n\\t\\t\\t\\t_this.object.top = _zoomFactor * _this.top0 + ( 1 - _zoomFactor ) *  _this.center0.y;\\n\\t\\t\\t\\t_this.object.bottom = _zoomFactor * _this.bottom0 + ( 1 - _zoomFactor ) *  _this.center0.y;\\n\\n\\t\\t\\t\\tif ( _this.staticMoving ) {\\n\\n\\t\\t\\t\\t\\t_zoomStart.copy( _zoomEnd );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.panCamera = function () {\\n\\n\\t\\tvar mouseChange = _panEnd.clone().sub( _panStart );\\n\\n\\t\\tif ( mouseChange.lengthSq() ) {\\n\\n\\t\\t\\tmouseChange.multiplyScalar( _eye.length() * _this.panSpeed );\\n\\n\\t\\t\\tvar pan = _eye.clone().cross( _this.object.up ).setLength( mouseChange.x );\\n\\t\\t\\tpan.add( _this.object.up.clone().setLength( mouseChange.y ) );\\n\\n\\t\\t\\t_this.object.position.add( pan );\\n\\t\\t\\t_this.target.add( pan );\\n\\n\\t\\t\\tif ( _this.staticMoving ) {\\n\\n\\t\\t\\t\\t_panStart = _panEnd;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.update = function () {\\n\\n\\t\\t_eye.subVectors( _this.object.position, _this.target );\\n\\n\\t\\tif ( !_this.noRotate ) {\\n\\n\\t\\t\\t_this.rotateCamera();\\n\\n\\t\\t}\\n\\n\\t\\tif ( !_this.noZoom ) {\\n\\n\\t\\t\\t_this.zoomCamera();\\n\\t\\t\\t_this.object.updateProjectionMatrix();\\n\\n\\t\\t}\\n\\n\\t\\tif ( !_this.noPan ) {\\n\\n\\t\\t\\t_this.panCamera();\\n\\n\\t\\t}\\n\\n\\t\\t_this.object.position.addVectors( _this.target, _eye );\\n\\n\\t\\t_this.object.lookAt( _this.target );\\n\\n\\t\\tif ( lastPosition.distanceToSquared( _this.object.position ) > 0 ) {\\n\\n\\t\\t\\t_this.dispatchEvent( changeEvent );\\n\\n\\t\\t\\tlastPosition.copy( _this.object.position );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.reset = function () {\\n\\n\\t\\t_state = STATE.NONE;\\n\\t\\t_prevState = STATE.NONE;\\n\\n\\t\\t_this.target.copy( _this.target0 );\\n\\t\\t_this.object.position.copy( _this.position0 );\\n\\t\\t_this.object.up.copy( _this.up0 );\\n\\n\\t\\t_eye.subVectors( _this.object.position, _this.target );\\n\\n\\t\\t_this.object.left = _this.left0;\\n\\t\\t_this.object.right = _this.right0;\\n\\t\\t_this.object.top = _this.top0;\\n\\t\\t_this.object.bottom = _this.bottom0;\\n\\n\\t\\t_this.object.lookAt( _this.target );\\n\\n\\t\\t_this.dispatchEvent( changeEvent );\\n\\n\\t\\tlastPosition.copy( _this.object.position );\\n\\n\\t};\\n\\n\\t// listeners\\n\\n\\tfunction keydown( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\twindow.removeEventListener( 'keydown', keydown );\\n\\n\\t\\t_prevState = _state;\\n\\n\\t\\tif ( _state !== STATE.NONE ) {\\n\\n\\t\\t\\treturn;\\n\\n\\t\\t} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {\\n\\n\\t\\t\\t_state = STATE.ROTATE;\\n\\n\\t\\t} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom ) {\\n\\n\\t\\t\\t_state = STATE.ZOOM;\\n\\n\\t\\t} else if ( event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan ) {\\n\\n\\t\\t\\t_state = STATE.PAN;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction keyup( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\t_state = _prevState;\\n\\n\\t\\twindow.addEventListener( 'keydown', keydown, false );\\n\\n\\t}\\n\\n\\tfunction mousedown( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tif ( _state === STATE.NONE ) {\\n\\n\\t\\t\\t_state = event.button;\\n\\n\\t\\t}\\n\\n\\t\\tif ( _state === STATE.ROTATE && !_this.noRotate ) {\\n\\n\\t\\t\\t_rotateStart = _rotateEnd = _this.getMouseProjectionOnBall( event.clientX, event.clientY );\\n\\n\\t\\t} else if ( _state === STATE.ZOOM && !_this.noZoom ) {\\n\\n\\t\\t\\t_zoomStart = _zoomEnd = _this.getMouseOnScreen( event.clientX, event.clientY );\\n\\n\\t\\t} else if ( _state === STATE.PAN && !_this.noPan ) {\\n\\n\\t\\t\\t_panStart = _panEnd = _this.getMouseOnScreen( event.clientX, event.clientY );\\n\\n\\t\\t}\\n\\n\\t\\tdocument.addEventListener( 'mousemove', mousemove, false );\\n\\t\\tdocument.addEventListener( 'mouseup', mouseup, false );\\n\\n\\t}\\n\\n\\tfunction mousemove( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tif ( _state === STATE.ROTATE && !_this.noRotate ) {\\n\\n\\t\\t\\t_rotateEnd = _this.getMouseProjectionOnBall( event.clientX, event.clientY );\\n\\n\\t\\t} else if ( _state === STATE.ZOOM && !_this.noZoom ) {\\n\\n\\t\\t\\t_zoomEnd = _this.getMouseOnScreen( event.clientX, event.clientY );\\n\\n\\t\\t} else if ( _state === STATE.PAN && !_this.noPan ) {\\n\\n\\t\\t\\t_panEnd = _this.getMouseOnScreen( event.clientX, event.clientY );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction mouseup( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\t_state = STATE.NONE;\\n\\n\\t\\tdocument.removeEventListener( 'mousemove', mousemove );\\n\\t\\tdocument.removeEventListener( 'mouseup', mouseup );\\n\\n\\t}\\n\\n\\tfunction mousewheel( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tvar delta = 0;\\n\\n\\t\\tif ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\\n\\n\\t\\t\\tdelta = event.wheelDelta / 40;\\n\\n\\t\\t} else if ( event.detail ) { // Firefox\\n\\n\\t\\t\\tdelta = - event.detail / 3;\\n\\n\\t\\t}\\n\\n\\t\\t_zoomStart.y += delta * 0.01;\\n\\n\\t}\\n\\n\\tfunction touchstart( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\t_state = STATE.TOUCH_ROTATE;\\n\\t\\t\\t\\t_rotateStart = _rotateEnd = _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\t_state = STATE.TOUCH_ZOOM;\\n\\t\\t\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\t\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\t\\t\\t\\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3:\\n\\t\\t\\t\\t_state = STATE.TOUCH_PAN;\\n\\t\\t\\t\\t_panStart = _panEnd = _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\t_state = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction touchmove( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\t_rotateEnd = _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\t\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\t\\t\\t\\t_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy )\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3:\\n\\t\\t\\t\\t_panEnd = _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\t_state = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction touchend( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\t_rotateStart = _rotateEnd = _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\t_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3:\\n\\t\\t\\t\\t_panStart = _panEnd = _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t\\t_state = STATE.NONE;\\n\\n\\t}\\n\\n\\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\\n\\n\\tthis.domElement.addEventListener( 'mousedown', mousedown, false );\\n\\n\\tthis.domElement.addEventListener( 'mousewheel', mousewheel, false );\\n\\tthis.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox\\n\\n\\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\\n\\tthis.domElement.addEventListener( 'touchend', touchend, false );\\n\\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\\n\\n\\twindow.addEventListener( 'keydown', keydown, false );\\n\\twindow.addEventListener( 'keyup', keyup, false );\\n\\n\\tthis.handleResize();\\n\\n};\\n\\nTHREE.OrthographicTrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/PointerLockControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/PointerLockControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author mrdoob / http://mrdoob.com/\\n */\\n\\nTHREE.PointerLockControls = function ( camera ) {\\n\\n\\tvar scope = this;\\n\\n\\tcamera.rotation.set( 0, 0, 0 );\\n\\n\\tvar pitchObject = new THREE.Object3D();\\n\\tpitchObject.add( camera );\\n\\n\\tvar yawObject = new THREE.Object3D();\\n\\tyawObject.position.y = 10;\\n\\tyawObject.add( pitchObject );\\n\\n\\tvar moveForward = false;\\n\\tvar moveBackward = false;\\n\\tvar moveLeft = false;\\n\\tvar moveRight = false;\\n\\n\\tvar isOnObject = false;\\n\\tvar canJump = false;\\n\\n\\tvar prevTime = performance.now();\\n\\n\\tvar velocity = new THREE.Vector3();\\n\\n\\tvar PI_2 = Math.PI / 2;\\n\\n\\tvar onMouseMove = function ( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tvar movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;\\n\\t\\tvar movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;\\n\\n\\t\\tyawObject.rotation.y -= movementX * 0.002;\\n\\t\\tpitchObject.rotation.x -= movementY * 0.002;\\n\\n\\t\\tpitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, pitchObject.rotation.x ) );\\n\\n\\t};\\n\\n\\tvar onKeyDown = function ( event ) {\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\n\\t\\t\\tcase 38: // up\\n\\t\\t\\tcase 87: // w\\n\\t\\t\\t\\tmoveForward = true;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 37: // left\\n\\t\\t\\tcase 65: // a\\n\\t\\t\\t\\tmoveLeft = true; break;\\n\\n\\t\\t\\tcase 40: // down\\n\\t\\t\\tcase 83: // s\\n\\t\\t\\t\\tmoveBackward = true;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 39: // right\\n\\t\\t\\tcase 68: // d\\n\\t\\t\\t\\tmoveRight = true;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 32: // space\\n\\t\\t\\t\\tif ( canJump === true ) velocity.y += 350;\\n\\t\\t\\t\\tcanJump = false;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar onKeyUp = function ( event ) {\\n\\n\\t\\tswitch( event.keyCode ) {\\n\\n\\t\\t\\tcase 38: // up\\n\\t\\t\\tcase 87: // w\\n\\t\\t\\t\\tmoveForward = false;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 37: // left\\n\\t\\t\\tcase 65: // a\\n\\t\\t\\t\\tmoveLeft = false;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 40: // down\\n\\t\\t\\tcase 83: // s\\n\\t\\t\\t\\tmoveBackward = false;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 39: // right\\n\\t\\t\\tcase 68: // d\\n\\t\\t\\t\\tmoveRight = false;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tdocument.addEventListener( 'mousemove', onMouseMove, false );\\n\\tdocument.addEventListener( 'keydown', onKeyDown, false );\\n\\tdocument.addEventListener( 'keyup', onKeyUp, false );\\n\\n\\tthis.enabled = false;\\n\\n\\tthis.getObject = function () {\\n\\n\\t\\treturn yawObject;\\n\\n\\t};\\n\\n\\tthis.isOnObject = function ( boolean ) {\\n\\n\\t\\tisOnObject = boolean;\\n\\t\\tcanJump = boolean;\\n\\n\\t};\\n\\n\\tthis.getDirection = function() {\\n\\n\\t\\t// assumes the camera itself is not rotated\\n\\n\\t\\tvar direction = new THREE.Vector3( 0, 0, -1 );\\n\\t\\tvar rotation = new THREE.Euler( 0, 0, 0, \\\"YXZ\\\" );\\n\\n\\t\\treturn function( v ) {\\n\\n\\t\\t\\trotation.set( pitchObject.rotation.x, yawObject.rotation.y, 0 );\\n\\n\\t\\t\\tv.copy( direction ).applyEuler( rotation );\\n\\n\\t\\t\\treturn v;\\n\\n\\t\\t}\\n\\n\\t}();\\n\\n\\tthis.update = function () {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tvar time = performance.now();\\n\\t\\tvar delta = ( time - prevTime ) / 1000;\\n\\n\\t\\tvelocity.x -= velocity.x * 10.0 * delta;\\n\\t\\tvelocity.z -= velocity.z * 10.0 * delta;\\n\\n\\t\\tvelocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass\\n\\n\\t\\tif ( moveForward ) velocity.z -= 400.0 * delta;\\n\\t\\tif ( moveBackward ) velocity.z += 400.0 * delta;\\n\\n\\t\\tif ( moveLeft ) velocity.x -= 400.0 * delta;\\n\\t\\tif ( moveRight ) velocity.x += 400.0 * delta;\\n\\n\\t\\tif ( isOnObject === true ) {\\n\\n\\t\\t\\tvelocity.y = Math.max( 0, velocity.y );\\n\\n\\t\\t}\\n\\n\\t\\tyawObject.translateX( velocity.x * delta );\\n\\t\\tyawObject.translateY( velocity.y * delta ); \\n\\t\\tyawObject.translateZ( velocity.z * delta );\\n\\n\\t\\tif ( yawObject.position.y < 10 ) {\\n\\n\\t\\t\\tvelocity.y = 0;\\n\\t\\t\\tyawObject.position.y = 10;\\n\\n\\t\\t\\tcanJump = true;\\n\\n\\t\\t}\\n\\n\\t\\tprevTime = time;\\n\\n\\t};\\n\\n};\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/TrackballControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/TrackballControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author Eberhard Graether / http://egraether.com/\\n * @author Mark Lundin \\t/ http://mark-lundin.com\\n */\\n\\nTHREE.TrackballControls = function ( object, domElement ) {\\n\\n\\tvar _this = this;\\n\\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\\n\\n\\tthis.object = object;\\n\\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\\n\\n\\t// API\\n\\n\\tthis.enabled = true;\\n\\n\\tthis.screen = { left: 0, top: 0, width: 0, height: 0 };\\n\\n\\tthis.rotateSpeed = 1.0;\\n\\tthis.zoomSpeed = 1.2;\\n\\tthis.panSpeed = 0.3;\\n\\n\\tthis.noRotate = false;\\n\\tthis.noZoom = false;\\n\\tthis.noPan = false;\\n\\tthis.noRoll = false;\\n\\n\\tthis.staticMoving = false;\\n\\tthis.dynamicDampingFactor = 0.2;\\n\\n\\tthis.minDistance = 0;\\n\\tthis.maxDistance = Infinity;\\n\\n\\tthis.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];\\n\\n\\t// internals\\n\\n\\tthis.target = new THREE.Vector3();\\n\\n\\tvar EPS = 0.000001;\\n\\n\\tvar lastPosition = new THREE.Vector3();\\n\\n\\tvar _state = STATE.NONE,\\n\\t_prevState = STATE.NONE,\\n\\n\\t_eye = new THREE.Vector3(),\\n\\n\\t_rotateStart = new THREE.Vector3(),\\n\\t_rotateEnd = new THREE.Vector3(),\\n\\n\\t_zoomStart = new THREE.Vector2(),\\n\\t_zoomEnd = new THREE.Vector2(),\\n\\n\\t_touchZoomDistanceStart = 0,\\n\\t_touchZoomDistanceEnd = 0,\\n\\n\\t_panStart = new THREE.Vector2(),\\n\\t_panEnd = new THREE.Vector2();\\n\\n\\t// for reset\\n\\n\\tthis.target0 = this.target.clone();\\n\\tthis.position0 = this.object.position.clone();\\n\\tthis.up0 = this.object.up.clone();\\n\\n\\t// events\\n\\n\\tvar changeEvent = { type: 'change' };\\n\\tvar startEvent = { type: 'start'};\\n\\tvar endEvent = { type: 'end'};\\n\\n\\n\\t// methods\\n\\n\\tthis.handleResize = function () {\\n\\n\\t\\tif ( this.domElement === document ) {\\n\\n\\t\\t\\tthis.screen.left = 0;\\n\\t\\t\\tthis.screen.top = 0;\\n\\t\\t\\tthis.screen.width = window.innerWidth;\\n\\t\\t\\tthis.screen.height = window.innerHeight;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tvar box = this.domElement.getBoundingClientRect();\\n\\t\\t\\t// adjustments come from similar code in the jquery offset() function\\n\\t\\t\\tvar d = this.domElement.ownerDocument.documentElement;\\n\\t\\t\\tthis.screen.left = box.left + window.pageXOffset - d.clientLeft;\\n\\t\\t\\tthis.screen.top = box.top + window.pageYOffset - d.clientTop;\\n\\t\\t\\tthis.screen.width = box.width;\\n\\t\\t\\tthis.screen.height = box.height;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.handleEvent = function ( event ) {\\n\\n\\t\\tif ( typeof this[ event.type ] == 'function' ) {\\n\\n\\t\\t\\tthis[ event.type ]( event );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar getMouseOnScreen = ( function () {\\n\\n\\t\\tvar vector = new THREE.Vector2();\\n\\n\\t\\treturn function ( pageX, pageY ) {\\n\\n\\t\\t\\tvector.set(\\n\\t\\t\\t\\t( pageX - _this.screen.left ) / _this.screen.width,\\n\\t\\t\\t\\t( pageY - _this.screen.top ) / _this.screen.height\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn vector;\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\tvar getMouseProjectionOnBall = ( function () {\\n\\n\\t\\tvar vector = new THREE.Vector3();\\n\\t\\tvar objectUp = new THREE.Vector3();\\n\\t\\tvar mouseOnBall = new THREE.Vector3();\\n\\n\\t\\treturn function ( pageX, pageY ) {\\n\\n\\t\\t\\tmouseOnBall.set(\\n\\t\\t\\t\\t( pageX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*.5),\\n\\t\\t\\t\\t( _this.screen.height * 0.5 + _this.screen.top - pageY ) / (_this.screen.height*.5),\\n\\t\\t\\t\\t0.0\\n\\t\\t\\t);\\n\\n\\t\\t\\tvar length = mouseOnBall.length();\\n\\n\\t\\t\\tif ( _this.noRoll ) {\\n\\n\\t\\t\\t\\tif ( length < Math.SQRT1_2 ) {\\n\\n\\t\\t\\t\\t\\tmouseOnBall.z = Math.sqrt( 1.0 - length*length );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tmouseOnBall.z = .5 / length;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( length > 1.0 ) {\\n\\n\\t\\t\\t\\tmouseOnBall.normalize();\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmouseOnBall.z = Math.sqrt( 1.0 - length * length );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_eye.copy( _this.object.position ).sub( _this.target );\\n\\n\\t\\t\\tvector.copy( _this.object.up ).setLength( mouseOnBall.y )\\n\\t\\t\\tvector.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );\\n\\t\\t\\tvector.add( _eye.setLength( mouseOnBall.z ) );\\n\\n\\t\\t\\treturn vector;\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\tthis.rotateCamera = (function(){\\n\\n\\t\\tvar axis = new THREE.Vector3(),\\n\\t\\t\\tquaternion = new THREE.Quaternion();\\n\\n\\n\\t\\treturn function () {\\n\\n\\t\\t\\tvar angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );\\n\\n\\t\\t\\tif ( angle ) {\\n\\n\\t\\t\\t\\taxis.crossVectors( _rotateStart, _rotateEnd ).normalize();\\n\\n\\t\\t\\t\\tangle *= _this.rotateSpeed;\\n\\n\\t\\t\\t\\tquaternion.setFromAxisAngle( axis, -angle );\\n\\n\\t\\t\\t\\t_eye.applyQuaternion( quaternion );\\n\\t\\t\\t\\t_this.object.up.applyQuaternion( quaternion );\\n\\n\\t\\t\\t\\t_rotateEnd.applyQuaternion( quaternion );\\n\\n\\t\\t\\t\\tif ( _this.staticMoving ) {\\n\\n\\t\\t\\t\\t\\t_rotateStart.copy( _rotateEnd );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tquaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );\\n\\t\\t\\t\\t\\t_rotateStart.applyQuaternion( quaternion );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}());\\n\\n\\tthis.zoomCamera = function () {\\n\\n\\t\\tif ( _state === STATE.TOUCH_ZOOM_PAN ) {\\n\\n\\t\\t\\tvar factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;\\n\\t\\t\\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\\n\\t\\t\\t_eye.multiplyScalar( factor );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tvar factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;\\n\\n\\t\\t\\tif ( factor !== 1.0 && factor > 0.0 ) {\\n\\n\\t\\t\\t\\t_eye.multiplyScalar( factor );\\n\\n\\t\\t\\t\\tif ( _this.staticMoving ) {\\n\\n\\t\\t\\t\\t\\t_zoomStart.copy( _zoomEnd );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.panCamera = (function(){\\n\\n\\t\\tvar mouseChange = new THREE.Vector2(),\\n\\t\\t\\tobjectUp = new THREE.Vector3(),\\n\\t\\t\\tpan = new THREE.Vector3();\\n\\n\\t\\treturn function () {\\n\\n\\t\\t\\tmouseChange.copy( _panEnd ).sub( _panStart );\\n\\n\\t\\t\\tif ( mouseChange.lengthSq() ) {\\n\\n\\t\\t\\t\\tmouseChange.multiplyScalar( _eye.length() * _this.panSpeed );\\n\\n\\t\\t\\t\\tpan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );\\n\\t\\t\\t\\tpan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );\\n\\n\\t\\t\\t\\t_this.object.position.add( pan );\\n\\t\\t\\t\\t_this.target.add( pan );\\n\\n\\t\\t\\t\\tif ( _this.staticMoving ) {\\n\\n\\t\\t\\t\\t\\t_panStart.copy( _panEnd );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}());\\n\\n\\tthis.checkDistances = function () {\\n\\n\\t\\tif ( !_this.noZoom || !_this.noPan ) {\\n\\n\\t\\t\\tif ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {\\n\\n\\t\\t\\t\\t_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {\\n\\n\\t\\t\\t\\t_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.update = function () {\\n\\n\\t\\t_eye.subVectors( _this.object.position, _this.target );\\n\\n\\t\\tif ( !_this.noRotate ) {\\n\\n\\t\\t\\t_this.rotateCamera();\\n\\n\\t\\t}\\n\\n\\t\\tif ( !_this.noZoom ) {\\n\\n\\t\\t\\t_this.zoomCamera();\\n\\n\\t\\t}\\n\\n\\t\\tif ( !_this.noPan ) {\\n\\n\\t\\t\\t_this.panCamera();\\n\\n\\t\\t}\\n\\n\\t\\t_this.object.position.addVectors( _this.target, _eye );\\n\\n\\t\\t_this.checkDistances();\\n\\n\\t\\t_this.object.lookAt( _this.target );\\n\\n\\t\\tif ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {\\n\\n\\t\\t\\t_this.dispatchEvent( changeEvent );\\n\\n\\t\\t\\tlastPosition.copy( _this.object.position );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tthis.reset = function () {\\n\\n\\t\\t_state = STATE.NONE;\\n\\t\\t_prevState = STATE.NONE;\\n\\n\\t\\t_this.target.copy( _this.target0 );\\n\\t\\t_this.object.position.copy( _this.position0 );\\n\\t\\t_this.object.up.copy( _this.up0 );\\n\\n\\t\\t_eye.subVectors( _this.object.position, _this.target );\\n\\n\\t\\t_this.object.lookAt( _this.target );\\n\\n\\t\\t_this.dispatchEvent( changeEvent );\\n\\n\\t\\tlastPosition.copy( _this.object.position );\\n\\n\\t};\\n\\n\\t// listeners\\n\\n\\tfunction keydown( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\twindow.removeEventListener( 'keydown', keydown );\\n\\n\\t\\t_prevState = _state;\\n\\n\\t\\tif ( _state !== STATE.NONE ) {\\n\\n\\t\\t\\treturn;\\n\\n\\t\\t} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {\\n\\n\\t\\t\\t_state = STATE.ROTATE;\\n\\n\\t\\t} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom ) {\\n\\n\\t\\t\\t_state = STATE.ZOOM;\\n\\n\\t\\t} else if ( event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan ) {\\n\\n\\t\\t\\t_state = STATE.PAN;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction keyup( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\t_state = _prevState;\\n\\n\\t\\twindow.addEventListener( 'keydown', keydown, false );\\n\\n\\t}\\n\\n\\tfunction mousedown( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tif ( _state === STATE.NONE ) {\\n\\n\\t\\t\\t_state = event.button;\\n\\n\\t\\t}\\n\\n\\t\\tif ( _state === STATE.ROTATE && !_this.noRotate ) {\\n\\n\\t\\t\\t_rotateStart.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );\\n\\t\\t\\t_rotateEnd.copy( _rotateStart );\\n\\n\\t\\t} else if ( _state === STATE.ZOOM && !_this.noZoom ) {\\n\\n\\t\\t\\t_zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );\\n\\t\\t\\t_zoomEnd.copy(_zoomStart);\\n\\n\\t\\t} else if ( _state === STATE.PAN && !_this.noPan ) {\\n\\n\\t\\t\\t_panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );\\n\\t\\t\\t_panEnd.copy(_panStart)\\n\\n\\t\\t}\\n\\n\\t\\tdocument.addEventListener( 'mousemove', mousemove, false );\\n\\t\\tdocument.addEventListener( 'mouseup', mouseup, false );\\n\\n\\t\\t_this.dispatchEvent( startEvent );\\n\\n\\t}\\n\\n\\tfunction mousemove( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tif ( _state === STATE.ROTATE && !_this.noRotate ) {\\n\\n\\t\\t\\t_rotateEnd.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );\\n\\n\\t\\t} else if ( _state === STATE.ZOOM && !_this.noZoom ) {\\n\\n\\t\\t\\t_zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );\\n\\n\\t\\t} else if ( _state === STATE.PAN && !_this.noPan ) {\\n\\n\\t\\t\\t_panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction mouseup( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\t_state = STATE.NONE;\\n\\n\\t\\tdocument.removeEventListener( 'mousemove', mousemove );\\n\\t\\tdocument.removeEventListener( 'mouseup', mouseup );\\n\\t\\t_this.dispatchEvent( endEvent );\\n\\n\\t}\\n\\n\\tfunction mousewheel( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tvar delta = 0;\\n\\n\\t\\tif ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\\n\\n\\t\\t\\tdelta = event.wheelDelta / 40;\\n\\n\\t\\t} else if ( event.detail ) { // Firefox\\n\\n\\t\\t\\tdelta = - event.detail / 3;\\n\\n\\t\\t}\\n\\n\\t\\t_zoomStart.y += delta * 0.01;\\n\\t\\t_this.dispatchEvent( startEvent );\\n\\t\\t_this.dispatchEvent( endEvent );\\n\\n\\t}\\n\\n\\tfunction touchstart( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\t_state = STATE.TOUCH_ROTATE;\\n\\t\\t\\t\\t_rotateStart.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\\n\\t\\t\\t\\t_rotateEnd.copy( _rotateStart );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\t_state = STATE.TOUCH_ZOOM_PAN;\\n\\t\\t\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\t\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\t\\t\\t\\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\t\\t\\tvar x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;\\n\\t\\t\\t\\tvar y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;\\n\\t\\t\\t\\t_panStart.copy( getMouseOnScreen( x, y ) );\\n\\t\\t\\t\\t_panEnd.copy( _panStart );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\t_state = STATE.NONE;\\n\\n\\t\\t}\\n\\t\\t_this.dispatchEvent( startEvent );\\n\\n\\n\\t}\\n\\n\\tfunction touchmove( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\t_rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\t\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\t\\t\\t\\t_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\t\\t\\tvar x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;\\n\\t\\t\\t\\tvar y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;\\n\\t\\t\\t\\t_panEnd.copy( getMouseOnScreen( x, y ) );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\t_state = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction touchend( event ) {\\n\\n\\t\\tif ( _this.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\t_rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\\n\\t\\t\\t\\t_rotateStart.copy( _rotateEnd );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\t_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;\\n\\n\\t\\t\\t\\tvar x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;\\n\\t\\t\\t\\tvar y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;\\n\\t\\t\\t\\t_panEnd.copy( getMouseOnScreen( x, y ) );\\n\\t\\t\\t\\t_panStart.copy( _panEnd );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t\\t_state = STATE.NONE;\\n\\t\\t_this.dispatchEvent( endEvent );\\n\\n\\t}\\n\\n\\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\\n\\n\\tthis.domElement.addEventListener( 'mousedown', mousedown, false );\\n\\n\\tthis.domElement.addEventListener( 'mousewheel', mousewheel, false );\\n\\tthis.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox\\n\\n\\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\\n\\tthis.domElement.addEventListener( 'touchend', touchend, false );\\n\\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\\n\\n\\twindow.addEventListener( 'keydown', keydown, false );\\n\\twindow.addEventListener( 'keyup', keyup, false );\\n\\n\\tthis.handleResize();\\n\\n\\t// force an update at start\\n\\tthis.update();\\n\\n};\\n\\nTHREE.TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/TransformControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/TransformControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author arodic / https://github.com/arodic\\n */\\n /*jshint sub:true*/\\n\\n(function () {\\n\\n\\t'use strict';\\n\\n\\tvar GizmoMaterial = function ( parameters ) {\\n\\n\\t\\tTHREE.MeshBasicMaterial.call( this );\\n\\n\\t\\tthis.depthTest = false;\\n\\t\\tthis.depthWrite = false;\\n\\t\\tthis.side = THREE.FrontSide;\\n\\t\\tthis.transparent = true;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t\\tthis.oldColor = this.color.clone();\\n\\t\\tthis.oldOpacity = this.opacity;\\n\\n\\t\\tthis.highlight = function( highlighted ) {\\n\\n\\t\\t\\tif ( highlighted ) {\\n\\n\\t\\t\\t\\tthis.color.setRGB( 1, 1, 0 );\\n\\t\\t\\t\\tthis.opacity = 1;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis.color.copy( this.oldColor );\\n\\t\\t\\t\\t\\tthis.opacity = this.oldOpacity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t};\\n\\n\\tGizmoMaterial.prototype = Object.create( THREE.MeshBasicMaterial.prototype );\\n\\n\\tvar GizmoLineMaterial = function ( parameters ) {\\n\\n\\t\\tTHREE.LineBasicMaterial.call( this );\\n\\n\\t\\tthis.depthTest = false;\\n\\t\\tthis.depthWrite = false;\\n\\t\\tthis.transparent = true;\\n\\t\\tthis.linewidth = 1;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t\\tthis.oldColor = this.color.clone();\\n\\t\\tthis.oldOpacity = this.opacity;\\n\\n\\t\\tthis.highlight = function( highlighted ) {\\n\\n\\t\\t\\tif ( highlighted ) {\\n\\n\\t\\t\\t\\tthis.color.setRGB( 1, 1, 0 );\\n\\t\\t\\t\\tthis.opacity = 1;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis.color.copy( this.oldColor );\\n\\t\\t\\t\\t\\tthis.opacity = this.oldOpacity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t};\\n\\n\\tGizmoLineMaterial.prototype = Object.create( THREE.LineBasicMaterial.prototype );\\n\\n\\tTHREE.TransformGizmo = function () {\\n\\n\\t\\tvar scope = this;\\n\\t\\tvar showPickers = false; //debug\\n\\t\\tvar showActivePlane = false; //debug\\n\\n\\t\\tthis.init = function () {\\n\\n\\t\\t\\tTHREE.Object3D.call( this );\\n\\n\\t\\t\\tthis.handles = new THREE.Object3D();\\n\\t\\t\\tthis.pickers = new THREE.Object3D();\\n\\t\\t\\tthis.planes = new THREE.Object3D();\\n\\n\\t\\t\\tthis.add(this.handles);\\n\\t\\t\\tthis.add(this.pickers);\\n\\t\\t\\tthis.add(this.planes);\\n\\n\\t\\t\\t//// PLANES\\n\\n\\t\\t\\tvar planeGeometry = new THREE.PlaneGeometry( 50, 50, 2, 2 );\\n\\t\\t\\tvar planeMaterial = new THREE.MeshBasicMaterial( { wireframe: true } );\\n\\t\\t\\tplaneMaterial.side = THREE.DoubleSide;\\n\\n\\t\\t\\tvar planes = {\\n\\t\\t\\t\\t\\\"XY\\\":   new THREE.Mesh( planeGeometry, planeMaterial ),\\n\\t\\t\\t\\t\\\"YZ\\\":   new THREE.Mesh( planeGeometry, planeMaterial ),\\n\\t\\t\\t\\t\\\"XZ\\\":   new THREE.Mesh( planeGeometry, planeMaterial ),\\n\\t\\t\\t\\t\\\"XYZE\\\": new THREE.Mesh( planeGeometry, planeMaterial )\\n\\t\\t\\t};\\n\\n\\t\\t\\tthis.activePlane = planes[\\\"XYZE\\\"];\\n\\n\\t\\t\\tplanes[\\\"YZ\\\"].rotation.set( 0, Math.PI/2, 0 );\\n\\t\\t\\tplanes[\\\"XZ\\\"].rotation.set( -Math.PI/2, 0, 0 );\\n\\n\\t\\t\\tfor (var i in planes) {\\n\\t\\t\\t\\tplanes[i].name = i;\\n\\t\\t\\t\\tthis.planes.add(planes[i]);\\n\\t\\t\\t\\tthis.planes[i] = planes[i];\\n\\t\\t\\t\\tplanes[i].visible = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//// HANDLES AND PICKERS\\n\\n\\t\\t\\tvar setupGizmos = function( gizmoMap, parent ) {\\n\\n\\t\\t\\t\\tfor ( var name in gizmoMap ) {\\n\\n\\t\\t\\t\\t\\tfor ( i = gizmoMap[name].length; i--;) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tvar object = gizmoMap[name][i][0];\\n\\t\\t\\t\\t\\t\\tvar position = gizmoMap[name][i][1];\\n\\t\\t\\t\\t\\t\\tvar rotation = gizmoMap[name][i][2];\\n\\n\\t\\t\\t\\t\\t\\tobject.name = name;\\n\\n\\t\\t\\t\\t\\t\\tif ( position ) object.position.set( position[0], position[1], position[2] );\\n\\t\\t\\t\\t\\t\\tif ( rotation ) object.rotation.set( rotation[0], rotation[1], rotation[2] );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tparent.add( object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tsetupGizmos(this.handleGizmos, this.handles);\\n\\t\\t\\tsetupGizmos(this.pickerGizmos, this.pickers);\\n\\n\\t\\t\\t// reset Transformations\\n\\n\\t\\t\\tthis.traverse(function ( child ) {\\n\\t\\t\\t\\tif (child instanceof THREE.Mesh) {\\n\\t\\t\\t\\t\\tchild.updateMatrix();\\n\\n\\t\\t\\t\\t\\tvar tempGeometry = new THREE.Geometry();\\n\\t\\t\\t\\t\\ttempGeometry.merge( child.geometry, child.matrix );\\n\\n\\t\\t\\t\\t\\tchild.geometry = tempGeometry;\\n\\t\\t\\t\\t\\tchild.position.set( 0, 0, 0 );\\n\\t\\t\\t\\t\\tchild.rotation.set( 0, 0, 0 );\\n\\t\\t\\t\\t\\tchild.scale.set( 1, 1, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t};\\n\\n\\t\\tthis.hide = function () {\\n\\t\\t\\tthis.traverse(function( child ) {\\n\\t\\t\\t\\tchild.visible = false;\\n\\t\\t\\t});\\n\\t\\t};\\n\\n\\t\\tthis.show = function () {\\n\\t\\t\\tthis.traverse(function( child ) {\\n\\t\\t\\t\\tchild.visible = true;\\n\\t\\t\\t\\tif (child.parent == scope.pickers ) child.visible = showPickers;\\n\\t\\t\\t\\tif (child.parent == scope.planes ) child.visible = false;\\n\\t\\t\\t});\\n\\t\\t\\tthis.activePlane.visible = showActivePlane;\\n\\t\\t};\\n\\n\\t\\tthis.highlight = function ( axis ) {\\n\\t\\t\\tthis.traverse(function( child ) {\\n\\t\\t\\t\\tif ( child.material && child.material.highlight ){\\n\\t\\t\\t\\t\\tif ( child.name == axis ) {\\n\\t\\t\\t\\t\\t\\tchild.material.highlight( true );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tchild.material.highlight( false );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t};\\n\\n\\t};\\n\\n\\tTHREE.TransformGizmo.prototype = Object.create( THREE.Object3D.prototype );\\n\\n\\tTHREE.TransformGizmo.prototype.update = function ( rotation, eye ) {\\n\\n\\t\\tvar vec1 = new THREE.Vector3( 0, 0, 0 );\\n\\t\\tvar vec2 = new THREE.Vector3( 0, 1, 0 );\\n\\t\\tvar lookAtMatrix = new THREE.Matrix4();\\n\\n\\t\\tthis.traverse(function(child) {\\n\\t\\t\\tif ( child.name.search(\\\"E\\\") != -1 ) {\\n\\t\\t\\t\\tchild.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( eye, vec1, vec2 ) );\\n\\t\\t\\t} else if ( child.name.search(\\\"X\\\") != -1 || child.name.search(\\\"Y\\\") != -1 || child.name.search(\\\"Z\\\") != -1 ) {\\n\\t\\t\\t\\tchild.quaternion.setFromEuler( rotation );\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t};\\n\\n\\tTHREE.TransformGizmoTranslate = function () {\\n\\n\\t\\tTHREE.TransformGizmo.call( this );\\n\\n\\t\\tvar arrowGeometry = new THREE.Geometry();\\n\\t\\tvar mesh = new THREE.Mesh( new THREE.CylinderGeometry( 0, 0.05, 0.2, 12, 1, false ) );\\n\\t\\tmesh.position.y = 0.5;\\n\\t\\tmesh.updateMatrix();\\n\\n\\t\\tarrowGeometry.merge( mesh.geometry, mesh.matrix );\\n\\t\\t\\n\\t\\tvar lineXGeometry = new THREE.Geometry();\\n\\t\\tlineXGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 1, 0, 0 ) );\\n\\n\\t\\tvar lineYGeometry = new THREE.Geometry();\\n\\t\\tlineYGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\\n\\n\\t\\tvar lineZGeometry = new THREE.Geometry();\\n\\t\\tlineZGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 1 ) );\\n\\n\\t\\tthis.handleGizmos = {\\n\\t\\t\\tX: [\\n\\t\\t\\t\\t[ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0xff0000 } ) ), [ 0.5, 0, 0 ], [ 0, 0, -Math.PI/2 ] ],\\n\\t\\t\\t\\t[ new THREE.Line( lineXGeometry, new GizmoLineMaterial( { color: 0xff0000 } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tY: [\\n\\t\\t\\t\\t[ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x00ff00 } ) ), [ 0, 0.5, 0 ] ],\\n\\t\\t\\t\\t[\\tnew THREE.Line( lineYGeometry, new GizmoLineMaterial( { color: 0x00ff00 } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x0000ff } ) ), [ 0, 0, 0.5 ], [ Math.PI/2, 0, 0 ] ],\\n\\t\\t\\t\\t[ new THREE.Line( lineZGeometry, new GizmoLineMaterial( { color: 0x0000ff } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tXYZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.OctahedronGeometry( 0.1, 0 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ 0, 0, 0 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tXY: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.PlaneGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0xffff00, opacity: 0.25 } ) ), [ 0.15, 0.15, 0 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tYZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.PlaneGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0x00ffff, opacity: 0.25 } ) ), [ 0, 0.15, 0.15 ], [ 0, Math.PI/2, 0 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tXZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.PlaneGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0xff00ff, opacity: 0.25 } ) ), [ 0.15, 0, 0.15 ], [ -Math.PI/2, 0, 0 ] ]\\n\\t\\t\\t]\\n\\t\\t};\\n\\n\\t\\tthis.pickerGizmos = {\\n\\t\\t\\tX: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0.6, 0, 0 ], [ 0, 0, -Math.PI/2 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tY: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x00ff00, opacity: 0.25 } ) ), [ 0, 0.6, 0 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0.6 ], [ Math.PI/2, 0, 0 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tXYZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.OctahedronGeometry( 0.2, 0 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tXY: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.PlaneGeometry( 0.4, 0.4 ), new GizmoMaterial( { color: 0xffff00, opacity: 0.25 } ) ), [ 0.2, 0.2, 0 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tYZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.PlaneGeometry( 0.4, 0.4 ), new GizmoMaterial( { color: 0x00ffff, opacity: 0.25 } ) ), [ 0, 0.2, 0.2 ], [ 0, Math.PI/2, 0 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tXZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.PlaneGeometry( 0.4, 0.4 ), new GizmoMaterial( { color: 0xff00ff, opacity: 0.25 } ) ), [ 0.2, 0, 0.2 ], [ -Math.PI/2, 0, 0 ] ]\\n\\t\\t\\t]\\n\\t\\t};\\n\\n\\t\\tthis.setActivePlane = function ( axis, eye ) {\\n\\n\\t\\t\\tvar tempMatrix = new THREE.Matrix4();\\n\\t\\t\\teye.applyMatrix4( tempMatrix.getInverse( tempMatrix.extractRotation( this.planes[ \\\"XY\\\" ].matrixWorld ) ) );\\n\\n\\t\\t\\tif ( axis == \\\"X\\\" ) {\\n\\t\\t\\t\\tthis.activePlane = this.planes[ \\\"XY\\\" ];\\n\\t\\t\\t\\tif ( Math.abs(eye.y) > Math.abs(eye.z) ) this.activePlane = this.planes[ \\\"XZ\\\" ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( axis == \\\"Y\\\" ){\\n\\t\\t\\t\\tthis.activePlane = this.planes[ \\\"XY\\\" ];\\n\\t\\t\\t\\tif ( Math.abs(eye.x) > Math.abs(eye.z) ) this.activePlane = this.planes[ \\\"YZ\\\" ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( axis == \\\"Z\\\" ){\\n\\t\\t\\t\\tthis.activePlane = this.planes[ \\\"XZ\\\" ];\\n\\t\\t\\t\\tif ( Math.abs(eye.x) > Math.abs(eye.y) ) this.activePlane = this.planes[ \\\"YZ\\\" ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( axis == \\\"XYZ\\\" ) this.activePlane = this.planes[ \\\"XYZE\\\" ];\\n\\n\\t\\t\\tif ( axis == \\\"XY\\\" ) this.activePlane = this.planes[ \\\"XY\\\" ];\\n\\n\\t\\t\\tif ( axis == \\\"YZ\\\" ) this.activePlane = this.planes[ \\\"YZ\\\" ];\\n\\n\\t\\t\\tif ( axis == \\\"XZ\\\" ) this.activePlane = this.planes[ \\\"XZ\\\" ];\\n\\n\\t\\t\\tthis.hide();\\n\\t\\t\\tthis.show();\\n\\n\\t\\t};\\n\\n\\t\\tthis.init();\\n\\n\\t};\\n\\n\\tTHREE.TransformGizmoTranslate.prototype = Object.create( THREE.TransformGizmo.prototype );\\n\\n\\tTHREE.TransformGizmoRotate = function () {\\n\\n\\t\\tTHREE.TransformGizmo.call( this );\\n\\n\\t\\tvar CircleGeometry = function ( radius, facing, arc ) {\\n\\n\\t\\t\\t\\tvar geometry = new THREE.Geometry();\\n\\t\\t\\t\\tarc = arc ? arc : 1;\\n\\t\\t\\t\\tfor ( var i = 0; i <= 64 * arc; ++i ) {\\n\\t\\t\\t\\t\\tif ( facing == 'x' ) geometry.vertices.push( new THREE.Vector3( 0, Math.cos( i / 32 * Math.PI ), Math.sin( i / 32 * Math.PI ) ).multiplyScalar(radius) );\\n\\t\\t\\t\\t\\tif ( facing == 'y' ) geometry.vertices.push( new THREE.Vector3( Math.cos( i / 32 * Math.PI ), 0, Math.sin( i / 32 * Math.PI ) ).multiplyScalar(radius) );\\n\\t\\t\\t\\t\\tif ( facing == 'z' ) geometry.vertices.push( new THREE.Vector3( Math.sin( i / 32 * Math.PI ), Math.cos( i / 32 * Math.PI ), 0 ).multiplyScalar(radius) );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn geometry;\\n\\t\\t};\\n\\n\\t\\tthis.handleGizmos = {\\n\\t\\t\\tX: [\\n\\t\\t\\t\\t[ new THREE.Line( new CircleGeometry(1,'x',0.5), new GizmoLineMaterial( { color: 0xff0000 } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tY: [\\n\\t\\t\\t\\t[ new THREE.Line( new CircleGeometry(1,'y',0.5), new GizmoLineMaterial( { color: 0x00ff00 } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tZ: [\\n\\t\\t\\t\\t[ new THREE.Line( new CircleGeometry(1,'z',0.5), new GizmoLineMaterial( { color: 0x0000ff } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tE: [\\n\\t\\t\\t\\t[ new THREE.Line( new CircleGeometry(1.25,'z',1), new GizmoLineMaterial( { color: 0xcccc00 } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tXYZE: [\\n\\t\\t\\t\\t[ new THREE.Line( new CircleGeometry(1,'z',1), new GizmoLineMaterial( { color: 0x787878 } ) ) ]\\n\\t\\t\\t]\\n\\t\\t};\\n\\n\\t\\tthis.pickerGizmos = {\\n\\t\\t\\tX: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, Math.PI ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ 0, -Math.PI/2, -Math.PI/2 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tY: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, Math.PI ), new GizmoMaterial( { color: 0x00ff00, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ Math.PI/2, 0, 0 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, Math.PI ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ 0, 0, -Math.PI/2 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tE: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.TorusGeometry( 1.25, 0.12, 2, 24 ), new GizmoMaterial( { color: 0xffff00, opacity: 0.25 } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tXYZE: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.Geometry() ) ]// TODO\\n\\t\\t\\t]\\n\\t\\t};\\n\\n\\t\\tthis.setActivePlane = function ( axis ) {\\n\\n\\t\\t\\tif ( axis == \\\"E\\\" ) this.activePlane = this.planes[ \\\"XYZE\\\" ];\\n\\n\\t\\t\\tif ( axis == \\\"X\\\" ) this.activePlane = this.planes[ \\\"YZ\\\" ];\\n\\n\\t\\t\\tif ( axis == \\\"Y\\\" ) this.activePlane = this.planes[ \\\"XZ\\\" ];\\n\\n\\t\\t\\tif ( axis == \\\"Z\\\" ) this.activePlane = this.planes[ \\\"XY\\\" ];\\n\\n\\t\\t\\tthis.hide();\\n\\t\\t\\tthis.show();\\n\\n\\t\\t};\\n\\n\\t\\tthis.update = function ( rotation, eye2 ) {\\n\\n\\t\\t\\tTHREE.TransformGizmo.prototype.update.apply( this, arguments );\\n\\n\\t\\t\\tvar group = {\\n\\t\\t\\t\\thandles: this[\\\"handles\\\"],\\n\\t\\t\\t\\tpickers: this[\\\"pickers\\\"],\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar tempMatrix = new THREE.Matrix4();\\n\\t\\t\\tvar worldRotation = new THREE.Euler( 0, 0, 1 );\\n\\t\\t\\tvar tempQuaternion = new THREE.Quaternion();\\n\\t\\t\\tvar unitX = new THREE.Vector3( 1, 0, 0 );\\n\\t\\t\\tvar unitY = new THREE.Vector3( 0, 1, 0 );\\n\\t\\t\\tvar unitZ = new THREE.Vector3( 0, 0, 1 );\\n\\t\\t\\tvar quaternionX = new THREE.Quaternion();\\n\\t\\t\\tvar quaternionY = new THREE.Quaternion();\\n\\t\\t\\tvar quaternionZ = new THREE.Quaternion();\\n\\t\\t\\tvar eye = eye2.clone();\\n\\n\\t\\t\\tworldRotation.copy( this.planes[\\\"XY\\\"].rotation );\\n\\t\\t\\ttempQuaternion.setFromEuler( worldRotation );\\n\\n\\t\\t\\ttempMatrix.makeRotationFromQuaternion( tempQuaternion ).getInverse( tempMatrix );\\n\\t\\t\\teye.applyMatrix4( tempMatrix );\\n\\n\\t\\t\\tthis.traverse(function(child) {\\n\\n\\t\\t\\t\\ttempQuaternion.setFromEuler( worldRotation );\\n\\n\\t\\t\\t\\tif ( child.name == \\\"X\\\" ) {\\n\\t\\t\\t\\t\\tquaternionX.setFromAxisAngle( unitX, Math.atan2( -eye.y, eye.z ) );\\n\\t\\t\\t\\t\\ttempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );\\n\\t\\t\\t\\t\\tchild.quaternion.copy( tempQuaternion );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( child.name == \\\"Y\\\" ) {\\n\\t\\t\\t\\t\\tquaternionY.setFromAxisAngle( unitY, Math.atan2( eye.x, eye.z ) );\\n\\t\\t\\t\\t\\ttempQuaternion.multiplyQuaternions( tempQuaternion, quaternionY );\\n\\t\\t\\t\\t\\tchild.quaternion.copy( tempQuaternion );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( child.name == \\\"Z\\\" ) {\\n\\t\\t\\t\\t\\tquaternionZ.setFromAxisAngle( unitZ, Math.atan2( eye.y, eye.x ) );\\n\\t\\t\\t\\t\\ttempQuaternion.multiplyQuaternions( tempQuaternion, quaternionZ );\\n\\t\\t\\t\\t\\tchild.quaternion.copy( tempQuaternion );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t});\\n\\n\\t\\t};\\n\\n\\t\\tthis.init();\\n\\n\\t};\\n\\n\\tTHREE.TransformGizmoRotate.prototype = Object.create( THREE.TransformGizmo.prototype );\\n\\n\\tTHREE.TransformGizmoScale = function () {\\n\\n\\t\\tTHREE.TransformGizmo.call( this );\\n\\n\\t\\tvar arrowGeometry = new THREE.Geometry();\\n\\t\\tvar mesh = new THREE.Mesh( new THREE.BoxGeometry( 0.125, 0.125, 0.125 ) );\\n\\t\\tmesh.position.y = 0.5;\\n\\t\\tmesh.updateMatrix();\\n\\n\\t\\tarrowGeometry.merge( mesh.geometry, mesh.matrix );\\n\\n\\t\\tvar lineXGeometry = new THREE.Geometry();\\n\\t\\tlineXGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 1, 0, 0 ) );\\n\\n\\t\\tvar lineYGeometry = new THREE.Geometry();\\n\\t\\tlineYGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\\n\\n\\t\\tvar lineZGeometry = new THREE.Geometry();\\n\\t\\tlineZGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 1 ) );\\n\\n\\t\\tthis.handleGizmos = {\\n\\t\\t\\tX: [\\n\\t\\t\\t\\t[ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0xff0000 } ) ), [ 0.5, 0, 0 ], [ 0, 0, -Math.PI/2 ] ],\\n\\t\\t\\t\\t[ new THREE.Line( lineXGeometry, new GizmoLineMaterial( { color: 0xff0000 } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tY: [\\n\\t\\t\\t\\t[ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x00ff00 } ) ), [ 0, 0.5, 0 ] ],\\n\\t\\t\\t\\t[ new THREE.Line( lineYGeometry, new GizmoLineMaterial( { color: 0x00ff00 } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x0000ff } ) ), [ 0, 0, 0.5 ], [ Math.PI/2, 0, 0 ] ],\\n\\t\\t\\t\\t[ new THREE.Line( lineZGeometry, new GizmoLineMaterial( { color: 0x0000ff } ) ) ]\\n\\t\\t\\t],\\n\\t\\t\\tXYZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.BoxGeometry( 0.125, 0.125, 0.125 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ) ]\\n\\t\\t\\t]\\n\\t\\t};\\n\\n\\t\\tthis.pickerGizmos = {\\n\\t\\t\\tX: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0.6, 0, 0 ], [ 0, 0, -Math.PI/2 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tY: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x00ff00, opacity: 0.25 } ) ), [ 0, 0.6, 0 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0.6 ], [ Math.PI/2, 0, 0 ] ]\\n\\t\\t\\t],\\n\\t\\t\\tXYZ: [\\n\\t\\t\\t\\t[ new THREE.Mesh( new THREE.BoxGeometry( 0.4, 0.4, 0.4 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ) ]\\n\\t\\t\\t]\\n\\t\\t};\\n\\n\\t\\tthis.setActivePlane = function ( axis, eye ) {\\n\\n\\t\\t\\tvar tempMatrix = new THREE.Matrix4();\\n\\t\\t\\teye.applyMatrix4( tempMatrix.getInverse( tempMatrix.extractRotation( this.planes[ \\\"XY\\\" ].matrixWorld ) ) );\\n\\n\\t\\t\\tif ( axis == \\\"X\\\" ) {\\n\\t\\t\\t\\tthis.activePlane = this.planes[ \\\"XY\\\" ];\\n\\t\\t\\t\\tif ( Math.abs(eye.y) > Math.abs(eye.z) ) this.activePlane = this.planes[ \\\"XZ\\\" ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( axis == \\\"Y\\\" ){\\n\\t\\t\\t\\tthis.activePlane = this.planes[ \\\"XY\\\" ];\\n\\t\\t\\t\\tif ( Math.abs(eye.x) > Math.abs(eye.z) ) this.activePlane = this.planes[ \\\"YZ\\\" ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( axis == \\\"Z\\\" ){\\n\\t\\t\\t\\tthis.activePlane = this.planes[ \\\"XZ\\\" ];\\n\\t\\t\\t\\tif ( Math.abs(eye.x) > Math.abs(eye.y) ) this.activePlane = this.planes[ \\\"YZ\\\" ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( axis == \\\"XYZ\\\" ) this.activePlane = this.planes[ \\\"XYZE\\\" ];\\n\\n\\t\\t\\tthis.hide();\\n\\t\\t\\tthis.show();\\n\\n\\t\\t};\\n\\n\\t\\tthis.init();\\n\\n\\t};\\n\\n\\tTHREE.TransformGizmoScale.prototype = Object.create( THREE.TransformGizmo.prototype );\\n\\n\\tTHREE.TransformControls = function ( camera, domElement ) {\\n\\n\\t\\t// TODO: Make non-uniform scale and rotate play nice in hierarchies\\n\\t\\t// TODO: ADD RXYZ contol\\n\\n\\t\\tTHREE.Object3D.call( this );\\n\\n\\t\\tdomElement = ( domElement !== undefined ) ? domElement : document;\\n\\n\\t\\tthis.gizmo = {};\\n\\t\\tthis.gizmo[\\\"translate\\\"] = new THREE.TransformGizmoTranslate();\\n\\t\\tthis.gizmo[\\\"rotate\\\"] = new THREE.TransformGizmoRotate();\\n\\t\\tthis.gizmo[\\\"scale\\\"] = new THREE.TransformGizmoScale();\\n\\n\\t\\tthis.add(this.gizmo[\\\"translate\\\"]);\\n\\t\\tthis.add(this.gizmo[\\\"rotate\\\"]);\\n\\t\\tthis.add(this.gizmo[\\\"scale\\\"]);\\n\\n\\t\\tthis.gizmo[\\\"translate\\\"].hide();\\n\\t\\tthis.gizmo[\\\"rotate\\\"].hide();\\n\\t\\tthis.gizmo[\\\"scale\\\"].hide();\\n\\n\\t\\tthis.object = undefined;\\n\\t\\tthis.snap = null;\\n\\t\\tthis.space = \\\"world\\\";\\n\\t\\tthis.size = 1;\\n\\t\\tthis.axis = null;\\n\\n\\t\\tvar scope = this;\\n\\t\\t\\n\\t\\tvar _dragging = false;\\n\\t\\tvar _mode = \\\"translate\\\";\\n\\t\\tvar _plane = \\\"XY\\\";\\n\\n\\t\\tvar changeEvent = { type: \\\"change\\\" };\\n\\n\\t\\tvar ray = new THREE.Raycaster();\\n\\t\\tvar projector = new THREE.Projector();\\n\\t\\tvar pointerVector = new THREE.Vector3();\\n\\n\\t\\tvar point = new THREE.Vector3();\\n\\t\\tvar offset = new THREE.Vector3();\\n\\n\\t\\tvar rotation = new THREE.Vector3();\\n\\t\\tvar offsetRotation = new THREE.Vector3();\\n\\t\\tvar scale = 1;\\n\\n\\t\\tvar lookAtMatrix = new THREE.Matrix4();\\n\\t\\tvar eye = new THREE.Vector3();\\n\\n\\t\\tvar tempMatrix = new THREE.Matrix4();\\n\\t\\tvar tempVector = new THREE.Vector3();\\n\\t\\tvar tempQuaternion = new THREE.Quaternion();\\n\\t\\tvar unitX = new THREE.Vector3( 1, 0, 0 );\\n\\t\\tvar unitY = new THREE.Vector3( 0, 1, 0 );\\n\\t\\tvar unitZ = new THREE.Vector3( 0, 0, 1 );\\n\\n\\t\\tvar quaternionXYZ = new THREE.Quaternion();\\n\\t\\tvar quaternionX = new THREE.Quaternion();\\n\\t\\tvar quaternionY = new THREE.Quaternion();\\n\\t\\tvar quaternionZ = new THREE.Quaternion();\\n\\t\\tvar quaternionE = new THREE.Quaternion();\\n\\n\\t\\tvar oldPosition = new THREE.Vector3();\\n\\t\\tvar oldScale = new THREE.Vector3();\\n\\t\\tvar oldRotationMatrix = new THREE.Matrix4();\\n\\n\\t\\tvar parentRotationMatrix  = new THREE.Matrix4();\\n\\t\\tvar parentScale = new THREE.Vector3();\\n\\n\\t\\tvar worldPosition = new THREE.Vector3();\\n\\t\\tvar worldRotation = new THREE.Euler();\\n\\t\\tvar worldRotationMatrix  = new THREE.Matrix4();\\n\\t\\tvar camPosition = new THREE.Vector3();\\n\\t\\tvar camRotation = new THREE.Euler();\\n\\n\\t\\tdomElement.addEventListener( \\\"mousedown\\\", onPointerDown, false );\\n\\t\\tdomElement.addEventListener( \\\"touchstart\\\", onPointerDown, false );\\n\\n\\t\\tdomElement.addEventListener( \\\"mousemove\\\", onPointerHover, false );\\n\\t\\tdomElement.addEventListener( \\\"touchmove\\\", onPointerHover, false );\\n\\n\\t\\tdomElement.addEventListener( \\\"mousemove\\\", onPointerMove, false );\\n\\t\\tdomElement.addEventListener( \\\"touchmove\\\", onPointerMove, false );\\n\\n\\t\\tdomElement.addEventListener( \\\"mouseup\\\", onPointerUp, false );\\n\\t\\tdomElement.addEventListener( \\\"mouseout\\\", onPointerUp, false );\\n\\t\\tdomElement.addEventListener( \\\"touchend\\\", onPointerUp, false );\\n\\t\\tdomElement.addEventListener( \\\"touchcancel\\\", onPointerUp, false );\\n\\t\\tdomElement.addEventListener( \\\"touchleave\\\", onPointerUp, false );\\n\\n\\t\\tthis.attach = function ( object ) {\\n\\n\\t\\t\\tscope.object = object;\\n\\n\\t\\t\\tthis.gizmo[\\\"translate\\\"].hide();\\n\\t\\t\\tthis.gizmo[\\\"rotate\\\"].hide();\\n\\t\\t\\tthis.gizmo[\\\"scale\\\"].hide();\\n\\t\\t\\tthis.gizmo[_mode].show();\\n\\n\\t\\t\\tscope.update();\\n\\n\\t\\t};\\n\\n\\t\\tthis.detach = function ( object ) {\\n\\n\\t\\t\\tscope.object = undefined;\\n\\t\\t\\tthis.axis = undefined;\\n\\n\\t\\t\\tthis.gizmo[\\\"translate\\\"].hide();\\n\\t\\t\\tthis.gizmo[\\\"rotate\\\"].hide();\\n\\t\\t\\tthis.gizmo[\\\"scale\\\"].hide();\\n\\n\\t\\t};\\n\\n\\t\\tthis.setMode = function ( mode ) {\\n\\n\\t\\t\\t_mode = mode ? mode : _mode;\\n\\n\\t\\t\\tif ( _mode == \\\"scale\\\" ) scope.space = \\\"local\\\";\\n\\n\\t\\t\\tthis.gizmo[\\\"translate\\\"].hide();\\n\\t\\t\\tthis.gizmo[\\\"rotate\\\"].hide();\\n\\t\\t\\tthis.gizmo[\\\"scale\\\"].hide();\\t\\n\\t\\t\\tthis.gizmo[_mode].show();\\n\\n\\t\\t\\tthis.update();\\n\\t\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\t};\\n\\n\\t\\tthis.setSnap = function ( snap ) {\\n\\n\\t\\t\\tscope.snap = snap;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setSize = function ( size ) {\\n\\n\\t\\t\\tscope.size = size;\\n\\t\\t\\tthis.update();\\n\\t\\t\\tscope.dispatchEvent( changeEvent );\\n\\t\\t\\t\\n\\t\\t};\\n\\n\\t\\tthis.setSpace = function ( space ) {\\n\\n\\t\\t\\tscope.space = space;\\n\\t\\t\\tthis.update();\\n\\t\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\t};\\n\\n\\t\\tthis.update = function () {\\n\\n\\t\\t\\tif ( scope.object === undefined ) return;\\n\\n\\t\\t\\tscope.object.updateMatrixWorld();\\n\\t\\t\\tworldPosition.setFromMatrixPosition( scope.object.matrixWorld );\\n\\t\\t\\tworldRotation.setFromRotationMatrix( tempMatrix.extractRotation( scope.object.matrixWorld ) );\\n\\n\\t\\t\\tcamera.updateMatrixWorld();\\n\\t\\t\\tcamPosition.setFromMatrixPosition( camera.matrixWorld );\\n\\t\\t\\tcamRotation.setFromRotationMatrix( tempMatrix.extractRotation( camera.matrixWorld ) );\\n\\n\\t\\t\\tscale = worldPosition.distanceTo( camPosition ) / 6 * scope.size;\\n\\t\\t\\tthis.position.copy( worldPosition );\\n\\t\\t\\tthis.scale.set( scale, scale, scale );\\n\\n\\t\\t\\teye.copy( camPosition ).sub( worldPosition ).normalize();\\n\\n\\t\\t\\tif ( scope.space == \\\"local\\\" )\\n\\t\\t\\t\\tthis.gizmo[_mode].update( worldRotation, eye );\\n\\n\\t\\t\\telse if ( scope.space == \\\"world\\\" )\\n\\t\\t\\t\\tthis.gizmo[_mode].update( new THREE.Euler(), eye );\\n\\n\\t\\t\\tthis.gizmo[_mode].highlight( scope.axis );\\n\\n\\t\\t};\\n\\n\\t\\tfunction onPointerHover( event ) {\\n\\n\\t\\t\\tif ( scope.object === undefined || _dragging === true ) return;\\n\\n\\t\\t\\tevent.preventDefault();\\n\\n\\t\\t\\tvar pointer = event.changedTouches ? event.changedTouches[ 0 ] : event;\\n\\n\\t\\t\\tvar intersect = intersectObjects( pointer, scope.gizmo[_mode].pickers.children );\\n\\n\\t\\t\\tif ( intersect ) {\\n\\n\\t\\t\\t\\tscope.axis = intersect.object.name;\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\t\\t} else if ( scope.axis !== null ) {\\n\\n\\t\\t\\t\\tscope.axis = null;\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction onPointerDown( event ) {\\n\\n\\t\\t\\tif ( scope.object === undefined || _dragging === true ) return;\\n\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t\\tevent.stopPropagation();\\n\\n\\t\\t\\tvar pointer = event.changedTouches ? event.changedTouches[ 0 ] : event;\\n\\n\\t\\t\\tif ( pointer.button === 0 || pointer.button === undefined ) {\\n\\n\\t\\t\\t\\tvar intersect = intersectObjects( pointer, scope.gizmo[_mode].pickers.children );\\n\\n\\t\\t\\t\\tif ( intersect ) {\\n\\n\\t\\t\\t\\t\\tscope.axis = intersect.object.name;\\n\\n\\t\\t\\t\\t\\tscope.update();\\n\\n\\t\\t\\t\\t\\teye.copy( camPosition ).sub( worldPosition ).normalize();\\n\\n\\t\\t\\t\\t\\tscope.gizmo[_mode].setActivePlane( scope.axis, eye );\\n\\n\\t\\t\\t\\t\\tvar planeIntersect = intersectObjects( pointer, [scope.gizmo[_mode].activePlane] );\\n\\n\\t\\t\\t\\t\\toldPosition.copy( scope.object.position );\\n\\t\\t\\t\\t\\toldScale.copy( scope.object.scale );\\n\\n\\t\\t\\t\\t\\toldRotationMatrix.extractRotation( scope.object.matrix );\\n\\t\\t\\t\\t\\tworldRotationMatrix.extractRotation( scope.object.matrixWorld );\\n\\n\\t\\t\\t\\t\\tparentRotationMatrix.extractRotation( scope.object.parent.matrixWorld );\\n\\t\\t\\t\\t\\tparentScale.setFromMatrixScale( tempMatrix.getInverse( scope.object.parent.matrixWorld ) );\\n\\n\\t\\t\\t\\t\\toffset.copy( planeIntersect.point );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_dragging = true;\\n\\n\\t\\t}\\n\\n\\t\\tfunction onPointerMove( event ) {\\n\\n\\t\\t\\tif ( scope.object === undefined || scope.axis === null || _dragging === false ) return;\\n\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t\\tevent.stopPropagation();\\n\\n\\t\\t\\tvar pointer = event.changedTouches? event.changedTouches[0] : event;\\n\\n\\t\\t\\tvar planeIntersect = intersectObjects( pointer, [scope.gizmo[_mode].activePlane] );\\n\\n\\t\\t\\tpoint.copy( planeIntersect.point );\\n\\n\\t\\t\\tif ( _mode == \\\"translate\\\" ) {\\n\\n\\t\\t\\t\\tpoint.sub( offset );\\n\\t\\t\\t\\tpoint.multiply(parentScale);\\n\\n\\t\\t\\t\\tif ( scope.space == \\\"local\\\" ) {\\n\\n\\t\\t\\t\\t\\tpoint.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );\\n\\n\\t\\t\\t\\t\\tif ( scope.axis.search(\\\"X\\\") == -1 ) point.x = 0;\\n\\t\\t\\t\\t\\tif ( scope.axis.search(\\\"Y\\\") == -1 ) point.y = 0;\\n\\t\\t\\t\\t\\tif ( scope.axis.search(\\\"Z\\\") == -1 ) point.z = 0;\\n\\n\\t\\t\\t\\t\\tpoint.applyMatrix4( oldRotationMatrix );\\n\\n\\t\\t\\t\\t\\tscope.object.position.copy( oldPosition );\\n\\t\\t\\t\\t\\tscope.object.position.add( point );\\n\\n\\t\\t\\t\\t} \\n\\n\\t\\t\\t\\tif ( scope.space == \\\"world\\\" || scope.axis.search(\\\"XYZ\\\") != -1 ) {\\n\\n\\t\\t\\t\\t\\tif ( scope.axis.search(\\\"X\\\") == -1 ) point.x = 0;\\n\\t\\t\\t\\t\\tif ( scope.axis.search(\\\"Y\\\") == -1 ) point.y = 0;\\n\\t\\t\\t\\t\\tif ( scope.axis.search(\\\"Z\\\") == -1 ) point.z = 0;\\n\\n\\t\\t\\t\\t\\tpoint.applyMatrix4( tempMatrix.getInverse( parentRotationMatrix ) );\\n\\n\\t\\t\\t\\t\\tscope.object.position.copy( oldPosition );\\n\\t\\t\\t\\t\\tscope.object.position.add( point );\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( scope.snap !== null ) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif ( scope.axis.search(\\\"X\\\") != -1 ) scope.object.position.x = Math.round( scope.object.position.x / scope.snap ) * scope.snap;\\n\\t\\t\\t\\t\\tif ( scope.axis.search(\\\"Y\\\") != -1 ) scope.object.position.y = Math.round( scope.object.position.y / scope.snap ) * scope.snap;\\n\\t\\t\\t\\t\\tif ( scope.axis.search(\\\"Z\\\") != -1 ) scope.object.position.z = Math.round( scope.object.position.z / scope.snap ) * scope.snap;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( _mode == \\\"scale\\\" ) {\\n\\n\\t\\t\\t\\tpoint.sub( offset );\\n\\t\\t\\t\\tpoint.multiply(parentScale);\\n\\n\\t\\t\\t\\tif ( scope.space == \\\"local\\\" ) {\\n\\n\\t\\t\\t\\t\\tif ( scope.axis == \\\"XYZ\\\") {\\n\\n\\t\\t\\t\\t\\t\\tscale = 1 + ( ( point.y ) / 50 );\\n\\n\\t\\t\\t\\t\\t\\tscope.object.scale.x = oldScale.x * scale;\\n\\t\\t\\t\\t\\t\\tscope.object.scale.y = oldScale.y * scale;\\n\\t\\t\\t\\t\\t\\tscope.object.scale.z = oldScale.z * scale;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tpoint.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );\\n\\n\\t\\t\\t\\t\\t\\tif ( scope.axis == \\\"X\\\" ) scope.object.scale.x = oldScale.x * ( 1 + point.x / 50 );\\n\\t\\t\\t\\t\\t\\tif ( scope.axis == \\\"Y\\\" ) scope.object.scale.y = oldScale.y * ( 1 + point.y / 50 );\\n\\t\\t\\t\\t\\t\\tif ( scope.axis == \\\"Z\\\" ) scope.object.scale.z = oldScale.z * ( 1 + point.z / 50 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( _mode == \\\"rotate\\\" ) {\\n\\n\\t\\t\\t\\tpoint.sub( worldPosition );\\n\\t\\t\\t\\tpoint.multiply(parentScale);\\n\\t\\t\\t\\ttempVector.copy(offset).sub( worldPosition );\\n\\t\\t\\t\\ttempVector.multiply(parentScale);\\n\\n\\t\\t\\t\\tif ( scope.axis == \\\"E\\\" ) {\\n\\n\\t\\t\\t\\t\\tpoint.applyMatrix4( tempMatrix.getInverse( lookAtMatrix ) );\\n\\t\\t\\t\\t\\ttempVector.applyMatrix4( tempMatrix.getInverse( lookAtMatrix ) );\\n\\n\\t\\t\\t\\t\\trotation.set( Math.atan2( point.z, point.y ), Math.atan2( point.x, point.z ), Math.atan2( point.y, point.x ) );\\n\\t\\t\\t\\t\\toffsetRotation.set( Math.atan2( tempVector.z, tempVector.y ), Math.atan2( tempVector.x, tempVector.z ), Math.atan2( tempVector.y, tempVector.x ) );\\n\\n\\t\\t\\t\\t\\ttempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );\\n\\n\\t\\t\\t\\t\\tquaternionE.setFromAxisAngle( eye, rotation.z - offsetRotation.z );\\n\\t\\t\\t\\t\\tquaternionXYZ.setFromRotationMatrix( worldRotationMatrix );\\n\\n\\t\\t\\t\\t\\ttempQuaternion.multiplyQuaternions( tempQuaternion, quaternionE );\\n\\t\\t\\t\\t\\ttempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );\\n\\n\\t\\t\\t\\t\\tscope.object.quaternion.copy( tempQuaternion );\\n\\n\\t\\t\\t\\t} else if ( scope.axis == \\\"XYZE\\\" ) {\\n\\n\\t\\t\\t\\t\\tquaternionE.setFromEuler( point.clone().cross(tempVector).normalize() ); // rotation axis\\n\\n\\t\\t\\t\\t\\ttempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );\\n\\t\\t\\t\\t\\tquaternionX.setFromAxisAngle( quaternionE, - point.clone().angleTo(tempVector) );\\n\\t\\t\\t\\t\\tquaternionXYZ.setFromRotationMatrix( worldRotationMatrix );\\n\\n\\t\\t\\t\\t\\ttempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );\\n\\t\\t\\t\\t\\ttempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );\\n\\n\\t\\t\\t\\t\\tscope.object.quaternion.copy( tempQuaternion );\\n\\n\\t\\t\\t\\t} else if ( scope.space == \\\"local\\\" ) {\\n\\n\\t\\t\\t\\t\\tpoint.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );\\n\\n\\t\\t\\t\\t\\ttempVector.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );\\n\\n\\t\\t\\t\\t\\trotation.set( Math.atan2( point.z, point.y ), Math.atan2( point.x, point.z ), Math.atan2( point.y, point.x ) );\\n\\t\\t\\t\\t\\toffsetRotation.set( Math.atan2( tempVector.z, tempVector.y ), Math.atan2( tempVector.x, tempVector.z ), Math.atan2( tempVector.y, tempVector.x ) );\\n\\n\\t\\t\\t\\t\\tquaternionXYZ.setFromRotationMatrix( oldRotationMatrix );\\n\\t\\t\\t\\t\\tquaternionX.setFromAxisAngle( unitX, rotation.x - offsetRotation.x );\\n\\t\\t\\t\\t\\tquaternionY.setFromAxisAngle( unitY, rotation.y - offsetRotation.y );\\n\\t\\t\\t\\t\\tquaternionZ.setFromAxisAngle( unitZ, rotation.z - offsetRotation.z );\\n\\n\\t\\t\\t\\t\\tif ( scope.axis == \\\"X\\\" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionX );\\n\\t\\t\\t\\t\\tif ( scope.axis == \\\"Y\\\" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionY );\\n\\t\\t\\t\\t\\tif ( scope.axis == \\\"Z\\\" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionZ );\\n\\n\\t\\t\\t\\t\\tscope.object.quaternion.copy( quaternionXYZ );\\n\\n\\t\\t\\t\\t} else if ( scope.space == \\\"world\\\" ) {\\n\\n\\t\\t\\t\\t\\trotation.set( Math.atan2( point.z, point.y ), Math.atan2( point.x, point.z ), Math.atan2( point.y, point.x ) );\\n\\t\\t\\t\\t\\toffsetRotation.set( Math.atan2( tempVector.z, tempVector.y ), Math.atan2( tempVector.x, tempVector.z ), Math.atan2( tempVector.y, tempVector.x ) );\\n\\n\\t\\t\\t\\t\\ttempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );\\n\\n\\t\\t\\t\\t\\tquaternionX.setFromAxisAngle( unitX, rotation.x - offsetRotation.x );\\n\\t\\t\\t\\t\\tquaternionY.setFromAxisAngle( unitY, rotation.y - offsetRotation.y );\\n\\t\\t\\t\\t\\tquaternionZ.setFromAxisAngle( unitZ, rotation.z - offsetRotation.z );\\n\\t\\t\\t\\t\\tquaternionXYZ.setFromRotationMatrix( worldRotationMatrix );\\n\\n\\t\\t\\t\\t\\tif ( scope.axis == \\\"X\\\" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );\\n\\t\\t\\t\\t\\tif ( scope.axis == \\\"Y\\\" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionY );\\n\\t\\t\\t\\t\\tif ( scope.axis == \\\"Z\\\" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionZ );\\n\\n\\t\\t\\t\\t\\ttempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );\\n\\n\\t\\t\\t\\t\\tscope.object.quaternion.copy( tempQuaternion );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.update();\\n\\t\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\t}\\n\\n\\t\\tfunction onPointerUp( event ) {\\n\\n\\t\\t\\t_dragging = false;\\n\\t\\t\\tonPointerHover( event );\\n\\n\\t\\t}\\n\\n\\t\\tfunction intersectObjects( pointer, objects ) {\\n\\n\\t\\t\\tvar rect = domElement.getBoundingClientRect();\\n\\t\\t\\tvar x = (pointer.clientX - rect.left) / rect.width;\\n\\t\\t\\tvar y = (pointer.clientY - rect.top) / rect.height;\\n\\t\\t\\tpointerVector.set( ( x ) * 2 - 1, - ( y ) * 2 + 1, 0.5 );\\n\\n\\t\\t\\tprojector.unprojectVector( pointerVector, camera );\\n\\t\\t\\tray.set( camPosition, pointerVector.sub( camPosition ).normalize() );\\n\\n\\t\\t\\tvar intersections = ray.intersectObjects( objects, true );\\n\\t\\t\\treturn intersections[0] ? intersections[0] : false;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tTHREE.TransformControls.prototype = Object.create( THREE.Object3D.prototype );\\n\\n}());\"\n        },\n        \"$:/plugins/rboue/Three.js/Lib/Controls/VRControls.js\": {\n            \"type\": \"application/javascript\",\n            \"title\": \"$:/plugins/rboue/Three.js/Lib/Controls/VRControls.js\",\n            \"module-type\": \"library\",\n            \"text\": \"/**\\n * @author dmarcos / https://github.com/dmarcos\\n */\\n\\nTHREE.VRControls = function ( camera, done ) {\\n\\n\\tthis._camera = camera;\\n\\n\\tthis._init = function () {\\n\\t\\tvar self = this;\\n\\t\\tif ( !navigator.mozGetVRDevices && !navigator.getVRDevices ) {\\n\\t\\t\\tif ( done ) {\\n\\t\\t\\t\\tdone(\\\"Your browser is not VR Ready\\\");\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif ( navigator.getVRDevices ) {\\n\\t\\t\\tnavigator.getVRDevices().then( gotVRDevices );\\n\\t\\t} else {\\n\\t\\t\\tnavigator.mozGetVRDevices( gotVRDevices );\\n\\t\\t}\\n\\t\\tfunction gotVRDevices( devices ) {\\n\\t\\t\\tvar vrInput;\\n\\t\\t\\tvar error;\\n\\t\\t\\tfor ( var i = 0; i < devices.length; ++i ) {\\n\\t\\t\\t\\tif ( devices[i] instanceof PositionSensorVRDevice ) {\\n\\t\\t\\t\\t\\tvrInput = devices[i]\\n\\t\\t\\t\\t\\tself._vrInput = vrInput;\\n\\t\\t\\t\\t\\tbreak; // We keep the first we encounter\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( done ) {\\n\\t\\t\\t\\tif ( !vrInput ) {\\n\\t\\t\\t\\t error = 'HMD not available';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdone( error );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tthis._init();\\n\\n\\tthis.update = function() {\\n\\t\\tvar camera = this._camera;\\n\\t\\tvar quat;\\n\\t\\tvar vrState = this.getVRState();\\n\\t\\tif ( !vrState ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// Applies head rotation from sensors data.\\n\\t\\tif ( camera ) {\\n\\t\\t\\tcamera.quaternion.fromArray( vrState.hmd.rotation );\\n\\t\\t}\\n\\t};\\n\\n\\tthis.getVRState = function() {\\n\\t\\tvar vrInput = this._vrInput;\\n\\t\\tvar orientation;\\n\\t\\tvar vrState;\\n\\t\\tif ( !vrInput ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\torientation\\t= vrInput.getState().orientation;\\n\\t\\tvrState = {\\n\\t\\t\\thmd : {\\n\\t\\t\\t\\trotation : [\\n\\t\\t\\t\\t\\torientation.x,\\n\\t\\t\\t\\t\\torientation.y,\\n\\t\\t\\t\\t\\torientation.z,\\n\\t\\t\\t\\t\\torientation.w\\n\\t\\t\\t\\t]\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn vrState;\\n\\t};\\n\\n};\"\n        },\n        \"$:/plugins/rboue/Three.js/config.json\": {\n            \"title\": \"$:/plugins/rboue/Three.js/config.json\",\n            \"type\": \"application/json\",\n            \"text\": \"{\\n\\\"\\\":\\\"Actually nothing.\\\",\\n\\n\\\"\\\":\\\"\\\"\\n}\"\n        },\n        \"$:/plugins/rboue/Three.js/icon\": {\n            \"created\": \"20150122113649353\",\n            \"modified\": \"20150122113650949\",\n            \"title\": \"$:/plugins/rboue/Three.js/icon\",\n            \"type\": \"image/png\",\n            \"text\": \"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABmJLR0QA/wD/AP+gvaeTAAAACXBI\\nWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wMRCAYZvJsQjgAAABl0RVh0Q29tbWVudABDcmVhdGVk\\nIHdpdGggR0lNUFeBDhcAABHaSURBVHja7Z15VJNX3se/N7IoWElQgwiEVUBZBJdSSweFEZdaWjew\\nIrZqO9O302l9562n9cx5zxydMzOnp6eli+2r09KilipuoxVKlUarUOqGBRcUiBKIiQjGLEAggZD7\\n/kHTwRGyB7I837845Fnuc3+f53eX53d/l1BK4UqilOLBgwdob2+HQqGAQqGAUqmEWq2GUDMxPFWe\\n22To/CrOvohw7wfCsWPHgs1mw8/PD2w2GwEBAfD39wchxKXqizg7ACqVCiKRCCKRCGKxGMHtm+36\\nQGLuRyQ4OBihoaEICQmBr68vA8BISqfTQSQSQSAQoPJ2j9E32t4Sct4jUVFRiIqKAo/HA4vFYgCw\\nh1tvampCXV0dvOtyHbrAvfH7SVxcHMLDw52iuXBoANra2nDp0iV4XnveKdupvoRiMnfuXAQEBDAA\\nmOVWhUKcO3cOE1t+7xI9VFnY52TevHkICwtjADDk5uvr61FRUYEw2ZuuNTT5RS0T80laWhpiYmIc\\npnlwCAAaGxvxww8/uKzhhwIhPT0d06ZNc28A7ty5gxMnToAn/ZNbGP6R55/8IVmyZAmCg4PdC4De\\n3l6cOnUKrNpstzT8I5p1hGRkZMDT09P1ARAIBGg6nMwYfghF5VwhkZGRrgmAWq1GSUkJJtzayBjf\\ngLpjvyLLli2Dl5fXiNxvRKat2trasL3wdD5jfOPyqV9P//blifD79++7hgeoqalB+4nfMIa3QAFL\\nfyRJSUnOCQClFHw+H7rqFYzxrZBnynGSnp5ut3kDuzQBWq0WBw4cYIxvA/VdeJYePHgQWq3WOQDQ\\naDQoKioCR/gyY3wbid30Ev3666+h0WgcG4DOzk78vfBkeGDrHxnj21hT7r5G/154Mryzs9MxAVAq\\nlTh6dOfPo/193pWVKs9t+kdRZX5HR4djdQK7urpQtWMK89aPJAyv3yPjx48ffQ+gVqvxbtHpcMYk\\nI6t3i06Hq9Xq0fUAWq0WRUVFYNr80dG9qZ+SdevWwcPDY+Q9gE6nw6FDhxjjj3LH8PDhw7DmJbbY\\nA5SXl4NeXskY3wHkmXKcZGRkjJwHqKmpYYzvQOq78Cytr68fGQDa29uZuX0HVMvROdSSOQKzAOjr\\n68MHR6rzmep2TB04cAD9/f326wOUlZVhzJUc5u13YLHmHCWZmZm29wDNzc2M8Z1AuuoV9M6dO7YF\\noLe3Fw374xnjO4l2fXslT6fT2a4J4PP56L+0nAFgBNXs/z6ZPn06OBwOfHx80N/fD5VKBbFYDK/r\\na43awi+dT5544gnrAWhvb0fNFxEuZ3wx9yPC5XIxbtw4AAMBLDKZDOyml0b1WaW8f5KFCxciICBg\\n2HJQSnH16lVyryzVYFlTXhUTNpttHQB79+5FgOQPLgFA57TdJD4+HhEREdRQ0KVUKs2pr68/pKpc\\nMqLPHZR1nsTHm97UarVafPPNN2R844tDnqOM/JLk5ORYDsDt27dx6+BMpzd+R1QhycjIeHvixInv\\nmNWh0ulQU1NDpOXz7V4HcevrSXBwsNn3+SX0jgwXfRWz9joxtCaRZejCe76vc/qvfNwllSQ7O5ua\\na3wAYLFYmD17Nn3qjTa0Bn5it8V8kdm1FhkfAAghWLhwIe2K3jNk+U6dOmWZB6irq4P4eIpTv/0z\\nN94iU6bYJk6BUopTp04RW3eGe6YXkeXLl9O+vj6cPHmSnD17Fh0dHQgMDMTSpUuRkmKaDdRqNc5+\\nMGnI32Jz60hoaKh5AOzatQvh8i1OC0DyS03+XC5XZuvrlpaWElvmK0h5VUxqa2vxyiuvoLGx8ZHr\\nLly4kBQUFCA0NNToPX/88UcyVL9FyvsnWbdunekA3Lp1C7cPJTmt8X9ZYmWX8ut0OhQVFRFbdIxl\\nYZ8THx8frF69mhqK+p00aVLOhQsXDkVEGB6N9fT0oOLDyUP+NiPvJgkJCTGtD3D+/Hnn9fuzjjxk\\n/I6ODpSXl5Pdu3eTvXv3kjNnzhBrImlYLBZWrVplE7i4XC42bNhw21jIt1QqPfjCCy8Y/e4/btw4\\nSAI+HrIvUFVVZVonUCaTYfKd/3Lat3/+/IEee01NDVmxYgXhcrlYvHgx3bhxI33xxRdpeno65XK5\\n2LRpExEKhRZ17Hx9feHz1HdWdwq1F5+jCoUiwpRjq6qqKJ/PN3rPwMDAIf/PEb5M5XK5cQCqq6ud\\n9uUf++S3xNvbG9u3bydz5syhx44do0PF0nd2dqKwsJBOnz6d7tmzxyJDmto5M6StB6eZde+ysjKj\\nxzz22GPD/nb58mXDAPT39zt1oMfcuXOxZcsWsm3bNmrKXLhGo8HGjRvpzp07zYbAy8sLZPa/rPIC\\nYrE425zjm5ubjR5jKD6w/9LyR+rlIQAEAoHTvv13p+wgx44dQ35+vlkAU0qxefNmev78ebONGRsb\\na1WZvb29D5lzvI+Pj9FjjAWF3Lp1a3gA6urqnBYAHo+HLVu2WHRuX18fXn/9dbODKy2dvNHL3BxB\\niYmJxkcWMsMj3xs3bgwNgFarxXBzys4g7cXnaGtrq8Xlr66uNtsLsFgstAfvtLgZ2Lroksnl9fLy\\nwpo1awzXgVZr9GPWuJt5dHDU0K8ACIVCOLM+PZdhda+8pKTE7HOMfW0zprS0NJPK/dZbb5GwsDBq\\nxL2bdK3BfQmWK7T/ANDQ0GD1NSxpAr29va2655tvvomEhASDhsvJySHbtm2jxiaoLl48/rMp9xxs\\n618B4PQc6XJmAGQyWba115BKpSNebu+6XFpWVobt27eT4ODgh0CYOXMmKSwsJMXFxXTMmDEGr3Pp\\n0iUSIPlrsin3PCvU5T8EgFKpREfjAafOe+7n53fI2mtwOByzz+np6bG67J+V/hy+detW2tLSQhsb\\nG0l1dTWRSCSktraWbtiwgRrLDiIUConi9G9N7k8sUOT8Sb/CmAUMJGx0dg03A2aOwsPDLfE8Vt83\\nVZ7b9LcvT0R0dHQ0TZs2jc6ePZtOnTrVJINeuXKFNBYnmN35FYvFrgXA/z5dY/UIJisry6zjKaWY\\neu91m4ycUuW5TRd2BkfU1taaFKepUqnw7bffGg0LG04ikejfANy9e9fpAajgFK83NA1qTJGRkSQ9\\nPd2symxtbbV5kEjbd0/RP+/67oPKykoilUpzBg/Zent70dTUREpLS8mPHwfA4+oai+FrbW0FABCd\\nTofydx5zmaDPJX9WWXTewYMHSXa2ealry8vLiTNPnS/a2klYQ30hclbR5MNk6dKlZr+Vr732mtnG\\nV6lUTr9AVqlUgjUaQx97idSsprt378amTZtMgoDFYuGdd94hO3bsMNuQFRUVTr99mFQqhUt5AGAg\\n8KGgoADFxcUkLCxsWCMlJSURPp9P3n77bWpuEkaZTPaZK2Q6l8vl8FAoFC4FgE/9elpd/QNZs2YN\\nzc7Oxrlz50hFRQXu3r0LFosFHo+HzMxMJCYmWmRAjUaD0tKCuQEuUFcKhQIeSqUSfnAtyfjpVDK1\\ngQQFBdHU1FSamppqmz4GpSgpKSEBkr+6RKdZqVSC1d3dDVfU9b0xtL6+3mbttEajwb59+8hjgg0u\\nM2JSqVRgCdST8uCiajk6h/70009W50JUKBRNe/bsIZNEr7jUGsmenh6QE//wdflVv21Bf6mZM+eZ\\nWdOnTzerw9fV1YUzZ84QZ9230KSRkzsAoJeY+xFJTk5GdHQ0HS7LJqUUYrGYXL9+3S32NHIrAAZr\\nQvQa1e2e9PH67/mUUiiVSrfbwcxtAWA0IBZTBQwAjBgAGDEAMHJPAKo4+yKYanBPCTnvEVbEWJmQ\\nqQr3lI+PD1imrDdj5MIAWLuyhZHzis1mMwAwADAAuDcAkydPZmrCTcXlchkP4M6aMGECWIQQiLkf\\nEaY63Et3p+wgwC8zgcHBwUyNuJn0NmcBA+lVGLmX9EkjGQ/AADCQW66CU7yeqRb3kJDzHvH19f03\\nAAAwP8KriKka91BUVNSvf3sM/qfgMlM55qot6P+Iv78//Pz84OHhAS8vL3h7e4PFGni3ent7odVq\\nodFooNFoIJPJIJfLRzX2cEgAeDweBIw9DUoZ+SUJDQ0Fj8cDl8vV5+2x0JC/Q3d3N8RiMWlpaUFL\\nSwtC7v/3iEAxOGv4Q4smjh07hnE385gg0UHSJR0iCQkJVieFNEUajQY3b94k165dA1f8ql3up4nb\\nR5599tmhARAIBGg6nOz2AFRwitfnzY8siomJoXpXPtLq6urCuXPnht0LyGL3P7CXwtAA9Pf3g/+u\\nn1sDELjsJ5KQkGD2knF7qbOzE2fOnCGm7BVoijLf7iCDoX4I7zFjxsDj8W/cclr43tRPyW82tyMx\\nMdFhjK8fomdlZdHQFdVWF8rriRLynx7tEf+WnJzsdsaXhX1O8vLyqCNHR8XGxtL4FxqsgiApKemR\\n/z0CgL+/P+ThBW7jBSZEr1GtXr3aaCZOR1BQUBANee6iRbZRRHxBhkqEOWQPx5Q9Z11FPlFvjPf0\\n9HSa8s6YMYO2TMw3G4Inn3xyyP8PCUBYWBiEnPfcwgtER0dTJyyzWceLJn0w5I5hwwIAAOnp6W7h\\nAcaOHet0ZdZveG2qDNlyWABiYmLcIlBEKpXOcbYy379/3+RjWwM/IYOnfk0GAAAWLFjg8h7g8lBb\\naTmwenp6YE7Gkvnz5xv83SAAkZGRLj8iIDWrqUgkcopnpJSirKzM5LJ2x35FjGVANzrPuXjxYpf3\\nAje/nkElEglxdOOfPHmSmLOv06JFi4weYxQADoeDMXOPuXxf4PreGFpbW+uQz9nT04P9+/cTUrPa\\nZOP7pfN/DfqwCgB9L9IdIobavnuK/mXX8YgbN244BAgajQZ8Pp9UfDgZE1t+b7Lx70z+kKSkpJjW\\nBJqaQ6+5uRkN++Pd5kPR/ZBdZNasWYiOjqaGduO0h+RyOf/atWuZPVVPW1Tfw+0UbhUAAMDn89F/\\nabnbfS1Uz/iaxMTEgMfj2eV7AaUU7e3tRCgUoq6uDsHtmy2u43GpZSQtLc30TrA5APT396OgoABh\\nsjfd9pNxBad4/bxgFHG5XLDZbLDZbA6bzZZ5eXmZZOiuri4oFAqiUCggl8shkUjg3/w7m9Rne/BO\\nkpeXB3O+ZpqdRrW9vR01X0QwUUMGAInwbCvy8vICpRRqtRqhD/5nROrryT+2EnO3zbEoj25DQwOa\\n/zWbgcCBFJtbR0JDQ80+z6J4p5iYGKu3TmdkO3mmHLfI+BYDAACZmZnQxO1jIBjtoWLcPmLNhzuL\\nASCEICsrC4qILxgIRknKyC9JVlYWrAlhsyrklRCCVatW/brUmNHI6e6UHWTlypWwNn7R6phnDw8P\\n5Obmuk0AiSOo2f99kpubC1tMUNkk6N3b2xtr165FW9Bfahjz2Fdn2Ac/WLt2rdXb1ls1DBxOarUa\\n+/fvt9l+uoweVmvgJ+T555+3aRSTTQEABmYLjxw5Ar/bmxgIbKiOqEKycuVK2Dp62eYAAANTnqWl\\npbDVahZ3V19CMVm2bBnssWDFLgDoITh9+jS0F59jILBCXk+UkAULFsBeq5XsBoBeLS0tqN8Xx0Bg\\ngeJfaCBBQUF2vYfdAQCA7u5uHD16FK6275699CD0M7J8+XKMxFK1EQFA3yRcvHgRitO/ZSAwIHbG\\nKfL4449jpBaojhgAeonFYpSWliJcvoUBYZCa/d8nzzzzDOzt8kcdAL03uHr1Ku6VpTIQAJjydBVJ\\nTEzEaCxLHxUA9Orq6sL3338Pn/r1bglCd+xXZNGiRTAletclAdBLIBDg7NmzI5YkabTVMjGfZGRk\\nwNCSLbcCQC+hUIjKykoESP5AXdXwaWlpAwE1DpKFxKEA0EsikaCyshIc4csuAYIs7HMyb948hIWF\\nOVzZHBIAvTo7O3H16lV0VSx2ShDGp50kM2fOxHA7lTMAmDFqaGpqQl1dHbzrch26wL3x+0lcXBzC\\nw8PhSMmmnBqAwdLpdBCJRBAIBKi83ROeKs9tGtV+C+c9EhUVhaioKPB4PIxWXkG3AeA/pVKpIBKJ\\nIBKJIJFIENT2hl0fSBLwMQkKCkJoaChCQkJGdQjHADCMOjo6IJVKoVQqoVAooFAo0N3dDZVKZXSR\\nRsvEfOLr6wsfHx/9yh+w2WxMmjQJ5i66cAb9P0ino5gBTAIlAAAAAElFTkSuQmCC\\n\"\n        },\n        \"$:/plugins/rboue/Three.js/license\": {\n            \"title\": \"$:/plugins/rboue/Three.js/license\",\n            \"text\": \"!Plugin license\\nCopyright (C) 2015 Ren Bou (rboue) &lt;rboue01 (at) gmail (dot) com&gt;<br>\\nAll rights reserved.\\n\\nThis program is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation, either version 3 of the License, or\\n(at your option) any later version.\\n\\nThis program is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n!Three.js r69 license\\nThe Three.js r69 LICENSE file is as follows :\\n\\n```\\nThe MIT License\\n\\nCopyright &copy; 2010-2014 three.js authors\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n```\"\n        },\n        \"$:/plugins/rboue/Three.js/readme\": {\n            \"title\": \"$:/plugins/rboue/Three.js/readme\",\n            \"text\": \"Three.js r69 for ~TiddlyWiki.\"\n        },\n        \"$:/plugins/rboue/Three.js/tiddlywiki.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/rboue/Three.js/tiddlywiki.js\\ntype: application/javascript\\nmodule-type: library\\n\\n  Adaptation of Three.js to TiddlyWiki.\\n\\n\\\\*/\\n(function() {\\n\\n  var TiddlyWiki = function(widget, tiddlerTitle, widgetConfiguration) {\\n    this.widget = widget; // widget\\n    this.tiddlerTitle = tiddlerTitle;   // title of the main code tiddler\\n    this.widgetConfiguration = widgetConfiguration; // widget's configuration object\\n  };\\n\\n  // Static members\\n\\n  // Initialized at TiddlyWiki session opening\\n  TiddlyWiki.sessionConfiguration = null; // Session configuration\\n\\n  // Static initialisations\\n  TiddlyWiki.init = function(sessionConfiguration) {\\n    TiddlyWiki.sessionConfiguration = sessionConfiguration;\\n  };\\n\\n  // Get CSS raw source of a tiddler image\\n  TiddlyWiki.getRawTiddlerImage = function(tiddlerName) {\\n    if (!$tw || !$tw.wiki) return false;\\n    // Check if it is an image tiddler\\n    if (!$tw.wiki.isImageTiddler(tiddlerName)) return false;\\n    var tiddler = $tw.wiki.getTiddler(tiddlerName);\\n    if ((typeof(tiddler) == \\\"undefined\\\") || !tiddler) return false;\\n    var text = tiddler.fields.text;\\n    if (!text) return false;\\n    var type = tiddler.fields.type;\\n    // Render the appropriate element for the image type\\n    var src = \\\"\\\";\\n    switch(type) {\\n    case \\\"image/svg+xml\\\":\\n      src = \\\"data:image/svg+xml,\\\" + encodeURIComponent(text);\\n      break;\\n    default:\\n      src = \\\"data:\\\" + type + \\\";base64,\\\" + text;\\n      break;\\n    }\\n\\n    return src;\\n  }; \\n\\n  // Loading of TiddlyWiki specific URL\\n  // Parameters :\\n  //   <url> : URL with specific syntax : \\\"tw:<tiddler title>\\\"\\n  //   <type> : \\\"image\\\" for image tiddler, \\\"ArrayBuffer\\\" for tiddler with base64 content.\\n  // Returns the tiddler data (text or binary) or null.\\n  // The type of data (text or binary) is deduced from the tiddler's type.\\n  // Type image/xx means tiddler image.\\n  // Type application/octet-stream means binary data coded with base64. In that case an ArrayBuffer\\n  // is returned.\\n  // Other types means plain text.\\n  TiddlyWiki.load = function(url) {\\n    var func = \\\"TiddlyWiki.load\\\";\\n    if (!url || !url.match(/^tw:/)) return null;\\n    hack.log(\\\"url: \\\"+url, hack.loader, func);\\n    var tiddlerTitle = tiddlyWiki.resolvePath(url.replace(\\\"tw:\\\", \\\"\\\"), true);\\n    var tiddler = $tw.wiki.getTiddler(tiddlerTitle);\\n    if ((typeof(tiddler) == \\\"undefined\\\") || !tiddler) {\\n      throw new Error(\\\"TiddlyWiki.load: \\\\\\\"\\\" + url + \\\"\\\\\\\" : unknown tiddler.\\\");\\n    }\\n    if (tiddler.fields.type.match(/^image\\\\//))\\n      return TiddlyWiki.getRawTiddlerImage(tiddlerTitle);\\n    else {\\n      if (!tiddler.fields.text) {\\n        console.error(\\\"TiddlyWiki.load: \\\\\\\"\\\" + url + \\\"\\\\\\\" seems to be unreachable or the tiddler is empty.\\\");\\n        return null;\\n      }\\n      if (tiddler.fields.type == \\\"application/octet-stream\\\")\\n        return StringView.makeFromBase64(tiddler.fields.text).buffer;\\n      else\\n        return tiddler.fields.text;\\n    }\\n  };\\n\\n  // Export current view to an image tiddler\\n  // Parameters :\\n  //   <domElement> : DOM element, <canvas> or <svg>.\\n  //   <url> : URL with specific syntax : \\\"tw:<tiddler title>\\\".\\n  //   <type> : type of image tiddler : \\\"image/png\\\" (default) or \\\"image/jpeg\\\".\\n  //   <flagOverwrite> : if true, overwrites existing tiddler without asking.\\n  // Saves view data as a tiddler image with required type.\\n  TiddlyWiki.exportToTiddler = function(domElement, url, type, flagOverwrite) {\\n    var func = \\\"TiddlyWiki.exportToTiddler\\\";\\n    if (!url || !url.match(/^tw:/)) {\\n      console.error(func+\\\": bad URL format, not a tiddler.\\\");\\n      return;\\n    }\\n    hack.log(\\\"url: \\\"+url, hack.render, func);\\n    var tag = domElement.tagName.toUpperCase();\\n    if (!type) {\\n      if (tag == \\\"SVG\\\")\\n        type = \\\"image/svg+xml\\\";\\n      else\\n        type = \\\"image/png\\\";\\n    }\\n    if ((((type == \\\"image/png\\\") || (type == \\\"image/jpeg\\\")) && (tag != \\\"CANVAS\\\")) ||\\n        ((type == \\\"image/svg+xml\\\") && (tag != \\\"SVG\\\"))) {\\n      console.error(func+\\\": bad tiddler type : \\\"+type)\\n      return;\\n    }\\n    var tiddlerTitle = tiddlyWiki.resolvePath(url.replace(\\\"tw:\\\", \\\"\\\"), true);\\n    if (!flagOverwrite) {\\n      var tiddler = $tw.wiki.getTiddler(tiddlerTitle);\\n      if ((typeof(tiddler) != \\\"undefined\\\") && tiddler) {\\n        if (!confirm(\\\"View image saving : tiddler <\\\"+tiddlerTitle+\\\"> exists, would you like to overwrite it ?\\\")) return;\\n      }\\n    }\\n    var data = null;\\n    if (tag == \\\"SVG\\\") {\\n      data = domElement.outerHTML;\\n      type = \\\"\\\"; // bad TiddlyWiki behavior (with 5.1.5) !?\\n    } else\\n      data = domElement.toDataURL(type).replace(/^data:.*?;base64,/, \\\"\\\");\\n    //console.log(func+\\\": data = \\\"+data);\\n\\n    // Create the image tiddler\\n    $tw.wiki.addTiddler(new $tw.Tiddler({title: tiddlerTitle, type: type, text: data}));\\n  };\\n\\n  // Create a Worker to execute inline code\\n  TiddlyWiki.createWorker = function (func) {\\n    var blobURL = URL.createObjectURL(new Blob(\\n      [\\\"(\\\", func.toString(), \\\")()\\\"],\\n      {type: \\\"application/javascript\\\"}\\n    ));\\n    var worker = new Worker(blobURL);\\n    URL.revokeObjectURL(blobURL);\\n\\n    return worker;\\n  };\\n\\n\\n  // Instance members\\n\\n  TiddlyWiki.prototype = {\\n\\n    // Resolve file path.\\n    //\\n    // Following behaviour apply only if widget's configuration's object property \\\"filesystem\\\"\\n    // is defined. If not, file is assumed to be a tiddler's title.\\n    //\\n    // File path resolution is as close as possible to Unix (for executables, libraries,\\n    // manuals, ...).\\n    // We make assumption that tiddler title follows classical Unix Path pattern\\n    // like : /dir1/dir2/ ... /dir/file. If not the case, file should be\\n    // in the \\\"current\\\" directory, or completely out of path convention.\\n    // The curent directory (if any) is the \\\"directory\\\" of the current sheet tiddler.\\n    // Example :\\n    //   File to resolve = myTiddler\\n    //   Tiddler title of the current sheet = MyProject/MySubProject/calc1\\n    //   Current directory = MyProject/MySubProject\\n    //   Sheet file in filesystem mode = calc1\\n    //   File path = MyProject/MySubProject/myTiddler\\n    //\\n    // Unlike Unix, there is no notion of root directory or \\\"/\\\". TiddlyWiki has no\\n    // real filesystem so we can't rely on a root node. Relative versus absolute\\n    // path is deduced from the following. If the first caracter of a file\\n    // path is \\\"/\\\" and there is no more \\\"/\\\" after that, then the current directory is \\\"\\\".\\n    // Remark that the behavior is identical to Unix. A file path beginning with a \\\"/\\\"\\n    // will be directly converted in a tiddler title.\\n    // By default (and unlike Unix), malformed path like multiple \\\"/\\\" instead of one\\n    // are not accepted. For example \\\"//\\\" is not reduced to \\\"/\\\" and treated like a\\n    // path separator. It is the responsibility of the user to be clear about the significance of\\n    // it's file reference, path-like name or tiddler title. For same reason,\\n    // blank characters, eventually around \\\"/\\\", are treated like ordinary characters\\n    // and not deleted in the final tiddler title.\\n    // With optionnal <flagNormalize> parameter set, malformed path are normalized like\\n    // Unix does, but blank characters are still not deleted.\\n    //\\n    // If not found in the current directory, a file is searched under a collection\\n    // of path directories, pre-defined in the PATH variable. Those directories are\\n    // absolute (i.e. not relative to current directory).\\n    // Syntax of the PATH variable :\\n    //   <path1>';'<path2>';' ... ';'<pathN>\\n    // The PATH is searched first in a variable defined with a <$set> widget (not actually\\n    // implemented, maybe in the future if someone asks :), then in the \\\"path\\\" parameter\\n    // of the <$edit-socialcalc> widget, then in the widget's configuration object, under\\n    // filesystem.PATH property. The widget's configuration object is searched first in\\n    // $:/config/Three.js tiddler of \\\"application/json\\\" type, then in\\n    // $:/plugins/Three.js/config-defaults.json tiddler.\\n    // Please note that final PATH value is never a combination of different sources. The first\\n    // source that defines a valid PATH (either <$set> variable, \\\"path\\\" parameter of\\n    // <$edit-socialcalc> widget or widget's configuration object) gives the proper PATH value\\n    // and stops all subsequent PATH search.\\n    //\\n    // Search algorithm :\\n    //   <file> : input file path.\\n    //   <tiddlerTitle> : output.\\n    //   <currentTiddlerTitle> : tiddler title of the current sheet.\\n    //   PATH <- value of a \\\"path\\\" variable defined with <$set> widget, or \\\"path\\\" field\\n    //           of <currentTiddlerTitle>.\\n    //   currentDir <- path of <currentTiddlerTitle> (anything before the last '/', or \\\"\\\").\\n    //   if <file> begins with \\\"./\\\" or \\\"../\\\" then\\n    //     # Relative path\\n    //     <finalPath> <- ... (search  la Unix)\\n    //     if tiddler <finalPath> found then return <finalPath>\\n    //   else\\n    //     # Under <currentDir> or under a PATH directory, or absolute\\n    //     if tiddler <currentDir>/<file> found then return <currentDir>/<file>\\n    //     if <PATH> exists then\\n    //       for all <dir> in <PATH>\\n    //         if tiddler <dir>/<file> found then return <dir>/<file>\\n    //       end for\\n    //     end if\\n    //     if tiddler <file> found then return file\\n    //   end if\\n    //\\n    resolvePath: function(file, flagNormalize) {\\n      var fonc = \\\"TiddlyWiki.resolvePath\\\";\\n\\n      hack.log(\\\"============= file = \\\"+file, hack.filesystem, fonc);\\n\\n      if (!file) return null;\\n      var tiddlerTitle = \\\"\\\";\\n      var tiddler = false;\\n      if (!this.widgetConfiguration || !this.widgetConfiguration.filesystem) {\\n        hack.log(\\\"no filesystem in widget's configuration !\\\", hack.filesystem, fonc);\\n        return(file);\\n      }\\n\\n      // Initialisation\\n      var currentTiddlerTitle = this.tiddlerTitle\\n      var currentDir = \\\"\\\";\\n      tiddler = $tw.wiki.getTiddler(currentTiddlerTitle);\\n      if ((typeof(tiddler) == \\\"undefined\\\") || !tiddler) return null;\\n        \\n      // In case current tiddler is edited, we refer to the \\\"file\\\", not the draft tiddler\\n      if (tiddler.isDraft()) currentTiddlerTitle = tiddler.fields[\\\"draft.of\\\"];\\n      hack.log(\\\"currentTiddlerTitle = \\\"+currentTiddlerTitle, hack.filesystem, fonc);\\n        \\n      // Get PATH\\n      var tabPath = null;\\n      if (this.widgetConfiguration.filesystem.PATH && this.widgetConfiguration.filesystem.PATH != \\\"\\\")\\n        tabPath = this.widgetConfiguration.filesystem.PATH.split(/[\\\\s]*;[\\\\s]*/);\\n      hack.log(\\\"tabPath = \\\"+(tabPath ? tabPath.join(\\\" | \\\"): tabPath), hack.filesystem, fonc);\\n\\n      currentDir = currentTiddlerTitle.replace(/[\\\\/][^\\\\/]*$/, \\\"\\\").replace(/[\\\\/][.][\\\\/]/, \\\"/\\\");;\\n      hack.log(\\\"currentDir = \\\"+currentDir, hack.filesystem, fonc);\\n\\n      // File normalization\\n      if (flagNormalize) {\\n        file = file.replace(/[\\\\/][\\\\/]+/g, \\\"/\\\").replace(/\\\\/\\\\.\\\\//g, \\\"/\\\");\\n        hack.log(\\\"file normalized = \\\"+file, hack.filesystem, fonc);\\n      }\\n\\n      if (file.match(/^\\\\.\\\\/|^\\\\.\\\\.\\\\/|\\\\/\\\\.\\\\.\\\\//)) {\\n        // Relative path or with relative sub-expressions\\n          \\n        hack.log(\\\"relative path\\\", hack.filesystem, fonc);\\n        tabCurrentDir = currentDir.split(\\\"/\\\");\\n        hack.log(\\\"tabCurrentDir = \\\"+tabCurrentDir.join(\\\" | \\\"), hack.filesystem, fonc);\\n        tabPageName = file.split(\\\"/\\\");\\n        var tabTiddlerTitle = [];\\n        for (var i = 0; i < tabCurrentDir.length; i++)\\n          tabTiddlerTitle.push(tabCurrentDir[i]);\\n        hack.log(\\\"tabTiddlerTitle = \\\"+tabTiddlerTitle.join(\\\" | \\\"), hack.filesystem, fonc);\\n        var indexInCurrentDir = tabCurrentDir.length - 1;\\n        hack.log(\\\"indexInCurrentDir = \\\"+indexInCurrentDir, hack.filesystem, fonc);\\n        var flagAbsolute = false;\\n        for (var i = 0; i < tabPageName.length; i++) {\\n          hack.log(\\\"boucle: tabPageName[\\\"+i+\\\"] = \\\"+tabPageName[i], hack.filesystem, fonc);\\n          hack.log(\\\"  indexInCurrentDir = \\\"+indexInCurrentDir, hack.filesystem, fonc);\\n          hack.log(\\\"  tabTiddlerTitle = \\\"+tabTiddlerTitle.join(\\\" | \\\"), hack.filesystem, fonc);\\n          if (tabPageName[i] == \\\".\\\") continue;\\n          if (tabPageName[i] == \\\"..\\\") {\\n            indexInCurrentDir--;\\n            if (tabTiddlerTitle.length == 0) {\\n              // Malformed path -> it seems to be an absolute non-path tiddler title\\n              hack.log(\\\"  malformed path case 1\\\", hack.filesystem, fonc);\\n              flagAbsolute = true;\\n              break;\\n            }\\n            tabTiddlerTitle.pop();\\n            continue;\\n          }\\n          indexInCurrentDir++; // alas ! maybe we will return above currentDir\\n          hack.log(\\\"  tabCurrentDir[indexInCurrentDir] = \\\"+tabCurrentDir[indexInCurrentDir], hack.filesystem, fonc);\\n          if (indexInCurrentDir < tabCurrentDir.length - 1) {\\n            // We wander above currentDir\\n            if ((indexInCurrentDir < 0) || (tabPageName[i] != tabCurrentDir[indexInCurrentDir])) {\\n              // Malformed path -> it seems to be an absolute non-path tiddler title\\n              hack.log(\\\"  malformed path case 2\\\", hack.filesystem, fonc);\\n              flagAbsolute = true;\\n              break;\\n            }\\n          }\\n          tabTiddlerTitle.push(tabPageName[i])\\n        }\\n\\n        if (!flagAbsolute) {\\n          tiddlerTitle = tabTiddlerTitle.join(\\\"/\\\");\\n        } else {\\n          tiddlerTitle = file;\\n        }\\n\\n      } else {\\n        // Not relative path\\n        hack.log(\\\"absolute path (under curent dir, PATH dirs or really absolute)\\\", hack.filesystem, fonc);\\n        var flagFind = false;\\n          \\n        // Search under currentDir\\n        tiddlerTitle = currentDir + \\\"/\\\" + file;\\n        var tiddler1 = $tw.wiki.getTiddler(tiddlerTitle);\\n        if ((typeof(tiddler1) != \\\"undefined\\\") && tiddler1)\\n          flagFind = true;\\n          \\n        if (!flagFind && tabPath) {\\n          // Search under PATH directories\\n          for (var i = 0; i < tabPath.length; i++) {\\n            tiddlerTitle = tabPath[i] + \\\"/\\\" + file;\\n            var tiddler2 = $tw.wiki.getTiddler(tiddlerTitle);\\n            if ((typeof(tiddler2) != \\\"undefined\\\") && tiddler2) {\\n              flagFind = true;\\n              break;\\n            }\\n          }\\n        }\\n          \\n        // Maybe a tiddler already\\n        if (!flagFind)\\n          tiddlerTitle = file;\\n      }\\n\\n      hack.log(\\\"============= tiddler = \\\"+tiddlerTitle, hack.filesystem, fonc);\\n      return tiddlerTitle;\\n    }\\n  };\\n\\n  exports.TiddlyWiki = TiddlyWiki;\\n\\n})();\",\n            \"title\": \"$:/plugins/rboue/Three.js/tiddlywiki.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/rboue/Three.js/view3js.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/rboue/Three.js/view3js.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nThe view3js widget displays a 3D view defined in a local tiddler.\\n\\n```\\n<$view3js tiddler=\\\"TiddlerTitle\\\" width=\\\"320\\\" height=\\\"400\\\" class=\\\"classnames\\\"/>\\n```\\n\\nThe widget generates an HTML5 WebGL node with a 3D view produced by main javascript code tiddler.\\n\\nThe width and height attributes are interpreted as a number of pixels, and do not need to include the \\\"px\\\" suffix.\\nThe path attribute contains a collection of pseudo-path directory to search files to be loaded.\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar CONST_NODE_ID_PREFIX = \\\"ThreejsWidget\\\"; // prefix of root node's id attribute\\nvar CONST_MIN_HEIGHT = 300;                 // root node minimal height\\nvar CONST_PLUGIN_PATH = \\\"$:/plugins/rboue/Three.js\\\";\\nvar CONST_CONFIG_TIDDLER = \\\"$:/config/rboue/Three.js\\\";\\nvar CONST_CONFIG_DEFAULT_TIDDLER = CONST_PLUGIN_PATH+\\\"/config.json\\\";\\n\\n// Get session configuration.\\nvar sessionConfig = null;\\nvar configTiddler = $tw.wiki.getTiddler(CONST_CONFIG_TIDDLER);\\nif ((typeof(configTiddler) != \\\"undefined\\\") && configTiddler) {\\n  sessionConfig = $tw.wiki.getTiddlerData(configTiddler, null)\\n}\\nif (!sessionConfig) {\\n  var configTiddlerDefault = $tw.wiki.getTiddler(CONST_CONFIG_DEFAULT_TIDDLER);\\n  if ((typeof(configTiddlerDefault) != \\\"undefined\\\") && configTiddlerDefault) {\\n    sessionConfig = $tw.wiki.getTiddlerData(configTiddlerDefault, null)\\n  }\\n}\\n\\n// Create objects\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\nvar StringView = require(\\\"./Lib/stringview.js\\\").StringView;\\nvar TiddlyWiki = require(\\\"./tiddlywiki.js\\\").TiddlyWiki;\\nTiddlyWiki.init(sessionConfig);\\n\\nvar View3jsWidget = function(parseTreeNode,options) {\\n  this.initialise(parseTreeNode,options);\\n};\\nView3jsWidget.instanceNb = 0; // count class instances\\n\\n// Inherit from the base widget class\\nView3jsWidget.prototype = new Widget();\\n\\n//=======================================================================================\\n\\n// Render this widget into the DOM\\nView3jsWidget.prototype.render = function(parent,nextSibling) {\\n  var fonc = \\\"View3jsWidget.render\\\";\\n  var self = this;\\n\\n  // Debug tools\\n  var hack = {\\n    flagActiv: true, // Activate the logs\\n    log: function(mess, flagNoLog, fonc) {\\n      if (!hack.flagActiv || flagNoLog) return;\\n      var id = \\\"[]\\\";\\n      if (tiddlyWiki) id = \\\"[\\\"+tiddlyWiki.widget.nodeRootId+\\\"]\\\";\\n      console.log(id+(fonc ? fonc+\\\": \\\" : \\\"\\\")+mess);\\n    },\\n    logPoint: function(x,y) {return \\\"(\\\"+x+\\\",\\\"+y+\\\")\\\";},\\n    // Following are flags activating logs for specific fonctionnalities.\\n    // Value : false to activate, true to desactivate (no log).\\n    bug: false,      // current bug investigation\\n    filesystem: true, // filesystem\\n    loader: true,     // loader\\n    sceneLoader: true,  // Scene loader\\n    render: true      // rendering\\n  };\\n  window.hack = hack;\\n\\n  // Create objects (continued)\\n  // Unfortunately, we can't create THREE object at TiddlyWiki start time (i.e. before\\n  // any widget instance) :\\n  //   There is a complaint \\\"ReferenceError: Float32Array is not defined\\\" because a lot\\n  //   of code is running at load time (many functions auto-defines themselves, allocating\\n  //   Float32Array and returning a sub-function.\\n  //   Float32Array is an object specific to WebGL. It seems that TiddlyWiki denies the use\\n  //   of WebGL in sandbox environment !\\n  // The THREE module is loaded only once, thanks to the TiddlyWiki's load mechanism.\\n  window.StringView = StringView;\\n  window.TiddlyWiki = TiddlyWiki;\\n  window.THREE = require(\\\"./Lib/three-min.js\\\").THREE;\\n\\n  this.parentDomNode = parent;\\n  this.computeAttributes();\\n  this.execute();\\n\\n  // Create element and assign attributes\\n  this.nodeRoot = this.document.createElement(\\\"div\\\");\\n  this.nodeRootId = CONST_NODE_ID_PREFIX + \\\"-\\\" + ++View3jsWidget.instanceNb;\\n  this.nodeRoot.setAttribute(\\\"id\\\", this.nodeRootId);\\n  if (this[\\\"class\\\"])\\n    this.nodeRoot.setAttribute(\\\"class\\\", this[\\\"class\\\"]);\\t\\t\\n  if (this.width) {\\n    var widthStyle = parseInt(this.width,10) + \\\"px\\\";\\n    this.nodeRoot.setAttribute(\\\"width\\\", widthStyle);\\n    this.nodeRoot.style.width = widthStyle;\\n  }\\n  if (this.height) {\\n    var heightStyle = parseInt(this.height,10) + \\\"px\\\";\\n    this.nodeRoot.setAttribute(\\\"height\\\", heightStyle);\\n    this.nodeRoot.style.height = heightStyle;\\n  } else {\\n    this.nodeRoot.setAttribute(\\\"height\\\", \\\"\\\" + CONST_MIN_HEIGHT + \\\"px\\\");\\n    this.nodeRoot.style.height = \\\"\\\" + CONST_MIN_HEIGHT + \\\"px\\\";\\n  }\\n\\n  // Insert element\\n  parent.insertBefore(this.nodeRoot,nextSibling);\\n  this.domNodes.push(this.nodeRoot);\\n\\n  // UI template\\n  var uiNodeCreate = function(id, that) {\\n    // Create a node : <div id=\\\"<id>\\\"></div>\\n    var node = that.document.createElement(\\\"div\\\");\\n    node.setAttribute(\\\"id\\\", id);\\n    parent.insertBefore(node, nextSibling);\\n    that.domNodes.push(node);\\n    return node;\\n  };\\n  this.nodeError = uiNodeCreate(this.nodeRootId + \\\"-error\\\", this);\\n\\n  // Test browser compatibility with WebGL\\n  var webgl = (function () {\\n    try {\\n      var canvas = document.createElement(\\\"canvas\\\");\\n      return !! window.WebGLRenderingContext && (canvas.getContext(\\\"webgl\\\") || canvas.getContext(\\\"experimental-webgl\\\"));\\n    } catch(e) {\\n      return false;\\n    }\\n  })();\\n  if (!webgl) {\\n    this.nodeError.innerHTML = window.WebGLRenderingContext ?\\n      'Your graphics card does not seem to support <a href=\\\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\\\" target=\\\"_blank\\\">WebGL</a>.<br/>' +\\n      'Find out how to get it <a href=\\\"http://get.webgl.org/\\\" target=\\\"_blank\\\">here</a>.'\\n      :\\n      'Your browser does not seem to support <a href=\\\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\\\" target=\\\"_blank\\\">WebGL</a>.<br/>' +\\n      'Find out how to get it <a href=\\\"http://get.webgl.org/\\\" target=\\\"_blank\\\">here</a>.';\\n    return;\\n  }\\n\\n  // Get code tiddler\\n  if (!this.tiddler) {\\n    this.nodeError.innerHTML = \\\"Error: you must specify a code tiddler\\\";\\n    return;\\n  }\\n  var tiddler = this.wiki.getTiddler(this.tiddler);\\n  if ((typeof(tiddler) == \\\"undefined\\\") || !tiddler) {\\n    this.nodeError.innerHTML = \\\"Error: unknown tiddler: \\\"+this.tiddler;\\n    return;\\n  }\\n\\n  // Get widget configuration\\n  var widgetConfig = {};\\n  if (this.path) {\\n    widgetConfig.filesystem = {PATH: this.path};\\n  } else {\\n    if (sessionConfig && sessionConfig.filesystem) {\\n      widgetConfig.filesystem = {};\\n      if (sessionConfig.filesystem.PATH)\\n        widgetConfig.filesystem.PATH = sessionConfig.filesystem.PATH;\\n    }\\n  }\\n\\n  window.tiddlyWiki = new TiddlyWiki(this, this.tiddler, widgetConfig);\\n\\n  // Create viewer\\n\\n  // Execute user code\\n  // Prototype :\\n  //   function main(input)\\n  //     Returns : {onTiddlerRefresh: <refresh function>}\\n  //\\n  this.input = {node: this.nodeRoot};\\n  try {\\n    this.output = eval(tiddler.fields.text+\\\";main(this.input);\\\");\\n  } catch(e) {\\n    this.nodeError.innerHTML = \\\"Error when executing javascript code in <b>\\\"+this.tiddler+\\\"</b> tiddler :<br><b>\\\"+e+\\\"</b>\\\";\\n    alert(\\\"Stop on error\\\"); // stop debug and log in case of deaf mad program\\n  }\\n};\\n  \\n// Compute the internal state of the widget\\nView3jsWidget.prototype.execute = function() {\\n  // Get our parameters\\n  this.tiddler = this.getAttribute(\\\"tiddler\\\");\\n  this.width = this.getAttribute(\\\"width\\\");\\n  this.height = this.getAttribute(\\\"height\\\");\\n  this.path = this.getAttribute(\\\"path\\\");\\n  this[\\\"class\\\"] = this.getAttribute(\\\"class\\\");\\n};\\n\\n// Selectively refreshes the widget if needed. Returns true if the widget or any\\n// of its children needed re-rendering\\nView3jsWidget.prototype.refresh = function(changedTiddlers) {\\n  var fonc = \\\"View3jsWidget.refresh\\\";\\n\\n  var changedAttributes = this.computeAttributes();\\n  if (changedAttributes.tiddler ||\\n      changedAttributes.width ||\\n      changedAttributes.height ||\\n      changedAttributes.path ||\\n      changedAttributes[\\\"class\\\"] ||\\n      changedTiddlers[this.tiddler]) {\\n    this.refreshSelf();\\n    //hack.log(\\\"after this.refreshSelf()\\\", false, fonc);\\n    return true;\\n  } else {\\n    //hack.log(\\\"other case\\\", false, fonc);\\n    if (this.output && this.output.onTiddlerRefresh) this.output.onTiddlerRefresh();\\n    return false;\\t\\t\\n  }\\n};\\n\\nexports.view3js = View3jsWidget;\\n\\n})();\\n\",\n            \"title\": \"$:/plugins/rboue/Three.js/view3js.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        }\n    }\n}","author":"rboue","bag":"default","core-version":">=5.1.1","dependents":"","description":"Three.js","list":"readme license","plugin-type":"plugin","revision":"0","title":"$:/plugins/rboue/Three.js","version":"1.0.0","name":"Three.js"}