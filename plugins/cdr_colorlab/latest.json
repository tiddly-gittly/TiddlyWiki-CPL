{"title":"$:/plugins/cdr/colorlab","name":"Color Library","description":"Color manipulation library","author":"cdruan","list":"","version":"0.2.0","plugin-type":"plugin","dependents":"","type":"application/json","text":"{\"tiddlers\":{\"$:/plugins/cdr/colorlab/action-wikifypalette.js\":{\"title\":\"$:/plugins/cdr/colorlab/action-wikifypalette.js\",\"text\":\"/*\\\\\\n\\ntitle: $:/plugins/cdr/colorlab/action-wikifypalette.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nParse the given palette and converts all entry values to color strings--execute\\nany macros/filters/transclusions if necessary.\\n\\\\*/\\n(function(){\\n\\n\\t/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\nvar WikifyPaletteWidget = function(parseTreeNode,options) {\\n\\tthis.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nWikifyPaletteWidget.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nWikifyPaletteWidget.prototype.render = function(parent,nextSibling) {\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nWikifyPaletteWidget.prototype.execute = function() {\\n\\tthis.srcTiddler = this.getAttribute(\\\"palette\\\",this.wiki.getTiddlerText(\\\"$:/palette\\\"));\\n\\tthis.dstTiddler = this.getAttribute(\\\"save\\\",\\\"$:/state/wikified-palette\\\");\\n};\\n\\n/*\\nRefresh the widget by ensuring our attributes are up to date\\n*/\\nWikifyPaletteWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\tif(changedAttributes[\\\"$message\\\"] || changedAttributes[\\\"$prompt\\\"]) {\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t}\\n\\treturn this.refreshChildren(changedTiddlers);\\n};\\n\\n/*\\nInvoke the action associated with this widget\\n*/\\nWikifyPaletteWidget.prototype.invokeAction = function(triggeringWidget,event) {\\n\\tvar srcTiddler = this.wiki.getTiddler(this.srcTiddler);\\n\\n\\tif (! srcTiddler) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tvar data = this.wiki.getTiddlerData(srcTiddler);\\n\\n\\t// rgba values where r,g,b in [0..255]\\n\\tvar rgbaToHex = function(rgba) {\\n\\t\\t\\tif (!rgba || rgba.length < 4) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\t\\t\\t// scale alpha to 0..255\\n\\t\\t\\tvar alpha = Math.round(rgba[3] * 255)\\n\\t\\t\\tvar hex = [rgba[0],rgba[1],rgba[2],alpha].map(function(e) {\\n\\t\\t\\t\\treturn (\\\"0\\\" + e.toString(16)).slice(-2);\\n\\t\\t\\t});\\n\\n\\t\\t\\tvar hexstr = \\\"#\\\" + hex.join(\\\"\\\");\\n\\n\\t\\t\\tif (alpha == 255) {\\n\\t\\t\\t\\treturn hexstr.slice(0,7);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn hexstr;\\n\\t\\t};\\n\\n\\tvar macro = {\\n\\t\\tbody: '<$transclude tiddler=\\\"'+ this.srcTiddler + '\\\" index=\\\"$name$\\\"/>',\\n\\t\\tparams: [ {name: \\\"name\\\",default: \\\"\\\"} ]\\n\\t};\\n\\tthis.setVariable(\\\"colour\\\",macro.body,macro.params,true);\\n\\tthis.setVariable(\\\"color\\\",macro.body,macro.params,true);\\n\\n\\tfor (var key in data) {\\n\\t\\tvar colorString = utils.wikifyText(data[key],this);\\n\\t\\tvar color = Color.parse(colorString);\\n\\t\\tif (color && $tw.browser && color.space && color.space !== \\\"rgb\\\") {\\n\\t\\t\\tif (window.matchMedia(\\\"(color-gamut: p3)\\\").matches) {\\n\\t\\t\\t\\tcolorString = (new Color(color)).toString(\\\"p3\\\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcolorString = (new Color(color)).toString(\\\"rgb\\\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tdata[key] = colorString;\\n\\t}\\n\\n\\tvar newFields = {\\n\\t\\ttitle: this.dstTiddler,\\n\\t\\ttags: \\\"$:/tags/Palette\\\",\\n\\t\\tname: srcTiddler.fields.name,\\n\\t\\tdescription: srcTiddler.fields.description,\\n\\t\\ttype: \\\"application/x-tiddler-dictionary\\\",\\n\\t\\tsource: this.srcTiddler\\n\\t};\\n\\tnewFields.text = $tw.utils.makeTiddlerDictionary(data);\\n\\n\\tif(srcTiddler.fields['color-scheme']) {\\n\\t\\tnewFields['color-scheme'] = srcTiddler.fields['color-scheme'];\\n\\t}\\n\\tthis.wiki.addTiddler(new $tw.Tiddler(this.wiki.getCreationFields(),newFields));\\n\\treturn true; // Action was invoked\\n};\\n\\nWikifyPaletteWidget.prototype.allowActionPropagation = function() {\\n\\treturn false;\\n};\\n\\nexports[\\\"action-wikifypalette\\\"] = WikifyPaletteWidget;\\n\\n})();\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/cdr/colorlab/color-alpha.js\":{\"title\":\"$:/plugins/cdr/colorlab/color-alpha.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/color-alpha.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nManipulate alpha component of a color or return given color's alpha value.\\n\\\\*/\\n\\n(function(){\\n\\n/* jslint node: true, browser: true */\\n/* global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"color-alpha\\\";\\n\\nexports.params = [\\n\\t{name: \\\"color\\\"},\\n\\t{name: \\\"value\\\"}\\n];\\n\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\nexports.run = function(color,value) {\\n\\tcolor = new Color(utils.wikifyText(color,this));\\n\\n\\tif (value === void(0) || value.trim() === \\\"\\\") {\\n\\t\\treturn color.alpha.toString();\\n\\t}\\n\\n\\tvar num = isNaN(value) ? 0 : parseFloat(value);\\n\\n\\tcolor.alpha = num;\\n\\treturn color.toString();\\n};\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/cdr/colorlab/color-autocontrast.js\":{\"title\":\"$:/plugins/cdr/colorlab/color-autocontrast.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/color-autocontrast.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nGenerates a contrasting color. If the given color is dark enough,\\nreturns white as the contrast color; otherwise, returns the darker version\\nof the input color. Alpha is ignored.\\n\\nWhen given the optional \\\"against\\\" parameter, generate constrasting color against\\nthis parameter.\\n\\\\*/\\n\\n(function(){\\n\\n/* jslint node: true, browser: true */\\n/* global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"color-autocontrast\\\";\\n\\nexports.params = [\\n\\t{name: \\\"color\\\"},\\n\\t{name: \\\"against\\\"}\\n];\\n\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\nexports.run = function(color,against) {\\n\\tcolor = new Color(utils.wikifyText(color,this));\\n\\n\\tvar colorLight = color.lightness;\\n\\n\\tif (against === \\\"\\\") {\\n\\t\\t// return color based color's lightness\\n\\t\\tif(colorLight < utils.MaxContrastWhite) {\\n\\t\\t\\treturn \\\"#ffffff\\\";\\n\\t\\t}\\n\\n\\t\\tcolor.lightness = 20;\\n\\t\\treturn color.toString('rgb');\\n\\t} else {\\n\\t\\tagainst = new Color(utils.wikifyText(against,this));\\n\\t\\tvar againstLight = against.lightness;\\n\\n\\t\\tif (Math.abs(colorLight - againstLight) < 35) {\\n\\t\\t\\tcolorLight = againstLight + (againstLight < 50 ? 35 : -35);\\n\\t\\t}\\n\\t\\tcolor.lightness = colorLight;\\n\\t\\treturn color.toString('rgb');\\n\\t}\\n};\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/cdr/colorlab/color-deviate.js\":{\"title\":\"$:/plugins/cdr/colorlab/color-deviate.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/color-deviate.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nAdjust the color a bit. If the color is on the dark side, make it slightly\\nlighter; and make a light color slightly darker.\\n\\\\*/\\n\\n(function(){\\n\\n/* jslint node: true, browser: true */\\n/* global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"color-deviate\\\";\\n\\nexports.params = [\\n\\t{name: \\\"color\\\"},\\n];\\n\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\nexports.run = function(color,value) {\\n\\tcolor = new Color(utils.wikifyText(color,this));\\n\\n\\tvar lightness = color.lightness;\\n\\tvar adjust;\\n\\n\\tvar newval;\\n\\tif(lightness < 40) {\\n\\t\\tnewval = 0.085 * Math.pow(lightness,1.45) + 28;\\n\\t} else {\\n\\t\\tnewval = lightness - Math.pow(Math.max(100-lightness,11),0.79) * 0.4;\\n\\t}\\n\\tcolor.lightness = newval;\\n\\treturn color.toString();\\n};\\n\\n})();\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/cdr/colorlab/color-eval.js\":{\"title\":\"$:/plugins/cdr/colorlab/color-eval.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/color-eval.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nReturns a color string that is supported by the browser. Can be used to\\n\\\"downgrade\\\" a p3 color string on browsers that don't support p3 color space.\\n\\\\*/\\n\\n(function(){\\n\\n/* jslint node: true, browser: true */\\n/* global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"color-eval\\\";\\n\\nexports.params = [\\n\\t{name: \\\"color\\\"},\\n];\\n\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\nexports.run = function(color) {\\n\\tvar cssColor = utils.wikifyText(color,this);\\n\\tcolor = Color.parse(cssColor);\\n\\tif (! color) {\\n\\t\\treturn \\\"\\\";\\n\\t}\\n\\n\\tif (color.space && color.space !== \\\"rgb\\\" && $tw.browser) {\\n\\t\\tif (window.matchMedia(\\\"(color-gamut: p3)\\\").matches) {\\n\\t\\t\\treturn (new Color(color)).toString(\\\"p3\\\");\\n\\t\\t}\\n\\t\\treturn (new Color(color)).toString(\\\"rgb\\\");\\n\\t}\\n\\treturn cssColor;\\n};\\n\\n})();\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/cdr/colorlab/color-filters.js\":{\"title\":\"$:/plugins/cdr/colorlab/color-filters.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/color-filters.js\\ntype: application/javascript\\nmodule-type: filteroperator\\n\\nFilter operators for colors.\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\n/*\\n * input:     ignored\\n * parameter: index name in palette, e.g. page-background\\n * output:    color value, currently an rgb[a] value\\n */\\nexports.colour = function(source,operator,options) {\\n\\tif (operator.operand.trim().length === 0) {\\n\\t\\treturn [];\\n\\t}\\n\\n\\tvar text = \\\"<<colour \\\\\\\"\\\" + operator.operand + \\\"\\\\\\\">>\\\",\\n\\t    color = utils.wikifyText(text,options.widget);\\n\\tif (color !== \\\"\\\") {\\n\\t\\treturn [color];\\n\\t}\\n\\n\\treturn [];\\n};\\n\\nexports.lightness = makeColorBinaryOperator(\\\"color-lightness\\\");\\n\\nexports.alpha = makeColorBinaryOperator(\\\"color-alpha\\\");\\n\\nexports.mute = makeColorBinaryOperator(\\\"color-mute\\\");\\n\\n/*\\nMix input with the operand with optional second operand specifying the\\nweighting for the operand (default=0.5).\\n*/\\nexports.mix = function(source,operator,options) {\\n\\tvar result = [],\\n\\t\\tmacro = $tw.macros[\\\"color-mix\\\"];\\n\\t\\t//colorStr = utils.wikifyText(operator.operands[0].trim(),options.widget);\\n\\n\\tsource(function(tiddler,title) {\\n\\t\\tresult.push(macro.run.call(options.widget,title,operator.operand.trim(),operator.operands[1]));\\n\\t});\\n\\treturn result;\\n};\\n\\nexports.over = makeColorBinaryOperator(\\\"color-over\\\");\\n\\nexports.autocontrast = makeColorBinaryOperator(\\\"color-autocontrast\\\");\\n\\n/*\\nMix input with the operand with optional second operand specifying the\\nweighting for the operand (default=0.5).\\n*/\\nexports.deviate =  makeColorBinaryOperator(\\\"color-deviate\\\");\\n\\nfunction makeColorBinaryOperator(macroName) {\\n\\treturn function(source,operator,options) {\\n\\t\\toptions = options || {widget: $tw.rootWidget};\\n\\t\\tvar result = [];\\n\\t\\tvar macro = $tw.macros[macroName];\\n\\n\\t\\tsource(function(tiddler,title) {\\n\\t\\t\\tresult.push(macro.run.call(options.widget,title,operator.operand.trim()));\\n\\t\\t});\\n\\t\\treturn result;\\n\\t};\\n}\\n})();\",\"type\":\"application/javascript\",\"module-type\":\"filteroperator\"},\"$:/plugins/cdr/colorlab/color-lightness.js\":{\"title\":\"$:/plugins/cdr/colorlab/color-lightness.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/color-lightness.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nManipulate lightness component of a color (in LCH space) or return given\\ncolor's lightness value.\\n\\\\*/\\n\\n(function(){\\n\\n/* jslint node: true, browser: true */\\n/* global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"color-lightness\\\";\\n\\nexports.params = [\\n\\t{name: \\\"color\\\"},\\n\\t{name: \\\"value\\\"}\\n];\\n\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\nexports.run = function(color,value) {\\n\\tcolor = new Color(utils.wikifyText(color,this));\\n\\n\\tif (value === void(0) || value.trim() === \\\"\\\") {\\n\\t\\treturn color.lightness.toString();\\n\\t}\\n\\n\\tvar num, lightness = color.lightness;\\n\\n\\tif (!isNaN(value)) {\\n\\t\\tnum = parseFloat(value);\\n\\t\\tif(value[0] === \\\"+\\\" || value[0] === \\\"-\\\") {\\n\\t\\t\\tnum += lightness;\\n\\t\\t\\tnum = Math.min(Math.max(0,num),100);\\n\\t\\t}\\n\\t} else {\\n\\t\\tvar re = /^\\\\s*(min|max|range)\\\\(([^)]+)\\\\)\\\\s*$/;\\n\\t\\tvar m = value.match(re);\\n\\n\\t\\tif (m) {\\n\\t\\t\\tswitch(m[1]) {\\n\\t\\t\\tcase \\\"min\\\":\\n\\t\\t\\t\\tnum = parseFloat(m[2]);\\n\\t\\t\\t\\tnum = Math.min(Math.max(num,lightness),100);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"max\\\":\\n\\t\\t\\t\\tnum = parseFloat(m[2]);\\n\\t\\t\\t\\tnum = Math.max(Math.min(num,lightness),0);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"range\\\":\\n\\t\\t\\t\\tvar args = m[2].split(',');\\n\\t\\t\\t\\targs[0] = parseFloat(args[0]) || 0;\\n\\t\\t\\t\\targs[1] = parseFloat(args[1]) || 0;\\n\\t\\t\\t\\tnum = Math.min(Math.max(lightness,args[0]),args[1]);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tnum = 0;\\n\\t\\t}\\n\\t}\\n\\n\\tcolor.lightness = num;\\n\\treturn color.toString();\\n};\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/cdr/colorlab/color-mix.js\":{\"title\":\"$:/plugins/cdr/colorlab/color-mix.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/color-mix.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nMix two colors.\\n\\\\*/\\n\\n(function(){\\n/* jslint node: true, browser: true */\\n/* global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"color-mix\\\";\\n\\nexports.params = [\\n\\t{name: \\\"color1\\\"},\\n\\t{name: \\\"color2\\\"},\\n\\t{name: \\\"weight\\\",default: 0.5}\\n];\\n\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\n/**\\n * Computes weighted average of two colors in LCH color space\\n * @param {Color} color1\\n * @param {Color} color2\\n * @param {number} [weight=0.5] weight [0..1] given to color2 in blend\\n * @returns {Color} The blended color\\n */\\nexports.run = function(color1,color2,weight) {\\n\\tcolor1 = new Color(utils.wikifyText(color1,this));\\n\\tcolor2 = new Color(utils.wikifyText(color2,this));\\n\\n\\tif (weight === void(0) || isNaN(weight)) {\\n\\t\\tweight = 0.5;\\n\\t} else {\\n\\t\\tweight = isNaN(weight) ? 0.5 : parseFloat(weight);\\n\\t}\\n\\n\\treturn color1.mix(color2,weight).toString();\\n};\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/cdr/colorlab/color-mute.js\":{\"title\":\"$:/plugins/cdr/colorlab/color-mute.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/color-mute.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nAdjust the saturation/chroma of the color.\\n\\\\*/\\n\\n(function(){\\n\\n/* jslint node: true, browser: true */\\n/* global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"color-mute\\\";\\n\\nexports.params = [\\n\\t{name: \\\"color\\\"},\\n];\\n\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\n/*\\nThis is an ad hoc function to tone down a color. Avoid pale color to be too\\ngray. Make dark colors paler, i.e. bring up their lightness level.\\n*/\\nexports.run = function(color) {\\n\\t// avoid wide-gamut color space by bringing color down to sRGB\\n\\tcolor = (new Color(utils.wikifyText(color,this))).to(\\\"rgb\\\");\\n\\tvar lch = color.lch;\\n\\tvar percent = 30;        // chroma reduction\\n\\tvar lightness = lch[0];\\n\\n\\tif (lightness >= 70) {\\n\\t\\tvar b=200; // higher the less decrease\\n\\n\\t\\t// lower the lightness slightly as it approaches 100\\n\\t\\tlightness = b * Math.atan((lightness - 30)/b)+30;\\n\\n\\t\\t// less chroma reduction as lightness goes up\\n\\t\\tpercent = 22 * (1 + (87 - lightness)/87);\\n\\t} else if (lightness < 30) {\\n\\t\\tlightness = 0.3 * lightness + 21;\\n\\t}\\n\\n\\tlch[0] = lightness;\\n\\tlch[1] -= lch[1] * percent/100;\\n\\tcolor.lch = lch;\\n\\treturn color.toString('rgb');\\n};\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/cdr/colorlab/color-over.js\":{\"title\":\"$:/plugins/cdr/colorlab/color-over.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/color-over.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nAlpha composite with source over operator\\n\\\\*/\\n\\n(function(){\\n/* jslint node: true, browser: true */\\n/* global $tw: false */\\n\\\"use strict\\\";\\n\\nexports.name = \\\"color-over\\\";\\n\\nexports.params = [\\n\\t{name: \\\"top\\\"},\\n\\t{name: \\\"bottom\\\"},\\n];\\n\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\n/**\\n * Computes weighted average of two colors in LCH color space\\n * @param {Color} top top color\\n * @param {Color} bottom bottom color\\n * @returns {Color} returns top over bottom composite result\\n */\\nexports.run = function(top,bottom) {\\n\\ttop = new Color(utils.wikifyText(top,this));\\n\\tbottom = new Color(utils.wikifyText(bottom,this));\\n\\n\\treturn top.over(bottom).toString('rgb');\\n};\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/core/modules/macros/contrastcolour.js\":{\"title\":\"$:/core/modules/macros/contrastcolour.js\",\"text\":\"/*\\\\\\ntitle: $:/core/modules/macros/contrastcolour.js\\ntype: application/javascript\\nmodule-type: macro\\n\\nRedefine contrastcolour. Wikify the arguments first and slightly preferrs\\nlighter contrast to the dark one.\\n\\\\*/\\n\\n(function(){\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar Color = require(\\\"$:/plugins/cdr/colorlab/lib/color.js\\\");\\nvar utils = require(\\\"$:/plugins/cdr/colorlab/twutils.js\\\");\\n\\nexports.name = \\\"contrastcolour\\\";\\n\\nexports.params = [\\n\\t{name: \\\"target\\\"},\\n\\t{name: \\\"fallbackTarget\\\"},\\n\\t{name: \\\"colourA\\\"},\\n\\t{name: \\\"colourB\\\"}\\n];\\n\\nexports.run = function(target,fallbackTarget,colourA,colourB) {\\n\\tvar colTarget = new Color(utils.wikifyText(target,this) || utils.wikifyText(fallbackTarget,this));\\n\\n\\tvar colA = new Color(utils.wikifyText(colourA,this));\\n\\tvar colB = new Color(utils.wikifyText(colourB,this));\\n\\n\\tif (colTarget.alpha === 0) {\\n\\t\\treturn colA.toString();\\n\\t}\\n\\n\\tvar contrastA = colTarget.contrast(colA),\\n\\t    contrastB = colTarget.contrast(colB);\\n\\n\\tvar lightnessTarget = colTarget.lightness;\\n\\tvar minContrast = 3.1;\\n\\n\\t// if target is dark enough, prefer light contrast, even if contrast ratio is insufficient\\n\\tif (lightnessTarget <= utils.MaxContrastWhite) {\\n\\t\\tvar lightnessA = colA.lightness,\\n\\t\\t    lightnessB = colB.lightness;\\n\\n\\t\\tif (lightnessA >= lightnessB) {\\n\\t\\t\\treturn (contrastA >= minContrast ? colA.toString() : \\\"#ffffff\\\");\\n\\t\\t}\\n\\t\\treturn (contrastB >= minContrast ? colB.toString() : \\\"#ffffff\\\");\\n\\t}\\n\\n\\tif (contrastA < minContrast && contrastB < minContrast) {\\n\\t\\treturn \\\"#000000\\\";\\n\\t}\\n\\treturn (contrastA >= contrastB ? colA.toString() : colB.toString());\\n};\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"macro\"},\"$:/plugins/cdr/colorlab/demo/lightness\":{\"title\":\"$:/plugins/cdr/colorlab/demo/lightness\",\"type\":\"text/vnd.tiddlywiki\",\"samples\":\"#098cff  #cddc39  #511ab2  #d3effd\",\"text\":\"\\\\define tempTiddler() $:/temp/demo/lch\\n\\n\\\\define colorboxStyle()\\nbackground-color:<$macrocall $name=\\\"color-eval\\\" color=\\\"$(color)$\\\" />;\\nborder-color:$(color)$;\\ncolor:<$macrocall $name=\\\"color-autocontrast\\\" color=\\\"$(color)$\\\" />;\\nfont-size:0.95em;\\nwidth: 220px;\\n\\\\end\\n\\n\\\\define colortextStyle()\\ncolor:$(color)$;\\ntext-align: center;\\nfont-weight: 400;\\n\\\\end\\n\\n\\\\define showResult()\\n<$wikify name=color text=\\\"\\\"\\\"<$macrocall $name=\\\"color-lightness\\\" color={{{[<tempTiddler>get[result]] ~[[#000000]]}}} value={{{[<tempTiddler>get[text]] ~[[0]]}}}/>\\\"\\\"\\\">\\n<$wikify name=boxstyle text=<<colorboxStyle>> >\\n\\t<span class=\\\"demo-colorbox\\\" style=<<boxstyle>> >\\n\\t<$text text=<<color>> />\\n\\t</span> <span style=<<colortextStyle>> > sample text </span>\\n</$wikify>\\n</$wikify>\\n\\\\end\\n\\n<div style=\\\"display:flex;align-items:center\\\">\\nLightness:\\n<$range class=\\\"demo-rangectrl\\\" tiddler=<<tempTiddler>> min=\\\"0\\\" max=\\\"100\\\" default=\\\"0\\\" increment=\\\"1\\\"/>\\n<$text text={{{[<tempTiddler>get[text]fixed[2]]}}}/>\\n</div>\\n<<showResult>>\\n\\n<p>Enter a color and click on the ''Reset'' button to see the color's lightness value:</p>\\n<$edit-text tiddler=<<tempTiddler>> field=\\\"initial\\\" placeholder=\\\"css color string\\\" default=\\\"\\\"/>&ensp;\\n<$wikify name=initialLight text=\\\"\\\"\\\"<$macrocall $name=\\\"color-lightness\\\" color={{{[<tempTiddler>get[initial]]}}} />\\\"\\\"\\\">\\n<$button>\\n<$action-setfield $tiddler=<<tempTiddler>> text=<<initialLight>> result={{{ [<tempTiddler>get[initial]] }}} />Reset\\n</$button>\\n</$wikify>\\n\\n!! Sample Colors:\\n\\nClick on a color to see its lightness value.\\n\\n<div style=\\\"margin-top:10px; display:flex; flex-flow: row wrap;\\\">\\n<$list filter=\\\"[list[!!samples]]\\\" variable=\\\"color\\\">\\n<div style=<<colortextStyle>>>\\n\\t<$wikify name=boxstyle text=<<colorboxStyle>> >\\n\\t<$button class=\\\"demo-colorbox\\\" style=<<boxstyle>> >\\n\\t<$text text=<<color>> />\\n\\t<$wikify name=initialLight text=\\\"\\\"\\\"<$macrocall $name=\\\"color-lightness\\\" color=<<color>> />\\\"\\\"\\\">\\n\\t\\t<$action-setfield $tiddler=<<tempTiddler>> text=<<initialLight>> result=<<color>> initial=<<color>> />\\n\\t</$wikify>\\n\\t</$button>\\n\\t</$wikify><br/>\\n\\tHello World\\n</div>\\n\\n</$list>\\n</div>\\n\\n\"},\"$:/plugins/cdr/colorlab/demo/styles.css\":{\"title\":\"$:/plugins/cdr/colorlab/demo/styles.css\",\"tags\":\"$:/tags/Stylesheet\",\"type\":\"text/css\",\"text\":\".demo-colorbox{\\n  display: inline-block;\\n  font-weight:500;\\n  text-align:center;\\n  width:190px;\\n  margin:10px 5px 0px;\\n  padding:15px 10px;\\n}\\n\\n.demo-rangectrl {\\n  margin: 3px 10px 0px;\\n  width: 45%;\\n}\\n\"},\"$:/plugins/cdr/colorlab/lib/color.js\":{\"title\":\"$:/plugins/cdr/colorlab/lib/color.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/lib/color.js\\ntype: application/javascript\\nmodule-type: library\\n\\nColor manipulation library\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar Convert = require(\\\"$:/plugins/cdr/colorlab/lib/convert.js\\\");\\nvar parseColorString = require(\\\"$:/plugins/cdr/colorlab/lib/parse.js\\\");\\n\\nif (!Array.isArray) {\\n\\tArray.isArray = function (arg) {\\n\\t\\treturn Object.prototype.toString.call(arg) === '[object Array]';\\n\\t};\\n}\\n\\nfunction clone(obj) {\\n\\treturn JSON.parse(JSON.stringify(obj));\\n}\\n\\n/*\\nCreate a Color object. If unable to process the input, rgba(0,0,0,0) is\\ncreated.\\n\\nValid inputs are:\\n- CSS color string\\n- object: {space, coords, alpha}\\n- array with [0..255] rgb values and optional alpha in [0..1]\\n- multiple arguments: space, coords, [alpha]\\n*/\\nfunction Color(color,optCoords,optAlpha) {\\n\\t// If we are called as a function, call using new instead\\n\\tif (!(this instanceof Color)) {\\n\\t\\treturn new Color(color,optCoords,optAlpha);\\n\\t}\\n\\n\\tvar alpha = 1;\\n\\n\\tObject.defineProperty(this,'alpha',{\\n\\t\\tget: function() { return alpha;},\\n\\t\\tset: function(a) { alpha = Convert.clamp(a,0,1); }\\n\\t});\\n\\n\\t// If input is already a Color, return a copy of itself\\n\\tif (color instanceof Color) {\\n\\t\\tthis.space = color.space;\\n\\t\\tthis.coords = color.coords.slice(0);\\n\\t\\tthis.alpha = color.alpha;\\n\\t\\treturn;\\n\\t}\\n\\n\\tif (typeof color === \\\"string\\\" || color instanceof String) {\\n\\t\\tcolor = parseColorString(color);\\n\\t}\\n\\n\\t// If input is an array, assumes it contains rgb tuple in [0..255]\\n\\tif (Array.isArray(color) && color.length >= 3) {\\n\\t\\tsetupInternal.call(this,\\\"rgb\\\",\\n\\t\\t\\tcolor.slice(0,3).map(function(e) {return e/255;}),\\n\\t\\t\\tcolor.length > 3 ? color[3] : 1)\\n\\t} else if (color && typeof color === \\\"object\\\" && color.space) {\\n\\t\\tsetupInternal.call(this,color.space,color.coords,color.alpha);\\n\\t} else if (arguments.length >= 2 && Array.isArray(arguments[1])) {\\n\\t\\tsetupInternal.call(this,arguments[0],arguments[1],arguments[2]);\\n\\t} else {\\n\\t\\tsetupInternal.call(this,\\\"rgb\\\",[0,0,0],0);\\n\\t}\\n}\\n\\n/*\\nFor each color space, set up getter and setter to the coords of the\\ngiven space. Example:\\n\\ncoords = color.rgb;   // returns coords in rgb color space\\ncolor.lab = coords;   // changes the color by using the coords in lab space\\n*/\\nObject.keys(Convert.spaces).forEach(function(id) {\\n\\tObject.defineProperty(Color.prototype,id,{\\n\\t\\tget: function() {\\n\\t\\t\\treturn convert(this.space,this.coords,id);\\n\\t\\t},\\n\\t\\tset: function(coords) {   // e.g. color.lch = coords\\n\\t\\t\\tcoords = coords.slice(0);\\n\\t\\t\\tConvert.getSpace(id).clip(coords);\\n\\t\\t\\tthis.coords = convert(id,coords,this.space);\\n\\t\\t}\\n\\t})\\n},this);\\n\\nfunction setupInternal(space,coords,alpha) {\\n\\tif (Convert.spaces.hasOwnProperty(space)) {\\n\\t\\tthis.space  = space;\\n\\t\\tthis.coords = coords.slice(0);\\n\\t\\tthis.alpha = alpha == null ? 1 : alpha;\\n\\t\\tConvert.getSpace(this.space).clip(this.coords);\\n\\t} else {\\n\\t\\tthrow new Error('unknown color space ' + color.space);\\n\\t}\\n}\\n\\n/**\\n * If value is given (will be clipped between [0..100]), sets the lightness\\n * level to the specified value. Otherwise, returns current lightness level.\\n */\\n Object.defineProperty(Color.prototype,'lightness',{\\n\\tget: function() {\\n\\t\\treturn (this.lch)[0];\\n\\t},\\n\\tset: function(value) {\\n\\t\\tvar lch = this.lch;\\n\\t\\tvar lightness = lch[0];\\n\\n\\t\\tvalue = Convert.clamp(value,0,100);\\n\\t\\t// When a color has high lightness, it's chroma is typically clipped\\n\\t\\t// to fit in rgb, so decreasing L tends to introduce black shade;\\n\\t\\t// try to compensate by increasing chroma first\\n\\t\\tif (value < lightness && lightness >= 80 && lch[1] > 0.5) {\\n\\t\\t\\t//var adjust = 100 - 0.04 * Math.pow(50-value, 2);\\n\\t\\t\\tlch[1] += Math.max(20 - 0.008 * Math.pow(50-value,2),2);\\n\\t\\t}\\n\\t\\tlch[0] = value;\\n\\t\\tthis.lch = lch;\\n\\t}\\n})\\n\\n/**\\n * Convert to color space and return a new color\\n*/\\nColor.prototype.to = function(spaceId) {\\n\\treturn new Color({\\n\\t\\tspace: spaceId,\\n\\t\\tcoords: this[spaceId],\\n\\t\\talpha: this.alpha\\n\\t});\\n}\\n\\nColor.prototype.toString = function(space) {\\n\\tif (space !== void(0) && !(Convert.spaces.hasOwnProperty(space))) {\\n\\t\\tthrow new Error('unknown color space ' + space);\\n\\t}\\n\\tif (space === void(0)) {\\n\\t\\tspace = this.space;\\n\\t}\\n\\tvar tuple;\\n\\tif (space === this.space) {\\n\\t\\ttuple = this.coords;\\n\\t} else {\\n\\t\\ttuple = this[space];\\n\\t}\\n\\treturn Convert.spaces[space].toString(tuple,this.alpha);\\n};\\n\\nColor.prototype.mixSRLAB2 = function(colorB,weight) {\\n\\tif (!(colorB instanceof Color)) {\\n\\t\\tthrow new TypeError('Input must be of type Color.');\\n\\t}\\n\\n\\tvar colorA = this;\\n\\tvar labA = colorA.srlab2;\\n\\tvar labB = colorB.srlab2;\\n\\n\\tif(colorA.alpha < 1) {\\n\\t\\tpremultiply(\\\"srlab2\\\",labA,colorA.alpha);\\n\\t}\\n\\tif(colorB.alpha < 1) {\\n\\t\\tpremultiply(\\\"srlab2\\\",labB,colorB.alpha);\\n\\t}\\n\\n\\tweight = Convert.clamp(weight,0,1);\\n\\n\\tvar l = labA[0] + weight * (labB[0] - labA[0]);\\n\\tvar a = labA[1] + weight * (labB[1] - labA[1]);\\n\\tvar b = labA[2] + weight * (labB[2] - labA[2]);\\n\\n\\tvar alpha = colorA.alpha + weight * (colorB.alpha - colorA.alpha);\\n\\tif (alpha !== 0) {\\n\\t\\tl = l / alpha;\\n\\t\\ta = a / alpha;\\n\\t\\tb = b / alpha;\\n\\t}\\n\\n\\treturn (new Color({space: \\\"srlab2\\\",coords:[l,a,b],alpha:alpha})).to(this.space);\\n}\\n\\nColor.prototype.mixXYZ = function(colorB,weight) {\\n\\tif (!(colorB instanceof Color)) {\\n\\t\\tthrow new TypeError('Input must be of type Color.');\\n\\t}\\n\\n\\tvar colorA = this;\\n\\tvar xyzA = colorA.xyz;\\n\\tvar xyzB = colorB.xyz;\\n\\n\\tif(colorA.alpha < 1) {\\n\\t\\tpremultiply(\\\"xyz\\\",xyzA,colorA.alpha);\\n\\t}\\n\\tif(colorB.alpha < 1) {\\n\\t\\tpremultiply(\\\"xyz\\\",xyzB,colorB.alpha);\\n\\t}\\n\\n\\tweight = Convert.clamp(weight,0,1);\\n\\n\\tvar x = xyzA[0] + weight * (xyzB[0] - xyzA[0]);\\n\\tvar y = xyzA[1] + weight * (xyzB[1] - xyzA[1]);\\n\\tvar z = xyzA[2] + weight * (xyzB[2] - xyzA[2]);\\n\\n\\tvar alpha = colorA.alpha + weight * (colorB.alpha - colorA.alpha);\\n\\tif (alpha !== 0) {\\n\\t\\tx = x / alpha;\\n\\t\\ty = y / alpha;\\n\\t\\tz = z / alpha;\\n\\t}\\n\\n\\treturn (new Color({space: \\\"xyz\\\",coords:[x,y,z],alpha:alpha})).to(this.space);\\n}\\n\\nColor.prototype.mix = Color.prototype.mixSRLAB2;\\n\\n// returns alpha composite color (this over colorB) using the \\\"source over\\\" operator\\nColor.prototype.over = function(colorB) {\\n\\tif (!(colorB instanceof Color)) {\\n\\t\\tthrow new TypeError('Input must be of type Color.');\\n\\t}\\n\\n\\tif(this.alpha === 1) {\\n\\t\\treturn (new Color(this));\\n\\t}\\n\\tif(this.alpha === 0) {\\n\\t\\treturn (new Color(colorB));\\n\\t}\\n\\tvar rgbA = this.rgb, rgbB = colorB.rgb;\\n\\n\\tpremultiply(\\\"rgb\\\",rgbA,this.alpha);\\n\\tpremultiply(\\\"rgb\\\",rgbB,colorB.alpha);\\n\\n\\tvar r = rgbA[0] + rgbB[0] * (1 - this.alpha),\\n\\t\\tg = rgbA[1] + rgbB[1] * (1 - this.alpha),\\n\\t\\tb = rgbA[2] + rgbB[2] * (1 - this.alpha),\\n\\t\\talpha = this.alpha + colorB.alpha * (1 - this.alpha);\\n\\n\\tr /= alpha;\\n\\tg /= alpha;\\n\\tb /= alpha;\\n\\treturn (new Color({space:\\\"rgb\\\",coords:[r,g,b],alpha:alpha}));\\n}\\n\\n// returns the relative luminance of the color--\\\"Y\\\" component of the xyz space\\nColor.prototype.luminance = function() {\\n\\tvar xyz = this.xyz;\\n\\treturn xyz[1];\\n}\\n\\n// returns the contrast ratio between two colors\\nColor.prototype.contrast = function(color) {\\n\\tif (!(color instanceof Color)) {\\n\\t\\tthrow new TypeError('Input must be of type Color.');\\n\\t}\\n\\n\\tvar L1 = this.luminance(),\\n\\t    L2 = color.luminance();\\n\\n\\tif (L2 > L1) {\\n\\t\\tvar temp = L1;\\n\\t\\tvar L1 = L2;\\n\\t\\tvar L2 = temp;\\n\\t}\\n\\n\\treturn (L1 + .05) / (L2 + .05);\\n}\\n\\n// deltaE2000 - http://www2.ece.rochester.edu/~gsharma/ciede2000/\\nColor.prototype.deltaE = function(color,konst) {\\n\\tvar lab1 = this.lab,\\n\\t\\tlab2 = color.lab;\\n\\n\\treturn deltaE(lab1,lab2,konst);\\n}\\n\\nColor.parse = parseColorString;\\n\\n// multiply (in place) any non-angle coordinate by alpha value\\nfunction premultiply(space,coords,alpha) {\\n\\tspace = Convert.getSpace(space);\\n\\tcoords.forEach(function(c,i,coords) {\\n\\t\\tif (! space.coords[i].isAngle) {\\n\\t\\t\\tcoords[i] *= alpha;\\n\\t\\t}\\n\\t});\\n}\\n\\n// map coords to new space, force the gamut if necessary\\nfunction convert(fromSpaceID,coords,toSpaceID) {\\n\\tvar fromSpace = Convert.getSpace(fromSpaceID);\\n\\tvar toSpace = Convert.getSpace(toSpaceID);\\n\\n\\tvar temp = Convert.map(fromSpace,coords,toSpace);\\n\\n\\tif (!Convert.isInSpace(toSpace,temp) && toSpace.intoGamut) {\\n\\t\\ttemp = forceIntoGamut(fromSpace,coords,toSpace)\\n\\t}\\n\\treturn temp;\\n}\\n\\nfunction forceIntoGamut(fromSpace,coords,toSpace) {\\n\\tvar lchSpace = Convert.getSpace(\\\"lchsr\\\");\\n\\tvar lch = Convert.map(fromSpace,coords,lchSpace);\\n\\n\\tvar transformFromLCH = function(lch,toSpace) {\\n\\t\\treturn Convert.map(lchSpace,lch,toSpace)\\n\\t}\\n\\n\\tvar temp;\\n\\tvar hiC = lch[1];\\n\\tvar loC = 0;\\n\\tvar ε = 0.0005;\\n\\n\\ttemp = transformFromLCH(lch,toSpace);\\n\\n\\tlch[1] /= 2;\\n\\n\\t// .0001 chosen fairly arbitrarily as \\\"close enough\\\"\\n\\twhile (hiC - loC > ε) {\\n\\t\\ttemp = transformFromLCH(lch,toSpace);\\n\\n\\t\\tif (Convert.isInSpace(toSpace,temp)) {\\n\\t\\t\\tloC = lch[1];\\n\\t\\t} else {\\n\\t\\t\\thiC = lch[1];\\n\\t\\t}\\n\\t\\tlch[1] = (hiC + loC)/2;\\n\\t}\\n\\n\\ttoSpace.clip(temp);\\n\\treturn temp;\\n}\\n\\nfunction deltaE(lab1,lab2,konst) {\\n\\tvar kL = 1,kC = 1,kH = 1;\\n\\tif (konst !== void(0)) {\\n\\t\\tkL = konst[0];\\n\\t\\tkC = konst[1];\\n\\t\\tkH = konst[2];\\n\\t}\\n\\tvar\\tchroma1 = Math.sqrt(lab1[1]*lab1[1] + lab1[2]*lab1[2]),\\n\\t\\tchroma2 = Math.sqrt(lab2[1]*lab2[1] + lab2[2]*lab2[2]);\\n\\tvar Lavg = (lab1[0] + lab2[0]) / 2,\\n\\t\\tC7 = Math.pow(0.5 * (chroma1 + chroma2),7),\\n\\t\\td2r = 0.017453292519943295,// Math.PI/180,\\n\\t\\tP25 = 6103515625,// Math.pow(25,7),\\n\\t\\tG = 0.5 * (1 - Math.sqrt(C7/(C7 + P25))),\\n\\t\\ta1 = lab1[1] * (1+G),\\n\\t\\ta2 = lab2[1] * (1+G),\\n\\t\\tC1 = Math.sqrt(a1 * a1 + lab1[2] * lab1[2]),\\n\\t\\tC2 = Math.sqrt(a2 * a2 + lab2[2] * lab2[2]),\\n\\t\\th1 = a1 == 0 && lab1[2] == 0 ? 0 : Convert.clamp360(Math.atan2(lab1[2],a1)/d2r),\\n\\t\\th2 = a2 == 0 && lab2[2] == 0 ? 0 : Convert.clamp360(Math.atan2(lab2[2],a2)/d2r),\\n\\t\\tdL = lab2[0] - lab1[0],\\n\\t\\tdC = C2 - C1,\\n\\t\\tCavg = (C1 + C2) / 2,\\n\\t\\tdh = h2 - h1,\\n\\t\\tHavg = h1 + h2;\\n\\n\\tif (C1*C2 !== 0) {\\n\\t\\tif (dh > 180) {\\n\\t\\t\\tdh = dh - 360;\\n\\t\\t\\tHavg = Havg < 360 ? (Havg +360) / 2 : (Havg - 360) / 2;\\n\\t\\t} else if (dh < -180) {\\n\\t\\t\\tdh = dh + 360;\\n\\t\\t\\tHavg = Havg < 360 ? (Havg +360) / 2 : (Havg - 360) / 2;\\n\\t\\t} else {\\n\\t\\t\\tHavg = Havg / 2;\\n\\t\\t}\\n\\t}\\n\\n\\tvar dH = 2 * Math.sqrt(C1 * C2) * Math.sin(dh/2 * d2r),\\n\\t\\tT = 1\\n\\t\\t\\t- 0.17 * Math.cos((Havg - 30)     * d2r)\\n\\t\\t\\t+ 0.24 * Math.cos((2 * Havg)      * d2r)\\n\\t\\t\\t+ 0.32 * Math.cos((3 * Havg + 6)  * d2r)\\n\\t\\t\\t- 0.20 * Math.cos((4 * Havg - 63) * d2r),\\n\\t\\tCavg7 = Math.pow(Cavg,7),\\n\\t\\tLavg2 = Math.pow(Lavg - 50,2),\\n\\t\\tRC = 2 * Math.sqrt(Cavg7/(Cavg7 + P25)),\\n\\t\\tSL = 1 + (0.015 * Lavg2 / Math.sqrt(20 + Lavg2)),\\n\\t\\tSC = 1 + 0.045 * Cavg,\\n\\t\\tSH = 1 + 0.015 * Cavg * T,\\n\\t\\tRT = - Math.sin(60 * Math.exp(-Math.pow((Havg - 275)/25,2))*d2r) * RC;\\n\\n\\t\\tvar dE = Math.sqrt(Math.pow(dL/(kL * SL),2)\\n\\t\\t\\t\\t+ Math.pow(dC/(kC * SC),2)\\n\\t\\t\\t\\t+ Math.pow(dH/(kH * SH),2)\\n\\t\\t\\t\\t+ RT * dC * dH / (kC * SC * kH * SH));\\n\\n\\treturn dE;\\n}\\n\\nmodule.exports = Color;\\n\\n})();\\n\\n//rgb [255,255,255] => xyz[0.96422, 1, 0.82521] lab[1000.00000, 0.00000, 0] lch[1000, 0, 0]\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/cdr/colorlab/lib/convert.js\":{\"title\":\"$:/plugins/cdr/colorlab/lib/convert.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/lib/convert.js\\ntype: application/javascript\\nmodule-type: library\\n\\nColor manipulation library\\n\\nColor componnent 'none' will be interpreted as NaN and in most cases, behaves as a zero value.\\nSee https://www.w3.org/TR/css-color-4/#missing for more details.\\n\\\\*/\\n(function() {\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n// given white point in (x,y), returns its XYZ coordinate\\nfunction whitepoint(x,y) {return [x/y, 1, (1-x-y)/y];}\\n\\nfunction uv(p) {\\n\\treturn [4*p[0] / (p[0] + 15*p[1] + 3*p[2]), 9*p[1] / (p[0] + 15*p[1] + 3*p[2])];\\n}\\n\\n// given an 3x3 matrix M and a vector v, multiple M x v\\nfunction matmul(M,v) {\\n\\treturn v.map(function (e /*not used*/,i,a) {\\n\\t\\treturn M[i][0]*a[0] + M[i][1]*a[1] + M[i][2]*a[2];\\n\\t});\\n}\\n\\nvar CIE = {\\n\\tε: 216/24389,\\n\\tκ: 24389/27,\\n\\tε_cbrt: 6/29,\\n\\tilluminant: function(x,y) {\\n\\t\\tvar wp = whitepoint(x,y);\\n\\t\\treturn {\\n\\t\\t\\twhite: Object.freeze(wp),\\n\\t\\t\\tuvref: Object.freeze(uv(wp))\\n\\t\\t};\\n\\t}\\n};\\n\\nCIE.D65 = CIE.illuminant(0.3127,0.3290);\\nCIE.D50 = CIE.illuminant(0.3457,0.3585);\\n\\nvar Convert = {};\\n\\nfunction clamp(v,min,max) {\\n\\treturn Math.min(Math.max(v,min),max);\\n}\\n\\nfunction clamp360(v) {\\n\\treturn  ((v % 360) + 360) % 360;\\n}\\n\\nConvert.clamp = clamp;\\nConvert.clamp360 = clamp360;\\n\\nConvert.spaces = {};\\n\\nConvert.spaces.xyz = {\\n\\tid: \\\"xyz\\\",\\n\\tname: \\\"XYZ\\\",\\n\\tcoords: [{name:\\\"X\\\",range:[-Infinity,Infinity]},\\n\\t         {name:\\\"Y\\\",range:[-Infinity,Infinity]},\\n\\t         {name:\\\"Z\\\",range:[-Infinity,Infinity]}],\\n\\twhite: CIE.D65.white,\\n\\n\\tfromXYZ: function(xyz) {return xyz;},\\n\\ttoXYZ:   function(xyz) {return xyz;},\\n\\n\\ttoString: function(coords,alpha) {\\n\\t\\tcoords = coords.map(function(c) {return numstr(c);});\\n\\t\\treturn \\\"xyz(\\\" + coords.join(\\\" \\\") + appendAlpha(alpha) + \\\")\\\";\\n\\t}\\n};\\n\\nConvert.spaces.rgb = {\\n\\tid: \\\"rgb\\\",\\n\\tname: \\\"sRGB\\\",\\n\\tcoords: [{name:\\\"r\\\",range:[0,1]},\\n\\t         {name:\\\"g\\\",range:[0,1]},\\n\\t         {name:\\\"b\\\",range:[0,1]}],\\n\\twhite: CIE.D65.white,\\n\\tintoGamut: true,\\n\\n\\t// extended transfer function: if x < 0, returns -f(-x)\\n\\ttoLinear: function(rgb) {\\n\\t\\tfunction invCompand(c) {\\n\\t\\t\\tvar sign = c < 0 ? -1 : 1;\\n\\t\\t\\tc = Math.abs(c);\\n\\t\\t\\treturn sign * (c  <= 0.04045 ? c/12.92 : Math.pow((c+0.055)/1.055,2.4));\\n\\t\\t}\\n\\n\\t\\t// expand gamma correction\\n\\t\\treturn rgb.map(invCompand);\\n\\t},\\n\\n\\t// extended transfer function: if x < 0, returns -f(-x)\\n\\ttoGamma: function(lrgb) {\\n\\t\\tfunction compand(c) {\\n\\t\\t\\tvar sign = c < 0 ? -1 : 1;\\n\\t\\t\\tc = Math.abs(c);\\n\\t\\t\\treturn sign * (c <= 0.0031308 ? 12.92*c : 1.055*Math.pow(c,5/12)-0.055);\\n\\t\\t}\\n\\t\\t// compress linear rgb with gamma correction\\n\\t\\treturn lrgb.map(compand)\\n\\t},\\n\\n\\t// sRGB to xyz\\n\\ttoXYZ: (function() {\\n\\t\\t// computed from white point\\n\\t\\tvar M = [[0.4123907992659595, 0.357584339383878 , 0.1804807884018343],\\n\\t\\t         [0.2126390058715103, 0.7151686787677559, 0.0721923153607337],\\n\\t\\t         [0.0193308187155918, 0.1191947797946259, 0.9505321522496605]];\\n\\t\\treturn function(rgb) {\\n\\t\\t\\treturn matmul(M,this.toLinear(rgb));\\n\\t\\t}\\n\\t})(),\\n\\n\\t// xyz to sRGB\\n\\tfromXYZ: (function() {\\n\\t\\tvar M = [[ 3.240969941904522 , -1.5373831775700937, -0.4986107602930033],\\n\\t\\t         [-0.9692436362808798,  1.8759675015077206,  0.0415550574071756],\\n\\t\\t         [ 0.0556300796969936, -0.2039769588889765,  1.0569715142428786]];\\n\\t\\treturn function(xyz) {\\n\\t\\t\\treturn this.toGamma(matmul(M,xyz));\\n\\t\\t}\\n\\t})(),\\n\\n\\ttoString: function(coords,alpha) {\\n\\t\\tvar rgb = coords.map(function(x) {return Math.round(x*255);});\\n\\n\\t\\tfunction hex(n) {\\n\\t\\t\\treturn isNaN(n) ? '00' : ('0' + n.toString(16)).slice(-2);\\n\\t\\t}\\n\\n\\t\\tif (alpha < 1) {\\n\\t\\t\\treturn \\\"rgba(\\\" + rgb.join(\\\",\\\") + \\\",\\\" + numstr(alpha) + \\\")\\\";\\n\\t\\t} else {\\n\\t\\t\\treturn \\\"#\\\" + hex(rgb[0]) + hex(rgb[1]) + hex(rgb[2]);\\n\\t\\t}\\n\\t}\\n};\\n\\nConvert.spaces.hsl = {\\n\\tid: \\\"hsl\\\",\\n\\tname: \\\"HSL\\\",\\n\\tcoords: [{name:\\\"h\\\",range:[0,360],isAngle:true},\\n\\t\\t\\t {name:\\\"s\\\",range:[0,1]},\\n\\t\\t\\t {name:\\\"l\\\",range:[0,1]}],\\n\\twhite: CIE.D65.white,\\n\\tintoGamut: true,\\n\\n\\ttoString: function(hsl,alpha) {\\n\\t\\treturn \\\"hsl(\\\"\\n\\t\\t+ (isNaN(hsl[0]) ? 0 : Math.round(hsl[0])) + \\\" \\\"\\n\\t\\t+ numstr(Math.round(hsl[1]*100)) + \\\"% \\\"\\n\\t\\t+ numstr(Math.round(hsl[2]*100)) + \\\"% \\\" + appendAlpha(alpha) + \\\")\\\";\\n\\t},\\n\\n\\tfrom: {\\n\\t\\t\\\"rgb\\\": function(rgb) {\\n\\t\\t\\tvar r = rgb[0], g = rgb[1], b = rgb[2];\\n\\t\\t\\tvar max = Math.max(r, g, b);\\n\\t\\t\\tvar min = Math.min(r, g, b);\\n\\t\\t\\tvar d = max - min;\\n\\t\\t\\tvar h = NaN,\\n\\t\\t\\t\\ts = 0, // zero when light is 0 or 1\\n\\t\\t\\t\\tl = (min+max)/2;\\n\\n\\t\\t\\tif(d !== 0) {\\n\\t\\t\\t\\ts = d / (l < 0.5 ? (max + min) : (2 - max - min));\\n\\n\\t\\t\\t\\tswitch (max) {\\n\\t\\t\\t\\t\\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\\n\\t\\t\\t\\t\\tcase g: h = (b - r) / d + 2; break;\\n\\t\\t\\t\\t\\tcase b: h = (r - g) / d + 4;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\th = h * 60;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn [h, s, l];   // deg, [0..1], [0..1]\\n\\t\\t}\\n\\t},\\n\\n\\tto: {\\n\\t\\t// Adapted from https://www.w3.org/TR/css-color-4/#hsl-to-rgb\\n\\t\\t\\\"rgb\\\": function(hsl) {\\n\\t\\t\\thsl = hsl.map(function (n) { return isNaN(n) ? 0 : n; });\\n\\n\\t\\t\\tvar h = hsl[0], s = hsl[1], l = hsl[2];\\n\\n\\t\\t\\th = (((h % 360) + 360) % 360);\\n\\n\\t\\t\\tvar f = function(n) {\\n\\t\\t\\t\\tvar k = (n + h/30) % 12;\\n\\t\\t\\t\\tvar a = s * Math.min(l, 1 - l);\\n\\t\\t\\t\\treturn l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));\\n\\t\\t\\t}\\n\\t\\t\\treturn [f(0),f(8),f(4)]; // normalized to [0..1]\\n\\t\\t}\\n\\t}\\n};\\n\\nConvert.spaces.p3 = {\\n\\tid: \\\"p3\\\",\\n\\tname: \\\"display-p3\\\",\\n\\tcoords:\\t[{name:\\\"r\\\",range:[0,1]},\\n\\t         {name:\\\"g\\\",range:[0,1]},\\n\\t         {name:\\\"b\\\",range:[0,1]}\\t],\\n\\twhite: CIE.D65.white,\\n\\tintoGamut: true,\\n\\n\\ttoLinear: Convert.spaces.rgb.toLinear,\\n\\n\\ttoGamma: Convert.spaces.rgb.toGamma,\\n\\n\\ttoXYZ: (function() {\\n\\t\\t// computed from white point\\n\\t\\tvar M = [[0.486570948648216,  0.2656676931690931, 0.1982172852343625],\\n\\t\\t         [0.2289745640697487, 0.6917385218365063, 0.079286914093745 ],\\n\\t\\t         [0,                  0.0451133818589026, 1.0439443689009757]];\\n\\t\\treturn function(rgb) {\\n\\t\\t\\treturn matmul(M,this.toLinear(rgb));\\n\\t\\t}\\n\\t})(),\\n\\n\\tfromXYZ: (function() {\\n\\t\\tvar M = [[ 2.4934969119414263, -0.9313836179191244, -0.4027107844507171],\\n\\t\\t         [-0.8294889695615749,  1.7626640603183465,  0.0236246858419436],\\n\\t\\t         [ 0.0358458302437845, -0.0761723892680418,  0.9568845240076874]];\\n\\t\\treturn function(xyz) {\\n\\t\\t\\treturn this.toGamma(matmul(M,xyz));\\n\\t\\t}\\n\\t})(),\\n\\n\\ttoString: function(coords,alpha) {\\n\\t\\tcoords = coords.map(function(c) {return numstr(c);});\\n\\t\\treturn \\\"color(display-p3 \\\" + coords.join(\\\" \\\") + appendAlpha(alpha) + \\\")\\\";\\n\\t}\\n};\\n\\nConvert.spaces.lab = {\\n\\tid: \\\"lab\\\",\\n\\tname: \\\"Lab\\\",\\n\\tcoords:\\t[{name:\\\"l\\\",range:[0,100]},\\n\\t         {name:\\\"a\\\",range:[-Infinity,Infinity]},\\n\\t         {name:\\\"b\\\",range:[-Infinity,Infinity]} ],\\n\\twhite: CIE.D50.white,\\n\\n\\ttoXYZ: function(lab) {\\n\\t\\tvar f=[];\\n\\n\\t\\tf[1] = (lab[0] + 16)/116;\\n\\t\\tf[0] = lab[1]/500 + f[1];\\n\\t\\tf[2] = f[1] - lab[2]/200;\\n\\n\\t\\tvar xyz = f.map(function(value,i) {\\n\\t\\t\\tvar cubed = value * value * value;\\n\\t\\t\\treturn (cubed > CIE.ε ? cubed : (value * 116 - 16) / CIE.κ) * this.white[i];\\n\\t\\t},this);\\n\\n\\t\\tif (this.white != Convert.spaces.xyz.white) {\\n\\t\\t\\txyz = Convert.chromaticAdaptation(this.white,Convert.spaces.xyz.white,xyz);\\n\\t\\t}\\n\\t\\treturn xyz;\\n\\t},\\n\\n\\tfromXYZ: function(xyz) {\\n\\t\\tif (this.white != Convert.spaces.xyz.white) {\\n\\t\\t\\txyz = Convert.chromaticAdaptation(Convert.spaces.xyz.white,this.white,xyz);\\n\\t\\t}\\n\\n\\t\\txyz = xyz.map(function(value,i) {\\n\\t\\t\\treturn value / this.white[i];\\n\\t\\t},this);\\n\\n\\t\\tvar f = xyz.map(function(value,i) {\\n\\t\\t\\treturn value > CIE.ε ? Math.cbrt(value) : (CIE.κ * value + 16)/116;\\n\\t\\t});\\n\\n\\t\\treturn [\\n\\t\\t\\tclamp((116 * f[1]) - 16,0,100), // L\\n\\t\\t\\t500 * (f[0] - f[1]), // a\\n\\t\\t\\t200 * (f[1] - f[2])  // b\\n\\t\\t];\\n\\t},\\n\\n\\ttoString: function(lab,alpha) {\\n\\t\\treturn \\\"lab(\\\"\\n\\t\\t\\t+ numstr(lab[0]) + \\\"% \\\"\\n\\t\\t\\t+ numstr(lab[1]) + \\\" \\\"\\n\\t\\t\\t+ numstr(lab[2]) + appendAlpha(alpha) + \\\")\\\";\\n\\t}\\n};\\n\\n/* https://www.magnetkern.de/srlab2.pdf */\\nConvert.spaces.srlab2 = {\\n\\tid: \\\"srlab2\\\",\\n\\tname: \\\"SRLAB2\\\",\\n\\tcoords: [{name: \\\"l\\\", range:[0,100]},\\n\\t         {name: \\\"a\\\", range:[-Infinity, Infinity]},\\n\\t\\t\\t {name: \\\"b\\\", range:[-Infinity, Infinity]}],\\n\\twhite: CIE.D65.white,\\n\\n\\tfromXYZ: (function() {\\n\\t\\t// M_HPE * inv(M_CAT02) * diagonal(1/rgb_ref) * M_CAT02\\n\\t\\tvar M1 = [\\n\\t\\t\\t[ 0.4239866073983792,  0.6933061285086612, -0.0884036796338899],\\n\\t\\t\\t[-0.203631183252087 ,  1.1536283980317619,  0.0366500922424727],\\n\\t\\t    [-0.0007593175873917, -0.0010007075130392,  0.919806506785842 ]];\\n\\t\\tvar inv_M_HPE = [\\n\\t\\t\\t[ 1.910196834052035 , -1.1121238927878747,  0.2019079567674994],\\n\\t\\t\\t[ 0.3709500882486886,  0.6290542573926132, -0.0000080551421844],\\n\\t\\t\\t[ 0.                ,  0.                ,  1.                ]];\\n\\t\\tvar f = function(w) {\\n\\t\\t\\treturn w <= CIE.ε ? w * 0.01 * CIE.κ  : 1.16 * Math.cbrt(w) - 0.16;\\n\\t\\t}\\n\\n\\t\\treturn function(xyz) {\\n\\t\\t\\txyz = matmul(M1,xyz).map(f);\\n\\t\\t\\txyz = matmul(inv_M_HPE,xyz);\\n\\t\\t\\tvar L = 100 * xyz[1],\\n\\t\\t\\t    a = 500/1.16 * (xyz[0] - xyz[1]),\\n\\t\\t\\t\\tb = 200/1.16 * (xyz[1] - xyz[2]);\\n\\n\\t\\t\\treturn [L,a,b];\\n\\t\\t}\\n\\t})(),\\n\\n\\ttoXYZ: (function() {\\n\\t\\t// M_HPE * inv(M_CAT02) * diagonal(1/rgb_ref) * M_CAT02\\n\\t\\tvar M_HPE = [\\n\\t\\t\\t[ 0.38971,  0.68898, -0.07868],\\n\\t\\t\\t[-0.22981,  1.18340,  0.04641],\\n\\t\\t\\t[ 0.00000,  0.00000,  1.0000]];\\n\\t\\tvar inv_M1 = [\\n\\t\\t\\t[ 1.8306560666900926, -1.099994712882931 ,  0.2197762666838433],\\n\\t\\t\\t[ 0.3230766443179263,  0.6726717504705783,  0.0042483744450524],\\n\\t\\t\\t[ 0.001862733695097 , -0.0001762301699639,  1.0873712286074086]];\\n\\t\\tvar f = function(w) {\\n\\t\\t\\treturn w <= 0.08 ? w * 100 / CIE.κ : Math.pow((w + 0.16)/1.16,3);\\n\\t\\t}\\n\\n\\t\\treturn function(lab) {\\n\\t\\t\\tvar y = 0.01 * lab[0],\\n\\t\\t\\t    x = lab[1] * 1.16/500 + y,\\n\\t\\t\\t\\tz = y - lab[2] * 1.16/200;\\n\\n\\t\\t\\tvar xyz = matmul(M_HPE,[x,y,z]);\\n\\t\\t\\txyz = matmul(inv_M1,xyz.map(f));\\n\\n\\t\\t\\treturn xyz;\\n\\t\\t}\\n\\t})(),\\n\\n\\tfrom: {\\n\\t\\t\\\"rgb\\\": function(rgb) {\\n\\t\\t\\tvar linRGB = Convert.spaces.rgb.toLinear(rgb),\\n\\t\\t\\t    x = 0.3205631863289935 * linRGB[0] + 0.6369045416942921 * linRGB[1] + 0.0425422719767143 * linRGB[2],\\n\\t\\t\\t    y = 0.1620392455748646 * linRGB[0] + 0.7565920747424774 * linRGB[1] + 0.0813686796826581 * linRGB[2],\\n\\t\\t\\t    z = 0.0172546877985969 * linRGB[0] + 0.1086489392821993 * linRGB[1] + 0.8740963729192033 * linRGB[2];\\n\\n\\t\\t\\tx = x <= 216/24389 ? x * 24389 / 2700 : 1.16 * Math.cbrt(x) - 0.16;\\n\\t\\t\\ty = y <= 216/24389 ? y * 24389 / 2700 : 1.16 * Math.cbrt(y) - 0.16;\\n\\t\\t\\tz = z <= 216/24389 ? z * 24389 / 2700 : 1.16 * Math.cbrt(z) - 0.16;\\n\\n\\t\\t\\tvar lightness =    37.0950 * x +  62.9054 * y -   0.0008 * z;\\n\\t\\t\\tvar a         =   663.4684 * x - 750.5078 * y +  87.0328 * z;\\n\\t\\t\\tvar b         =    63.9569 * x + 108.4576 * y - 172.4152 * z;\\n\\n\\t\\t\\treturn [lightness,a,b];\\n\\t\\t}\\n\\t},\\n\\n\\tto: {\\n\\t\\t\\\"rgb\\\": function(lab) {\\n\\t\\t\\tvar x = 0.01 * lab[0] + 0.000904127 * lab[1] + 0.000456344 * lab[2];\\n\\t\\t\\tvar y = 0.01 * lab[0] - 0.000533159 * lab[1] - 0.000269178 * lab[2];\\n\\t\\t\\tvar z = 0.01 * lab[0]                        - 0.005800000 * lab[2];\\n\\t\\t\\tif (x <= 0.08) x *= 2700 / 24389;\\n\\t\\t\\telse x = Math.pow((x + 0.16) / 1.16,3);\\n\\t\\t\\tif (y <= 0.08) y *= 2700 / 24389;\\n\\t\\t\\telse y = Math.pow((y + 0.16) / 1.16,3);\\n\\t\\t\\tif (z <= 0.08) z *= 2700 / 24389;\\n\\t\\t\\telse z = Math.pow((z + 0.16) / 1.16,3);\\n\\n\\t\\t\\tvar rd =  5.435479909003638  * x - 4.599116163648537  * y + 0.1635818998458092 * z;\\n\\t\\t\\tvar gn = -1.1681930516161254 * x + 2.32806589521468   * y - 0.1598611616680385 * z;\\n\\t\\t\\tvar bl =  0.0379082079460666 * x - 0.1985886018050641 * y + 1.1606800147769185 * z;\\n\\n\\t\\t\\treturn Convert.spaces.rgb.toGamma([rd,gn,bl]);\\n\\t\\t}\\n\\t},\\n\\n\\ttoString: function(lab,alpha) {\\n\\t\\treturn \\\"srlab2(\\\"\\n\\t\\t\\t+ numstr(lab[0]) + \\\"% \\\"\\n\\t\\t\\t+ numstr(lab[1]) + \\\" \\\"\\n\\t\\t\\t+ numstr(lab[2]) + appendAlpha(alpha) + \\\")\\\";\\n\\t}\\n};\\n\\n/* https://bottosson.github.io/posts/oklab/ */\\nConvert.spaces.oklab = {\\n\\tid: \\\"oklab\\\",\\n\\tname: \\\"Oklab\\\",\\n\\tcoords: [{name:\\\"l\\\",range:[0,100]},\\n\\t         {name:\\\"a\\\",range:[-Infinity,Infinity]},\\n\\t         {name:\\\"b\\\",range:[-Infinity,Infinity]} ],\\n\\twhite: CIE.D65.white,\\n\\n\\t_lms2lab: (function() {\\n\\t\\tvar M2 = [[ 0.2104542553,  0.7936177850, -0.0040720468],\\n\\t\\t          [ 1.9779984951, -2.4285922050,  0.4505937099],\\n\\t\\t          [ 0.0259040371,  0.7827717662, -0.8086757660]];\\n\\t\\treturn function(lms) {\\n\\t\\t\\tlms[0] = Math.cbrt(lms[0]);\\n\\t\\t\\tlms[1] = Math.cbrt(lms[1]);\\n\\t\\t\\tlms[2] = Math.cbrt(lms[2]);\\n\\n\\t\\t\\tvar lab = matmul(M2,lms);\\n\\t\\t\\tlab[0] = clamp(lab[0] * 100,0,100);\\n\\t\\t\\treturn lab;\\n\\t\\t};\\n\\t})(),\\n\\n\\t_lab2lms: (function() {\\n\\t\\tvar M2inv = [[ 1,  0.3963377921737677,  0.2158037580607588],\\n\\t\\t             [ 1, -0.1055613423236563, -0.0638541747717059],\\n\\t\\t             [ 1, -0.0894841820949657, -1.2914855378640917]];\\n\\t\\treturn function(lab) {\\n\\t\\t\\tlab = lab.slice(0);\\n\\t\\t\\tlab[0] /= 100;\\n\\t\\t\\tvar lms = matmul(M2inv,lab);\\n\\n\\t\\t\\tlms[0] = Math.pow(lms[0],3);\\n\\t\\t\\tlms[1] = Math.pow(lms[1],3);\\n\\t\\t\\tlms[2] = Math.pow(lms[2],3);\\n\\t\\t\\treturn lms;\\n\\t\\t};\\n\\t})(),\\n\\n\\ttoXYZ: (function() {\\n\\t\\tvar M1inv = [[ 1.2270138511035211, -0.5577999806518222,  0.2812561489664678],\\n\\t\\t             [-0.0405801784232806,  1.11225686961683  , -0.0716766786656012],\\n\\t\\t             [-0.0763812845057069, -0.4214819784180127,  1.5861632204407947]];\\n\\t\\treturn function(lab) {\\n\\t\\t\\tvar lms = this._lab2lms(lab);\\n\\n\\t\\t\\treturn matmul(M1inv,lms);\\n\\t\\t}\\n\\t})(),\\n\\n\\tfromXYZ: (function() {\\n\\t\\tvar M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137],\\n\\t\\t          [ 0.0329845436, 0.9293118715,  0.0361456387],\\n\\t\\t          [ 0.0482003018, 0.2643662691,  0.6338517070]];\\n\\t\\treturn function(xyz) {\\n\\t\\t\\tvar lms = matmul(M1,xyz);\\n\\n\\t\\t\\treturn this._lms2lab(lms);\\n\\t\\t}\\n\\t})(),\\n\\n\\tfrom: {\\n\\t\\t\\\"rgb\\\": (function() {\\n\\t\\t\\tvar M = [[ 0.4122214708, 0.5363325363, 0.0514459929],\\n\\t\\t\\t         [ 0.2119034982, 0.6806995451, 0.1073969566],\\n\\t\\t\\t         [ 0.0883024619, 0.2817188376, 0.6299787005]];\\n\\t\\t\\treturn function(rgb) {\\n\\t\\t\\t\\tvar linRGB = Convert.spaces.rgb.toLinear(rgb),\\n\\t\\t\\t\\t\\tlms = matmul(M,linRGB);\\n\\t\\t\\t\\treturn this._lms2lab(lms);\\n\\t\\t\\t}\\n\\t\\t})()\\n\\t},\\n\\n\\tto: {\\n\\t\\t\\\"rgb\\\": (function() {\\n\\t\\t\\tvar Minv = [[ 4.0767416621, -3.3077115913,  0.2309699292],\\n\\t\\t\\t            [-1.2684380046,  2.6097574011, -0.3413193965],\\n\\t\\t\\t            [-0.0041960863, -0.7034186147,  1.7076147010]];\\n\\t\\t\\treturn function(lab) {\\n\\t\\t\\t\\tvar lms = this._lab2lms(lab),\\n\\t\\t\\t\\t\\tlinRGB = matmul(Minv,lms);\\n\\t\\t\\t\\treturn Convert.spaces.rgb.toGamma(linRGB);\\n\\t\\t\\t};\\n\\t\\t})()\\n\\t},\\n\\n\\ttoString: function(lab,alpha) {\\n\\t\\treturn \\\"oklab(\\\"\\n\\t\\t\\t+ numstr(lab[0]) + \\\"% \\\"\\n\\t\\t\\t+ numstr(lab[1]) + \\\" \\\"\\n\\t\\t\\t+ numstr(lab[2]) + appendAlpha(alpha) + \\\")\\\";\\n\\t}\\n};\\n\\nConvert.spaces.luv = {\\n\\tid: \\\"luv\\\",\\n\\tname: \\\"Luv\\\",\\n\\tcoords: [{name:\\\"l\\\",range:[0,100]},\\n\\t         {name:\\\"u\\\",range:[-Infinity,Infinity]},\\n\\t         {name:\\\"v\\\",range:[-Infinity,Infinity]} ],\\n\\twhite: CIE.D65.white,\\n\\tuvref: CIE.D65.uvref,\\n\\n\\ttoXYZ: function(luv) {\\n\\t\\tif (luv[0] === 0) {\\n\\t\\t\\treturn [0,0,0];\\n\\t\\t}\\n\\n\\t\\tvar L = luv[0],u = luv[1],v = luv[2];\\n\\t\\tvar u0 = this.uvref[0];\\n\\t\\tvar v0 = this.uvref[1];\\n\\n\\t\\tvar u1 = u / (13 * L) + u0;\\n\\t\\tvar v1 = v / (13 * L) + v0;\\n\\t\\tvar d  = 4 * v1;\\n\\n\\t\\tvar y = (L > CIE.κ * CIE.ε) ? Math.pow((L + 16) / 116,3) : L / CIE.κ;\\n\\t\\tvar x = 9 * y *  u1 / d;\\n\\t\\tvar z = y * (12 - 3 * u1 - 20 * v1) / d;\\n\\n\\t\\treturn [x,y,z];\\n\\t},\\n\\n\\tfromXYZ: function(xyz) {\\n\\t\\tvar uR = this.uvref[0];\\n\\t\\tvar vR = this.uvref[1];\\n\\n\\t\\tvar denom = xyz[0] + 15*xyz[1] + 3*xyz[2];\\n\\t\\tif (denom === 0) {\\n\\t\\t\\treturn [0,0,0];\\n\\t\\t}\\n\\t\\tvar u1 = 4 * xyz[0] / denom;\\n\\t\\tvar v1 = 9 * xyz[1] / denom;\\n\\n\\t\\tvar yR = xyz[1]; // (Yr = 1)\\n\\t\\tvar l = yR > CIE.ε ? 116*Math.cbrt(yR) - 16 : CIE.κ * yR;\\n\\n\\t\\tvar u =  13 * l * (u1 - uR);\\n\\t\\tvar v =  13 * l * (v1 - vR);\\n\\n\\t\\treturn [l,u,v];\\n\\t},\\n\\n\\ttoString: function(luv,alpha) {\\n\\t\\treturn \\\"luv(\\\"\\n\\t\\t\\t+ numstr(luv[0]) + \\\"% \\\"\\n\\t\\t\\t+ numstr(luv[1]) + \\\" \\\"\\n\\t\\t\\t+ numstr(luv[2]) + appendAlpha(alpha) + \\\")\\\";\\n\\t}\\n};\\n\\n(function() {\\n\\tvar lch = {\\n\\t\\tcoords: [{name:\\\"l\\\",range:[0,100]},\\n\\t\\t\\t\\t {name:\\\"c\\\",range:[0,Infinity]},\\n\\t\\t\\t\\t {name:\\\"h\\\",range:[0,360],isAngle:true}],\\n\\n\\t\\ttoString: function(lch,alpha) {\\n\\t\\t\\treturn \\\"lch(\\\"\\n\\t\\t\\t+ numstr(lch[0]) + \\\"% \\\"\\n\\t\\t\\t+ numstr(lch[1]) + \\\" \\\"\\n\\t\\t\\t+ numstr(lch[2]) + appendAlpha(alpha) + \\\")\\\";\\n\\t\\t}\\n\\t};\\n\\n\\tvar defineLCH = function(nickname,base) {\\n\\t\\tvar space = {}\\n\\n\\t\\tspace.coords = lch.coords;\\n\\t\\tspace.toString = lch.toString;\\n\\n\\t\\tspace.id = nickname;\\n\\t\\tspace.name = \\\"LCH(\\\" + base.id + \\\")\\\";\\n\\t\\tspace.white = base.white;\\n\\t\\tspace.from = {}\\n\\t\\tspace.from[base.id] = toLCH;\\n\\t\\tspace.to = {}\\n\\t\\tspace.to[base.id] = toCartesian;\\n\\t\\tConvert.spaces[space.id] = space;\\n\\t}\\n\\n\\tdefineLCH(\\\"lchab\\\",Convert.spaces.lab);\\n\\tdefineLCH(\\\"lchok\\\",Convert.spaces.oklab);\\n\\tdefineLCH(\\\"lchuv\\\",Convert.spaces.luv);\\n\\tdefineLCH(\\\"lchsr\\\",Convert.spaces.srlab2);\\n})();\\n\\n// set default lch space\\nConvert.spaces.lch = Convert.spaces.lchsr;\\n\\n// Convert Lab / Luv to cylindrical coord [lightness, chroma, hue]\\nfunction toLCH(tuple) {\\n\\tvar l = tuple[0],\\n\\t    a = tuple[1],\\n\\t    b = tuple[2];\\n\\tvar c = Math.sqrt(a*a + b*b);\\n\\tvar h;\\n\\n\\tif (c <= 0.0001) {\\n\\t\\tc = 0;\\n\\t\\th = NaN;\\n\\t} else {\\n\\t\\th = Math.atan2(b,a) * 180 / Math.PI; // convert to degrees\\n\\t}\\n\\n\\treturn [clamp(l,0,100), c, clamp360(h)];\\n}\\n\\n// Convert from cylindrical coord [lightness (l), chroma, hue] to cartesian coord .\\nfunction toCartesian(lch) {\\n\\tvar l = lch[0], c = lch[1], h = lch[2];\\n\\n\\tif (isNaN(h)) {\\n\\t\\th = 0;\\n\\t} else {\\n\\t\\th = h * Math.PI / 180; // convert to radians\\n\\t}\\n\\n\\tvar a = c * Math.cos(h);\\n\\tvar b = c * Math.sin(h);\\n\\treturn [clamp(l,0,100), a, b];\\n}\\n\\n// Color space representation adapted from:\\n// https://github.com/LeaVerou/color.js/blob/master/src/color.js\\nObject.keys(Convert.spaces).forEach(function(spaceId) {\\n\\tvar space = Convert.spaces[spaceId];\\n\\tconsole.assert(spaceId === \\\"lch\\\" || spaceId === space.id);\\n\\tif (!space.fromXYZ && !space.toXYZ) {\\n\\t\\t// add connection space if a space is missing to/from XYZ()\\n\\t\\tvar connectionSpace;\\n\\n\\t\\tif (space.from && space.to) {\\n\\t\\t\\tvar from = new Set(Object.keys(space.from)),\\n\\t\\t\\t    to = new Set(Object.keys(space.to)),\\n\\t\\t\\t\\tcandidates = [];\\n\\n\\t\\t\\tfrom.forEach(function(id) {\\n\\t\\t\\t\\tif (to.has(id)) {\\n\\t\\t\\t\\t\\tvar sp = Convert.spaces[id];\\n\\t\\t\\t\\t\\tif (sp && sp.fromXYZ && sp.toXYZ) {\\n\\t\\t\\t\\t\\t\\tcandidates.push(id);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (candidates.length > 0) {\\n\\t\\t\\t\\tconnectionSpace = Convert.spaces[candidates[0]];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (connectionSpace) {\\n\\t\\t\\t// define from/to XYZ functions based on the connection space\\n\\t\\t\\tObject.assign(space,{\\n\\t\\t\\t\\tfromXYZ: function(xyz) {\\n\\t\\t\\t\\t\\tvar newCoords = connectionSpace.fromXYZ(xyz);\\n\\t\\t\\t\\t\\treturn this.from[connectionSpace.id].call(this,newCoords);\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\ttoXYZ: function(coords) {\\n\\t\\t\\t\\t\\tvar newCoords = this.to[connectionSpace.id].call(this,coords);\\n\\t\\t\\t\\t\\treturn connectionSpace.toXYZ(newCoords);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t// add connection space's to/from functions as well, e.g.\\n\\t\\t\\t// add lab.from to lch's from property\\n\\t\\t\\tif (connectionSpace.from) { // e.g. lab.from=rgb\\n\\t\\t\\t\\tObject.keys(connectionSpace.from).forEach(function(id) {\\n\\t\\t\\t\\t\\tspace.from[id] = function(tuple) {\\n\\t\\t\\t\\t\\t\\tvar newCoords = connectionSpace.from[id].call(connectionSpace,tuple);\\n\\t\\t\\t\\t\\t\\treturn this.from[connectionSpace.id].call(this,newCoords);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\tif (connectionSpace.to) {\\n\\t\\t\\t\\tObject.keys(connectionSpace.to).forEach(function(id) {\\n\\t\\t\\t\\t\\tspace.to[id] = function(tuple) {\\n\\t\\t\\t\\t\\t\\tvar newCoords = this.to[connectionSpace.id].call(this,tuple);\\n\\t\\t\\t\\t\\t\\treturn connectionSpace.to[id].call(connectionSpace,newCoords);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tthrow new ReferenceError(\\\"No connection space found for \\\" + space.name + \\\".\\\");\\n\\t\\t}\\n\\t}\\n\\tObject.assign(space,{\\n\\t\\tclip: function(coords) {\\n\\t\\t\\treturn clip.call(this,coords);\\n\\t\\t}\\n\\t});\\n});\\n\\n// map coords to new space WITHOUT forcing into gamut\\nConvert.map = function(fromSpace,coords,toSpace) {\\n\\tif (fromSpace === toSpace) {\\n\\t\\t// Same space, no change needed\\n\\t\\treturn coords.slice(0);\\n\\t}\\n\\n\\t// Use direct to/from if available; otherwise, go through xyz space.\\n\\t// Custom function takes care any chromatic adaptation and gamut\\n\\t// mapping.\\n\\tif (toSpace.from && toSpace.from[fromSpace.id]) {\\n\\t\\treturn toSpace.from[fromSpace.id].call(toSpace,coords);\\n\\t}\\n\\n\\tif (fromSpace.to && fromSpace.to[toSpace.id]) {\\n\\t\\treturn fromSpace.to[toSpace.id].call(fromSpace,coords);\\n\\t}\\n\\n\\tvar xyz = fromSpace.toXYZ(coords);\\n\\n\\treturn toSpace.fromXYZ(xyz);\\n};\\n\\nConvert.chromaticAdaptation = function(from,to,xyz) {\\n\\tvar M;\\n\\n\\t// computed\\n\\tif (from === CIE.D65.white && to === CIE.D50.white) {\\n\\t\\tM = [[ 1.0479297925449966,  0.0229468706016096, -0.0501922662892052],\\n\\t\\t     [ 0.0296278087700558,  0.9904344267538798, -0.0170737990634188],\\n\\t\\t     [-0.0092430406462045,  0.0150551914902981,  0.7518742814281371]];\\n\\t} else if (from === CIE.D50.white && to === CIE.D65.white) {\\n\\t\\tM = [[ 0.9554734214880753, -0.0230984549487646, 0.0632592432005706],\\n\\t\\t     [-0.0283697093338637,  1.0099953980813041, 0.0210414411919173],\\n\\t\\t     [ 0.012314014864482 , -0.020507649298899 , 1.3303659262421237]];\\n\\t} else {\\n\\t\\tthrow new TypeError(\\\"Only Bradford Chromatic Adaptation with white points D50 and D65 are supported.\\\");\\n\\t}\\n\\treturn matmul(M,xyz);\\n};\\n\\n// check each coordinate in <coords> are within the bounds\\nConvert.isInSpace = function(space,coords) {\\n\\tif (typeof space === \\\"string\\\") {\\n\\t\\tspace = Convert.getSpace(space)\\n\\t}\\n\\n\\tvar isInSpace = coords.every(function(v,i) {\\n\\t\\tvar epsilon = .00005;\\n\\t\\tvar min = space.coords[i].range[0];\\n\\t\\tvar max = space.coords[i].range[1];\\n\\t\\treturn v >= min - epsilon && v <= max + epsilon;\\n\\t});\\n\\n\\tif (isInSpace) {\\n\\t\\tspace.clip(coords);\\n\\t}\\n\\treturn isInSpace;\\n};\\n\\nConvert.getSpace = function(spaceID) {\\n\\tif (! Convert.spaces.hasOwnProperty(spaceID)) {\\n\\t\\tthrow new TypeError(\\\"unknown color space: \\\" + spaceID);\\n\\t}\\n\\treturn Convert.spaces[spaceID];\\n};\\n\\n// clips components of coords to valid range; padd missing members to zero.\\nfunction clip(coords) {\\n\\tvar space = this;\\n\\n\\tspace.coords.forEach(function(c,i) {\\n\\t\\tif (i >= coords.length) {\\n\\t\\t\\tcoords[i] = 0;\\n\\t\\t} else if (c.isAngle) {\\n\\t\\t\\tcoords[i] = clamp360(coords[i]);\\n\\t\\t} else {\\n\\t\\t\\tcoords[i] = clamp(coords[i],c.range[0],c.range[1]);\\n\\t\\t}\\n\\t});\\n\\tcoords.splice(space.coords.length);\\n\\treturn coords;\\n}\\n\\n// 3-digit precision\\nfunction numstr(n) {\\n\\tif (isNaN(n)) {\\n\\t\\treturn \\\"0\\\";\\n\\t}\\n\\treturn (Math.round(n*1000)/1000).toString();\\n}\\n\\nfunction appendAlpha(a,join) {\\n\\tif (isNaN(a)) {\\n\\t\\treturn \\\" / 0\\\";\\n\\t}\\n\\treturn a < 1 ? \\\" / \\\" + numstr(a) : \\\"\\\";\\n}\\n\\nmodule.exports = Convert;\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/cdr/colorlab/lib/parse.js\":{\"title\":\"$:/plugins/cdr/colorlab/lib/parse.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/lib/parse.js\\ntype: application/javascript\\nmodule-type: library\\n\\nParses a css color specification\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\n\\\"use strict\\\";\\n\\n// https://www.w3.org/TR/css-color-4/#named-colors\\nvar NamedColors = {\\n\\t\\\"aliceblue\\\": [240,248,255],\\t\\\"antiquewhite\\\": [250,235,215],\\n\\t\\\"aqua\\\": [0,255,255],\\t\\\"aquamarine\\\": [127,255,212],\\n\\t\\\"azure\\\": [240,255,255],\\t\\\"beige\\\": [245,245,220],\\n\\t\\\"bisque\\\": [255,228,196],\\t\\\"black\\\": [0,0,0],\\n\\t\\\"blanchedalmond\\\": [255,235,205],\\t\\\"blue\\\": [0,0,255],\\n\\t\\\"blueviolet\\\": [138,43,226],\\t\\\"brown\\\": [165,42,42],\\n\\t\\\"burlywood\\\": [222,184,135],\\t\\\"cadetblue\\\": [95,158,160],\\n\\t\\\"chartreuse\\\": [127,255,0],\\t\\\"chocolate\\\": [210,105,30],\\n\\t\\\"coral\\\": [255,127,80],\\t\\\"cornflowerblue\\\": [100,149,237],\\n\\t\\\"cornsilk\\\": [255,248,220],\\t\\\"crimson\\\": [220,20,60],\\n\\t\\\"cyan\\\": [0,255,255],\\t\\\"darkblue\\\": [0,0,139],\\n\\t\\\"darkcyan\\\": [0,139,139],\\t\\\"darkgoldenrod\\\": [184,134,11],\\n\\t\\\"darkgray\\\": [169,169,169],\\t\\\"darkgreen\\\": [0,100,0],\\n\\t\\\"darkgrey\\\": [169,169,169],\\t\\\"darkkhaki\\\": [189,183,107],\\n\\t\\\"darkmagenta\\\": [139,0,139],\\t\\\"darkolivegreen\\\": [85,107,47],\\n\\t\\\"darkorange\\\": [255,140,0],\\t\\\"darkorchid\\\": [153,50,204],\\n\\t\\\"darkred\\\": [139,0,0],\\t\\\"darksalmon\\\": [233,150,122],\\n\\t\\\"darkseagreen\\\": [143,188,143],\\t\\\"darkslateblue\\\": [72,61,139],\\n\\t\\\"darkslategray\\\": [47,79,79],\\t\\\"darkslategrey\\\": [47,79,79],\\n\\t\\\"darkturquoise\\\": [0,206,209],\\t\\\"darkviolet\\\": [148,0,211],\\n\\t\\\"deeppink\\\": [255,20,147],\\t\\\"deepskyblue\\\": [0,191,255],\\n\\t\\\"dimgray\\\": [105,105,105],\\t\\\"dimgrey\\\": [105,105,105],\\n\\t\\\"dodgerblue\\\": [30,144,255],\\t\\\"firebrick\\\": [178,34,34],\\n\\t\\\"floralwhite\\\": [255,250,240],\\t\\\"forestgreen\\\": [34,139,34],\\n\\t\\\"fuchsia\\\": [255,0,255],\\t\\\"gainsboro\\\": [220,220,220],\\n\\t\\\"ghostwhite\\\": [248,248,255],\\t\\\"gold\\\": [255,215,0],\\n\\t\\\"goldenrod\\\": [218,165,32],\\t\\\"gray\\\": [128,128,128],\\n\\t\\\"green\\\": [0,128,0],\\t\\\"greenyellow\\\": [173,255,47],\\n\\t\\\"grey\\\": [128,128,128],\\t\\\"honeydew\\\": [240,255,240],\\n\\t\\\"hotpink\\\": [255,105,180],\\t\\\"indianred\\\": [205,92,92],\\n\\t\\\"indigo\\\": [75,0,130],\\t\\\"ivory\\\": [255,255,240],\\n\\t\\\"khaki\\\": [240,230,140],\\t\\\"lavender\\\": [230,230,250],\\n\\t\\\"lavenderblush\\\": [255,240,245],\\t\\\"lawngreen\\\": [124,252,0],\\n\\t\\\"lemonchiffon\\\": [255,250,205],\\t\\\"lightblue\\\": [173,216,230],\\n\\t\\\"lightcoral\\\": [240,128,128],\\t\\\"lightcyan\\\": [224,255,255],\\n\\t\\\"lightgoldenrodyellow\\\": [250,250,210],\\t\\\"lightgray\\\": [211,211,211],\\n\\t\\\"lightgreen\\\": [144,238,144],\\t\\\"lightgrey\\\": [211,211,211],\\n\\t\\\"lightpink\\\": [255,182,193],\\t\\\"lightsalmon\\\": [255,160,122],\\n\\t\\\"lightseagreen\\\": [32,178,170],\\t\\\"lightskyblue\\\": [135,206,250],\\n\\t\\\"lightslategray\\\": [119,136,153],\\t\\\"lightslategrey\\\": [119,136,153],\\n\\t\\\"lightsteelblue\\\": [176,196,222],\\t\\\"lightyellow\\\": [255,255,224],\\n\\t\\\"lime\\\": [0,255,0],\\t\\\"limegreen\\\": [50,205,50],\\n\\t\\\"linen\\\": [250,240,230],\\t\\\"magenta\\\": [255,0,255],\\n\\t\\\"maroon\\\": [128,0,0],\\t\\\"mediumaquamarine\\\": [102,205,170],\\n\\t\\\"mediumblue\\\": [0,0,205],\\t\\\"mediumorchid\\\": [186,85,211],\\n\\t\\\"mediumpurple\\\": [147,112,219],\\t\\\"mediumseagreen\\\": [60,179,113],\\n\\t\\\"mediumslateblue\\\": [123,104,238],\\t\\\"mediumspringgreen\\\": [0,250,154],\\n\\t\\\"mediumturquoise\\\": [72,209,204],\\t\\\"mediumvioletred\\\": [199,21,133],\\n\\t\\\"midnightblue\\\": [25,25,112],\\t\\\"mintcream\\\": [245,255,250],\\n\\t\\\"mistyrose\\\": [255,228,225],\\t\\\"moccasin\\\": [255,228,181],\\n\\t\\\"navajowhite\\\": [255,222,173],\\t\\\"navy\\\": [0,0,128],\\n\\t\\\"oldlace\\\": [253,245,230],\\t\\\"olive\\\": [128,128,0],\\n\\t\\\"olivedrab\\\": [107,142,35],\\t\\\"orange\\\": [255,165,0],\\n\\t\\\"orangered\\\": [255,69,0],\\t\\\"orchid\\\": [218,112,214],\\n\\t\\\"palegoldenrod\\\": [238,232,170],\\t\\\"palegreen\\\": [152,251,152],\\n\\t\\\"paleturquoise\\\": [175,238,238],\\t\\\"palevioletred\\\": [219,112,147],\\n\\t\\\"papayawhip\\\": [255,239,213],\\t\\\"peachpuff\\\": [255,218,185],\\n\\t\\\"peru\\\": [205,133,63],\\t\\\"pink\\\": [255,192,203],\\n\\t\\\"plum\\\": [221,160,221],\\t\\\"powderblue\\\": [176,224,230],\\n\\t\\\"purple\\\": [128,0,128],\\t\\\"rebeccapurple\\\": [102,51,153],\\n\\t\\\"red\\\": [255,0,0],\\t\\\"rosybrown\\\": [188,143,143],\\n\\t\\\"royalblue\\\": [65,105,225],\\t\\\"saddlebrown\\\": [139,69,19],\\n\\t\\\"salmon\\\": [250,128,114],\\t\\\"sandybrown\\\": [244,164,96],\\n\\t\\\"seagreen\\\": [46,139,87],\\t\\\"seashell\\\": [255,245,238],\\n\\t\\\"sienna\\\": [160,82,45],\\t\\\"silver\\\": [192,192,192],\\n\\t\\\"skyblue\\\": [135,206,235],\\t\\\"slateblue\\\": [106,90,205],\\n\\t\\\"slategray\\\": [112,128,144],\\t\\\"slategrey\\\": [112,128,144],\\n\\t\\\"snow\\\": [255,250,250],\\t\\\"springgreen\\\": [0,255,127],\\n\\t\\\"steelblue\\\": [70,130,180],\\t\\\"tan\\\": [210,180,140],\\n\\t\\\"teal\\\": [0,128,128],\\t\\\"thistle\\\": [216,191,216],\\n\\t\\\"tomato\\\": [255,99,71],\\t\\\"turquoise\\\": [64,224,208],\\n\\t\\\"violet\\\": [238,130,238],\\t\\\"wheat\\\": [245,222,179],\\n\\t\\\"white\\\": [255,255,255],\\t\\\"whitesmoke\\\": [245,245,245],\\n\\t\\\"yellow\\\": [255,255,0],\\t\\\"yellowgreen\\\": [154,205,50]\\n};\\n\\nvar Numeric = \\\"([-+]?(?:0|[1-9]\\\\\\\\d*|(?=\\\\\\\\.\\\\\\\\d+))(?:\\\\\\\\.\\\\\\\\d*)?(?:[eE][-+]?\\\\\\\\d+)?)\\\";\\nvar NumberUnit = new RegExp(\\\"^\\\"+Numeric+\\\"([a-z%]*)$\\\");\\n\\n/*\\n * Arguments to color functions may be separated by either spaces or commas.\\n * Alpha channel specified after \\\" / \\\" takes precedence over alpha component in\\n * a color tuple.\\n *\\n * Returns either:\\n * 1) an rgb array with components in [0..255], or\\n * 2) an object with space, coords, and alpha properties, or\\n * 3) null\\n */\\nmodule.exports = function parseColorString(str) {\\n\\tif (typeof str !== \\\"string\\\" && ! (str instanceof String)) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\tstr = str.trim().toLowerCase();\\n\\n\\tif (str === \\\"transparent\\\") {\\n\\t\\treturn {space:\\\"rgb\\\",coords:[0,0,0],alpha:0};\\n\\t}\\n\\n\\tif (NamedColors.hasOwnProperty(str)) {\\n\\t\\treturn NamedColors[str];\\n\\t}\\n\\n\\tif (str[0] === \\\"#\\\") {\\n\\t\\treturn parseHex(str);\\n\\t}\\n\\n\\tvar re = /^([a-z]+)\\\\(([^)]+)\\\\)$/;\\n\\tvar m = str.match(re);\\n\\n\\tif (!m) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\tvar alpha = 1;\\n\\tvar isColorFn = (m[1] === \\\"color\\\");\\n\\tvar coords = m[2].trim().split(/\\\\s*,\\\\s*|\\\\s+/);\\n\\tvar func = (isColorFn ? coords.shift() : m[1]);\\n\\n\\tvar i = coords.indexOf(\\\"/\\\");\\n\\tif (i >= 0) {\\n\\t\\tif (coords.length <= i+1) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tvar alphaStr = coords[i+1];\\n\\t\\tcoords.splice(i);\\n\\t\\talpha = parseNumberOrPercent(alphaStr);\\n\\t} else if (coords.length > 3) {\\n\\t\\talpha = parseNumberOrPercent(coords[3]);\\n\\t}\\n\\n\\tif (alpha === undefined) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// per css4 color() spec:\\n\\t// If more <number>s or <percentage>s are provided than parameters that the\\n\\t// color space takes, the excess <number>s at the end are ignored.\\n\\t// If fewer <number>s or <percentage>s are provided than parameters that the\\n\\t// color space takes, the missing parameters default to 0.\\n\\tcoords.splice(3);\\n\\tif (coords.length < 3) {\\n\\t\\tif (! isColorFn) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\t// pad missing entries with 0\\n\\t\\tfor (var i = 3 - coords.length; i > 0; i--) {\\n\\t\\t\\tcoords.push(\\\"0\\\");\\n\\t\\t}\\n\\t}\\n\\tvar space;\\n\\n\\tswitch(func) {\\n\\t\\tcase \\\"rgb\\\":\\n\\t\\tcase \\\"rgba\\\":\\n\\t\\t\\tspace = \\\"rgb\\\";\\n\\t\\t\\tcoords = parseCoordsRGB(coords,255);\\n\\t\\t\\tbreak;\\n\\t\\tcase \\\"hsl\\\":\\n\\t\\tcase \\\"hsla\\\":\\n\\t\\t\\tspace = \\\"hsl\\\";\\n\\t\\t\\tcoords = parseCoordsHSL(coords);\\n\\t\\t\\tbreak;\\n\\t\\tcase \\\"display-p3\\\":\\n\\t\\t\\tspace = \\\"p3\\\";\\n\\t\\t\\tcoords = parseCoordsRGB(coords);\\n\\t\\t\\tbreak;\\n\\t\\tcase \\\"lab\\\":\\n\\t\\t\\tspace = \\\"lab\\\";\\n\\t\\t\\tcoords = parseCoordsLab(coords);\\n\\t\\t\\tbreak;\\n\\t\\tcase \\\"srgb\\\":\\n\\t\\t\\tspace = \\\"rgb\\\";\\n\\t\\t\\tcoords = parseCoordsRGB(coords);\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\treturn null;\\n\\t}\\n\\n\\tif (coords === null) {\\n\\t\\treturn null;\\n\\t}\\n\\treturn { space:space, coords:coords, alpha:alpha };\\n}\\n\\n// convert percentage to float; if str is a number and scale is provided, return\\n// the number divided by the scale.\\nfunction parseNumberOrPercent(str,scale) {\\n\\tif (str === \\\"none\\\") return NaN;\\n\\n\\tvar m = str.match(NumberUnit);\\n\\tif (!m) {\\n\\t\\treturn undefined;\\n\\t}\\n\\tif (m[2] === \\\"%\\\") {\\n\\t\\treturn parseFloat(m[1]/100);\\n\\t}\\n\\tvar n = parseFloat(m[1]);\\n\\tif (scale !== void(0) && scale > 0) {\\n\\t\\tn = n / scale;\\n\\t}\\n\\treturn n;\\n}\\n\\nfunction parseNumber(str) {\\n\\tif (str === \\\"none\\\") return NaN;\\n\\n\\tvar m = str.match(NumberUnit);\\n\\tif (!m || m[2] !== \\\"\\\") {\\n\\t\\treturn undefined;\\n\\t}\\n\\n\\treturn parseFloat(m[1]);\\n}\\n\\n// returns hue in degrees\\nfunction parseHue(str) {\\n\\tif (str === \\\"none\\\") return NaN;\\n\\n\\tvar m = str.match(NumberUnit);\\n\\tif (!m) {\\n\\t\\treturn undefined;\\n\\t}\\n\\tvar n = parseFloat(m[1]);\\n\\n\\tswitch(m[2]) {\\n\\tcase \\\"\\\":\\n\\tcase \\\"deg\\\":\\n\\t\\tbreak;\\n\\tcase \\\"rad\\\":\\n\\t\\tn = n * 180 / Math.PI;\\n\\t\\tbreak;\\n\\tcase \\\"grad\\\":  // 400 gradians in a circle\\n\\t\\tn = n * 360 / 400;\\n\\t\\tbreak;\\n\\tcase \\\"turn\\\":  // 1 turn in a circle\\n\\t\\tn = n * 360;\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\treturn undefined;\\n\\t}\\n\\treturn n;\\n}\\n\\nfunction parsePercent(str) {\\n\\tif (str === \\\"none\\\") return NaN;\\n\\n\\tvar m = str.match(NumberUnit);\\n\\tif (!m || m[2] !== \\\"%\\\") {\\n\\t\\treturn undefined;\\n\\t}\\n\\treturn parseFloat(m[1])/100;\\n}\\n\\n// assumes the first character is \\\"#\\\"\\nfunction parseHex(str) {\\n\\tif (str === \\\"none\\\") return NaN;\\n\\n\\t// #RGB[A] and #RRGGBB[AA] syntax.\\n\\tif (isNaN(\\\"0x\\\"+str.slice(1))) {\\n\\t\\treturn undefined;\\n\\t}\\n\\tif (str.length === 4 || str.length === 5) {\\n\\t\\tvar iv = parseInt((str+\\\"f\\\").slice(1,5),16);\\n\\t\\treturn [((iv & 0xf000) >> 8) | ((iv & 0xf000) >> 12),\\n\\t\\t\\t\\t(iv & 0xf00) >> 4| ((iv & 0xf00) >> 8),\\n\\t\\t\\t\\t(iv & 0xf0) | ((iv & 0xf0) >> 4),\\n\\t\\t\\t\\t((iv & 0xf) | ((iv & 0xf) << 4)) / 255];\\n\\t} else if (str.length === 7 || str.length === 9) {\\n\\t\\tvar iv = parseInt((str+\\\"ff\\\").slice(1,9),16);\\n\\t\\treturn [(iv & 0xff000000) >>> 24,\\n\\t\\t\\t\\t(iv & 0xff0000) >> 16,\\n\\t\\t\\t\\t(iv & 0xff00) >> 8,\\n\\t\\t\\t\\t(iv & 0xff) / 255];\\n\\t}\\n\\n\\treturn undefined;\\n}\\n\\n// Numbers are interpreted from [0..scale] or [0..1] by default.\\nfunction parseCoordsRGB(coords,scale) {\\n\\tfor (var i = 0; i < 3; i++) {\\n\\t\\tcoords[i] = parseNumberOrPercent(coords[i],scale);\\n\\t\\tif (coords[i] === undefined) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\treturn coords;\\n}\\n\\n// Adapted from https://www.w3.org/TR/css-color-4/#hsl-to-rgb\\n// Returns RGB components in [0..1]\\nfunction parseCoordsHSL(coords) {\\n\\tvar hsl = [\\n\\t\\tparseHue(coords[0]),\\n\\t\\tparsePercent(coords[1]),\\n\\t\\tparsePercent(coords[2])\\n\\t];\\n\\n\\tif (hsl.includes(undefined)) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\treturn hsl;\\n}\\n\\nfunction parseCoordsLab(coords) {\\n\\tvar lab = [\\n\\t\\tparsePercent(coords[0]) * 100,\\n\\t\\tparseNumber(coords[1]),\\n\\t\\tparseNumber(coords[2])\\n\\t];\\n\\n\\tif (lab.includes(undefined)) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\treturn lab;\\n}\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"},\"$:/plugins/cdr/colorlab/twutils.js\":{\"title\":\"$:/plugins/cdr/colorlab/twutils.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/cdr/colorlab/twutils.js\\ntype: application/javascript\\nmodule-type: library\\n\\nUtility functions.\\n\\n\\\\*/\\n(function() {\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: true */\\n\\\"use strict\\\";\\n\\n/**\\n * UI components: background color <= this lightness can\\n * be paired with white text with enough contrast even\\n * if the contrast ratio is less than recommended AA\\n */\\nexports.MaxContrastWhite = 75;\\n\\nexports.wikifyText = function (t, parentWidget) {\\n\\tvar parser = $tw.wiki.parseText(\\\"text/vnd.tiddlywiki\\\",t,{ parseAsInline: true });\\n\\tvar widgetNode = $tw.wiki.makeWidget(parser,{\\n\\t\\t\\tdocument: $tw.fakeDocument,\\n\\t\\t\\tparentWidget: parentWidget\\n\\t\\t});\\n\\tvar container = $tw.fakeDocument.createElement(\\\"div\\\");\\n\\twidgetNode.render(container,null);\\n\\treturn container.textContent;\\n}\\n\\nvar _parseCSSColor = $tw.utils.parseCSSColor;\\n\\n// process hex codes separately since TW's parser doesn't accept alpha channel\\n// in hex codes\\n$tw.utils.parseCSSColor = function(str) {\\n\\t// #RGB[A] and #RRGGBB[AA] syntax.\\n\\tif (str[0] === '#') {\\n\\t\\tif (isNaN(\\\"0x\\\"+str.slice(1))) {\\n\\t\\treturn null;\\n\\t\\t}\\n\\t\\tif (str.length === 4 || str.length === 5) {\\n\\t\\tvar iv = parseInt((str+\\\"f\\\").slice(1,5), 16);\\n\\t\\treturn [((iv & 0xf000) >> 8) | ((iv & 0xf000) >> 12),\\n\\t\\t\\t\\t(iv & 0xf00) >> 4| ((iv & 0xf00) >> 8),\\n\\t\\t\\t\\t(iv & 0xf0) | ((iv & 0xf0) >> 4),\\n\\t\\t\\t\\t((iv & 0xf) | ((iv & 0xf) << 4)) / 255];\\n\\t\\t} else if (str.length === 7 || str.length === 9) {\\n\\t\\tvar iv = parseInt((str+\\\"ff\\\").slice(1,9), 16);\\n\\t\\treturn [(iv & 0xff000000) >>> 24,\\n\\t\\t\\t\\t(iv & 0xff0000) >> 16,\\n\\t\\t\\t\\t(iv & 0xff00) >> 8,\\n\\t\\t\\t\\t(iv & 0xff) / 255];\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\\n\\n\\tvar rgb = null;\\n\\ttry {\\n\\t\\trgb = _parseCSSColor(str);\\n\\t} finally {\\n\\t\\treturn rgb;\\n\\t}\\n}\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"library\"}}}","revision":"0","bag":"default"}